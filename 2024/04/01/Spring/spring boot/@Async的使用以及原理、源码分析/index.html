<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言Spring中用@Async注解标记的方法，称为异步方法，它会在调用方的当前线程之外的独立的线程中执行，其实就相当于我们自己new Thread(()-&gt; System.out.println(“hello world !”))这样在另一个线程中去执行相应的业务逻辑。 123456789101112131415&#x2F;&#x2F; @Async 若把注解放在类上或者接口上，那么他所有的方法都会异步执行了">
<meta property="og:type" content="article">
<meta property="og:title" content="注解@Async的使用以及原理、源码分析">
<meta property="og:url" content="http://example.com/2024/04/01/Spring/spring%20boot/@Async%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="zero&#39;s Blog">
<meta property="og:description" content="前言Spring中用@Async注解标记的方法，称为异步方法，它会在调用方的当前线程之外的独立的线程中执行，其实就相当于我们自己new Thread(()-&gt; System.out.println(“hello world !”))这样在另一个线程中去执行相应的业务逻辑。 123456789101112131415&#x2F;&#x2F; @Async 若把注解放在类上或者接口上，那么他所有的方法都会异步执行了">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-03-31T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-27T02:20:41.598Z">
<meta property="article:author" content="jianjia">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/04/01/Spring/spring%20boot/@Async%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>注解@Async的使用以及原理、源码分析 | zero's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zero's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">持续迭代</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/01/Spring/spring%20boot/@Async%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jianjia">
      <meta itemprop="description" content="笔记库&知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zero's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          注解@Async的使用以及原理、源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-01T00:00:00+08:00">2024-04-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Spring中用@Async注解标记的方法，称为异步方法，它会在调用方的当前线程之外的独立的线程中执行，其实就相当于我们自己new Thread(()-&gt; System.out.println(“hello world !”))这样在另一个线程中去执行相应的业务逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// @Async 若把注解放在类上或者接口上，那么他所有的方法都会异步执行了~~~~（包括私有方法）</span><br><span class="line">public interface HelloService &#123;</span><br><span class="line">    Object hello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class HelloServiceImpl implements HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Async // 注意此处加上了此注解</span><br><span class="line">    @Override</span><br><span class="line">    public Object hello() &#123;</span><br><span class="line">        System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName());</span><br><span class="line">        return &quot;service hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后只需要在配置里，开启对异步的支持即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAsync // 开启异步注解的支持</span><br><span class="line">public class RootConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的是线程池SimpleAsyncTaskExecutor，这也是Spring默认给我们提供的线程池。</p>
<span id="more"></span>


<h3 id="Async注解使用细节"><a href="#Async注解使用细节" class="headerlink" title="@Async注解使用细节"></a>@Async注解使用细节</h3><ol>
<li>@Async注解一般用在方法上，如果用在类上，那么这个类所有的方法都是异步执行的；</li>
<li>@Async可以放在任何方法上，即使是private的；</li>
<li>所使用的@Async注解方法的类对象应该是Spring容器管理的bean对象；</li>
<li>@Async可以放在接口处（或者接口方法上）。但是只有使用的是JDK的动态代理时才有效，CGLIB会失效。因此建议：统一写在实现类的方法上；</li>
<li>需要注解@EnableAsync来开启异步注解的支持；</li>
<li>若你希望得到异步调用的返回值，请你的返回值用Futrue变量包装起来</li>
</ol>
<h3 id="EnableAsync"><a href="#EnableAsync" class="headerlink" title="@EnableAsync"></a>@EnableAsync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AsyncConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAsync &#123;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//默认情况下，要开启异步操作，要在相应的方法或者类上加上@Async注解或者EJB3.1规范下的@Asynchronous注解。</span></span><br><span class="line">	 <span class="comment">//这个属性使得开发人员可以自己设置开启异步操作的注解(可谓非常的人性化了，但是大多情况下用Spring的就足够了)</span></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation() <span class="keyword">default</span> Annotation.class;</span><br><span class="line">	<span class="comment">// true表示启用CGLIB代理</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 代理方式：默认是PROXY  采用Spring的动态代理（含JDK动态代理和CGLIB）</span></span><br><span class="line">	<span class="comment">// 若改为：AdviceMode.ASPECTJ表示使用AspectJ静态代理方式。</span></span><br><span class="line">	<span class="comment">// 它能够解决同类内方法调用不走代理对象的问题，但是一般情况下都不建议这么去做，不要修改这个参数值</span></span><br><span class="line">	AdviceMode <span class="title function_">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY;</span><br><span class="line">	<span class="comment">// 直接定义：它的执行顺序（因为可能有多个@EnableXXX）</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Async &#123;</span><br><span class="line">	<span class="comment">// May be used to determine the target executor to be used when executing this method</span></span><br><span class="line">	<span class="comment">// 意思是这个value值是用来指定执行器的（写入执行器BeanName即可采用特定的执行器去执行此方法）</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>最重要的，还是上面的@Import注解导入的类：AsyncConfigurationSelector</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class AsyncConfigurationSelector extends AdviceModeImportSelector&lt;EnableAsync&gt; &#123;</span><br><span class="line"></span><br><span class="line">	// 这类 我也不知道在哪？是用于支持AspectJ这种静态代理Mode的,忽略吧~~~~</span><br><span class="line">	private static final String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME =</span><br><span class="line">			&quot;org.springframework.scheduling.aspectj.AspectJAsyncConfiguration&quot;;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		// 这里AdviceMode 进行不同的处理，从而向Spring容器注入了不同的Bean~~~</span><br><span class="line">		switch (adviceMode) &#123;</span><br><span class="line">			// 大多数情况下都走这里，ProxyAsyncConfiguration会被注入到Bean容器里面~~~</span><br><span class="line">			case PROXY:</span><br><span class="line">				return new String[] &#123; ProxyAsyncConfiguration.class.getName() &#125;;</span><br><span class="line">			case ASPECTJ:</span><br><span class="line">				return new String[] &#123; ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME &#125;;</span><br><span class="line">			default:</span><br><span class="line">				return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用：抽象实现支持了AdviceMode，并且支持通用的@EnableXXX模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@since 3.1  它是一个`ImportSelector`</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AdviceModeImportSelector</span>&lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认都叫mode</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME</span> <span class="operator">=</span> <span class="string">&quot;mode&quot;</span>;</span><br><span class="line">	<span class="comment">// 显然也允许子类覆盖此方法</span></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">getAdviceModeAttributeName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// importingClassMetadata：注解的信息</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">		<span class="comment">// 这里泛型，拿到泛型类型~~~</span></span><br><span class="line">		Class&lt;?&gt; annType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class);</span><br><span class="line">		Assert.state(annType != <span class="literal">null</span>, <span class="string">&quot;Unresolvable type argument for AdviceModeImportSelector&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 根据类型，拿到该类型的这个注解，然后转换为AnnotationAttributes</span></span><br><span class="line">		<span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line">		<span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format( <span class="string">&quot;@%s is not present annType.getSimpleName(), importingClassMetadata.getClassName()));</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">		// 拿到AdviceMode，最终交给子类，让它自己去实现，决定导入哪个Bean</span></span><br><span class="line"><span class="string">		AdviceMode adviceMode = attributes.getEnum(this.getAdviceModeAttributeName());</span></span><br><span class="line"><span class="string">		String[] imports = selectImports(adviceMode);</span></span><br><span class="line"><span class="string">		if (imports == null) &#123;</span></span><br><span class="line"><span class="string">			throw new IllegalArgumentException(String.format(&quot;</span>Unknown AdviceMode: <span class="string">&#x27;%s&#x27;</span><span class="string">&quot;, adviceMode));</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		return imports;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	// 子类去实现  具体导入哪个Bean</span></span><br><span class="line"><span class="string">	@Nullable</span></span><br><span class="line"><span class="string">	protected abstract String[] selectImports(AdviceMode adviceMode);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<p>@EnableAsync最终是向容器内注入了ProxyAsyncConfiguration这个Bean。由名字可议看出，它是一个配置类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它是一个配置类，角色为ROLE_INFRASTRUCTURE  框架自用的Bean类型</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyAsyncConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractAsyncConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 它的作用就是诸如了一个AsyncAnnotationBeanPostProcessor，它是个BeanPostProcessor</span></span><br><span class="line">	<span class="meta">@Bean(name = TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME)</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	<span class="keyword">public</span> AsyncAnnotationBeanPostProcessor <span class="title function_">asyncAdvisor</span><span class="params">()</span> &#123;</span><br><span class="line">		Assert.notNull(<span class="built_in">this</span>.enableAsync, <span class="string">&quot;@EnableAsync annotation metadata was not injected&quot;</span>);</span><br><span class="line">		<span class="type">AsyncAnnotationBeanPostProcessor</span> <span class="variable">bpp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncAnnotationBeanPostProcessor</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// customAsyncAnnotation：自定义的注解类型</span></span><br><span class="line">		<span class="comment">// AnnotationUtils.getDefaultValue(EnableAsync.class, &quot;annotation&quot;) 为拿到该注解该字段的默认值</span></span><br><span class="line">		Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; customAsyncAnnotation = <span class="built_in">this</span>.enableAsync.getClass(<span class="string">&quot;annotation&quot;</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 相当于如果你指定了AsyncAnnotationType,那就set进去吧</span></span><br><span class="line">		<span class="keyword">if</span> (customAsyncAnnotation != AnnotationUtils.getDefaultValue(EnableAsync.class, <span class="string">&quot;annotation&quot;</span>)) &#123;</span><br><span class="line">			bpp.setAsyncAnnotationType(customAsyncAnnotation);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 只有自定义了AsyncConfigurer的实现类，自定义了一个线程执行器，这里才会有值</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.executor != <span class="literal">null</span>) &#123;</span><br><span class="line">			bpp.setExecutor(<span class="built_in">this</span>.executor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 同上，异步线程异常的处理器~~~~~</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.exceptionHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">			bpp.setExceptionHandler(<span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 这两个参数，就不多说了。</span></span><br><span class="line">		<span class="comment">// 可以看到，order属性值，最终决定的是BeanProcessor的执行顺序的</span></span><br><span class="line">		bpp.setProxyTargetClass(<span class="built_in">this</span>.enableAsync.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>));</span><br><span class="line">		bpp.setOrder(<span class="built_in">this</span>.enableAsync.&lt;Integer&gt;getNumber(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> bpp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyAsyncConfiguration的父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAsyncConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ImportAware</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此注解@EnableAsync的元信息</span></span><br><span class="line">	<span class="keyword">protected</span> AnnotationAttributes enableAsync;</span><br><span class="line">	<span class="comment">// 异步线程池</span></span><br><span class="line">	<span class="keyword">protected</span> Executor executor;</span><br><span class="line">	<span class="comment">// 异步异常的处理器</span></span><br><span class="line">	<span class="keyword">protected</span> AsyncUncaughtExceptionHandler exceptionHandler;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> &#123;</span><br><span class="line">		<span class="comment">// 拿到@EnableAsync注解的元数据信息~~~</span></span><br><span class="line">		<span class="built_in">this</span>.enableAsync = AnnotationAttributes.fromMap(importMetadata.getAnnotationAttributes(EnableAsync.class.getName(), <span class="literal">false</span>));</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.enableAsync == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;@EnableAsync is not present on importing class &quot;</span> + importMetadata.getClassName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Collect any &#123;<span class="doctag">@link</span> AsyncConfigurer&#125; beans through autowiring.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">// doc说得很明白。它会把所有的`AsyncConfigurer`的实现类都搜集进来，然后进行类似属性的合并</span></span><br><span class="line">	 <span class="comment">// 备注  虽然这里用的是Collection 但是AsyncConfigurer的实现类只允许有一个</span></span><br><span class="line">	<span class="meta">@Autowired(required = false)</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setConfigurers</span><span class="params">(Collection&lt;AsyncConfigurer&gt; configurers)</span> &#123;</span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">if</span> (CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	  	<span class="comment">//AsyncConfigurer用来配置线程池配置以及异常处理器，而且在Spring环境中最多只能有一个</span></span><br><span class="line">	  	<span class="comment">//在这里我们知道了，如果想要自己去配置线程池，只需要实现AsyncConfigurer接口，并且不可以在Spring环境中有多个实现AsyncConfigurer的类。</span></span><br><span class="line">		<span class="keyword">if</span> (configurers.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Only one AsyncConfigurer may exist&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 拿到唯一的AsyncConfigurer ，然后赋值~~~~   默认的请参照这个类：AsyncConfigurerSupport（它并不会被加入进Spring容器里）</span></span><br><span class="line">		<span class="type">AsyncConfigurer</span> <span class="variable">configurer</span> <span class="operator">=</span> configurers.iterator().next();</span><br><span class="line">		<span class="built_in">this</span>.executor = configurer.getAsyncExecutor();</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = configurer.getAsyncUncaughtExceptionHandler();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上可知，真正做文章的最终还是 <strong>AsyncAnnotationBeanPostProcessor</strong> 这个后置处理器，继承自AbstractAdvisingBeanPostProcessor，从这个名字也能看出来。它主要处理AdvisingBean，也就是处理Advisor和Bean的关系的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它继承自，ProxyProcessorSupport，说明它也拥有AOP的通用配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAdvisingBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Advisor advisor;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">beforeExistingAdvisors</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 缓存合格的Bean们</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Boolean&gt; eligibleBeans = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">	  </span><br><span class="line">	<span class="comment">// 当遇到一个pre-object的时候，是否把该processor所持有得advisor放在现有的增强器们之前执行</span></span><br><span class="line">	<span class="comment">// 默认是false，会放在最后一个位置上的</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeforeExistingAdvisors</span><span class="params">(<span class="type">boolean</span> beforeExistingAdvisors)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.beforeExistingAdvisors = beforeExistingAdvisors;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 不处理</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Bean已经实例化、初始化完成之后执行。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="comment">// 忽略AopInfrastructureBean的Bean，并且如果没有advisor也会忽略不处理~~~~~</span></span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> AopInfrastructureBean || <span class="built_in">this</span>.advisor == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Ignore AOP infrastructure such as scoped proxies.</span></span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果这个Bean已经被代理过了（比如已经被AOP切中了），那本处就无需再重复创建代理了嘛</span></span><br><span class="line">		<span class="comment">// 直接向里面添加advisor就成了</span></span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">			<span class="type">Advised</span> <span class="variable">advised</span> <span class="operator">=</span> (Advised) bean;</span><br><span class="line">			<span class="comment">// 注意此advised不能是已经被冻结了的。且源对象必须是Eligible合格的</span></span><br><span class="line">			<span class="keyword">if</span> (!advised.isFrozen() &amp;&amp; isEligible(AopUtils.getTargetClass(bean))) &#123;</span><br><span class="line">				<span class="comment">// Add our local Advisor to the existing proxy&#x27;s Advisor chain...</span></span><br><span class="line">				<span class="comment">// 把自己持有的这个advisor放在首位（如果beforeExistingAdvisors=true）</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">this</span>.beforeExistingAdvisors) &#123;</span><br><span class="line">					advised.addAdvisor(<span class="number">0</span>, <span class="built_in">this</span>.advisor);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 否则就是尾部位置</span></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					advised.addAdvisor(<span class="built_in">this</span>.advisor);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 最终直接返回即可，因为已经没有必要再创建一次代理对象了</span></span><br><span class="line">				<span class="keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 如果这个Bean事合格的（此方法下面有解释）   这个时候是没有被代理过的</span></span><br><span class="line">		<span class="keyword">if</span> (isEligible(bean, beanName)) &#123;</span><br><span class="line">			<span class="comment">// 以当前的配置，创建一个ProxyFactory </span></span><br><span class="line">			<span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> prepareProxyFactory(bean, beanName);</span><br><span class="line">			<span class="comment">// 如果不是使用CGLIB常见代理，那就去分析出它所实现的接口们  然后放进ProxyFactory 里去</span></span><br><span class="line">			<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">				evaluateProxyInterfaces(bean.getClass(), proxyFactory);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 切面就是当前持有得advisor</span></span><br><span class="line">			proxyFactory.addAdvisor(<span class="built_in">this</span>.advisor);</span><br><span class="line">			<span class="comment">// 留给子类，自己还可以对proxyFactory进行自定义~~~~~</span></span><br><span class="line">			customizeProxyFactory(proxyFactory);</span><br><span class="line">			<span class="comment">// 最终返回这个代理对象~~~~~</span></span><br><span class="line">			<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// No async proxy needed.（相当于没有做任何的代理处理,返回原对象）</span></span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 检查这个Bean是否是合格的</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isEligible</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> isEligible(bean.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isEligible</span><span class="params">(Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">		<span class="comment">// 如果已经被缓存着了，那肯定靠谱啊</span></span><br><span class="line">		<span class="type">Boolean</span> <span class="variable">eligible</span> <span class="operator">=</span> <span class="built_in">this</span>.eligibleBeans.get(targetClass);</span><br><span class="line">		<span class="keyword">if</span> (eligible != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> eligible;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果没有切面（就相当于没有给配置增强器，那铁定是不合格的）</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.advisor == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 这个重要了：看看这个advisor是否能够切入进targetClass这个类，能够切入进取的也是合格的</span></span><br><span class="line">		eligible = AopUtils.canApply(<span class="built_in">this</span>.advisor, targetClass);</span><br><span class="line">		<span class="built_in">this</span>.eligibleBeans.put(targetClass, eligible);</span><br><span class="line">		<span class="keyword">return</span> eligible;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 子类可以复写。比如`AbstractBeanFactoryAwareAdvisingPostProcessor`就复写了这个方法~~~</span></span><br><span class="line">	<span class="keyword">protected</span> ProxyFactory <span class="title function_">prepareProxyFactory</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">		proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line">		proxyFactory.setTarget(bean);</span><br><span class="line">		<span class="keyword">return</span> proxyFactory;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 子类复写~</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeProxyFactory</span><span class="params">(ProxyFactory proxyFactory)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>AbstractBeanFactoryAwareAdvisingPostProcessor从名字可以看出，它相较于父类，就和BeanFactory有关了，也就是和Bean容器相关了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBeanFactoryAwareAdvisingPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractAdvisingBeanPostProcessor</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bean工厂</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> ConfigurableListableBeanFactory beanFactory;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果这个Bean工厂不是ConfigurableListableBeanFactory ，那就set一个null</span></span><br><span class="line">	<span class="comment">// 我们的`DefaultListableBeanFactory`显然就是它的子类~~~~~</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.beanFactory = (beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory ?</span><br><span class="line">				(ConfigurableListableBeanFactory) beanFactory : <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> ProxyFactory <span class="title function_">prepareProxyFactory</span><span class="params">(Object bean, String beanName)</span> &#123;		<span class="comment">// 如果Bean工厂是正常的，那就把这个Bean  expose一个特殊的Bean，记录下它的类型</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">			AutoProxyUtils.exposeTargetClass(<span class="built_in">this</span>.beanFactory, beanName, bean.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="built_in">super</span>.prepareProxyFactory(bean, beanName);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 这里创建代理也是和`AbstractAutoProxyCreator`差不多的逻辑。</span></span><br><span class="line">		<span class="comment">// 如果没有显示的设置为CGLIB，并且toProxyUtils.shouldProxyTargetClass还被暴露过时一个特殊的Bean，那就强制使用CGLIB代理吧    这里一般和Scope无关的话，都返回false了</span></span><br><span class="line">		<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass() &amp;&amp; <span class="built_in">this</span>.beanFactory != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">				AutoProxyUtils.shouldProxyTargetClass(<span class="built_in">this</span>.beanFactory, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> proxyFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面就可以看看具体的两个实现类了：<br>AsyncAnnotationBeanPostProcessor，该实现类就是具体和@Async相关的一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactoryAwareAdvisingPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建议换成AsyncExecutionAspectSupport.DEFAULT_TASK_EXECUTOR_BEAN_NAME  这样语意更加的清晰些</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TASK_EXECUTOR_BEAN_NAME</span> <span class="operator">=</span> AnnotationAsyncExecutionInterceptor.DEFAULT_TASK_EXECUTOR_BEAN_NAME;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 注解类型</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; asyncAnnotationType;</span><br><span class="line">	<span class="comment">// 异步的执行器</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Executor executor;</span><br><span class="line">	<span class="comment">// 异步异常处理器</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> AsyncUncaughtExceptionHandler exceptionHandler;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此处特别注意：这里设置为true，也就是说@Async的Advisor会放在首位</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">		setBeforeExistingAdvisors(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可以设定需要扫描哪些注解类型。默认只扫描@Async以及`javax.ejb.Asynchronous`这个注解</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsyncAnnotationType</span><span class="params">(Class&lt;? extends Annotation&gt; asyncAnnotationType)</span> &#123;</span><br><span class="line">		Assert.notNull(asyncAnnotationType, <span class="string">&quot;&#x27;asyncAnnotationType&#x27; must not be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.asyncAnnotationType = asyncAnnotationType;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果没有指定。那就将执行全局得默认查找。在上下文中查找唯一的`TaskExecutor`类型的Bean，或者一个名称为`taskExecutor`的Executor</span></span><br><span class="line">	<span class="comment">// 当然，如果上面途径都没找到。那就会采用一个默认的任务池</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExecutor</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.executor = executor;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExceptionHandler</span><span class="params">(AsyncUncaughtExceptionHandler exceptionHandler)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = exceptionHandler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写了父类的方法。然后下面：自己new了一个AsyncAnnotationAdvisor ，传入executor和exceptionHandler</span></span><br><span class="line">	<span class="comment">// 并且最终this.advisor = advisor </span></span><br><span class="line">	<span class="comment">// 因此可议看出：AsyncAnnotationAdvisor 才是重点了。它定义了它的匹配情况~~~~</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>.setBeanFactory(beanFactory);</span><br><span class="line">	</span><br><span class="line">		<span class="type">AsyncAnnotationAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncAnnotationAdvisor</span>(<span class="built_in">this</span>.executor, <span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.asyncAnnotationType != <span class="literal">null</span>) &#123;</span><br><span class="line">			advisor.setAsyncAnnotationType(<span class="built_in">this</span>.asyncAnnotationType);</span><br><span class="line">		&#125;</span><br><span class="line">		advisor.setBeanFactory(beanFactory);</span><br><span class="line">		<span class="built_in">this</span>.advisor = advisor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>AsyncAnnotationAdvisor:可以看出，它是一个PointcutAdvisor，并且Pointcut是一个AnnotationMatchingPointcut，因此是为注解来匹配的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncAnnotationAdvisor</span> <span class="keyword">extends</span> <span class="title class_">AbstractPointcutAdvisor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> AsyncUncaughtExceptionHandler exceptionHandler;</span><br><span class="line">	<span class="comment">// 增强器</span></span><br><span class="line">	<span class="keyword">private</span> Advice advice;</span><br><span class="line">	<span class="comment">// 切点</span></span><br><span class="line">	<span class="keyword">private</span> Pointcut pointcut;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 两个都为null，那就是都会采用默认的方案</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncAnnotationAdvisor</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建一个AsyncAnnotationAdvisor实例，可以自己指定Executor 和 AsyncUncaughtExceptionHandler </span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncAnnotationAdvisor</span><span class="params">(<span class="meta">@Nullable</span> Executor executor, <span class="meta">@Nullable</span> AsyncUncaughtExceptionHandler exceptionHandler)</span> &#123;</span><br><span class="line">		<span class="comment">// 这里List长度选择2，应为绝大部分情况下只会支持这两种@Async和@Asynchronous</span></span><br><span class="line">		Set&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;&gt; asyncAnnotationTypes = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">		asyncAnnotationTypes.add(Async.class);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			asyncAnnotationTypes.add((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;)</span><br><span class="line">					ClassUtils.forName(<span class="string">&quot;javax.ejb.Asynchronous&quot;</span>, AsyncAnnotationAdvisor.class.getClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="comment">// If EJB 3.1 API not present, simply ignore.</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (exceptionHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.exceptionHandler = exceptionHandler;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若没指定，那就使用默认的SimpleAsyncUncaughtExceptionHandler（它仅仅是输出了一句日志而已）</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.exceptionHandler = <span class="keyword">new</span> <span class="title class_">SimpleAsyncUncaughtExceptionHandler</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 这两个方法是重点，下面会重点介绍</span></span><br><span class="line">		<span class="built_in">this</span>.advice = buildAdvice(executor, <span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">		<span class="built_in">this</span>.pointcut = buildPointcut(asyncAnnotationTypes);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果set了Executor,advice会重新构建。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTaskExecutor</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.advice = buildAdvice(executor, <span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里注意：如果你自己指定了注解类型。那么将不再扫描其余两个默认的注解，因此pointcut也就需要重新构建了</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsyncAnnotationType</span><span class="params">(Class&lt;? extends Annotation&gt; asyncAnnotationType)</span> &#123;</span><br><span class="line">		Assert.notNull(asyncAnnotationType, <span class="string">&quot;&#x27;asyncAnnotationType&#x27; must not be null&quot;</span>);</span><br><span class="line">		Set&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;&gt; asyncAnnotationTypes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		asyncAnnotationTypes.add(asyncAnnotationType);</span><br><span class="line">		<span class="built_in">this</span>.pointcut = buildPointcut(asyncAnnotationTypes);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果这个advice也实现了BeanFactoryAware，那就也把BeanFactory放进去</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.advice <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">			((BeanFactoryAware) <span class="built_in">this</span>.advice).setBeanFactory(beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Advice <span class="title function_">getAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.advice;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Pointcut <span class="title function_">getPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.pointcut;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这个最终又是委托给`AnnotationAsyncExecutionInterceptor`，它是一个具体的增强器，有着核心内容</span></span><br><span class="line">	<span class="keyword">protected</span> Advice <span class="title function_">buildAdvice</span><span class="params">(<span class="meta">@Nullable</span> Executor executor, AsyncUncaughtExceptionHandler exceptionHandler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationAsyncExecutionInterceptor</span>(executor, exceptionHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Calculate a pointcut for the given async annotation types, if any</span></span><br><span class="line">	<span class="keyword">protected</span> Pointcut <span class="title function_">buildPointcut</span><span class="params">(Set&lt;Class&lt;? extends Annotation&gt;&gt; asyncAnnotationTypes)</span> &#123;</span><br><span class="line">		<span class="comment">// 采用一个组合切面：ComposablePointcut （因为可能需要支持多个注解嘛）</span></span><br><span class="line">		<span class="type">ComposablePointcut</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; asyncAnnotationType : asyncAnnotationTypes) &#123;</span><br><span class="line">			<span class="comment">// 这里为何new出来两个AnnotationMatchingPointcut？？？？？？</span></span><br><span class="line">			<span class="comment">// 第一个：类匹配（只需要类上面有这个注解，所有的方法都匹配）this.methodMatcher = MethodMatcher.TRUE;</span></span><br><span class="line">			<span class="comment">// 第二个：方法匹配。所有的类都可议。但是只有方法上有这个注解才会匹配上</span></span><br><span class="line">			<span class="type">Pointcut</span> <span class="variable">cpc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationMatchingPointcut</span>(asyncAnnotationType, <span class="literal">true</span>);</span><br><span class="line">			<span class="type">Pointcut</span> <span class="variable">mpc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationMatchingPointcut</span>(<span class="literal">null</span>, asyncAnnotationType, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">				result = <span class="keyword">new</span> <span class="title class_">ComposablePointcut</span>(cpc);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				result.union(cpc);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 最终的结果都是取值为并集的~~~~~~~</span></span><br><span class="line">			result = result.union(mpc);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//  最后一个处理厉害了：也就是说你啥类型都木有的情况下，是匹配所有类的所有方法~~~</span></span><br><span class="line">		<span class="keyword">return</span> (result != <span class="literal">null</span> ? result : Pointcut.TRUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上的源码可议看出，默认是支持@Asycn以及EJB的那个异步注解的。但是最终的增强行为，委托给了AnnotationAsyncExecutionInterceptor。AnnotationAsyncExecutionInterceptor是一个MethodInterceptor，并且继承自AsyncExecutionAspectSupport。<br>AsyncExecutionAspectSupport从类名就可以看出，它是用来支持处理异步线程执行器的，若没有指定，靠它提供一个默认的异步执行器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AsyncExecutionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这是备选的。如果找到多个类型为TaskExecutor的Bean，才会备选的再用这个名称去找的~~~</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TASK_EXECUTOR_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;taskExecutor&quot;</span>;</span><br><span class="line">	<span class="comment">// 缓存~~~AsyncTaskExecutor是TaskExecutor的子接口</span></span><br><span class="line">	<span class="comment">// 从这可以看出：不同的方法，对应的异步执行器还不一样咯~~~~~~</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, AsyncTaskExecutor&gt; executors = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">	<span class="comment">// 默认的线程执行器</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Executor defaultExecutor;</span><br><span class="line">	<span class="comment">// 异步异常处理器</span></span><br><span class="line">	<span class="keyword">private</span> AsyncUncaughtExceptionHandler exceptionHandler;</span><br><span class="line">	<span class="comment">// Bean工厂</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncExecutionAspectSupport</span><span class="params">(<span class="meta">@Nullable</span> Executor defaultExecutor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(defaultExecutor, <span class="keyword">new</span> <span class="title class_">SimpleAsyncUncaughtExceptionHandler</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncExecutionAspectSupport</span><span class="params">(<span class="meta">@Nullable</span> Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.defaultExecutor = defaultExecutor;</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = exceptionHandler;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExecutor</span><span class="params">(Executor defaultExecutor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.defaultExecutor = defaultExecutor;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExceptionHandler</span><span class="params">(AsyncUncaughtExceptionHandler exceptionHandler)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = exceptionHandler;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 该方法是找到一个异步执行器，去执行这个方法~~~~~~</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> AsyncTaskExecutor <span class="title function_">determineAsyncExecutor</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">		<span class="comment">// 如果缓存中能够找到该方法对应的执行器，就立马返回了</span></span><br><span class="line">		<span class="type">AsyncTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="built_in">this</span>.executors.get(method);</span><br><span class="line">		<span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">			Executor targetExecutor;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 抽象方法：`AnnotationAsyncExecutionInterceptor`有实现。就是@Async注解的value值</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">qualifier</span> <span class="operator">=</span> getExecutorQualifier(method);</span><br><span class="line">			<span class="comment">// 现在知道@Async直接的value值的作用了吧。就是制定执行此方法的执行器的（容器内执行器的Bean的名称）</span></span><br><span class="line">			<span class="comment">// 当然有可能为null。注意此处是支持@Qualified注解标注在类上来区分Bean的</span></span><br><span class="line">			<span class="comment">// 注意：此处targetExecutor仍然可能为null</span></span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasLength(qualifier)) &#123;</span><br><span class="line">				targetExecutor = findQualifiedExecutor(<span class="built_in">this</span>.beanFactory, qualifier);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 注解没有指定value值，那就去找默认的执行器</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				targetExecutor = <span class="built_in">this</span>.defaultExecutor;</span><br><span class="line">				<span class="keyword">if</span> (targetExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 去找getDefaultExecutor()~~~</span></span><br><span class="line">					<span class="keyword">synchronized</span> (<span class="built_in">this</span>.executors) &#123;</span><br><span class="line">						<span class="keyword">if</span> (<span class="built_in">this</span>.defaultExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">							<span class="built_in">this</span>.defaultExecutor = getDefaultExecutor(<span class="built_in">this</span>.beanFactory);</span><br><span class="line">						&#125;</span><br><span class="line">						targetExecutor = <span class="built_in">this</span>.defaultExecutor;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 若还未null，那就返回null吧</span></span><br><span class="line">			<span class="keyword">if</span> (targetExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 把targetExecutor 包装成一个AsyncTaskExecutor返回，并且缓存起来。</span></span><br><span class="line">			<span class="comment">// TaskExecutorAdapter就是AsyncListenableTaskExecutor的一个实现类</span></span><br><span class="line">			executor = (targetExecutor <span class="keyword">instanceof</span> AsyncListenableTaskExecutor ?</span><br><span class="line">					(AsyncListenableTaskExecutor) targetExecutor : <span class="keyword">new</span> <span class="title class_">TaskExecutorAdapter</span>(targetExecutor));</span><br><span class="line">			<span class="built_in">this</span>.executors.put(method, executor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> executor;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 子类去复写此方法。也就是拿到对应的key，从而方便找bean吧（执行器）</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">getExecutorQualifier</span><span class="params">(Method method)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// @since 4.2.6  也就是根据</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Executor <span class="title function_">findQualifiedExecutor</span><span class="params">(<span class="meta">@Nullable</span> BeanFactory beanFactory, String qualifier)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;BeanFactory must be set on &quot;</span> + getClass().getSimpleName() +</span><br><span class="line">					<span class="string">&quot; to access qualified executor &#x27;&quot;</span> + qualifier + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory, Executor.class, qualifier);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// @since 4.2.6 </span></span><br><span class="line">	<span class="comment">// Retrieve or build a default executor for this advice instance  检索或者创建一个默认的executor </span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Executor <span class="title function_">getDefaultExecutor</span><span class="params">(<span class="meta">@Nullable</span> BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 这个处理很有意思，它是用用的try catch的技巧去处理的</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 如果容器内存在唯一的TaskExecutor（子类），就直接返回了</span></span><br><span class="line">				<span class="keyword">return</span> beanFactory.getBean(TaskExecutor.class);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (NoUniqueBeanDefinitionException ex) &#123;</span><br><span class="line">				<span class="comment">// 这是出现了多个TaskExecutor类型的话，那就按照名字去拿  `taskExecutor`且是Executor类型</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 如果再没有找到，也不要报错，而是接下来创建一个默认的处理器</span></span><br><span class="line">				<span class="comment">// 这里输出一个info信息</span></span><br><span class="line">				<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex2) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex2) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 这里还没有获取到，就放弃。 用本地默认的executor吧~~~</span></span><br><span class="line">				<span class="comment">// 子类可以去复写此方法，发现为null的话可议给一个默认值~~~~比如`AsyncExecutionInterceptor`默认给的就是`SimpleAsyncTaskExecutor`作为执行器的</span></span><br><span class="line">				<span class="comment">// Giving up -&gt; either using local default executor or none at all...</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Delegate for actually executing the given task with the chosen executor</span></span><br><span class="line">	<span class="comment">// 用选定的执行者实际执行给定任务的委托</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">doSubmit</span><span class="params">(Callable&lt;Object&gt; task, AsyncTaskExecutor executor, Class&lt;?&gt; returnType)</span> &#123;</span><br><span class="line">		<span class="comment">// 根据不同的返回值类型，来采用不同的方案去异步执行，但是执行器都是executor</span></span><br><span class="line">		<span class="keyword">if</span> (CompletableFuture.class.isAssignableFrom(returnType)) &#123;</span><br><span class="line">			<span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> task.call();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CompletionException</span>(ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, executor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ListenableFuture接口继承自Future  是Spring自己扩展的一个接口。</span></span><br><span class="line">		<span class="comment">// 同样的AsyncListenableTaskExecutor也是Spring扩展自AsyncTaskExecutor的</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ListenableFuture.class.isAssignableFrom(returnType)) &#123;</span><br><span class="line">			<span class="keyword">return</span> ((AsyncListenableTaskExecutor) executor).submitListenable(task);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 普通的submit</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Future.class.isAssignableFrom(returnType)) &#123;</span><br><span class="line">			<span class="keyword">return</span> executor.submit(task);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 没有返回值的情况下  也用sumitt提交，按时返回null</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			executor.submit(task);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 处理错误</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleError</span><span class="params">(Throwable ex, Method method, Object... params)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	 	<span class="comment">// 如果方法的返回值类型是Future,就rethrowException，表示直接throw出去</span></span><br><span class="line">		<span class="keyword">if</span> (Future.class.isAssignableFrom(method.getReturnType())) &#123;</span><br><span class="line">			ReflectionUtils.rethrowException(ex);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Could not transmit the exception to the caller with default executor</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="built_in">this</span>.exceptionHandler.handleUncaughtException(ex, method, params);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">&quot;Exception handler for async method &#x27;&quot;</span> + method.toGenericString() +</span><br><span class="line">						<span class="string">&quot;&#x27; threw unexpected exception itself&quot;</span>, ex2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类相当于已经做了大部分的工作了，接下来继续看子类：AsyncExecutionInterceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 他继承自AsyncExecutionAspectSupport 来处理异步方法的处理，同时是个MethodInterceptor，来增强复合条件的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExecutionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">AsyncExecutionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, Ordered &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 显然这个方法它直接返回null，因为XML配置嘛~~~~</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">getExecutorQualifier</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个厉害了。如果父类返回的defaultExecutor 为null，那就new一个SimpleAsyncTaskExecutor作为默认的执行器</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Executor <span class="title function_">getDefaultExecutor</span><span class="params">(<span class="meta">@Nullable</span> BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="type">Executor</span> <span class="variable">defaultExecutor</span> <span class="operator">=</span> <span class="built_in">super</span>.getDefaultExecutor(beanFactory);</span><br><span class="line">		<span class="keyword">return</span> (defaultExecutor != <span class="literal">null</span> ? defaultExecutor : <span class="keyword">new</span> <span class="title class_">SimpleAsyncTaskExecutor</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最高优先级  希望的是最优先执行（XML配置就是这种优先级）</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最重要的当然是这个invoke方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// 注意：此处是getMostSpecificMethod  拿到最终要执行的那个方法</span></span><br><span class="line">		<span class="type">Method</span> <span class="variable">specificMethod</span> <span class="operator">=</span> ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);</span><br><span class="line">		<span class="comment">// 桥接方法~~~~~~~~~~~~~~</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">Method</span> <span class="variable">userDeclaredMethod</span> <span class="operator">=</span> BridgeMethodResolver.findBridgedMethod(specificMethod);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// determine一个用于执行此方法的异步执行器</span></span><br><span class="line">		<span class="type">AsyncTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> determineAsyncExecutor(userDeclaredMethod);</span><br><span class="line">		<span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">					<span class="string">&quot;No executor specified and no default executor set on AsyncExecutionInterceptor either&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 构造一个任务，Callable(此处不采用Runable，因为需要返回值)</span></span><br><span class="line">		Callable&lt;Object&gt; task = () -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// result就是返回值</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">				<span class="comment">// 注意此处的处理~~~~  相当于如果不是Future类型，就返回null了</span></span><br><span class="line">				<span class="keyword">if</span> (result <span class="keyword">instanceof</span> Future) &#123;</span><br><span class="line">					<span class="keyword">return</span> ((Future&lt;?&gt;) result).get();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 处理执行时可能产生的异常~~~~~~</span></span><br><span class="line">			<span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">				handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				handleError(ex, userDeclaredMethod, invocation.getArguments());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 提交任务~~~~invocation.getMethod().getReturnType()为返回值类型</span></span><br><span class="line">		<span class="keyword">return</span> doSubmit(task, executor, invocation.getMethod().getReturnType());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SimpleAsyncTaskExecutor：异步执行用户任务的SimpleAsyncTaskExecutor。每次执行客户提交给它的任务时，它会启动新的线程，并允许开发者控制并发线程的上限（concurrencyLimit），从而起到一定的资源节流作用。默认时，concurrencyLimit取值为-1，即<strong>不启用</strong>资源节流<br>所以它不是真的线程池，这个类不重用线程，每次调用都会创建一个新的线程（因此建议我们在使用@Aysnc的时候，自己配置一个线程池，节约资源）</p>
<p>AnnotationAsyncExecutionInterceptor很显然，他是在AsyncExecutionInterceptor的基础上，提供了对@Async注解的支持。所以它是继承它的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它继承自AsyncExecutionInterceptor ，只复写了一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationAsyncExecutionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">AsyncExecutionInterceptor</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 由此可以见它就是去拿到@Async的value值。以方法的为准，其次是类上面的</span></span><br><span class="line">	<span class="comment">// 备注：发现这里是不支持EJB的@Asynchronous注解的，它是不能指定执行器的</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">getExecutorQualifier</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">		<span class="comment">// Maintainer&#x27;s note: changes made here should also be made in</span></span><br><span class="line">		<span class="comment">// AnnotationAsyncExecutionAspect#getExecutorQualifier</span></span><br><span class="line">		<span class="type">Async</span> <span class="variable">async</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(method, Async.class);</span><br><span class="line">		<span class="keyword">if</span> (async == <span class="literal">null</span>) &#123;</span><br><span class="line">			async = AnnotatedElementUtils.findMergedAnnotation(method.getDeclaringClass(), Async.class);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (async != <span class="literal">null</span> ? async.value() : <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>使用推荐配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">//对应的@Enable注解，最好写在属于自己的配置文件上，保持内聚性</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>); <span class="comment">//核心线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);  <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">1000</span>); <span class="comment">//队列大小</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">300</span>); <span class="comment">//线程最大空闲时间</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;fsx-Executor-&quot;</span>); 指定用于新创建的线程名称的前缀。</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()); <span class="comment">// 拒绝策略（一共四种，此处省略）</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 这一步千万不能忘了，否则报错： java.lang.IllegalStateException: ThreadPoolTaskExecutor not initialized</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异常处理器：当然你也可以自定义的，这里我就这么简单写了~~~</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAsyncUncaughtExceptionHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/04/01/Spring/spring%20boot/@Async%E6%B3%A8%E8%A7%A3%E5%BC%95%E5%8F%91%E7%9A%84Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%88%86%E6%9E%90/" rel="prev" title="注解@Async引发的Spring循环依赖分析">
      <i class="fa fa-chevron-left"></i> 注解@Async引发的Spring循环依赖分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/04/01/Spring/spring%20boot/@ControllerAdvice%E6%B3%A8%E8%A7%A3/" rel="next" title="注解@ControllerAdvice">
      注解@ControllerAdvice <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Async%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="nav-number">2.</span> <span class="nav-text">@Async注解使用细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EnableAsync"><span class="nav-number">3.</span> <span class="nav-text">@EnableAsync</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jianjia</p>
  <div class="site-description" itemprop="description">笔记库&知识库</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">138</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:jianjia_z@163.com" title="E-Mail → mailto:jianjia_z@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/zero__007" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;zero__007" rel="noopener" target="_blank"><i class="csdn fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jianjia</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
