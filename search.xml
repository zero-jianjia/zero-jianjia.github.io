<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dubbo泛化调用使用及原理</title>
    <url>/2024/07/13/Dubbo/dubbo%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="什么是泛化调用"><a href="#什么是泛化调用" class="headerlink" title="什么是泛化调用"></a>什么是泛化调用</h2><p>通常我们想调用别人的dubbo服务时，我们需要在项目中引入对应的jar包。而泛化调用的作用是，我们无需依赖相关jar包，也能调用到该服务。这个特性一般使用在网关类项目中，在业务开发中基本不会使用。</p>
<span id="more"></span>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>假设我现在要调用下面的接口服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.scj.demo.dubbo.provider.service.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ByeService</span>&#123;</span><br><span class="line">    String <span class="title function_">bye</span> <span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="泛化调用实例"><a href="#泛化调用实例" class="headerlink" title="泛化调用实例"></a>泛化调用实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最好使用cache，否则每次请求都会创建一个ReferenceConfig，并在zk注册节点，最终可能导致zk节点过多影响性能</span></span><br><span class="line"><span class="type">ReferenceConfigCache</span> <span class="variable">referenceCache</span> <span class="operator">=</span> ReferenceConfigCache.getCache();</span><br><span class="line"></span><br><span class="line">ReferenceConfig&lt;GenericService&gt; referenceConfig = <span class="keyword">new</span> <span class="title class_">ReferenceConfig</span>&lt;&gt;();</span><br><span class="line">referenceConfig.setApplication(<span class="keyword">new</span> <span class="title class_">ApplicationConfig</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">referenceConfig.setRegistry(<span class="keyword">new</span> <span class="title class_">RegistryConfig</span>(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>));</span><br><span class="line">referenceConfig.setInterface(<span class="string">&quot;com.scj.demo.dubbo.provider.service.impl.ByeService&quot;</span>);</span><br><span class="line">referenceConfig.setGeneric(<span class="literal">true</span>);</span><br><span class="line">referenceConfig.setCheck(<span class="literal">false</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//cache.get方法中会缓存 Reference对象，并且调用ReferenceConfig.get方法启动ReferenceConfig</span></span><br><span class="line"><span class="type">GenericService</span> <span class="variable">genericService</span> <span class="operator">=</span> referenceCache.get(referenceConfig);</span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> genericService.$invoke(</span><br><span class="line">    <span class="string">&quot;bye&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;java.lang.String&quot;</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;1234&quot;</span>&#125;);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>需要使用被调用接口的字符串参数生成GenericService，通过GenericService的$invoke间接调用目标接口的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generic invocation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method         Method name, e.g. findPerson. If there are overridden methods, parameter info is</span></span><br><span class="line"><span class="comment">     *                       required, e.g. findPerson(java.lang.String)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameterTypes Parameter types</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args           Arguments</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invocation return value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable potential exception thrown from the invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object $invoke(String method, String[] parameterTypes, Object[] args) <span class="keyword">throws</span> GenericException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$invoke的三个参数分别为，方法名，方法参数类型数组，方法参数数组。</p>
<h3 id="方法入参构造"><a href="#方法入参构造" class="headerlink" title="方法入参构造"></a>方法入参构造</h3><p>可以看到泛化调用的一个复杂性在于$invoke的第三个参数的组装，下面介绍几种复杂入参的调用方式。首先丰富提供者接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ByeService &#123;</span><br><span class="line">    String bye(String name);</span><br><span class="line">    String bye(String name, Long age, Date date);</span><br><span class="line">    String bye(Person person);</span><br><span class="line">    String bye(List&lt;String&gt; names);</span><br><span class="line">    String bye(String[] names);</span><br><span class="line">    String byePersons(List&lt;Person&gt; persons);</span><br><span class="line">    String byePersons(Person[] persons);</span><br><span class="line">    @Data</span><br><span class="line">    public static class Person&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private Long age;</span><br><span class="line">        private Date birth;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Person.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>多参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMultiParam</span><span class="params">()</span>&#123;</span><br><span class="line">    result = genericService.$invoke(</span><br><span class="line">            <span class="string">&quot;bye&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;java.lang.String&quot;</span>,<span class="string">&quot;java.lang.Long&quot;</span>,<span class="string">&quot;java.util.Date&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;scj&quot;</span>,<span class="number">12L</span>,<span class="keyword">new</span> <span class="title class_">Date</span>()&#125;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>POJO</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Object&gt; personMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#123;</span><br><span class="line">    personMap.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;scj&quot;</span>);</span><br><span class="line">    personMap.put(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;12&quot;</span>);</span><br><span class="line">    personMap.put(<span class="string">&quot;birth&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPOJO</span><span class="params">()</span>&#123;</span><br><span class="line">    result = genericService.$invoke(</span><br><span class="line">            <span class="string">&quot;bye&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.scj.demo.dubbo.provider.service.impl.ByeService$Person&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;personMap&#125;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Map</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span>&#123;</span><br><span class="line">    result = genericService.$invoke(</span><br><span class="line">            <span class="string">&quot;bye&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;java.util.Map&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;personMap&#125;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>集合</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testArray</span><span class="params">()</span>&#123;</span><br><span class="line">    String[] nameArray = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;scj1&quot;</span>,<span class="string">&quot;scj3&quot;</span>&#125;;</span><br><span class="line">    result = genericService.$invoke(</span><br><span class="line">            <span class="string">&quot;bye&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;java.lang.String[]&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;nameArray&#125;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testArray</span><span class="params">()</span>&#123;</span><br><span class="line">    String[] nameArray = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;scj1&quot;</span>,<span class="string">&quot;scj3&quot;</span>&#125;;</span><br><span class="line">    result = genericService.$invoke(</span><br><span class="line">            <span class="string">&quot;bye&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;java.lang.String[]&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;nameArray&#125;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>集合+POJO</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPOJOList</span><span class="params">()</span>&#123;</span><br><span class="line">    result = genericService.$invoke(</span><br><span class="line">            <span class="string">&quot;byePersons&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;java.util.List&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;Lists.newArrayList(personMap,personMap)&#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>数组+POJO</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPOJOArray</span><span class="params">()</span>&#123;</span><br><span class="line">    result = genericService.$invoke(</span><br><span class="line">            <span class="string">&quot;byePersons&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.scj.demo.dubbo.provider.service.impl.ByeService$Person[]&quot;</span>&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;Lists.newArrayList(personMap,personMap)&#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Object&gt;map <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line"><span class="comment">//注意：如果参数类型是接口，或者L1st等丢失泛型，可通过class属性指定类型。</span></span><br><span class="line">map.put(<span class="string">&quot;class&quot;</span>,<span class="string">&quot;com.test.PersonImpl&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;jiaduo&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>











<h3 id="结果返回"><a href="#结果返回" class="headerlink" title="结果返回"></a>结果返回</h3><p>与入参相似，虽然$invoke的返回定义为Object，实际上针对不同类型有不同的返回。别想着转换为POJO，你都泛化调用了，搞不到接口，如何转换。当然自己定义一个完全一样的当然也行。</p>
<table>
<thead>
<tr>
<th align="left">接口返回类型</th>
<th align="left">$invoke返回类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">基础类型</td>
<td align="left">基础类型</td>
</tr>
<tr>
<td align="left">POJO</td>
<td align="left">HashMap</td>
</tr>
<tr>
<td align="left">Collection</td>
<td align="left">List返回ArrayList,Set返回HashSet</td>
</tr>
<tr>
<td align="left">Array</td>
<td align="left">Array</td>
</tr>
<tr>
<td align="left">组合类型</td>
<td align="left">根据上述映射组合返回</td>
</tr>
</tbody></table>
<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>dubbo通过filter实现泛化：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240710201240.png" alt="图片"></p>
<p>GenericlmplFilter和GenericFilter分别在消费者端和提供者端进行序列化的检查和处理。</p>
<h3 id="消费者端"><a href="#消费者端" class="headerlink" title="消费者端"></a>消费者端</h3><p>泛化调用和直接调用在消费者者端，在<strong>使用上的区别</strong>是，我们调用服务时使用的接口为GenericService，方法为$invoker。在<strong>底层的区别</strong>是，消费者端发出的rpc报文发生了变化。</p>
<p>在使用上，不管哪种配置方式，我们都需要配置generic&#x3D;true。设置generic&#x3D;true后，RefereceConfig的interfaceClass会被强制设置为GenericService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ProtocolUtils.isGeneric(getGeneric())) &#123;</span><br><span class="line">    <span class="comment">//如果是泛化调用</span></span><br><span class="line">    interfaceClass = GenericService.class;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        interfaceClass = Class.forName(interfaceName, <span class="literal">true</span>, Thread.currentThread()</span><br><span class="line">                                       .getContextClassLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也使得我们的RefereanceBean返回的是GenericService类型的代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invoker = refprotocol.refer(interfaceClass, urls.get(``<span class="number">0</span>``));</span><br></pre></td></tr></table></figure>

<p>生成的代理是GenericService的代理只是我们使用方式上的变化，更为核心的是，底层发送的rpc报文发生了什么变化。</p>
<h3 id="底层报文变化"><a href="#底层报文变化" class="headerlink" title="底层报文变化"></a>底层报文变化</h3><p>Dubbo的rpc报文分为header和body两部分。我们这边只需要关注body部分。构造逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encodeRequestData</span><span class="params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RpcInvocation</span> <span class="variable">inv</span> <span class="operator">=</span> (RpcInvocation) data;</span><br><span class="line">    out.writeUTF(version);  <span class="comment">//dubbo版本号</span></span><br><span class="line">    out.writeUTF(inv.getAttachment(Constants.PATH_KEY));<span class="comment">//path 就是接口全限定名</span></span><br><span class="line">    out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));<span class="comment">// 接口版本号</span></span><br><span class="line">    out.writeUTF(inv.getMethodName());<span class="comment">//方法名</span></span><br><span class="line">    out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));<span class="comment">//方法参数类型</span></span><br><span class="line">    Object[] args = inv.getArguments();</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            out.writeObject(encodeInvocationArgument(channel, inv, i));<span class="comment">//方法参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out.writeObject(RpcUtils.getNecessaryAttachments(inv));<span class="comment">//rpc上下文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们通过直接调用与泛化调用ByeService的bye方法在报文上有啥区别呢？</p>
<p>我一开始以为报文中的path是GenericeService，其实并没有，path就是我们调用的目标方法。</p>
<p>而报文中的方法名，方法参数类型以及具体参数，还是按照GenericeService的$invoke方法入参传递的。</p>
<p>这么个二合一的报文，发送到提供者那边，它估计也会很懵逼，我应该怎么执行？</p>
<p>所以针对泛化调用报文还会把generic&#x3D;true放在attchment中传递过去</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240710195055.png" alt="img"></p>
<p>具体逻辑在GenericImplFilter中。</p>
<p><strong>GenericImplFilter</strong>中有很多其他逻辑，比如泛化调用使用的序列化协议，正常接口走泛化调用的模式，我们只需要设置attachment的那部分。针对泛化调用，要进行2次序列化&#x2F;反序列化。看下POJO的调用方式你就知道为啥了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((RpcInvocation) invocation).setAttachment(</span><br><span class="line">    Constants.GENERIC_KEY, invoker.getUrl().getParameter(Constants.GENERIC_KEY));</span><br></pre></td></tr></table></figure>

<p>知道消费者端报文发生了什么变化，那么接下来就去看提供者端如何处理这个改造后的报文。</p>
<h3 id="提供者端"><a href="#提供者端" class="headerlink" title="提供者端"></a>提供者端</h3><p>消费者泛化调用的rpc报文传递到提供者还不能直接使用，虽然path是对的，但是实际的方法名，参数类型，参数要从rpc报文的参数中提取出来。<strong>GenericFilter</strong>就是用来做这件事情。在提供者这边，针对泛化调用的逻辑全部封装到了GenericFilter，解耦的非常好。</p>
<p><strong>GenericFilter逻辑分析</strong></p>
<ul>
<li><ol>
<li>是否是泛化调用判断</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (inv.getMethodName().equals(Constants.$INVOKE)</span><br><span class="line">                || inv.getArguments() != <span class="literal">null</span></span><br><span class="line">                || inv.getArguments().length == <span class="number">3</span></span><br><span class="line">                || !GenericService.class.isAssignableFrom(invoker.getInterface()))&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意第4个条件，一开始很疑惑，后来发现rpc报文中的path是目标接口的，这边invoker.getInterface()返回的肯定就是实际接口了</p>
<ul>
<li><ol start="2">
<li>方法参数提取</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从argument提取目标方法名 方法类型 方法参数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ((String) inv.getArguments()[<span class="number">0</span>]).trim();</span><br><span class="line">String[] types = (String[]) inv.getArguments()[<span class="number">1</span>];</span><br><span class="line">Object[] args = (Object[]) inv.getArguments()[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>



<ul>
<li><ol start="3">
<li>方法参数解析，进一步反序列化</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反射获取目标执行方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ReflectUtils.findMethodByMethodSignature(invoker.getInterface(), name, types);</span><br><span class="line">Class&lt;?&gt;[] params = method.getParameterTypes();</span><br><span class="line"><span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">    args = <span class="keyword">new</span> <span class="title class_">Object</span>[params.length];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">generic</span> <span class="operator">=</span> inv.getAttachment(Constants.GENERIC_KEY);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isBlank(generic)) &#123;</span><br><span class="line">    generic = RpcContext.getContext().getAttachment(Constants.GENERIC_KEY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一些反序列化</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(generic)</span><br><span class="line">    || ProtocolUtils.isDefaultGenericSerialization(generic)) &#123;</span><br><span class="line">    args = PojoUtils.realize(args, params, method.getGenericParameterTypes());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ProtocolUtils.isJavaGenericSerialization(generic)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">byte</span>[].class == args[i].getClass()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">UnsafeByteArrayInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeByteArrayInputStream</span>((<span class="type">byte</span>[]) args[i]);</span><br><span class="line">                args[i] = ExtensionLoader.getExtensionLoader(Serialization.class)</span><br><span class="line">                    .getExtension(Constants.GENERIC_SERIALIZATION_NATIVE_JAVA)</span><br><span class="line">                    .deserialize(<span class="literal">null</span>, is).readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Deserialize argument [&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;] failed.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(</span><br><span class="line">                <span class="string">&quot;Generic serialization [&quot;</span> +</span><br><span class="line">                Constants.GENERIC_SERIALIZATION_NATIVE_JAVA +</span><br><span class="line">                <span class="string">&quot;] only support message type &quot;</span> +</span><br><span class="line">                <span class="type">byte</span>[].class +</span><br><span class="line">                <span class="string">&quot; and your message type is &quot;</span> +</span><br><span class="line">                args[i].getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> JavaBeanDescriptor) &#123;</span><br><span class="line">            args[i] = JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) args[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(</span><br><span class="line">                <span class="string">&quot;Generic serialization [&quot;</span> +</span><br><span class="line">                Constants.GENERIC_SERIALIZATION_BEAN +</span><br><span class="line">                <span class="string">&quot;] only support message type &quot;</span> +</span><br><span class="line">                JavaBeanDescriptor.class.getName() +</span><br><span class="line">                <span class="string">&quot; and your message type is &quot;</span> +</span><br><span class="line">                args[i].getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边有个疑问，为什么这边还要再次反序列化一次，netty不是有decoder么？？</p>
<p>嗯，你别忘了，针对一个POJO你传过来是一个Map，从Map转换为POJO需要这边进一步处理。</p>
<ul>
<li><ol start="4">
<li>调用目标服务</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> invoker.invoke(<span class="keyword">new</span> <span class="title class_">RpcInvocation</span>(method, args, inv.getAttachments()));</span><br></pre></td></tr></table></figure>

<p>这边的invoker就是实际服务提供者的invoker，因为我们的path是正确的，invoker获取在DubboProtocl的requestHandler回调中</p>
<ul>
<li><ol start="5">
<li>异常处理</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.hasException()</span><br><span class="line">    &amp;amp;&amp;amp; !(result.getException() <span class="keyword">instanceof</span> GenericException)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcResult</span>(<span class="keyword">new</span> <span class="title class_">GenericException</span>(result.getException()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边需要注意一下！！针对接口的泛化调用，抛出的异常都会经过GenericException包装一下。</p>
<hr>
<p>转载自：<br><a href="https://www.jb51.net/program/297913ee2.htm">https://www.jb51.net/program/297913ee2.htm</a></p>
<p>扩展阅读：<br><a href="https://www.51cto.com/article/775094.html">我试图通过这篇文章告诉你，什么是神奇的泛化调用</a><br><a href="https://blog.51cto.com/u_12968/10091490">dubbo泛化调用配置 dubbo泛化调用原理</a></p>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>AIGC</title>
    <url>/2024/07/06/AI/AIGC/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="一、AIGC是什么？"><a href="#一、AIGC是什么？" class="headerlink" title="一、AIGC是什么？"></a>一、AIGC是什么？</h2><p>AIGC是一种新的人工智能技术，它的全称是Artificial Intelligence Generative Content，即人工智能生成内容。</p>
<p>AIGC技术的核心思想是利用人工智能算法生成具有一定创意和质量的内容。通过训练模型和大量数据的学习，AIGC可以根据输入的条件或指导，生成与之相关的内容。例如，通过输入关键词、描述或样本，AIGC可以生成与之相匹配的文章、图像、音频等。</p>
<h2 id="二、AIGC的4个主要特征"><a href="#二、AIGC的4个主要特征" class="headerlink" title="二、AIGC的4个主要特征"></a>二、AIGC的4个主要特征</h2><p>现阶段国内AIGC多以单模型应用的形式出现，主要分为文本生成、图像生成、视频生成、音频生成，其中文本生成成为其他内容生成的基础。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141114694.jpeg" alt="img"></p>
<span id="more"></span>

<p><strong>1、文本生成</strong></p>
<p>文本生成（AI Text Generation），人工智能文本生成是使用人工智能(AI)算法和模型来生成模仿人类书写内容的文本。它涉及在现有文本的大型数据集上训练机器学习模型，以生成在风格、语气和内容上与输入数据相似的新文本。</p>
<p><strong>2、图像生成</strong></p>
<p>图像生成（AI Image Generation），人工智能(AI)可用于生成非人类艺术家作品的图像。这种类型的图像被称为“人工智能生成的图像”。人工智能图像可以是现实的或抽象的，也可以传达特定的主题或信息。</p>
<p><strong>3、语音生成</strong></p>
<p>语音生成（AI Audio Generation），AIGC的音频生成技术可以分为两类，分别是文本到语音合成和语音克隆。文本到语音合成需要输入文本并输出特定说话者的语音，主要用于机器人和语音播报任务。到目前为止，文本转语音任务已经相对成熟，语音质量已达到自然标准，未来将向更具情感的语音合成和小样本语音学习方向发展；语音克隆以给定的目标语音作为输入，然后将输入语音或文本转换为目标说话人的语音。此类任务用于智能配音等类似场景，合成特定说话人的语音。</p>
<p><strong>4、视频生成</strong></p>
<p>视频生成（AI Video Generation），AIGC已被用于视频剪辑处理以生成预告片和宣传视频。工作流程类似于图像生成，视频的每一帧都在帧级别进行处理，然后利用 AI 算法检测视频片段。AIGC生成引人入胜且高效的宣传视频的能力是通过结合不同的AI算法实现的。凭借其先进的功能和日益普及，AIGC可能会继续革新视频内容的创建和营销方式。</p>
<h2 id="三、AIGC技术的核心支撑"><a href="#三、AIGC技术的核心支撑" class="headerlink" title="三、AIGC技术的核心支撑"></a>三、AIGC技术的核心支撑</h2><p><strong>1. 深度学习技术</strong></p>
<p>深度学习是AIGC技术的核心。通过构建深度神经网络模型，AIGC能够模拟人类大脑的神经结构，实现对海量数据的学习和理解。深度学习使得AIGC能够自动地提取数据的特征，并根据这些特征生成高质量的内容。</p>
<p><strong>2. 自然语言处理技术</strong></p>
<p>自然语言处理（NLP）是AIGC在文本生成领域的重要技术支撑。NLP技术包括文本分词、词性标注、句法分析、语义理解等多个方面，能够帮助AIGC理解和处理人类语言，从而生成符合语法和语义规则的文本内容。</p>
<p><strong>3. 计算机视觉技术</strong></p>
<p>计算机视觉技术为AIGC在图像和视频生成领域提供了支持。通过图像识别、目标检测、图像分割等技术，AIGC能够识别和理解图像和视频中的信息，并生成与之相关的内容。同时，计算机视觉技术还能够帮助AIGC模拟各种绘画风格和技巧，生成具有艺术性的图像。</p>
<p><strong>4. 音频生成技术</strong></p>
<p>音频生成技术包括音频信号处理、音频合成、语音合成等。这些技术使得AIGC能够生成各种类型的音频内容，如音乐、语音等。音频生成技术通过模拟人类发声器官的工作原理，实现将文本转换为语音的功能，为AIGC提供了更加丰富的应用场景。</p>
<p><strong>5. 大数据技术</strong></p>
<p>大数据技术是AIGC技术发展的重要基础。通过大数据技术，AIGC能够处理和分析海量的数据，提取出有价值的信息，并基于这些信息生成高质量的内容。同时，大数据技术还能够帮助AIGC实现个性化推荐和精准营销等功能，提升用户体验和商业价值。</p>
<h2 id="四、AIGC如何运作？"><a href="#四、AIGC如何运作？" class="headerlink" title="四、AIGC如何运作？"></a>四、AIGC如何运作？</h2><p>通过单个大规模数据的学习训练，令AI具备了多个不同领域的知识，只需要对模型进行适当的调整修正，就能完成真实场景的任务。AIGC的工作原理可以分为以下几个步骤：</p>
<p><strong>步骤1：收集数据</strong></p>
<p>AIGC 需要大量的数据来学习和理解人类创作的内容。这些数据可以包括书籍、文章、图片、音频和视频等各种形式的媒体。</p>
<p><strong>步骤2：模型训练</strong></p>
<p>基于收集的数据，AIGC利用深度学习模型进行训练。这些模型通常是神经网络，它们通过学习文本、图像或音频的模式和语法规则来生成新内容。</p>
<p><strong>步骤3：内容生成</strong></p>
<p>一旦模型训练好，它就可以开始生成内容。用户可以输入一些基本的信息或要求，然后AIGC会根据这些信息生成相应的内容。这可以是新闻文章、小说、音乐、绘画等各种类型的作品。</p>
<p><strong>步骤4：反馈和改进</strong></p>
<p>AIGC通常会用户的反馈，用于改进接收的内容。这有助于模型不断学习并提高生成质量。</p>
<h2 id="五、AIGC产业结构"><a href="#五、AIGC产业结构" class="headerlink" title="五、AIGC产业结构"></a>五、AIGC产业结构</h2><p>AI产业链主要由基础层、技术层、应用层三大层构成。其中基础层侧重于基础支撑平台的搭建，包含传感器、AI芯片、数据服务和计算平台；技术层侧重核心技术的研发，主要包括算法模型、基础框架、通用技术；应用层注重产业应用发展主要包含行业解决方案服务、硬件产品和软件产品。</p>
<p>调研归纳发现，国内AIGC产业链结构主要由<strong>基础大模型、行业&#x2F;场景中模型、业务&#x2F;领域小模型，AI基础设施、AIGC配套服务五部分构成</strong>，并且已经形成了丰富的产业链。</p>
<p><a href="https://baike.baidu.com/pic/AIGC/59988381/0/18d8bc3eb13533fa828bf32ee984ea1f4134970aed2e?fr=lemma&fromModule=lemma_content-image"><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141115963.jpeg" alt="img"></a></p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title>什么是元原生</title>
    <url>/2024/06/01/k8s&amp;docker/%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E5%8E%9F%E7%94%9F/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="一、云原生是什么"><a href="#一、云原生是什么" class="headerlink" title="一、云原生是什么"></a>一、云原生是什么</h1><p>要理解云原生，可以把云原生拆分为云和原生两部分。<br><strong>云</strong><br>云原生的“云”代表“云计算”，因此在了解云原生之前，需要先了解云计算。</p>
<p>云计算的字面意义是通过互联网提供计算资源，其中最为基础的计算资源就是服务器、存储、网络资源等，这些资源是互联网世界的基础设施，因此提供这些资源的租用的服务就叫做 IaaS（Infrastructure as a Service）。显而易见，这些基础设施服务供应商都是业界大佬：AWS（亚马逊云）、Azure（微软云）、阿里云、谷歌云、IBM 云、腾讯云、华为云等。</p>
<p>供应商将大量的基础设施进行统一管理，通过虚拟化等技术手段，形成巨大的可动态分配资源池，大大促进了物理资源的利用率，因此也使得租用成本降低。企业只需要按照使用量进行付费，再不用付出昂贵的设施购买、维护成本。除此之外，云服务还有可随时按需伸缩容量、备份恢复简单、快速部署易于集成等优点。</p>
<p>云资源不仅包含基础设施，在云上搭建的开发平台、应用等都可以作为一种服务提供给用户，这就是Paas（Platform as a Service）和 SaaS（Software as a Service）。根据云服务的开放范围，又可以分为公有云、私有云、混合云。</p>
<span id="more"></span>

<p><strong>原生</strong><br>什么是原生呢？原生就是指土生土长。我们程序在开发设计的时候，在本地自建服务器运行和在云服务器运行，项目的架构设计等方面，都是完全不一样的。<br>而原生，就是指，应用程序从设计之初即考虑到云的环境，原生为云而设计，在云上以最佳姿势运行，要充分利用云上资源的优点，从而使我们的的应用更强大，更迅速、更稳定。</p>
<p><strong>云+原生</strong><br>云原生应用即专门为在云平台部署和运行而设计的应用。</p>
<p>云原生的英文是Cloud Native，Cloud Native Application 就是指应用从设计开始就是为部署在云环境上的。</p>
<p>云原生计算基金会（CNCF，CLOUD NATIVE COMPUTING FOUNDATION）提供的官方定义如下：</p>
<blockquote>
<p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。<br>这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。</p>
</blockquote>
<h1 id="二、云原生四要素"><a href="#二、云原生四要素" class="headerlink" title="二、云原生四要素"></a>二、云原生四要素</h1><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240616092545.png" alt="image-20240616092543653"></p>
<p><strong>微服务</strong><br>几乎每个云原生的定义都包含微服务。</p>
<p><strong>DevOps</strong><br>这是个组合词，Dev+Ops。实际上DevOps其实是一种软件研发管理的思想，方法论，它追求的是一种没有隔阂的理想的研发协作的状态，可能涉及到的角色有开发、测试、产品、项目管理、运维等等，目标是自动执行软件交付和基础架构更改流程，可支撑快速、频繁、可靠地构建、测试和发布软件，缩短开发周期，增加部署频率，更可靠地发布。</p>
<p><strong>持续交付</strong><br>持续交付是不误时开发，不停机更新，小步快跑，反传统瀑布式开发模型，这要求开发版本和稳定版本并存，其实需要很多流程和工具支撑。</p>
<p><strong>容器化</strong><br>Docker是应用最为广泛的容器引擎，在思科谷歌等公司的基础设施中大量使用，是基于LXC技术搞的，容器化为微服务提供实施保障，起到应用隔离作用，K8S是容器编排系统，用于容器管理，容器间的负载均衡。</p>
<h1 id="三、云原生技术"><a href="#三、云原生技术" class="headerlink" title="三、云原生技术"></a>三、云原生技术</h1><p>云原生技术有很多，大体可以分为以下5种：容器、服务网格、声明式API、不可变基础设施、微服务。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240616091632.png" alt="image-20240616091629484"></p>
<h2 id="容器-Containers"><a href="#容器-Containers" class="headerlink" title="容器(Containers)"></a>容器(Containers)</h2><p>容器是是一种轻量级、可移植、自包含的软件打包技术，以容器为基础，应用程序封装在容器之中，在容器里运行，实现资源的相对隔离与容器镜像的重复使用，能够使应用程序在几乎任何地方以相同的方式运行。</p>
<p>开发人员只要编写一次应用程序，无须任何修改就能够在生产系统的虚拟机、物理服务器或公有云主机上等任意位置运行。这大大简化了开发的工作量，同时对于运维人员也极为友好，不需要再为环境问题而苦恼。使用到的技术包括Docker和k8s。</p>
<h2 id="服务网格-Service-Meshes"><a href="#服务网格-Service-Meshes" class="headerlink" title="服务网格(Service Meshes)"></a>服务网格(Service Meshes)</h2><p>服务网格(Service Mesh)是一个专门处理服务与服务之间通讯的基础设施层。它的职责是在由云原生应用组成服务的复杂拓扑结构下进行可靠的请求传送。在实践中，它是一组和应用服务部署在一起的轻量级的网络代理，并且对应用服务透明。</p>
<h2 id="微服务-Microservices"><a href="#微服务-Microservices" class="headerlink" title="微服务(Microservices)"></a>微服务(Microservices)</h2><p>微服务区别于单体应用而生。传统的单体应用由于耦合度高、扩展性差、迭代缓慢等缺点，已无法适应移动互联时代用户体量以及访问量几何式倍增、用户需求快速变化的现状。微服务便应运而生，其本质上是对传统的单体应用根据业务领域和模块进行划分、解耦，拆分成一个一个相对独立，相互解耦、单独部署、运行的微小应用。</p>
<h2 id="不可变基础设施-Immutable-Infrastructure"><a href="#不可变基础设施-Immutable-Infrastructure" class="headerlink" title="不可变基础设施(Immutable Infrastructure)"></a>不可变基础设施(Immutable Infrastructure)</h2><p>不可变基础设施里的“不可变”非常类似于程序设计中的“不可变”概念。程序设计中不可变变量(ImmutableVariable)就是在完成赋值后就不能发生更改，只能创建新的来整体替换旧的。由于具有这样的特性这种变量可以在并发环境下安全的使用。</p>
<p>对于基础设施的不可变性，最基本的就是指运行服务的服务器在完成部署后，就不在进行更改。如果需要以任何方式更新，修复或修改某些内容，则会根据具有相应更改的公共镜像构建新服务器以替换旧服务器。</p>
<p>不可变基础架构的好处包括基础架构中更高的一致性和可靠性，以及更简单，更可预测的部署过程，它可以缓解或完全防止可变基础架构中常见的问题，例如配置漂移和雪花服务器。</p>
<h2 id="声明式API-Deciarative-API"><a href="#声明式API-Deciarative-API" class="headerlink" title="声明式API(Deciarative API)"></a>声明式API(Deciarative API)</h2><p>声明式API是一种能够一次处理多个写操作、具备Merge能力的API。区别于命令式API直接发出的让服务器执行的命令，声明式API声明的是期望的状态，系统将不断地调整实际状态，直到与期望状态保持一致。</p>
<p>声明式API是Kubernetes的技术点，它的核心原理，就是当用户向Kubernetes提交了一个API对象的描述之后，Kubernetes会负责为你保证整个集群里各项资源的状态，都与你的API对象描述的需求相一致。更重要的是，这个保证是一项”无条件的”、”没有期限”的承诺：对于每个保存在etcd里的API对象，Kubernetes都通过启动一种叫做”控制器模式”(Controller Pattern)的无限循环，不断检查，然后调节，最后确保整个集群的状态与这个AP!对象的描述一致。</p>
<h1 id="四、云原生的好处"><a href="#四、云原生的好处" class="headerlink" title="四、云原生的好处"></a>四、云原生的好处</h1><ul>
<li>快速云原生架构使用敏捷开发和单位，不但可以让企业快速的进行开发，自动化的不做产品，同时还能持续地更新产品，让产品跟得上需求，甚至是引导需求，让企业立于不败之地。</li>
<li>弹性扩展云原生架构天生具有云计算的特点，资源可以按需进行伸缩，这样不单提高资源的利用率，也大大降低了企业成本。</li>
<li>强壮云原生架构依托于容器编排工去k8s与微服务的组合应用，就拥有了自动恢复能力，容错能力，故障隔离能力，让应用更强。</li>
<li>屏蔽底层差异，因为使用的容器化技术应用运行于容器之中，就不需要考虑底层硬件的差异，这大大简化了开发的工作量，同时对于运维人员也极为友好，不需要再为环境问题而苦恼。</li>
</ul>
<hr>
<p>转载自：<br><a href="https://www.yunsucheng.com/archives/6183">https://www.yunsucheng.com/archives/6183</a><br><a href="https://zhuanlan.zhihu.com/p/566804725">https://zhuanlan.zhihu.com/p/566804725</a></p>
]]></content>
      <categories>
        <category>k8s&amp;docker</category>
      </categories>
  </entry>
  <entry>
    <title>如何设计RPC框架</title>
    <url>/2024/04/05/Dubbo/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1RPC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;RPC框架的核心目标是解决分布式系统中服务之间的调用问题。</p>
<h3 id="RPC框架三个核心角色"><a href="#RPC框架三个核心角色" class="headerlink" title="RPC框架三个核心角色"></a>RPC框架三个核心角色</h3><p>&emsp;&emsp;1)服务提供者（Server）对外提供后台服务，将自己的服务信息，注册到注册中心</p>
<p>&emsp;&emsp;2)注册中心（Registry）用于服务端注册远程服务以及客户端发现服务。</p>
<p>&emsp;&emsp;3)服务消费者（Client） 从注册中心获取远程服务的注册信息，然后进行远程过程调用。</p>
<p>&emsp;&emsp;</p>
<h3 id="RPC远程调用过程"><a href="#RPC远程调用过程" class="headerlink" title="RPC远程调用过程"></a>RPC远程调用过程</h3><p>&emsp;&emsp;1）服务调用方（client）调用以本地调用方式调用服务；<br>&emsp;&emsp;2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；在Java里就是序列化的过程；<br>&emsp;&emsp;3）client stub找到服务地址，并将消息通过网络发送到服务端；<br>&emsp;&emsp;4）server stub收到消息后进行解码,在Java里就是反序列化的过程；<br>&emsp;&emsp;5）server stub根据解码结果调用本地的服务；<br>&emsp;&emsp;6）本地服务执行处理逻辑；<br>&emsp;&emsp;7）本地服务将结果返回给server stub；<br>&emsp;&emsp;8）server stub将返回结果打包成消息，Java里的序列化；<br>&emsp;&emsp;9）server stub将打包后的消息通过网络并发送至消费方；<br>&emsp;&emsp;10）client stub接收到消息，并进行解码, Java里的反序列化；<br>&emsp;&emsp;11）服务调用方（client）得到最终结果。</p>
<p>&emsp;&emsp;RPC框架的目标就是要2~10这些步骤都封装起来。</p>
<span id="more"></span>

<h3 id="RPC框架涉及技术"><a href="#RPC框架涉及技术" class="headerlink" title="RPC框架涉及技术"></a>RPC框架涉及技术</h3><p>a.建立通信<br>&emsp;&emsp;首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。<br>&emsp;&emsp;当前很多RPC框架都直接基于netty这一IO通信框架，推荐使用Netty 作为底层通信框架。</p>
<p>b.网络传输<br>&emsp;&emsp;数据传输采用什么协议（二进制数据格式组织）？<br>&emsp;&emsp;数据该如何序列化和反序列化？(kryo&#x2F;protobuf&#x2F;protostuff&#x2F;hessian&#x2F;fastjson&#x2F;…)</p>
<p>c.服务寻址<br>&emsp;&emsp;1）服务注册<br>&emsp;&emsp;服务提供者启动后主动把服务注册到服务中心，注册中心存储了该服务的IP、端口、调用方式(协议、序列化方式)等信息。</p>
<p>&emsp;&emsp;2）服务发现<br>&emsp;&emsp;服务消费者第一次调用服务时，会通过注册中心找到相应的服务提供方地址列表，并缓存到本地，以供后续使用。当消费者再次调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从IP列表中取一个服务提供者的服务器调用服务。</p>
<p>d.服务调用<br>&emsp;&emsp;服务消费者进行本地调用（通过代理Proxy）之后得到了返回值。实际上是在Proxy中封装了一系列的过程，包括序列化、请求服务提供者、反序列化等等。<br>&emsp;&emsp;创建Proxy的方式?(jdk proxy&#x2F;javassist&#x2F;cglib&#x2F;asm&#x2F;bytebuddy)<br>&emsp;&emsp;Proxy还能做什么？软负载均衡(加权随机、加权轮询、最小负载、一致性Hash…) 、集群容错(Fail-fast、Failover、Fail-safe、Fail-back)、同步&#x2F;异步调用、流控、熔断、降级、限流、隔离和超时…(服务治理)</p>
<p>&emsp;&emsp;</p>
<h3 id="实现高可用RPC框架需要考虑到的问题"><a href="#实现高可用RPC框架需要考虑到的问题" class="headerlink" title="实现高可用RPC框架需要考虑到的问题"></a>实现高可用RPC框架需要考虑到的问题</h3><p>&emsp;&emsp;要实现一个RPC不算难，难的是实现一个高性能高可靠的RPC框架。</p>
<ul>
<li>既然系统采用分布式架构，那一个服务势必会有多个实例，要解决如何获取实例的问题？</li>
<li>如何选择实例呢？就要考虑负载均衡</li>
<li>如果每次都去注册中心查询列表，效率很低，那么就要加缓存</li>
<li>客户端总不能每次调用完都等着服务端返回数据，所以就要支持异步调用</li>
<li>服务端的接口修改了，老的接口还有人在用，这就需要版本控制；</li>
<li>服务端总不能每次接到请求都马上启动一个线程去处理，于是就需要线程池；</li>
</ul>
<hr>
<p>&emsp;&emsp;<br><strong>Failover</strong> - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries&#x3D;”2” 来设置重试次数(不含第一次)。</p>
<p><strong>Failfast</strong> - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
<p><strong>Failsafe</strong> - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
<p><strong>Failback</strong> - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
<p><strong>Forking</strong> - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks&#x3D;”2” 来设置最大并行数。</p>
<p><strong>Broadcast</strong> - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息</p>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>Kubernetes快速入门</title>
    <url>/2024/06/11/k8s&amp;docker/Kubernetes%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="一、Docker"><a href="#一、Docker" class="headerlink" title="一、Docker"></a>一、Docker</h1><p>在介绍docker之前，先简单回顾一下操作系统是如何管理进程的。</p>
<p>首先，当我们登录到操作系统之后，可以通过 ps 等操作看到各式各样的进程，这些进程包括系统自带的服务和用户的应用进程。那么，这些进程都有什么样的特点？</p>
<ul>
<li>第一，这些进程可以相互看到、相互通信；</li>
<li>第二，它们使用的是同一个文件系统，可以对同一个文件进行读写操作；</li>
<li>第三，这些进程会使用相同的系统资源。</li>
</ul>
<p>这样的三个特点会带来什么问题呢？</p>
<ul>
<li>因为这些进程能够相互看到并且进行通信，高级权限的进程可以攻击其他进程；</li>
<li>因为它们使用的是同一个文件系统，因此会带来两个问题：这些进程可以对于已有的数据进行增删改查，具有高级权限的进程可能会将其他进程的数据删除掉，破坏掉其他进程的正常运行；此外，进程与进程之间的依赖可能会存在冲突，如此一来就会给运维带来很大的压力；</li>
<li>因为这些进程使用的是同一个宿主机的资源，应用之间可能会存在资源抢占的问题，当一个应用需要消耗大量 CPU 和内存资源的时候，就可能会破坏其他应用的运行，导致其他应用无法正常地提供服务。</li>
</ul>
<p>针对上述的三个问题，如何为进程提供一个独立的运行环境呢？</p>
<ul>
<li>针对不同进程使用同一个文件系统所造成的问题而言，Linux 和 Unix 操作系统可以通过 chroot 系统调用将子目录变成根目录，达到视图级别的隔离；进程在 chroot 的帮助下可以具有独立的文件系统，对于这样的文件系统进行增删改查不会影响到其他进程；</li>
<li>因为进程之间相互可见并且可以相互通信，使用 Namespace 技术来实现进程在资源的视图上进行隔离。在 chroot 和 Namespace 的帮助下，进程就能够运行在一个独立的环境下了；</li>
<li>但在独立的环境下，进程所使用的还是同一个操作系统的资源，一些进程可能会侵蚀掉整个系统的资源。为了减少进程彼此之间的影响，可以通过 Cgroup 来限制其资源使用率，设置其能够使用的 CPU 以及内存量。</li>
</ul>
<p><strong>容器就是一个视图隔离、资源可限制、独立文件系统的进程集合。</strong>容器就是一个进程集合，它将系统的其他资源隔离开来，具有自己独立的资源视图。Docker 就是基于上述技术实现的。</p>
<span id="more"></span>

<h1 id="二、Docker-compose"><a href="#二、Docker-compose" class="headerlink" title="二、Docker-compose"></a>二、Docker-compose</h1><p>Docker-compose 是一个单节点编排技术。如果把 docker 比喻成一堆杂乱无章的集装箱，而 compose 能够对这些集装箱整理归类，作为一个整体启动运行，docker-compose 是以 docker 为核心进行构建的，本身只支持单节点编排，在复杂多变的生产环境是无法投入使用的。docker-compose 适合于需要多个容器相互配合来完成服务的运行，当我们在开发工作中遇到一个项目运行，需要多个服务配合甚至数据库、负载均衡等这个时候我们可以考虑使用 Compose 编排管理，提高部署效率。</p>
<h1 id="三、Kubernetes"><a href="#三、Kubernetes" class="headerlink" title="三、Kubernetes"></a>三、Kubernetes</h1><p>工业级的编排平台主要提供服务的部署、弹性和管理；Kubernetes是希腊语，翻译中文是“舵手、飞行员”的意思。k8s，省略中间8个ubernete替换为8，而得来k8s。<br>如果说 docker 把应用打包成镜像，那么 Kubernetes 保证容器化应用简单高效运行。他跟 docker-swarm、moby 项目不同，它不在以 docker 为核心，而是把 docker 作为一个运行时组件，更多是提供应用部署，规划，更新，维护，在复杂多变的生产环境中，这些往往是我们更加需要的。</p>
<h2 id="3-1、Kubernetes-核心功能"><a href="#3-1、Kubernetes-核心功能" class="headerlink" title="3.1、Kubernetes 核心功能"></a>3.1、Kubernetes 核心功能</h2><p>1、服务发现和负载均衡：主要通过 Service 资源对象其底层是基于 iptables 实现。</p>
<p>2、服务自动装箱：主要是通过调度 组件 Scheduler 实现，它能够自动给帮助我们把容器调度到某几台机器上自动启动运行。</p>
<p>3、容器存储编排：Kubernetes 有跟 compose 类似的编排 yml 文件，让存储的生命周期和容器的生命周期有一个链接。</p>
<p>4、容器故障恢复：在集群环境中经常会因为系统原因、以及宿主机问题导致容器不可用，Kubernetes 会帮助我们把不可用的容器进行恢复或者转移到正常节点上面去。</p>
<p>5、自动发布和回滚：Kubernetes 能够对我们的应用进行自动的发布和回滚，并且根据不同应用场景提供了不同发布和回滚策略。</p>
<p>6、配置和密钥存储：Kubernetes 提供了 ConfigMap 解决了集群环境中配置文件的存储问题，其底层是基于数据卷实现，原应用不用修改任何代码即可无缝对接。</p>
<p>7、服务水平伸缩：Kubernetes 为了让集群更具有弹性提供了水平伸缩功能，如果线上有某种大流量活动，我们可以直接水平扩展应用部署应用的数量，当活动结束后，再减少应用部署的数量，从而高效应对高并发场景。</p>
<p>8、批量执行以及守护进程任务：Kubernentes 可以对 Job 类型的任务，进行批量的执行，比如数据同步、备份等；如果我们想要集群环境中每个节点都运行一份守护进程进行节点任务执行，我们可以使用 Kubernetes DeamonSet 资源类型进行任务执行。</p>
<p>9、探针：Kubernetes 主要提供了存活和就绪两种探针，支持 http、tcp、socket 或者脚本的形式进行检测服务是否正常，对原有服务架构没有任何侵入性。</p>
<h2 id="3-2、图文演示-Kubernetes-部分特性"><a href="#3-2、图文演示-Kubernetes-部分特性" class="headerlink" title="3.2、图文演示 Kubernetes 部分特性"></a>3.2、图文演示 Kubernetes 部分特性</h2><ul>
<li><p>Kubernetes 的调度器 Scheduler 可以把用户提交的容器，根据其规格大小调度到其中的一个节点上。如下动图所示：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612144954.gif" alt="图片"></p>
</li>
<li><p>Kubernetes 平台有健康检查的功能，当集群中的某个节点或者应用出现故障时，能够自动转移到健康节点上。如下动图所示：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612145048.gif" alt="图片"></p>
</li>
<li><p>Kubernetes 具备 HPA 自动扩容的能力，目前只支持按照 CPU 指标和用户自定义（比如 TPS 或 QPS）达到某个数量级触发自动扩容，当请求高峰过去之后，pod 可以恢复到原来的水平。如下图所示检测到白色节点负载过高，自动把服务复制两份，分发到其它节点运行：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612145103.gif" alt="图片"></p>
</li>
</ul>
<h2 id="3-3、架构介绍"><a href="#3-3、架构介绍" class="headerlink" title="3.3、架构介绍"></a>3.3、架构介绍</h2><p>Kubernetes 基于两层架构设计，主要包含主节点 master 和计算节点 node，master 包含 web UI 界面和 cli 命令行，支持多个 master 高可用部署，master 主要下发命令到 node，node 主要用于容器任务执行。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612145145.png" alt="img"></p>
<h2 id="3-4、master"><a href="#3-4、master" class="headerlink" title="3.4、master"></a>3.4、master</h2><p>master 主要包含 APIServer、Scheduler、Controller、Etcd 等组件。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612145202.png" alt="img"></p>
<h3 id="3-4-1、API-Server"><a href="#3-4-1、API-Server" class="headerlink" title="3.4.1、API Server"></a>3.4.1、API Server</h3><p>API Server 提供了资源的增、删、改、查等操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制，集群内部组件与组件之间不能直接调用，调用过程都要经过 ApiServer，其中 Apiserver 支持高可用配置。</p>
<h3 id="3-4-2、Scheduler"><a href="#3-4-2、Scheduler" class="headerlink" title="3.4.2、Scheduler"></a>3.4.2、Scheduler</h3><p>Scheduler 负责资源的调度策略，能够按照预设的策略把 pod 调度到相应的节点上，支持热备。</p>
<h3 id="3-4-3、Controller"><a href="#3-4-3、Controller" class="headerlink" title="3.4.3、Controller"></a>3.4.3、Controller</h3><p>Controller 负责维护集群的状态，资源对象的自动化控制中心，比如故障检测、自动扩展、滚动更新、服务帐户和令牌控制器等功能都是由 Kubernetes Controller 完成，支持热备。</p>
<h3 id="3-4-4、etcd"><a href="#3-4-4、etcd" class="headerlink" title="3.4.4、etcd"></a>3.4.4、etcd</h3><p>etcd 主要功能保存整个集群的状态；etcd 本身是一个独立与 Kubernetes 集群之外的分布式存储系统。支持高可用配置。</p>
<h2 id="3-5、node"><a href="#3-5、node" class="headerlink" title="3.5、node"></a>3.5、node</h2><p>Kubernetes 的业务是在 node上运行，而业务都是以最小单元 pod 进行运行的，而 pod 中可以运行一个或者多个容器，pod 本身在 kubelet 组件上运行，它通过跟 apiserver 进行交互获得 pod 的状态。node 主要包含 Kubelet、kube-proxy、Container Runtime、存储插件、网路插件等。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612145406.png" alt="img"></p>
<h3 id="3-5-1、kubelet"><a href="#3-5-1、kubelet" class="headerlink" title="3.5.1、kubelet"></a>3.5.1、kubelet</h3><p>kubelet 主要负责 pod 的创建、启动停止等任务，与 master 节点密切交互完成集群管理和运行的基本功能。</p>
<h3 id="3-5-2、kube-proxy"><a href="#3-5-2、kube-proxy" class="headerlink" title="3.5.2、kube-proxy"></a>3.5.2、kube-proxy</h3><p>kube-proxy 主要用于通过 Service 提供集群内部的服务发现和负载均衡。</p>
<h3 id="3-5-3、Container-Runtime"><a href="#3-5-3、Container-Runtime" class="headerlink" title="3.5.3、Container Runtime"></a>3.5.3、Container Runtime</h3><p>Container Runtime 主要负责镜像管理以及 pod 内容器运行环境配置。</p>
<h2 id="3-6、Kubernetes-资源对象"><a href="#3-6、Kubernetes-资源对象" class="headerlink" title="3.6、Kubernetes 资源对象"></a>3.6、Kubernetes 资源对象</h2><p>Kubernetes 提供了多种资源对象、配置对象、存储对象、策略对象，可以根据需求选择使用：</p>
<p>1、资源对象：Pod、ReplicaSet、ReplicationController、Deployment、StatefulSet、DaemonSet、Job、CronJob、HorizontalPodAutoscaling。<br>2、配置对象：Node、Namespace、Service、Secret、ConfigMap、Ingress、Label、ThirdPartyResource、 ServiceAccount。<br>3、存储对象：Volume、Persistent Volume及三方插件（NFS、ceph、gfs）。<br>4、策略对象：SecurityContext、ResourceQuota、LimitRange。</p>
<h2 id="3-7、Kubernetes-集群平台中-pod-执行过程"><a href="#3-7、Kubernetes-集群平台中-pod-执行过程" class="headerlink" title="3.7、Kubernetes 集群平台中 pod 执行过程"></a>3.7、Kubernetes 集群平台中 pod 执行过程</h2><p>用户可以通过命令行提交一个 pod 到 API Server，API Server 把 pod 当前信息存储到 etcd 数据库中，Scheduler 调度器根据 pod 规格资源配置调度某个节点上，通知 API Server 把调度的节点信息和 pod 存储到 etcd 中，API Server 会通知相应节点的 kubelet 执行启动，kubelet 首先调用 Container RunTime 配置容器以及运行环境，然后调度存储插件配置存储，网络插件配置网络，从而完成容器的运行。</p>
<h2 id="3-8、pod"><a href="#3-8、pod" class="headerlink" title="3.8、pod"></a>3.8、pod</h2><ol>
<li><p>最小调度以及资源单位，为什么 pod 是最小调度单位？<br>这里举个例子：我们有个多进程应用（比如 rsyslog 就是多进程应用），其中包含三个进程 p1，p2，p3，这三个进程必须运行在一台机器上，每个进程需要占用 0.5GB 内存，现在我们有三台机器，node1（2G）node2（1G）node3（1G）；假设 pod 不是最小调度单位，p1 调度到 node2 上，这完全是有可能的，因为 node2 资源足够 p1 使用，紧接着 p2 也被调度到 node2 上，那么问题来了 p3 呢？当然我们可以通过加锁的方式解决，但是如何加锁呢，都是问题，但是 Kubernetes 通过把 pod 作为最小调度单位从而解决了此问题；</p>
</li>
<li><p>包含一个或者多个容器，如果说我们服务之间存在大量 rpc 调用，这时我们可以把应用放在一个 pod 中运行，共享同一个网络环境，直接本地调用，而 pod 和 pod 之间是网络隔离，可以通过 Service 访问；</p>
</li>
<li><p>定义容器运行时方式（命令和环境变量）；</p>
</li>
<li><p>提供给容器共享的运行环境（网络和进程空间）。</p>
</li>
</ol>
<h3 id="3-8-1、pod-结构"><a href="#3-8-1、pod-结构" class="headerlink" title="3.8.1、pod 结构"></a>3.8.1、pod 结构</h3><p>pod 相当于一个容器，pod 有独立的 ip 地址，也有自己的 hostname，利用 namespace 进行资源隔离，相当于一个独立沙箱环境。</p>
<p>pod 内部封装的是容器，可以封装一个，或者多个容器（通常是一组相关的容器）</p>
<h3 id="3-8-2、pod-网络"><a href="#3-8-2、pod-网络" class="headerlink" title="3.8.2、pod 网络"></a>3.8.2、pod 网络</h3><p>pod 有自己独立的 IP 地址</p>
<p>pod 内部的容器之间是通过 localhost 进行访问</p>
<h3 id="3-8-3、pod-如何对外提供访问"><a href="#3-8-3、pod-如何对外提供访问" class="headerlink" title="3.8.3、pod 如何对外提供访问"></a>3.8.3、pod 如何对外提供访问</h3><p>首先 pod 有自己的 IP 和 hostname，但 pod 是虚拟的资源对象 (在计算机中表现为进程)，没有对应实体 (物理机，物理网卡) 与之对应，所以是无法直接对外提供服务访问的。因此如果 pod 想对外提供服务，必须绑定物理机端口 (即在物理机上开启端口，让这个端口和 pod 的端口进行映射)，这样就可以通过物理机进行数据包的转发。</p>
<h3 id="3-8-4、pod-的负载均衡"><a href="#3-8-4、pod-的负载均衡" class="headerlink" title="3.8.4、pod 的负载均衡"></a>3.8.4、pod 的负载均衡</h3><p>很关键的一个问题：一组相关的 pod 副本，如何实现访问负载均衡？就如当请求达到，请求转发给哪个 pod 比较好？<br>一个想法就是用 pod 再部署一个 Nginx。但pod 是一个进程，是有生命周期的，一旦宕机、版本更新都会创建新的 pod（ IP 地址会变化，hostname 会变化），此时再使用 Nginx 做负载均衡不太合适，因为它不知道 pod 发生了改变，那请求就不能被接受了。所以服务发生了变化它根本不知道，Nginx 无法发现服务，不能用 Nginx 做负载均衡。那该如何实现呢？使用 Service 资源对象。</p>
<h2 id="3-9、Deployment"><a href="#3-9、Deployment" class="headerlink" title="3.9、Deployment"></a>3.9、Deployment</h2><blockquote>
<ol>
<li>定义 pod 副本数量、版本等；</li>
<li>通过 ReplicaSet 控制 pod 数量（自动重启失败的 pod）；</li>
<li>按照指定策略控制版本（版本升级、回滚、重新生成）；</li>
</ol>
</blockquote>
<p>Deployment 是一个控制器，能够用来控制 pod 数量跟期望数量一致，配置 pod 的发布方式，Deployment 会按照给定策略进行发布 pod，保证在更新过程中不可用数量在限定范围内。看了上面的介绍感觉像是 Deployment 直接控制 pod，其实不然，Deployment 控制 ReplicateSet　ReplicateSet 控制 pod 副本的数量，pod 所属于 replicaset，同一个 replicaset 下的 pod 版本都是一样的。</p>
<h2 id="3-10、Volume"><a href="#3-10、Volume" class="headerlink" title="3.10、Volume"></a>3.10、Volume</h2><blockquote>
<ol>
<li>Pod中一个或者多个容器可以访问的目录</li>
<li>支持多种存储的抽象 本地存储、分布式存储、云存储</li>
</ol>
</blockquote>
<p>在 docker 中 volume 就是对应磁盘或者其它容器中的目录，docker 对它的管理比较松散，没有生命周期管理，而 Kubernetes 中的 volume 的生命周期和 pod 的生命周期相同。相比与 pod 中的容器来说，存储数据可能比容器生命周期更长，并且在容器重新启动后保留存储信息。在 Kubernetes 支持多种类型的卷，而 Pod 可以同时使用各种类型和任意数量的存储卷。</p>
<h2 id="3-11、Service"><a href="#3-11、Service" class="headerlink" title="3.11、Service"></a>3.11、Service</h2><p>提供访问多个pod的稳定访问方式 （IP、域名、环境变量）。说到Service不得不介绍kubernetes网络模型和通信方式。</p>
<ol>
<li>网络模型：一个完整的 Kubernetes 集群应该包含三层网络，首先第一层是 mater 和 node 节点之间的网络，这个网络需要在部署 kubernetes 集群之前配置完成。第二层网络是 pod 的网络通过 kubenet 或者 cni 插件实现，用于 pod 之间或者内部的通信，集群中的所有 pod 均处在同一个网络平面空间内，可以直接通信。第三层网络是 Service 资源的网络，是一个虚拟网络，用于为 Kubernetes 集群配置 IP 地址，但此地址并不配置于任何主机或者容器的网络接口之上，而是通过 kubeproxy 配置为 iptables 规则，将发往该地址的所有流量调度至后端的 pod 之上。</li>
<li>通信方式：同一个 pod 的内部通信；各个 pod 彼此通信；pod 和 service 的通信；集群外部流向 service 的通信。</li>
<li>端口介绍：containerPort是一个信息性数据，只是为集群提供一个可以快速了解相关  pod 可以访问端口的途径，而且显式指定容器端口，无论你是否指定都不影响其他节点上的客户端 pod 对其进行访问；port 是服务提供端口，用于 kubernetes 集群内部服务访问；targetPort 是 pod 目标端口，如果不设置使用默认 port 端口，port 和 nodePort 的数据通过这个端口进入到 Pod 内部，Pod 里面的 container 的端口映射到这个端口，提供服务；nodePort 是外部用户访问端口。</li>
</ol>
<h3 id="3-11-1、Service-资源对象是什么？"><a href="#3-11-1、Service-资源对象是什么？" class="headerlink" title="3.11.1、Service 资源对象是什么？"></a>3.11.1、Service 资源对象是什么？</h3><ul>
<li>POD IP：pod 的 IP 地址</li>
<li>NODE IP：物理机的 IP 地址</li>
<li>cluster IP：虚拟 IP，是由 kubernetes 抽象出的 service 对象，这个 service 对象就是一个 VIP (virtual IP, VIP) 的资源对象</li>
</ul>
<h3 id="3-11-2、service-如何实现负载均衡"><a href="#3-11-2、service-如何实现负载均衡" class="headerlink" title="3.11.2、service 如何实现负载均衡"></a>3.11.2、service 如何实现负载均衡</h3><p>例如现在要负载均衡地访问一组相同的服务副本——订单，这时就要去做一个 service，对外表现出是一个进程或资源对象，有虚拟的 IP (VIP) 和端口。请求会访问 service，然后 service 自己会 负载均衡 地发送给相应服务的 POD，也就是下图中 4 个相同的 pod。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612151059.png" alt="img"></p>
<h3 id="3-11-3、深入-service-VIP"><a href="#3-11-3、深入-service-VIP" class="headerlink" title="3.11.3、深入 service VIP"></a>3.11.3、深入 service VIP</h3><ul>
<li>service 和 pod 都是一个进程，都是虚拟的，因此实际上 service 也不能对外网提供服务</li>
<li>service 和 pod 之间可以直接进行通信，它们的通信属于局域网通信</li>
<li>负载策略：把请求交给 service 后，service 使用 iptables，ipvs 来实现数据包的分发</li>
</ul>
<p>而要对外网提供服务，首先需要和之前一样 在物理机上也绑定一个端口 来接受访问请求，然后把请求转发给 service，service 再把数据包分发给相应的 POD。访问流程如下图所示：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612151157.png" alt="img"></p>
<p><strong>那 service 对象是如何和 pod 进行关联的呢？</strong>它们之间的关联利用的 还是标签选择器 selector。且service 只能对 一组相同的副本 提供服务，不能跨组提供服务。如果有另一组，需要再创建一个 service。因此不同的业务会有不同的 service。举例：service 和 一组 pod 副本是通过标签选择器进行关联的，相同的副本的标签是一样的。selector：app &#x3D; x 选择一组订单的服务的 pod，创建一个 service；app &#x3D; y 选择了一组支付的服务的 pod。通过一个 endpoints 属性存储这组 pod 的 IP 地址，这样就有了映射关系了 (关联起来)。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612151243.png" alt="img"></p>
<p>pod 宕机或发布新版本了，service 是如何发现 pod 已经发生变化的？通过 k8s 中的一个组件 —— kube-proxy 每个 NODE 里都运行着这个服务。它需要做的工作如下图右侧：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612151256.png" alt="img"></p>
<p>service 实现服务的发现：kube-proxy 监控 pod，一旦发现 pod 服务变化，将会把新的 ip 地址更新到 service。注意：endpoints 那些都是存储在 etcd 里的，所以 kube-proxy 更新的存储在 etcd 里的映射关系。</p>
<h2 id="3-12、API-基础知识"><a href="#3-12、API-基础知识" class="headerlink" title="3.12、API 基础知识"></a>3.12、API 基础知识</h2><p>通过命令行提交一个pod到时候，其提交的内容是yml，yml是一种特殊资源配置文件，主要包含 apiversion、kind、metadata、spec几部分组成。</p>
<blockquote>
<p>apiVersion：用来描述当前操作的资源对象；<br>kind：是指资源类型，比如 Pod、Department 等；<br>metadata：是写上当前 pod 的名称，比如 nginx。刚刚介绍的 Deployment，它可能是代表一组的 Pod，它是一组 Pod 的抽象，一组 Pod 就是通过 label selector 来表达的，Service 通过选择一组 pod 统一进行访问。<br>spec：描述了pod预期达到状态，比如内部需要哪些container运行，需要哪些镜像，暴露什么端口等等信息，需要在这里定义。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template </span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># create pods using pod definition in this template </span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">     <span class="comment"># unlike pod-nginx.yaml, the name is not included in the meta data as a unique name is </span></span><br><span class="line">     <span class="comment">#       # generated from the deployment name  </span></span><br><span class="line">     <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker.hub.com/ops/openresty:1.15.8.2-6</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<hr>
<p>转载自：<br><a href="https://blog.csdn.net/u012562943/article/details/122337223">https://blog.csdn.net/u012562943/article/details/122337223</a><br><a href="https://blog.csdn.net/alisystemsoftware/article/details/100780078">https://blog.csdn.net/alisystemsoftware/article/details/100780078</a></p>
]]></content>
      <categories>
        <category>k8s&amp;docker</category>
      </categories>
  </entry>
  <entry>
    <title>控制器</title>
    <url>/2024/06/11/k8s&amp;docker/%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="控制器类型"><a href="#控制器类型" class="headerlink" title="控制器类型"></a>控制器类型</h2><ul>
<li>ReplicationController 和 ReplicaSet</li>
<li>Deployment</li>
<li>DaemonSet</li>
<li>StateFulSet</li>
<li>Job&#x2F;CronJob</li>
<li>Horizontal Pod Autoscaling</li>
</ul>
<span id="more"></span>

<p><strong>ReplicationController 和 ReplicaSet</strong><br>ReplicationController（RC）用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收；</p>
<p>在新版本的 Kubernetes 中建议使用 ReplicaSet 来取代 ReplicationController 。ReplicaSet 跟ReplicationController 没有本质的不同，只是名字不一样，并且 ReplicaSet 支持集合式的 selector；</p>
<p><strong>Deployment</strong><br>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义 (declarative) 方法，用来替代以前的ReplicationController 来方便的管理应用。典型的应用场景包括；</p>
<ul>
<li>定义 Deployment 来创建 Pod 和 ReplicaSet</li>
<li>滚动升级和回滚应用</li>
<li>扩容和缩容</li>
<li>暂停和继续 Deployment</li>
</ul>
<p><strong>DaemonSet</strong><br>DaemonSet 确保全部（或者一些）Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。<br>使用 DaemonSet 的一些典型用法：</p>
<ul>
<li>运行集群存储 daemon，例如在每个 Node 上运行 glusterd 、 ceph</li>
<li>在每个 Node 上运行日志收集 daemon，例如 fluentd 、 logstash</li>
<li>在每个 Node 上运行监控 daemon，例如 Prometheus Node Exporter、 collectd 、Datadog 代理、New Relic 代理，或 Ganglia gmond</li>
</ul>
<p><strong>Job</strong><br>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束</p>
<p><strong>CronJob</strong><br>Cron Job 管理基于时间的 Job，即：</p>
<ul>
<li>在给定时间点只运行一次</li>
<li>周期性地在给定时间点运行</li>
</ul>
<p>使用前提条件：当前使用的 Kubernetes 集群，版本 &gt;&#x3D; 1.8（对 CronJob）。对于先前版本的集群，版本 &lt;1.8，启动 API Server时，通过传递选项 <code>--runtime-config=batch/v2alpha1=true</code> 可以开启 batch&#x2F;v2alpha1 API</p>
<p>典型的用法如下所示：</p>
<ul>
<li>在给定的时间点调度 Job 运行</li>
<li>创建周期性运行的 Job，例如：数据库备份、发送邮件</li>
</ul>
<p><strong>StatefulSet</strong><br>StatefulSet 作为 Controller 为 Pod 提供唯一的标识。它可以保证部署和 scale 的顺序。<br>StatefulSet 是为了解决有状态服务的问题（对应Deployments和ReplicaSets是为无状态服务而设计），其应用场景包括：</p>
<ul>
<li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li>
<li>稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service（即没有Cluster IP的Service）来实现</li>
<li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态），基于init containers来实<br>现</li>
<li>有序收缩，有序删除（即从N-1到0）</li>
</ul>
<p><strong>Horizontal Pod Autoscaling</strong><br>应用的资源使用率通常都有高峰和低谷的时候，如何削峰填谷，提高集群的整体资源利用率，让service中的Pod个数自动调整呢？这就有赖于Horizontal Pod Autoscaling了，顾名思义，使Pod水平自动缩放。</p>
<h2 id="RS-与-RC-与-Deployment-关联"><a href="#RS-与-RC-与-Deployment-关联" class="headerlink" title="RS 与 RC 与 Deployment 关联"></a>RS 与 RC 与 Deployment 关联</h2><p>RC （ReplicationController ）主要的作用就是用来确保容器应用的副本数始终保持在用户定义的副本数 。即如果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收。Kubernetes 官方建议使用 RS（ReplicaSet ） 替代 RC （ReplicationController ） 进行部署，RS 跟 RC 没有本质的不同，只是名字不一样，并且 RS 支持集合式的 selector。</p>
<p>RS 与 Deployment 的关联：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240612194423.png" alt="在这里插入图片描述"><br>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义(declarative)方法，用来替代以前的ReplicationController 来方便的管理应用。典型的应用场景包括：</p>
<ul>
<li>定义Deployment来创建Pod和ReplicaSet</li>
<li>滚动升级和回滚应用</li>
<li>扩容和缩容</li>
<li>暂停和继续Deployment</li>
</ul>
<h2 id="Deployment使用"><a href="#Deployment使用" class="headerlink" title="Deployment使用"></a>Deployment使用</h2><p>Ⅰ、部署一个简单的 Nginx 应用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 当前所属的组是 apps，版本是 v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-test-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>  <span class="comment"># 跟 selector.matchLabels 相匹配</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.21.1</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span>        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f nginx-deployment.yaml --record</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># --record参数可以记录命令，我们可以很方便的查看每次 revision 的变化</span></span></span><br></pre></td></tr></table></figure>


<p>Ⅱ、扩容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment nginx-deployment --replicas 10</span><br></pre></td></tr></table></figure>


<p>Ⅲ、如果集群支持 horizontal pod autoscaling 的话，还可以为Deployment设置自动扩展</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80</span><br></pre></td></tr></table></figure>

<p>Ⅳ、更新镜像也比较简单</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl set image deployment/nginx-deployment nginx=nginx:1.26</span><br></pre></td></tr></table></figure>

<p>查看 rollout 的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout status deployment/nginx-deployment</span></span><br><span class="line">Waiting for rollout to finish: 2 out of 3 new replicas have been updated...</span><br><span class="line">deployment &quot;nginx-deployment&quot; successfully rolled out</span><br></pre></td></tr></table></figure>

<p>Ⅴ、回滚</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment/nginx-deployment</span><br></pre></td></tr></table></figure>



<p><strong>Deployment 更新策略</strong><br>Deployment 可以保证在升级时只有一定数量的 Pod 是 down 的。默认的，它会确保至少有比期望的Pod数量少一个是up状态（最多一个不可用）。</p>
<p>Deployment 同时也可以确保只创建出超过期望数量的一定数量的 Pod。默认的，它会确保最多比期望的Pod数量多一个的 Pod 是 up 的（最多1个 surge ）。未来的 Kuberentes 版本中，将从1-1变成25%-25%。</p>
<p><strong>回退 Deployment</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl set image deployment/nginx-deployment nginx=nginx:1.91</span><br><span class="line">kubectl rollout status deployments nginx-deployment</span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl rollout history deployment/nginx-deployment</span><br><span class="line">kubectl rollout undo deployment/nginx-deployment</span><br><span class="line">kubectl rollout undo deployment/nginx-deployment --to-revision=2 ## 可以使用 --revision参数指定某个历史版本</span><br><span class="line">kubectl rollout pause deployment/nginx-deployment ## 暂停 deployment 的更新</span><br></pre></td></tr></table></figure>

<p>您可以用 kubectl rollout status 命令查看 Deployment 是否完成。如果 rollout 成功完成， kubectl rollout status 将返回一个0值的 Exit Code.
 </p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/qq_27384769/article/details/103628233">https://blog.csdn.net/qq_27384769/article/details/103628233</a></p>
]]></content>
      <categories>
        <category>k8s&amp;docker</category>
      </categories>
  </entry>
  <entry>
    <title>详解 Pod 及容器设计模式</title>
    <url>/2024/06/12/k8s&amp;docker/%E8%AF%A6%E8%A7%A3Pod%E5%8F%8A%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="一、为什么需要-Pod"><a href="#一、为什么需要-Pod" class="headerlink" title="一、为什么需要 Pod"></a>一、为什么需要 Pod</h1><h2 id="容器的基本概念"><a href="#容器的基本概念" class="headerlink" title="容器的基本概念"></a>容器的基本概念</h2><p>Pod 是 Kubernetes 项目里面一个非常重要的概念，也是非常重要的一个原子调度单位，但是为什么我们会需要这样一个概念呢？在使用容器 Docker 的时候，也没有这个说法。其实，如果想要理解 Pod，首先要理解容器，所以来回顾一下容器的概念：</p>
<p><strong>容器的本质实际上是一个进程，是一个视图被隔离，资源受限的进程。</strong></p>
<p>容器里面 PID&#x3D;1 的进程就是应用本身，这意味着管理虚拟机等于管理基础设施，因为我们是在管理机器，但管理容器却等于直接管理应用本身。这也是之前说过的不可变基础设施的一个最佳体现，这个时候，你的应用就等于你的基础设施，它一定是不可变的。</p>
<span id="more"></span>
<p>在以上面的例子为前提的情况下，Kubernetes 又是什么呢？很多人都说 Kubernetes 是云时代的操作系统，这个非常有意思，因为如果以此类推，容器镜像就是这个操作系统的软件安装包，它们之间是这样的一个类比关系。</p>
<p>如果说 Kubernetes 就是操作系统的话，那么不妨看一下真实的操作系统的例子。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240616102342.png" alt="image-20240616102340299"></p>
<p>例子里面有一个程序叫做 Helloworld，这个 Helloworld 程序实际上是由一组进程组成的，需要注意一下，这里说的进程实际上等同于 Linux 中的线程。</p>
<p>因为 Linux 中的线程是轻量级进程，所以如果从 Linux 系统中去查看 Helloworld 中的 pstree，将会看到这个 Helloworld 实际上是由四个线程组成的，分别是 {api、main、log、compute}。也就是说，四个这样的线程共同协作，共享 Helloworld 程序的资源，组成了 Helloworld 程序的真实工作情况。</p>
<p>这是操作系统里面进程组或者线程组中一个非常真实的例子，以上就是进程组的一个概念。</p>
<p>那么大家不妨思考一下，在真实的操作系统里面，一个程序往往是根据进程组来进行管理的。Kubernetes 把它类比为一个操作系统，比如说 Linux。针对于容器我们前面提到可以类比为进程，就是前面的 Linux 线程。那么 Pod 又是什么呢？实际上 Pod 就是我们刚刚提到的进程组，也就是 Linux 里的线程组。</p>
<h2 id="进程组概念"><a href="#进程组概念" class="headerlink" title="进程组概念"></a>进程组概念</h2><p>还是前面那个例子：Helloworld 程序由四个进程组成，这些进程之间会共享一些资源和文件。那么现在有一个问题：假如说现在把 Helloworld 程序用容器跑起来，你会怎么去做？</p>
<p>当然，最自然的一个解法就是，我现在就启动一个 Docker 容器，里面运行四个进程。可是这样会有一个问题，这种情况下容器里面 PID&#x3D;1 的进程该是谁? 比如说，它应该是我的 main 进程，那么问题来了，“谁”又负责去管理剩余的 3 个进程呢？</p>
<p>这个核心问题在于，容器的设计本身是一种“单进程”模型，不是说容器里只能起一个进程，由于容器的应用等于进程，所以只能去管理 PID&#x3D;1 的这个进程，其他再起来的进程其实是一个托管状态。 所以说服务应用进程本身就具有“进程管理”的能力。</p>
<p>比如说 Helloworld 的程序有 system 的能力，或者直接把容器里 PID&#x3D;1 的进程直接改成 systemd，否则这个应用，或者是容器是没有办法去管理很多个进程的。因为 PID&#x3D;1 进程是应用本身，如果现在把这个 PID&#x3D;1 的进程给 kill 了，或者它自己运行过程中死掉了，那么剩下三个进程的资源就没有人回收了，这个是非常严重的一个问题。</p>
<p>反过来，如果真的把这个应用本身改成了 systemd，或者在容器里面运行了一个 systemd，将会导致另外一个问题：使得管理容器不再是管理应用本身了，而等于是管理 systemd，这里的问题就非常明显了。比如说我这个容器里面 run 的程序或者进程是 systemd，那么接下来，这个应用是不是退出了？是不是 fail 了？是不是出现异常失败了？实际上是没办法直接知道的，因为容器管理的是 systemd。这就是为什么在容器里面运行一个复杂程序往往比较困难的一个原因。</p>
<p>这里再帮大家梳理一下：<strong>由于容器实际上是一个“单进程”模型</strong>，所以如果你在容器里启动多个进程，只有一个可以作为 PID&#x3D;1 的进程，而这时候，如果这个 PID&#x3D;1 的进程挂了，或者说失败退出了，那么其他三个进程就会自然而然的成为孤儿，没有人能够管理它们，没有人能够回收它们的资源，这是一个非常不好的情况。</p>
<blockquote>
<p>注意：Linux 容器的“单进程”模型，指的是容器的生命周期等同于 PID&#x3D;1 的进程（容器应用进程）的生命周期，而不是说容器里不能创建多进程。当然，一般情况下，容器应用进程并不具备进程管理能力，所以你通过 exec 或者 ssh 在容器里创建的其他进程，一旦异常退出（比如 ssh 终止）是很容易变成孤儿进程的。</p>
</blockquote>
<p>反过来，其实可以在容器里面 run 一个 systemd，用它来管理其他所有的进程。这样会产生第二个问题：实际上没办法直接管理我的应用了，因为我的应用被 systemd 给接管了，那么这个时候应用状态的生命周期就不等于容器生命周期。这个管理模型实际上是非常非常复杂的。</p>
<h2 id="Pod-“进程组”"><a href="#Pod-“进程组”" class="headerlink" title="Pod &#x3D; “进程组”"></a>Pod &#x3D; “进程组”</h2><p>在 Kubernetes 里面，Pod 实际上正是 Kubernetes 项目为你抽象出来的一个可以类比为进程组的概念。</p>
<p>前面提到的，由四个进程共同组成的一个应用 Helloworld，在 Kubernetes 里面，实际上会被定义为一个拥有四个容器的 Pod，这个概念大家一定要非常仔细的理解。</p>
<p>就是说现在有四个职责不同、相互协作的进程，需要放在容器里去运行，在 Kubernetes 里面并不会把它们放到一个容器里，因为这里会遇到两个问题。那么在 Kubernetes 里会怎么去做呢？它会把四个独立的进程分别用四个独立的容器启动起来，然后把它们定义在一个 Pod 里面。</p>
<p>所以当 Kubernetes 把 Helloworld 给拉起来的时候，你实际上会看到四个容器，它们共享了某些资源，这些资源都属于 Pod，所以我们说 Pod 在 Kubernetes 里面只有一个逻辑单位，没有一个真实的东西对应说这个就是 Pod，不会有的。真正起来在物理上存在的东西，就是四个容器，这四个容器，或者说是多个容器的组合就叫做 Pod。并且还有一个概念一定要非常明确，Pod 是 Kubernetes 分配资源的一个单位，因为里面的容器要共享某些资源，所以 Pod 也是 Kubernetes 的原子调度单位。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240616103050.png" alt="image-20240616103049548"></p>
<h2 id="为什么-Pod-必须是原子调度单位？"><a href="#为什么-Pod-必须是原子调度单位？" class="headerlink" title="为什么 Pod 必须是原子调度单位？"></a>为什么 Pod 必须是原子调度单位？</h2><p>可能到这里大家会有一些问题：虽然了解这个东西是一个进程组，但是为什么要把 Pod 本身作为一个概念抽象出来呢？或者说能不能通过调度把 Pod 这个事情给解决掉呢？为什么 Pod 必须是 Kubernetes 里面的原子调度单位？</p>
<p>下面我们通过一个例子来解释。</p>
<p>假如现在有两个容器，它们是紧密协作的，所以它们应该被部署在一个 Pod 里面。具体来说，第一个容器叫做 App，就是业务容器，它会写日志文件；第二个容器叫做 LogCollector，它会把刚刚 App 容器写的日志文件转发到后端的 ElasticSearch 中。</p>
<p>两个容器的资源需求是这样的：App 容器需要 1G 内存，LogCollector 需要 0.5G 内存，而当前集群环境的可用内存是这样一个情况：NodeA：1.25G 内存，NodeB：2G 内存。</p>
<p>假如说现在没有 Pod 概念，就只有两个容器，这两个容器要紧密协作、运行在一台机器上。可是，如果调度器先把 App 调度到了 NodeA 上面，接下来会怎么样呢？这时你会发现：LogCollector 实际上是没办法调度到 NodeA 上的，因为资源不够。其实此时整个应用本身就已经出问题了，调度已经失败了，必须去重新调度。</p>
<p>以上就是一个非常典型的成组调度失败的例子。英文叫做：Task co-scheduling 问题，这个问题不是说不能解，在很多项目里面，这样的问题都有解法。</p>
<p>比如说在 Mesos 里面，它会做一个事情，叫做资源囤积（resource hoarding）：即当所有设置了 Affinity 约束的任务都达到时，才开始统一调度，这是一个非常典型的成组调度的解法。</p>
<p>所以上面提到的“App”和“LogCollector”这两个容器，在 Mesos 里面，他们不会说立刻调度，而是等两个容器都提交完成，才开始统一调度。这样也会带来新的问题，首先调度效率会损失，因为需要等待。由于需要等，还会有外一个情况会出现，就是产生死锁，即互相等待的一个情况。这些机制在 Mesos 里都是需要解决的，也带来了额外的复杂度。</p>
<p>另一种解法是 Google 的解法。它在 Omega 系统（就是 Borg 下一代）里面，做了一个非常复杂且非常厉害的解法，叫做乐观调度。比如说：不管这些冲突的异常情况，先调度，同时设置一个非常精妙的回滚机制，这样经过冲突后，通过回滚来解决问题。这个方式相对来说要更加优雅，也更加高效，但是它的实现机制是非常复杂的。这个有很多人也能理解，就是悲观锁的设置一定比乐观锁要简单。</p>
<p>而像这样的一个 Task co-scheduling 问题，在 Kubernetes 里，就直接通过 Pod 这样一个概念去解决了。因为在 Kubernetes 里，这样的一个 App 容器和 LogCollector 容器一定是属于一个 Pod 的，它们在调度时必然是以一个 Pod 为单位进行调度，所以这个问题是根本不存在的。</p>
<h2 id="再次理解-Pod"><a href="#再次理解-Pod" class="headerlink" title="再次理解 Pod"></a>再次理解 Pod</h2><p>在讲了前面这些知识点之后，我们来再次理解一下 Pod，首先 Pod 里面的容器是“超亲密关系”。</p>
<p>这里有个“超”字需要大家理解，正常来说，有一种关系叫做亲密关系，这个亲密关系是一定可以通过调度来解决的。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240616103401.png" alt="image-20240616103359846"></p>
<p>比如说现在有两个 Pod，它们需要运行在同一台宿主机上，那这样就属于亲密关系，调度器一定是可以帮助去做的。但是对于超亲密关系来说，有一个问题，即它必须通过 Pod 来解决。因为如果超亲密关系赋予不了，那么整个 Pod 或者说是整个应用都无法启动。</p>
<p>什么叫做超亲密关系呢？大概分为以下几类：</p>
<ul>
<li>比如说两个进程之间会发生文件交换，前面提到的例子就是这样，一个写日志，一个读日志；</li>
<li>两个进程之间需要通过 localhost 或者说是本地的 Socket 去进行通信，这种本地通信也是超亲密关系；</li>
<li>这两个容器或者是微服务之间，需要发生非常频繁的 RPC 调用，出于性能的考虑，也希望它们是超亲密关系；</li>
<li>两个容器或者是应用，它们需要共享某些 Linux Namespace。最简单常见的一个例子，就是我有一个容器需要加入另一个容器的 Network Namespace。这样我就能看到另一个容器的网络设备，和它的网络信息。</li>
</ul>
<p>像以上几种关系都属于超亲密关系，它们都是在 Kubernetes 中会通过 Pod 的概念去解决的。</p>
<p>现在我们理解了 Pod 这样的概念设计，理解了为什么需要 Pod。它解决了两个问题：</p>
<ul>
<li>我们怎么去描述超亲密关系；</li>
<li>我们怎么去对超亲密关系的容器或者说是业务去做统一调度，这是 Pod 最主要的一个诉求。</li>
</ul>
<h1 id="二、Pod-的实现机制"><a href="#二、Pod-的实现机制" class="headerlink" title="二、Pod 的实现机制"></a>二、Pod 的实现机制</h1><h2 id="Pod-要解决的问题"><a href="#Pod-要解决的问题" class="headerlink" title="Pod 要解决的问题"></a>Pod 要解决的问题</h2><p>像 Pod 这样一个东西，本身是一个逻辑概念。那在机器上，它究竟是怎么实现的呢？这就是我们要解释的第二个问题。<br>既然说 Pod 要解决这个问题，核心就在于如何让一个 Pod 里的多个容器之间最高效的共享某些资源和数据。<br>因为容器之间原本是被 Linux Namespace 和 cgroups 隔开的，所以现在实际要解决的是怎么去打破这个隔离，然后共享某些事情和某些信息。这就是 Pod 的设计要解决的核心问题所在。<br>所以说具体的解法分为两个部分：网络和存储。</p>
<p><strong>1.共享网络</strong><br>第一个问题是 Pod 里的多个容器怎么去共享网络？下面是个例子：<br>比如说现在有一个 Pod，其中包含了一个容器 A 和一个容器 B，它们两个就要共享 Network Namespace。在 Kubernetes 里的解法是这样的：它会在每个 Pod 里，额外起一个 Infra container 小容器来共享整个 Pod 的  Network Namespace。</p>
<p>Infra container 是一个非常小的镜像，大概 100~200KB 左右，是一个汇编语言写的、永远处于“暂停”状态的容器。由于有了这样一个 Infra container 之后，其他所有容器都会通过 Join Namespace 的方式加入到 Infra container 的 Network Namespace 中。</p>
<p>所以说一个 Pod 里面的所有容器，它们看到的网络视图是完全一样的。即：它们看到的网络设备、IP地址、Mac地址等等，跟网络相关的信息，其实全是一份，这一份都来自于 Pod 第一次创建的这个 Infra container。这就是 Pod 解决网络共享的一个解法。</p>
<p>在 Pod 里面，一定有一个 IP 地址，是这个 Pod 的 Network Namespace 对应的地址，也是这个 Infra container 的 IP 地址。所以大家看到的都是一份，而其他所有网络资源，都是一个 Pod 一份，并且被 Pod 中的所有容器共享。这就是 Pod 的网络实现方式。</p>
<p>由于需要有一个相当于说中间的容器存在，所以整个 Pod 里面，必然是 Infra container 第一个启动。并且整个 Pod 的生命周期是等同于 Infra container 的生命周期的，与容器 A 和 B 是无关的。这也是为什么在 Kubernetes 里面，它是允许去单独更新 Pod 里的某一个镜像的，即：做这个操作，整个 Pod 不会重建，也不会重启，这是非常重要的一个设计。</p>
<p><strong>2.共享存储</strong><br>第二问题：Pod 怎么去共享存储？Pod 共享存储就相对比较简单。</p>
<p>比如说现在有两个容器，一个是 Nginx，另外一个是非常普通的容器，在 Nginx 里放一些文件，让我能通过 Nginx 访问到。所以它需要去 share 这个目录。我 share 文件或者是 share 目录在 Pod 里面是非常简单的，实际上就是把 volume 变成了 Pod level。然后所有容器，就是所有同属于一个 Pod 的容器，他们共享所有的 volume。</p>
<p>所以在之前的例子中，应用容器 App 写了日志，只要这个日志是写在一个 volume 中，只要声明挂载了同样的 volume，这个 volume 就可以立刻被另外一个 LogCollector 容器给看到。以上就是 Pod 实现存储的方式。</p>
<h1 id="三、详解容器设计模式"><a href="#三、详解容器设计模式" class="headerlink" title="三、详解容器设计模式"></a>三、详解容器设计模式</h1><p>现在我们知道了为什么需要 Pod，也了解了 Pod 这个东西到底是怎么实现的。最后，以此为基础，详细介绍一下 Kubernetes 非常提倡的一个概念，叫做容器设计模式。</p>
<p>用一个例子来给大家进行讲解。</p>
<p>比如我现在有一个非常常见的一个诉求：我现在要发布一个应用，这个应用是 JAVA 写的，有一个 WAR 包需要把它放到 Tomcat 的 web APP 目录下面，这样就可以把它启动起来了。可是像这样一个 WAR 包或 Tomcat 这样一个容器的话，怎么去做，怎么去发布？这里面有几种做法。</p>
<ul>
<li><p>第一种方式：可以把 WAR 包和 Tomcat 打包放进一个镜像里面。但是这样带来一个问题，就是现在这个镜像实际上揉进了两个东西。那么接下来，无论是我要更新 WAR 包还是说我要更新 Tomcat，都要重新做一个新的镜像，这是比较麻烦的；</p>
</li>
<li><p>第二种方式：就是镜像里面只打包 Tomcat。它就是一个 Tomcat，但是需要使用数据卷的方式，比如说 hostPath，从宿主机上把 WAR 包挂载进我们 Tomcat 容器中，挂到我的 web APP 目录下面，这样把这个容器启用起来之后，里面就能用了。</p>
<p>但是这时会发现一个问题：这种做法一定需要维护一套分布式存储系统。因为这个容器可能第一次启动是在宿主机 A 上面，第二次重新启动就可能跑到 B 上去了，容器它是一个可迁移的东西，它的状态是不保持的。所以必须维护一套分布式存储系统，使容器不管是在 A 还是在 B 上，都可以找到这个 WAR 包，找到这个数据。</p>
<blockquote>
<p>注意，即使有了分布式存储系统做 Volume，你还需要负责维护 Volume 里的 WAR 包。比如：你需要单独写一套 Kubernetes Volume 插件，用来在每次 Pod 启动之前，把应用启动所需的 WAR 包下载到这个 Volume 里，然后才能被应用挂载使用到。</p>
<p>这样操作带来的复杂程度还是比较高的，且这个容器本身必须依赖于一套持久化的存储插件（用来管理 Volume 里的 WAR 包内容）。</p>
</blockquote>
</li>
</ul>
<h2 id="InitContainer"><a href="#InitContainer" class="headerlink" title="InitContainer"></a>InitContainer</h2><p>所以大家有没有考虑过，像这样的组合方式，有没有更加通用的方法？哪怕在本地 Kubernetes 上，没有分布式存储的情况下也能用、能玩、能发布。实际上方法是有的，在 Kubernetes 里面，像这样的组合方式，叫做 Init Container。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240616104154.png" alt="image-20240616104153162"></p>
<p>还是同样一个例子：在上图的 yaml 里，首先定义一个 Init Container，它只做一件事情，就是把 WAR 包从镜像里拷贝到一个 Volume 里面，它做完这个操作就退出了，所以 Init Container 会比用户容器先启动，并且严格按照定义顺序来依次执行。</p>
<p>然后，这个关键在于刚刚拷贝到的这样一个目的目录：APP 目录，实际上是一个 Volume。而我们前面提到，一个 Pod 里面的多个容器，它们是可以共享 Volume 的，所以现在这个 Tomcat 容器，只是打包了一个 Tomcat 镜像。但在启动的时候，要声明使用 APP 目录作为我的 Volume，并且要把它们挂载在 Web APP 目录下面。</p>
<p>而这个时候，由于前面运行过了一个 Init Container，已经执行完拷贝操作了，所以这个 Volume 里面已经存在了应用的 WAR 包：就是 sample.war，绝对已经存在这个 Volume 里面了。等到第二步执行启动这个 Tomcat 容器的时候，去挂这个 Volume，一定能在里面找到前面拷贝来的 sample.war。</p>
<p>所以可以这样去描述：这个 Pod 就是一个自包含的，可以把这一个 Pod 在全世界任何一个 Kubernetes 上面都顺利启用起来。不用担心没有分布式存储、Volume 不是持久化的，它一定是可以公布的。</p>
<p>所以这是一个通过组合两个不同角色的容器，并且按照一些像 Init Container 的编排方式，统一去打包这样一个应用，把它用 Pod 来去做的非常典型的一个例子。像这样的一个概念，在 Kubernetes 里面就是一个非常经典的容器设计模式，叫做：“Sidecar”。</p>
<h2 id="容器设计模式：Sidecar"><a href="#容器设计模式：Sidecar" class="headerlink" title="容器设计模式：Sidecar"></a>容器设计模式：Sidecar</h2><p>什么是 Sidecar？就是说其实在 Pod 里面，可以定义一些专门的容器，来执行主业务容器所需要的一些辅助工作，比如我们前面举的例子，其实就干了一个事儿，这个 Init Container，它就是一个 Sidecar，它只负责把镜像里的 WAR 包拷贝到共享目录里面，以便被 Tomcat 能够用起来。</p>
<p>其它有哪些操作呢？比如说：</p>
<ul>
<li>原本需要在容器里面执行 SSH 需要干的一些事情，可以写脚本、一些前置的条件，其实都可以通过像 Init Container 或者另外像 Sidecar 的方式去解决；</li>
<li>当然还有一个典型例子就是日志收集，日志收集本身是一个进程，是一个小容器，那么就可以把它打包进 Pod 里面去做这个收集工作；</li>
<li>还有一个非常重要的东西就是 Debug 应用，实际上现在 Debug 整个应用都可以在应用 Pod 里面再次定义一个额外的小的 Container，它可以去 exec 应用 pod 的 namespace；</li>
<li>查看其他容器的工作状态，这也是它可以做的事情。不再需要去 SSH 登陆到容器里去看，只要把监控组件装到额外的小容器里面就可以了，然后把它作为一个 Sidecar 启动起来，跟主业务容器进行协作，所以同样业务监控也都可以通过 Sidecar 方式来去做。</li>
</ul>
<h3 id="Sidecar：应用与日志收集"><a href="#Sidecar：应用与日志收集" class="headerlink" title="Sidecar：应用与日志收集"></a>Sidecar：应用与日志收集</h3><p>接下来，我们再详细细化一下 Sidecar 这样一个模式，它还有一些其他的场景。</p>
<p>比如说前面提到的应用日志收集，业务容器将日志写在一个 Volume 里面，而由于 Volume 在 Pod 里面是被共享的，所以日志容器 —— 即 Sidecar 容器一定可以通过共享该 Volume，直接把日志文件读出来，然后存到远程存储里面，或者转发到另外一个例子。现在业界常用的 Fluentd 日志进程或日志组件，基本上都是这样的工作方式。</p>
<h3 id="Sidecar：代理容器"><a href="#Sidecar：代理容器" class="headerlink" title="Sidecar：代理容器"></a>Sidecar：代理容器</h3><p>Sidecar 的第二个用法，可以称作为代理容器 Proxy。什么叫做代理容器呢？</p>
<p>假如现在有个 Pod 需要访问一个外部系统，或者一些外部服务，但是这些外部系统是一个集群，那么这个时候如何通过一个统一的、简单的方式，用一个 IP 地址，就把这些集群都访问到？有一种方法就是：修改代码。因为代码里记录了这些集群的地址；另外还有一种解耦的方法，即通过 Sidecar 代理容器。</p>
<p>简单说，单独写一个这么小的 Proxy，用来处理对接外部的服务集群，它对外暴露出来只有一个 IP 地址就可以了。所以接下来，业务容器主要访问 Proxy，然后由 Proxy 去连接这些服务集群，这里的关键在于 Pod 里面多个容器是通过 localhost 直接通信的，因为它们同属于一个 network Namespace，网络视图都一样，所以它们俩通信 localhost，并没有性能损耗。</p>
<p>所以说代理容器除了做了解耦之外，并不会降低性能，更重要的是，像这样一个代理容器的代码就又可以被全公司重用了。</p>
<h3 id="Sidecar：适配器容器"><a href="#Sidecar：适配器容器" class="headerlink" title="Sidecar：适配器容器"></a>Sidecar：适配器容器</h3><p>Sidecar 的第三个设计模式 —— 适配器容器 Adapter，什么叫 Adapter 呢？</p>
<p>现在业务暴露出来的 API，比如说有个 API 的一个格式是 A，但是现在有一个外部系统要去访问我的业务容器，它只知道的一种格式是 API B ,所以要做一个工作，就是把业务容器怎么想办法改掉，要去改业务代码。但实际上，你可以通过一个 Adapter 帮你来做这层转换。</p>
<p>有个例子：现在业务容器暴露出来的监控接口是 &#x2F;metrics，访问这个容器的 metrics 的 URL 就可以拿到了。可是现在，这个监控系统升级了，它访问的 URL 是 &#x2F;health，我只认得暴露出 health 健康检查的 URL，才能去做监控，metrics 不认识。那这个怎么办？那就需要改代码了，但可以不去改代码，额外写一个 Adapter，用来把所有对 health 的这个请求转发给 metrics 就可以了，所以这个 Adapter 对外暴露的是 health 这样一个监控的 URL，这就可以了，你的业务就又可以工作了。</p>
<p>这样的关键，还在于 Pod 之中的容器是通过 localhost 直接通信的，所以没有性能损耗，并且这样一个 Adapter 容器可以被全公司重用起来，这些都是设计模式给我们带来的好处。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/alisystemsoftware/article/details/101031025">https://blog.csdn.net/alisystemsoftware/article/details/101031025</a></p>
]]></content>
      <categories>
        <category>k8s&amp;docker</category>
      </categories>
  </entry>
  <entry>
    <title>数据库平滑扩容方案</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B3%E6%BB%91%E6%89%A9%E5%AE%B9%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>[toc]<br>每一个项目都是由小项目发展而来，从最初的一台数据库，到后面的几千上万台数据库，这发展的过程，都要涉及到一个技术问题：当数据量太大的时候，如何进行扩容？</p>
<p>现有一个站点，用户数据库有2个，网站用户数据通过<strong>ID取模</strong>，分别存在两台用户数据库中，随着数据增大，两台数据库已经不够用了，现在需要增加数据库进行扩容，应该如何进行扩容？<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141123333.jpg" alt="https://pic3.zhimg.com/80/v2-68ca415a69cbefb1002bf7a08a0c9154_hd.jpg"></p>
<span id="more"></span>

<h1 id="停机扩容"><a href="#停机扩容" class="headerlink" title="停机扩容"></a>停机扩容</h1><p>我们先来了解下停机扩容方案，这是一种很多人初期都会使用的方案（几台数据库的时候），具体步骤：</p>
<ol>
<li>小明先挂公告，告诉大家明天的凌晨02：00 - 06：00，站点将停机升级；</li>
<li>时间到了，小明停止了所有对外服务；</li>
<li>小明新增了2个数据库，然后写了一个程序，将原先的2个库的数据迁移到现有的4个库（2+2）上；</li>
<li>数据迁移完成，修改数据库服务配置；</li>
<li>重启服务，并重新开启对外服务。</li>
</ol>
<p><strong>回滚方案：</strong></p>
<p>数据迁移失败，或者迁移后测试失败，则将服务配置修改回原先的两个库，改天再升级。</p>
<p><strong>优点：</strong></p>
<ul>
<li>简单</li>
</ul>
<p><strong>缺点：</strong></p>
<ol>
<li>不高可用</li>
<li>开启升级到升级完成，时间短，项目组压力大，<strong>易出错</strong></li>
<li>升级时间基本是半夜人流量最少的时候，项目组疲累，容易出错</li>
<li>运行一段时间后，发现问题，<strong>难以回滚</strong>，只能回到扩容前，<strong>会丢失部分数据</strong></li>
</ol>
<p><strong>适用：</strong></p>
<ol>
<li>小型网站；</li>
<li>大部分游戏；</li>
<li>对高可用要求不高的服务。</li>
</ol>
<h1 id="平滑扩容"><a href="#平滑扩容" class="headerlink" title="平滑扩容"></a>平滑扩容</h1><p>  平滑扩容中最好的方案就是<strong>扩容的数据库是原先数据库的倍数</strong>，如：2个数据库扩容到4个数据库，是原先的2倍。步骤：</p>
<p>（1）新增2个数据库</p>
<p>（2）配置双主进行数据同步（先测试，后线上，重启服务时间是秒级）</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141125774.jpg" alt="img"></p>
<p>（3）数据同步完成之后，<strong>配置主主双写</strong>（<strong>因为同步有延迟，如果每时每刻都有数据写入&#x2F;更新的话，就不能准确的保证数据已经同步完成</strong>）</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141125058.jpg" alt="img"></p>
<p>（4）数据同步完成后（时间比较长），<strong>删除双主同步，修改数据库配置，并重启（秒级）；</strong></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141126669.jpg" alt="img"></p>
<p>（5）此时已经扩容完成，但此时的数据并没有减少，新增的数据库跟旧的数据库一样多的数据，此时还需要写一个程序，<strong>清空数据库中多余的数据</strong>，如：</p>
<ol>
<li>User1去除 uid % 4 &#x3D; 2的数据；</li>
<li>User3去除 uid % 4 &#x3D; 0的数据；</li>
<li>User2去除 uid % 4 &#x3D; 3的数据；</li>
<li>User4去除 uid % 4 &#x3D; 1的数据。</li>
</ol>
<p>现在，我们就已经完成了数据库的平滑扩容了。</p>
<p><strong>优点</strong></p>
<ol>
<li>扩容期间，服务照常进行，<strong>保证高可用</strong>；</li>
<li>时间长，项目组压力没有这么大，<strong>出错率低</strong>；</li>
<li>扩容期间，遇到什么问题，都<strong>可以随时调试，不怕影响线上服务</strong>；</li>
<li>每个数据库<strong>少了一半</strong>的数据量。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>程序复杂，需要配置双主、主主双写、检测数据同步等额外技术；</li>
<li>但后期数据库成千上万台的时候，扩容复杂（情况非常少，除非将很多业务数据放在同一个数据库）。</li>
</ol>
<p><strong>总结</strong></p>
<p>本文主要简单讲解了数据库扩容的两种方案，并对这两种方案的优缺点、适用场景进行了说明：</p>
<p>·    <strong>停机扩容：</strong>简单，不高可用，易出错，扩容后不能回滚，只能回档，会丢失一部分数据。</p>
<p>·    <strong>平滑扩容：</strong>复杂，高可用，出错调试容易，易回滚，不会造成数据丢失，</p>
<hr>
<p>转载自：<br><a href="https://www.cnblogs.com/kafeixiaoluo/p/9156855.html">https://www.cnblogs.com/kafeixiaoluo/p/9156855.html</a><br><a href="https://www.cnblogs.com/firstdream/p/7090524.html">https://www.cnblogs.com/firstdream/p/7090524.html</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
      </categories>
  </entry>
  <entry>
    <title>数据库分库分表</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="一、-MySQL扩展具体的实现方式"><a href="#一、-MySQL扩展具体的实现方式" class="headerlink" title="一、 MySQL扩展具体的实现方式"></a>一、 MySQL扩展具体的实现方式</h3><p>&emsp;&emsp;随着业务规模的不断扩大，需要选择合适的方案去应对数据规模的增长，以应对逐渐增长的访问压力和数据量。<br>&emsp;&emsp;关于数据库的扩展主要包括：<strong>业务拆分</strong>、<strong>主从复制</strong>，<strong>数据库分库与分表</strong>。这篇文章主要讲述数据库分库与分表。</p>
<p>（1）业务拆分<br>&emsp;&emsp;业务起步初始，为了加快应用上线和快速迭代，很多应用都采用集中式的架构。随着业务系统的扩大，系统变得越来越复杂，越来越难以维护，开发效率变得越来越低，并且对资源的消耗也变得越来越大，通过硬件提高系统性能的方式带来的成本也越来越高。<br>&emsp;&emsp;因此，在选型初期，一个优良的架构设计是后期系统进行扩展的重要保障。例如：电商平台，包含了用户、商品、评价、订单等几大模块，最简单的做法就是在一个数据库中分别创建users、shops、comment、order四张表。<br>&emsp;&emsp;但是，随着业务规模的增大，访问量的增大，我们不得不对业务进行拆分。每一个模块都使用单独的数据库来进行存储，不同的业务访问不同的数据库，将原本对一个数据库的依赖拆分为对4个数据库的依赖，这样的话就变成了4个数据库同时承担压力，系统的吞吐量自然就提高了。</p>
<p>（2）主从复制<br>&emsp;&emsp;MySQL主从复制的原理：数据复制的实际就是Slave从Master获取Binary log文件，然后再本地镜像的执行日志中记录的操作。由于主从复制的过程是异步的，因此Slave和Master之间的数据有可能存在延迟的现象，此时只能保证数据最终的一致性。</p>
<p>（3）数据库分库与分表<br>&emsp;&emsp;每台机器都有自身的物理上限，所以当应用已经能触及或远远超出单台机器的某个上限的时候，惟有寻找别的机器的帮助或者继续升级硬件，但常见的方案还是通过添加更多的机器来共同承担压力。<br>&emsp;&emsp;还得考虑当业务逻辑不断增长，机器能不能通过线性增长就能满足需求？因此，使用数据库的分库分表，能够立竿见影的提升系统的性能。</p>
 <span id="more"></span>

<h3 id="二、分表实现策略"><a href="#二、分表实现策略" class="headerlink" title="二、分表实现策略"></a>二、分表实现策略</h3><p>&emsp;&emsp;对于大部分数据库的设计和业务的操作基本都与用户的ID相关，因此使用用户ID是最常用的分库的路由策略。用户的ID可以作为贯穿整个系统用的重要字段。因此，使用用户的ID不仅可以方便查询，还可以将数据平均的分配到不同的数据库中。（当然，还可以根据类别等进行分表操作，分表的路由策略还有很多方式）<br>&emsp;&emsp;接着上述电商平台假设，订单表order存放用户的订单数据，sql脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `order` (</span><br><span class="line">  `order_id` bigint(32) primary key auto_increment,</span><br><span class="line">  `user_id` bigint(32),</span><br><span class="line">   ...</span><br><span class="line">) </span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当数据比较大的时候，对数据进行分表操作，首先要确定需要将数据平均分配到多少张表中，也就是：<strong>表容量</strong>。</p>
<p>&emsp;&emsp;这里假设有100张表进行存储，则我们在进行存储数据的时候，首先对用户ID进行取模操作，根据 user_id%100 获取对应的表进行存储查询操作，示意图如下：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141211278.png" width=40% higth=40%></p>
<p>&emsp;&emsp;例如，user_id &#x3D; 101 那么在获取值的时候的操作，可以通过下边的sql语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from order_1 where user_id= 101</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中，order_1是根据 101%100 计算所得，表示分表之后的第一张order表。<br>&emsp;&emsp;在实际的开发中，如果使用MyBatis做持久层的话，MyBatis已经提供了很好得支持数据库分表的功能，例如上述sql用MyBatis实现的话应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 获取用户相关的订单详细信息</span><br><span class="line">  * @param tableNum 具体某一个表的编号</span><br><span class="line">  * @param userId 用户ID</span><br><span class="line">  * @return 订单列表</span><br><span class="line">    */</span><br><span class="line">public List&lt;Order&gt; getOrder(@Param(&quot;tableNum&quot;) int tableNum,@Param(&quot;userId&quot;) int userId);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xml配置映射文件：</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;getOrder&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">    select * from order_$&#123;tableNum&#125;</span><br><span class="line">    where user_id = #&#123;userId&#125;</span><br><span class="line">  &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中 <code>$&#123;tableNum&#125;</code> 含义是直接让参数加入到sql中，这是MyBatis支持的特性。</p>
<h3 id="三、分库实现策略"><a href="#三、分库实现策略" class="headerlink" title="三、分库实现策略"></a>三、分库实现策略</h3><p>&emsp;&emsp;数据库分表能够解决单表数据量很大的时候数据查询的效率问题，但是无法给数据库的并发操作带来效率上的提高，因为分表的实质还是在一个数据库上进行的操作，很容易受数据库IO性能的限制。<br>&emsp;&emsp;因此，如何将数据库IO性能的问题平均分配出来，很显然将数据进行分库操作可以很好地解决单台数据库的性能问题。</p>
<p>&emsp;&emsp;分库策略与分表策略的实现很相似，最简单的都是可以通过取模的方式进行路由。还是上例，将用户ID进行取模操作，这样的话获取到具体的某一个数据库，同样关键字有：用户ID、库容量</p>
<p>&emsp;&emsp;路由的示意图如下：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141211536.png" width=50% higth=50%></p>
<h3 id="四、分库与分表实现策略"><a href="#四、分库与分表实现策略" class="headerlink" title="四、分库与分表实现策略"></a>四、分库与分表实现策略</h3><p>&emsp;&emsp;上述的配置中，数据库分表可以解决单表海量数据的查询性能问题，分库可以解决单台数据库的并发访问压力问题。<br>&emsp;&emsp;有时候需要同时考虑这两个问题，因此，既需要对单表进行分表操作，还需要进行分库操作，以便同时扩展系统的并发处理能力和提升单表的查询性能，就是使用到的分库分表。</p>
<p>&emsp;&emsp;分库分表的策略相对于前边两种复杂一些，一种常见的路由策略如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">１、中间变量　＝ user_id%（库数量*每个库的表数量）;</span><br><span class="line">２、库序号　＝　取整（中间变量／每个库的表数量）;</span><br><span class="line">３、表序号　＝　中间变量％每个库的表数量;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;例如：数据库有256 个，每一个库中有1024个数据表，用户的user_id＝262145，按照上述的路由策略，可得：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">１、中间变量　＝ 262145%（256*1024）= 1;</span><br><span class="line">２、库序号　＝　取整（1／1024）= 0;</span><br><span class="line">３、表序号　＝　1％1024 = 1;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样的话，对于user_id＝262145，将被路由到第０个数据库的第１个表中。示意图如下：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141212463.png" width=50% higth=50%></p>
<h3 id="五、分库分表总结"><a href="#五、分库分表总结" class="headerlink" title="五、分库分表总结"></a>五、分库分表总结</h3><p>&emsp;&emsp;关于分库分表策略的选择有很多种，上文中根据用户ID应该是比较简单的一种。其他方式比如使用号段进行分区或者直接使用hash进行路由等。<br>&emsp;&emsp;如果用户的ID是通过UUID的方式生成的话，需要单独的进行一次hash操作，然后在进行取模操作等，其实hash本身就是一种分库分表的策略，使用hash进行路由策略的时候，需要知道的是，也就是hash路由策略的优缺点，优点是：数据分布均匀；缺点是：数据迁移的时候麻烦，不能按照机器性能分摊数据。</p>
<p>&emsp;&emsp;上述的分库和分表操作，查询性能和并发能力都得到了提高，但是还有一些需要注意的就是，例如：原本跨表的事物变成了分布式事物；由于记录被切分到不同的数据库和不同的数据表中，难以进行多表关联查询，并且不能不指定路由字段对数据进行查询。分库分表之后，如果需要对系统进行进一步的扩阵容（路由策略变更），将变得非常不方便，需要重新进行数据迁移。</p>
<p>&emsp;&emsp;分库分表目前有很多的中间件可供选择，最常见的是使用淘宝的中间件Cobar。GitHub地址：<a href="https://github.com/alibaba/cobara">https://github.com/alibaba/cobara</a> ，文档地址为：<a href="https://github.com/alibaba/cobar/wiki">https://github.com/alibaba/cobar/wiki</a></p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/xlgen157387/article/details/53976153">https://blog.csdn.net/xlgen157387/article/details/53976153</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
      </categories>
  </entry>
  <entry>
    <title>缓存穿透，缓存击穿，缓存雪崩解决方案分析</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<p><strong>解决方案：</strong></p>
<p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层数据库的查询压力。</p>
<p>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），仍然把这个空结果进行缓存，但它的过期时间会很短，比如30s。</p>
<span id="more"></span>

<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指在设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，导致所有的查询都落在数据库上，造成了缓存雪崩。</p>
<p><strong>解决方案：</strong></p>
<p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存。</p>
<p>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<p>做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p>
<p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<h2 id="热点缓存解决方案"><a href="#热点缓存解决方案" class="headerlink" title="热点缓存解决方案"></a>热点缓存解决方案</h2><h3 id="1、缓存使用背景："><a href="#1、缓存使用背景：" class="headerlink" title="1、缓存使用背景："></a>1、缓存使用背景：</h3><p>拿用户中心的一个案例来说明：每个用户都会首先获取自己的用户信息，然后再进行其他相关的操作，有可能会有如下一些场景情况：</p>
<p>·    会有大量相同用户重复访问该项目。</p>
<p>·    会有同一用户频繁访问同一模块。</p>
<h3 id="2、思路解析"><a href="#2、思路解析" class="headerlink" title="2、思路解析"></a>2、思路解析</h3><p>·    因为用户本身是不固定的而且用户数量也有几百万尤其上千万，不可能把所有的用户信息全部缓存起来，通过第一个场景情况可以看到一些规律，那就是有大量的相同用户重复访问，但是究竟是哪些用户重复访问我们也并不知道。</p>
<p>·    如果有一个用户频繁刷新读取项目，那么对数据库本身也会造成较大压力，当然我们也会有相关的保护机制来确实恶意攻击，可以从前端控制，也可以有采黑名单等机制，这里不在赘述。如果用缓存的话，我们又该如何控制同一用户繁重读取用户信息呢。</p>
<p>我们能通过缓存系统做一个排序队列，比如1000个用户，系统会根据用户的访问时间更新用户信息的时间，越是最近访问的用户排名越排前，系统会定期过滤掉排名最后的200个用户，然后再从数据库中随机取出200个用户加入队列，这样请求每次到达的时候，会先从队列中获取用户信息，如果命中则根据userId，再从另一个缓存数据结构中读取用户信息，如果没有命中则说明该用户请求频率不高。</p>
<hr>
<p>转载自：<br><a href="http://blog.csdn.net/zeb_perfect/article/details/54135506">http://blog.csdn.net/zeb_perfect/article/details/54135506</a><br><a href="http://blog.csdn.net/AlbertFly/article/details/75546170">http://blog.csdn.net/AlbertFly/article/details/75546170</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
      </categories>
  </entry>
  <entry>
    <title>缓存更新策略</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a><strong>先更新数据库，再更新缓存</strong></h3><ul>
<li><p>首先这个逻辑是有问题的。</p>
<p>试想，两个更新操作，一个更新数据库为A，但还没来的及更新缓存，另一个更新数据库为B，又更新了缓存值为B，这时候第一个更新操作才更新缓存为A，那样数据库值为B，缓存值为A，数据不一致。</p>
</li>
</ul>
<h3 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a><strong>先更新缓存，再更新数据库</strong></h3><ul>
<li><p>这个流程跟上面很类似，出现的问题也很类似。</p>
<p>两个更新操作，一个更新缓存为A，但还没来的及更新数据库，另一个更新缓存为B，又更新了数据库为B，这时候第一个更新操作才更新数据库为A，那样数据库值为A，缓存值为B，数据不一致。</p>
</li>
</ul>
 <span id="more"></span>

<h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a><strong>先删除缓存，再更新数据库</strong></h3><ul>
<li><p>这个逻辑也是错误的。</p>
<p>两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p>
</li>
</ul>
<h3 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a><strong>先更新数据库，再删除缓存</strong></h3><p>来看下有没有问题，一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上删除缓存，后续的查询操作再把数据从数据库中拉出来。而不会像上面一样产生的问题，后续的查询操作一直都在取老的数据。</p>
<p>为什么不是写完数据库后更新缓存？主要是怕两个并发的写操作导致脏数据。</p>
<p>​        那么，是不是这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，删除缓存，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p>
<p>​        但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<h3 id="缓存删除失败，导致不一致"><a href="#缓存删除失败，导致不一致" class="headerlink" title="缓存删除失败，导致不一致"></a><strong>缓存删除失败，导致不一致</strong></h3><p>​         上面<strong>先更新数据库，再删除缓存的策略中，</strong>因为要删除缓存，但如果缓存删除失败，就会导致数据库与缓存不一致。这个问题怎么办？一般可以用消息队列解决。</p>
<p>​        如果删除缓存失败，发送消息投递到消息中间件中，进入消息队列。这样就保证了即使删除消息失败，也会重试。</p>
<p>​         <strong>但是，这个方案有个问题，就是和应用服务的业务代码耦合的比较厉害。代码业务不清晰。</strong>那有没有别的方案呢，对业务没有侵入呢？可以利用了mysql的底层机制，binlog日志进行删除缓存，这样就不需要和业务关联，删除缓存服务是独立的。可以利用阿里开源的canal去操作。</p>
<h3 id="读写分离，导致不一致"><a href="#读写分离，导致不一致" class="headerlink" title="读写分离，导致不一致"></a><strong>读写分离，导致不一致</strong></h3><p>​        关于<strong>先更新数据库，再删除缓存</strong>的策略，我们来看一下另一个场景，数据库的读写分离的场景。写请求在一个库，读请求在另一个库。读写分离时，库与库之间会存在数据延迟，因为存在数据同步。</p>
<p>  那再回顾一下流程，就会发现有问题，因为请求B更新数据 在一个库上面，请求A去读取数据时是另一个库。</p>
<p>  1）请求B更新值99，删除缓存<br>  2）请求A查询值100（读库数据还没有同步），在更新到缓存中（值为100）</p>
<p>  这样就导致不一致，这个场景是经常出现的，不是小概率事件。那我们如何处理呢？</p>
<p>​        可以不可以这样？预留数据库主从复制的同步时间，将删缓存的操作改为更新缓存并设置这个缓存的失效时间为一个“经验主从同步时间（500ms?）”,这个超时时间比正常的超时时间要短。</p>
<p>   来验证一下，之前提到了先更新数据库，再更新缓存可能存在的问题，那这边更新缓存并重设短的失效时间会导致一样的问题吗？两个更新操作，一个更新数据库为A，但还没来的及操作缓存，另一个更新数据库为B，又更新了缓存值为B，并设置了一个短的超时时间，这时候第一个更新操作才更新缓存为A并设置了一个短的超时时间，而此时数据库值是B，这的确会有短暂的不一致性问题，但是缓存会很快失效后，马上会更新值为B，所以还是可以保证最终一致性。</p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
      </categories>
  </entry>
  <entry>
    <title>Raft算法</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/Raft%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>[toc]<br>  首先介绍下<strong>分布式共识算法。分布式共识算法是指：多个参与者</strong> 针对 <strong>某一件事</strong> 达成完全 <strong>一致</strong> ：一件事，一个结论；已达成一致的结论，不可推翻。</p>
<p>  <strong>目前分布式共识算法有如下：</strong></p>
<ul>
<li>Paxos：被认为是分布式共识算法的根本，其他都是其变种，但是 Paxos 论文中只给出了单个提案的过程，并没有给出复制状态机中需要的 multi-paxos 的相关细节的描述，实现 Paxos 具有很高的工程复杂度（如多点可写，允许日志空洞等）。</li>
<li>Zab：被应用在 Zookeeper 中，业界使用广泛，但没有抽象成通用的 library。</li>
<li>Raft：以容易理解著称，业界也涌现出很多 Raft 实现，比如大名鼎鼎的 etcd, braft, tikv 等。</li>
</ul>
 <span id="more"></span>

<h1 id="什么是-Raft？"><a href="#什么是-Raft？" class="headerlink" title="什么是 Raft？"></a>什么是 Raft？</h1><p>​	Raft 是一种更易于理解的分布式共识算法，核心协议本质上还是师承 Paxos 的精髓，不同的是依靠 Raft 模块化的拆分以及更加简化的设计，Raft 协议相对更容易实现。</p>
<p>​	模块化的拆分主要体现在：Raft 把一致性协议划分为 Leader 选举、Membership 变更、日志复制、Snapshot 等几个几乎完全解耦的模块。</p>
<p>​	更加简化的设计则体现在：Raft不允许类似 Paxos 中的乱序提交、简化系统中的角色状态（只有 Leader、Follower、Candidate 三种角色）、限制仅 Leader 可写入、使用随机化的超时时间来设计 Leader Election 等等。</p>
<p>​	Raft算法中系统必须存在且同一时刻只能有一个 Leader，只有 Leader 可以接受 Clients 发过来的请求；Leader 负责主动与所有 Followers 通信，负责将“提案”发送给所有 Followers，同时收集多数派的 Followers 应答；Leader 还需向所有 Followers 主动发送心跳维持领导地位(保持存在感)。</p>
<h1 id="1-Raft-节点状态"><a href="#1-Raft-节点状态" class="headerlink" title="1. Raft 节点状态"></a>1. Raft 节点状态</h1><p>每个节点有<strong>三种状态：Follower，Candidate，Leader</strong>，状态之间是互相转换的。状态转换图:</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171318872.webp" alt="img"></p>
<p>  每个节点上都有一个倒计时器 (Election Timeout)，时间随机在 150ms ~300ms 之间。有几种情况会重设 Timeout：</p>
<ol>
<li>收到选举的请求</li>
<li>收到 Leader 的 Heartbeat</li>
</ol>
<p>在 Raft 运行过程中，最主要进行两个活动：</p>
<ol>
<li>选主 Leader Election</li>
<li>复制日志 Log Replication</li>
</ol>
<h1 id="2-选主-Leader-Election"><a href="#2-选主-Leader-Election" class="headerlink" title="2. 选主 Leader Election"></a>2. 选主 Leader Election</h1><h2 id="2-1-正常情况下选主"><a href="#2-1-正常情况下选主" class="headerlink" title="2.1 正常情况下选主"></a>2.1 正常情况下选主</h2><p>假设现在有如图5个节点，5个节点一开始的状态都是 Follower。在一个节点election timeout到期后，这个节点的状态变成 Candidate 开始选举，它会会先投自己一票，然后向整个集群发起选举请求 (RequestVote)</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171319141.webp"></p>
<p>其他四个节点都返回成功，这个节点的状态由 Candidate 变成了 Leader，并在每个一小段时间后，就给所有的 Follower 发送一个 Heartbeat 以保持所有节点的状态，Follower 收到 Leader 的 Heartbeat 后重设 Timeout。心跳检测时间很短，要远远小于选举超时时间election timout。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171319524.webp"></p>
<p>这是最简单的选主情况，<strong>只要有超过一半的节点投支持票了，Candidate才会被选举为 Leader</strong>，5个节点的情况下，3个节点 (包括 Candidate 本身) 投了支持就行。</p>
<p>除此之外，每个节点中还有一个字段，叫term，意思就是任期，这个term是一个全局的、连续递增的整数，每进行一次选举，term就会加一，如果candidate赢得选举，它会当leader直到此次任期结束。</p>
<h2 id="2-2-Leader出故障情况下的选主"><a href="#2-2-Leader出故障情况下的选主" class="headerlink" title="2.2 Leader出故障情况下的选主"></a>2.2 Leader出故障情况下的选主</h2><p>一开始已经有一个 Leader，所有节点正常运行。Leader 出故障挂掉了，其他四个 Follower 将进行重新选主。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171320669.webp" alt="img"></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171320787.webp" alt="img"></p>
<p>4个节点的选主过程和5个节点的类似，假设在选出一个新的 Leader 后，原来的 Leader 恢复了又重新加入了，这个时候怎么处理？在 Raft 里，第几轮选举是有记录的，重新加入的 Leader 是第一轮选举 (Term 1) 选出来的，而现在的 Leader 则是 Term 2，所有原来的 Leader 会自觉降级为 Follower。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171321139.webp" alt="img"></p>
<h2 id="2-3-多个-Candidate-情况下的选主"><a href="#2-3-多个-Candidate-情况下的选主" class="headerlink" title="2.3 多个 Candidate 情况下的选主"></a>2.3 多个 Candidate 情况下的选主</h2><p>假设一开始有4个节点，都还是 Follower。这时，有两个 Follower 同时 Timeout，都变成了 Candidate 开始选举，分别给 Follower 发送了投票请求。两个 Follower 分别返回了ok，这时两个 Candidate 都只有2票，要3票才能被选成 Leader。两个 Candidate 会分别给另外一个还没有给自己投票的 Follower 发送投票请求。但是因为 Follower 在这一轮选举中，都已经投完票了，所以都拒绝了他们的请求。所以在 Term 2 没有 Leader 被选出来。</p>
<p>这时，两个节点的状态是 Candidate，两个是 Follower，但是他们的倒计时器仍然在运行，最先 Timeout 的那个节点会进行发起新一轮 Term 3 的投票。两个 Follower 在 Term 3 还没投过票，所以返回 OK，这时 Candidate 一共有三票，被选为了 Leader。</p>
<p>如果 Leader Heartbeat 的时间晚于另外一个 Candidate timeout 的时间，另外一个 Candidate 仍然会发送选举请求。两个 Follower 已经投完票了，拒绝了这个 Candidate 的投票请求。Leader 进行 Heartbeat， Candidate 收到后状态自动转为 Follower，完成选主。</p>
<h1 id="3-复制日志-Log-Replication"><a href="#3-复制日志-Log-Replication" class="headerlink" title="3. 复制日志 Log Replication"></a>3. 复制日志 Log Replication</h1><h2 id="3-1-正常情况下复制日志"><a href="#3-1-正常情况下复制日志" class="headerlink" title="3.1 正常情况下复制日志"></a>3.1 正常情况下复制日志</h2><p>Raft 在实际应用场景中的一致性更多的是体现在不同节点之间的数据一致性，客户端发送请求到任何一个节点都能收到一致的返回，当一个节点出故障后，其他节点仍然能以已有的数据正常进行。在选主之后的复制日志就是为了达到这个目的。</p>
<p>Raft算法中无论读和写都会由leader节点来处理。读也由leader来处理，leader拿到请求后，再决定由哪一个节点来处理，要么将请求分发，要么自己处理；即使client端请求的是follower节点，Follower节点也会现将请求信息转给leader，再由leader决定由哪个节点来处理。</p>
<p>一开始，Leader 和 两个 Follower 都没有任何数据。客户端发送请求给 Leader，储存数据 “sally”，Leader 先将数据写在本地日志，这时候数据还是 <strong>Uncommitted</strong> (还没最终确认)。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171323020.webp" alt="img"></p>
<p>Leader 给两个 Follower 发送 AppendEntries 请求，数据在 Follower 上没有冲突，则将数据暂时写在本地日志，Follower 的数据也还是 Uncommitted。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171323343.webp" alt="img"></p>
<p>Follower将数据写到本地后，返回 OK。Leader 收到后成功返回，<strong>只要收到的成功返回的数量超过半数</strong> **(****包含Leader)**，Leader 将数据 “sally” 的状态改成 Committed。( 这个时候 Leader 就可以返回给客户端了)。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171324228.webp" alt="img"></p>
<p>Leader 再次给 Follower 发送 AppendEntries 请求（相当于commit的通知），收到请求后，Follower 将本地日志里 Uncommitted 数据改成 Committed。这样就完成了一整个复制日志的过程，三个节点的数据是一致的。</p>
<h2 id="3-2-Network-Partition-情况下进行复制日志"><a href="#3-2-Network-Partition-情况下进行复制日志" class="headerlink" title="3.2 Network Partition 情况下进行复制日志"></a>3.2 Network Partition 情况下进行复制日志</h2><p>在 Network Partition 的情况下，部分节点之间没办法互相通信，Raft 也能保证在这种情况下数据的一致性。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171324277.webp" alt="img"></p>
<p>假设，一开始有 5 个节点处于同一网络状态下。Network Partition 将节点分成两边，一边有两个节点，一边三个节点。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171324209.webp" alt="img"></p>
<p>两个节点这边已经有 Leader 了，来自客户端的数据 “bob” 通过 Leader 同步到 Follower。因为只有两个节点，少于3个节点，所以 “bob” 的状态仍是 Uncommitted。所以在这里，<strong>服务器会返回错误给客户端</strong>。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171326671.webp" alt="img"></p>
<p>另外一个 Partition 有三个节点，进行重新选主。客户端数据 “tom” 发到新的 Leader，通过和上节网络状态下相似的过程，同步到另外两个 Follower。因为这个 Partition 有3个节点，超过半数，所以数据 “tom” 都 Commit 了。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171326806.webp" alt="img"></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171326095.webp" alt="img"></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171326530.webp" alt="img"></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171327875.webp" alt="img"></p>
<p>网络状态恢复，5个节点再次处于同一个网络状态下。但是这里出现了数据冲突 “bob” 和 “tom”。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171327168.webp" alt="img"></p>
<p>三个节点的 Leader 广播 AppendEntries，两个节点 Partition 的 Leader 自动降级为 Follower，因为这个 Partition 的数据 “bob” 没有 Commit，返回给客户端的是错误，客户端知道请求没有成功，所以 Follower 在收到 AppendEntries 请求时，可以把 “bob“ 删除，然后同步 ”tom”，通过这么一个过程，就完成了在 Network Partition 情况下的复制日志，保证了数据的一致性。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171329272.webp" alt="img"> </p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171329440.webp" alt="img"></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171329621.webp" alt="img"></p>
<p>可以参考：</p>
<p>图解Raft：<a href="https://blog.csdn.net/i6448038/article/details/85525040">https://blog.csdn.net/i6448038/article/details/85525040</a></p>
<p>Raft 原理动画：<a href="https://link.jianshu.com/?t=http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<hr>
<p><strong>使用 Raft 算法，会有什么痛点呢?</strong></p>
<p>受限于 Raft 的强领导者模型。所有请求都在领导者节点上处理，整个集群的性能等于单机性能。这样会造成集群接入性能低下，无法支撑海量或大数据量的时序数据。</p>
<p>受限于强领导者模型，以及 Raft 的节点和副本一一对应的限制，无法实现水平扩展，分布式集群扩展了读性能，但写性能并没有提升。这样会出现写性能低下，和因为架构上的限制，无法提升写性能的问题。 Raft 的“一切以领导者为准”的日志复制特性，会导致 DATA 节点丢数据，出现时序数据记录缺失的问题。</p>
<hr>
<p>转载自：<br><a href="https://www.jianshu.com/p/8e4bbe7e276c">https://www.jianshu.com/p/8e4bbe7e276c</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统的SLA</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84SLA/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="1-什么是SLA（服务等级协议）？"><a href="#1-什么是SLA（服务等级协议）？" class="headerlink" title="1. 什么是SLA（服务等级协议）？"></a>1. 什么是SLA（服务等级协议）？</h2><p>SLA（Service-Level Agreement）<strong>服务等级协议</strong>，是指系统服务提供者（Provider）对客户（Customer）的一个<strong>可量化的服务承诺</strong>，常见于大型分布式系统中，<strong>用于衡量系统服务是否稳定健康的常见方法</strong>。</p>
<h2 id="2-SLA（服务等级协议）常用的衡量指标有哪些？"><a href="#2-SLA（服务等级协议）常用的衡量指标有哪些？" class="headerlink" title="2. SLA（服务等级协议）常用的衡量指标有哪些？"></a>2. SLA（服务等级协议）常用的衡量指标有哪些？</h2><p>SLA是一种服务承诺，因此指标具备多样性, <strong>业界主流常用指标包含：可用性、准确性、系统容量和延迟。</strong><br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291805462.jpeg" alt="img"></p>
<span id="more"></span>

<h3 id="2-1-Availability（可用性）"><a href="#2-1-Availability（可用性）" class="headerlink" title="2.1 Availability（可用性）"></a>2.1 Availability（可用性）</h3><p>系统服务能正常运行所占的时间百分比，业界对可用性的描述，通常采用年故障时长。比如，数据中心机房划分为不同等级，如 T1～T4 机房，它们的 可用性 及年平均故障时间如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291805134.png" alt="img"></p>
<p>网络服务的可用性，通常也会折算为不能提供服务的故障时间长度来衡量，比如典型的 <strong>5 个 9</strong> 可用性就表示年故障时长为 <strong>5 分钟</strong>，如下表所示。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291806027.png" alt="img"></p>
<p>对于许多系统而言，四个9的可用性（99.99％），或每年约52.6分钟的系统中断时间，即可以被认为是具备高可用性。</p>
<h3 id="2-2-Accuracy（准确性）"><a href="#2-2-Accuracy（准确性）" class="headerlink" title="2.2 Accuracy（准确性）"></a>2.2 Accuracy（准确性）</h3><p>准确性是指系统服务中，是否允许某些数据是不准确或者丢失，如果允许这样的情况发生，用户的容忍度（百分比，可以接受的概率）是多少，常见的衡量方式为：基于服务周期内的错误率计算准确性。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291806584.jpeg" alt="img"></p>
<p>例如，我们在一分钟内发送100个有效请求到系统中，其中有5个请求导致系统返回内部错误，那我们可以说这一分钟系统的错误率是 5 &#x2F; 100 &#x3D; 5%，准确率为1 - 5% &#x3D; 95%。</p>
<p>对于云服务而言，计算请求错误率时，计算时间范围越长越有利，因为时间越长，总请求数越多，错误率越有可能降得更低，一般有实力得服务商都会 <strong>从客户角度计算错误率，按照5分钟的粒度来计算</strong>，因为5 分钟是业界典型的机器故障恢复时间，能够快速修复机器，降低系统的错误率。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291806479.jpeg" alt="img"></p>
<p>最终准确率为：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291806830.jpeg" alt="img"></p>
<h3 id="2-3-Capacity（系统容量）"><a href="#2-3-Capacity（系统容量）" class="headerlink" title="2.3 Capacity（系统容量）"></a>2.3 Capacity（系统容量）</h3><p>指系统能够支持的负载量，一般会以每秒的请求数为单位来表示，与CPU的消耗、外部接口、IO等等紧密关联，常见衡量指标：</p>
<ul>
<li>QPS（Query Per Second）：每秒处理的查询数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，也即是最大吞吐能力。</li>
<li>TPS（Transactions Per Second）：每秒处理的事务个数，是软件测试结果的测量单位，一个事务是指一个客户机向服务器发送请求到服务器做出反应的全过程，客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，系统整体处理能力取决于处理能力最低模块的TPS值。</li>
<li>并发数： 系统可以同时承载的正常使用系统功能的用户的数量（同一时间处理的请求&#x2F;事务数），与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标</li>
<li>响应时间： 一般取平均响应时间。</li>
</ul>
<p>常用评估公式：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291806050.png" alt="img"></p>
<p>峰值QPS或峰值TPS计算原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。</p>
<p><strong>示例</strong>：公司早上8：00上班，7：30到8：00这30分钟的时间内用户需登录签到系统进行签到，公司员工总数为1000人，平均每一个员上登录签到系统的时长为5分钟。</p>
<ul>
<li>QPS &#x3D; 1000&#x2F;(30*60) 事务&#x2F;秒</li>
<li>RT（平均响应时间为） &#x3D; 5*60秒</li>
<li>并发数&#x3D; QPS<em>平均响应时间 &#x3D; 1000&#x2F;(30</em>60) <em>(5</em>60)&#x3D;166.7</li>
</ul>
<h3 id="2-4-Latency（延迟）"><a href="#2-4-Latency（延迟）" class="headerlink" title="2.4 Latency（延迟）"></a>2.4 Latency（延迟）</h3><p>延迟（Latency），指系统收到用户请求到响应请求之间的时间间隔，在定义延迟的SLA时，常用p95和p99这样的延迟声明，这里的p指的是percentile，也就是百分位的意思，<strong>如果p95是1秒的话，那就表示在100个请求里面有95个请求的响应时间会少于1秒，而剩下的5个请求响应时间会大于1秒，P99同理</strong>。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/wwd0501/article/details/127390615?spm=1001.2014.3001.5502">https://blog.csdn.net/wwd0501/article/details/127390615?spm=1001.2014.3001.5502</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统的接口幂等性</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="一、-背景"><a href="#一、-背景" class="headerlink" title="一、 背景"></a>一、 背景</h1><p>实际系统中有很多操作，不管做多少次，都应该产生一样的效果或返回一样的结果。比如完成一个订单流程时经常遇到下面的场景：</p>
<ol>
<li>一个订单创建接口，第一次调用超时了，然后调用方重试了一次</li>
<li>在订单创建时，需要去扣减库存，这时接口发生了超时，调用方重试了一次</li>
<li>当这笔订单开始支付，在支付请求发出之后，在服务端发生了扣钱操作，接口响应超时了，调用方重试了一次</li>
<li>一个订单状态更新接口，调用方连续发送了两个消息，一个是已创建，一个是已付款。但是先接收到已付款，然后又接收到了已创建</li>
<li>在支付完成订单之后，需要发送一条短信，当一台机器接收到短信发送的消息之后，处理较慢。消息中间件又把消息投递给另外一台机器处理。</li>
</ol>
<p>为了解决以上问题，就需要保证接口的幂等性。</p>
<span id="more"></span> 

<h1 id="二、幂等性概念"><a href="#二、幂等性概念" class="headerlink" title="二、幂等性概念"></a>二、幂等性概念</h1><p>​	幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。<br>​	在编程中幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。那么接口的实际上就是 <strong>接口可重复调用，在多次调用的情况下，接口产生的效果和返回的结果都是一致的</strong>。</p>
<p>​	举个最简单的例子，那就是支付，用户购买商品使用支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时不会进行第二次扣款，返回结果成功。 </p>
<p>​	有些接口可以天然的实现幂等性，比如查询接口，对于查询来说，查询一次和两次，对于系统来说，没有任何影响，查出的结果也是一样。</p>
<p>​	除了查询功能具有天然的幂等性之外，增加、更新、删除都要保证幂等性。那么如何来保证幂等性呢？</p>
<h1 id="三、技术方案"><a href="#三、技术方案" class="headerlink" title="三、技术方案"></a>三、技术方案</h1><p><strong>1.</strong> <strong>查询操作</strong><br>查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作 </p>
<p> <strong>2.</strong> <strong>删除操作</strong><br>删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个) </p>
<p> <strong>3.唯一索引，防止新增脏数据</strong><br>比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引。<strong>唯一索引或唯一组合索引来防止新增数据存在脏数据 （当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）</strong> </p>
<p> <strong>4. token机制，防止页面重复提交</strong><br>由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交，需要保证页面的数据只能被提交一次，可以使用采用token加redis或内存。</p>
<ol>
<li>数据提交前要向服务的申请token，token放到redis或jvm内存，token有有效时间。</li>
<li>提交后后台校验token，同时删除token，生成新的token返回。</li>
</ol>
<p>或者，请求时先异步获取token（或者说全局唯一ID），请求时带上token，根据token查询此次操作是否存在，如果存在则表示该操作已经执行过，直接返回结果；如果不存在则操作。这里的关键在于token获取的幂等性。</p>
<p> <strong>5.</strong> <strong>悲观锁</strong><br> 获取数据的时候加锁获取 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table_xxx where id=&#x27;xxx&#x27; for update;</span><br></pre></td></tr></table></figure>

<p><strong>id字段一定是主键或者唯一索引，不然会锁表。悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</strong> </p>
<p> <strong>6.</strong> <strong>乐观锁</strong>(<strong>多版本控制</strong>)<br>乐观锁的实现方式多种多样，可以通过version： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table_xxx set name=#name,version=version+1 where id=#id and version=#version</span><br></pre></td></tr></table></figure>



<p><strong>7.分布式锁</strong> </p>
<p>还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁。 </p>
<p><strong>8.select + insert</strong> </p>
<p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。<strong>注意：核心高并发流程不要用这种方法</strong></p>
<p> <strong>9.</strong> <strong>状态机幂等</strong><br>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。<br><strong>订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助</strong>。</p>
<p><strong>10.</strong> <strong>对外提供接口的api如何保证幂等</strong><br>比如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号 。source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)<br><strong>重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</strong> </p>
<p> <strong>11.insert or update</strong></p>
<p>这种方法插入并且有唯一索引的情况，比如要关联商品品类，其中商品的ID和品类的ID可以构成唯一索引，并且在数据表中也增加了唯一索引。这时就可以使用InsertOrUpdate操作。在mysql数据库中如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into goods_category (goods_id,category_id,create_time,update_time) </span><br><span class="line">       values(#&#123;goodsId&#125;,#&#123;categoryId&#125;,now(),now()) </span><br><span class="line">       on DUPLICATE KEY UPDATE</span><br><span class="line">       update_time=now()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<p>参考：<br><a href="https://blog.csdn.net/qq2531246791/article/details/81984381">https://blog.csdn.net/qq2531246791/article/details/81984381</a><br><a href="https://www.cnblogs.com/leechenxiang/p/6626629.html">https://www.cnblogs.com/leechenxiang/p/6626629.html</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>[toc]<br>如果在公司里落地生产环境用分布式锁的时候，一定是会用开源类库的，比如Redis分布式锁，一般就是用Redisson框架就好了，非常的简便易用。感兴趣可以去Redisson官网看看如何在项目中引入Redisson的依赖，然后基于Redis实现分布式锁的加锁与释放锁。</p>
<p>一段简单的使用代码片段，先直观的感受一下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824484.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>是不是感觉简单的不行！此外，还支持Redis单实例、Redis哨兵、Redis Cluster、redis master-slave等各种部署架构，都可以完美实现。</p>
<span id="more"></span>

<h2 id="一、Redisson实现Redis分布式锁的底层原理"><a href="#一、Redisson实现Redis分布式锁的底层原理" class="headerlink" title="一、Redisson实现Redis分布式锁的底层原理"></a><strong>一、Redisson实现Redis分布式锁的底层原理</strong></h2><p>现在通过一张手绘图，说说Redisson这个开源框架对Redis分布式锁的实现原理。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824812.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<h3 id="1、加锁机制"><a href="#1、加锁机制" class="headerlink" title="1、加锁机制"></a>1、加锁机制</h3><p>看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个Redis Cluster集群，他首先会根据Hash节点选择一台机器。</p>
<p>注：仅仅只是选择一台机器！然后发送一段Lua脚本到Redis上，那段Lua脚本如下所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824821.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>为啥要用Lua脚本呢？因为一大坨复杂的业务逻辑，可以通过封装在Lua脚本中发送给Redis，保证这段复杂业务逻辑执行的原子性。</p>
<p>那么，这段Lua脚本是什么意思呢？这里KEYS[1]代表的是你加锁的那个Key，比如说：<code>RLock lock = redisson.getLock(&quot;myLock&quot;)；</code>这里你自己设置了加锁的那个锁Key就是“myLock”。</p>
<ul>
<li>ARGV[1]代表的就是锁Key的默认生存时间，默认30秒。</li>
<li>ARGV[2]代表的是加锁的客户端的ID，类似于下面这样的：<br>8743c9c0-0795-4907-87fd-6c719a6b4586:1。</li>
</ul>
<p>第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁Key不存在的话，你就进行加锁。如何加锁呢？很简单，用下面的命令：hset myLock。</p>
<p>8743c9c0-0795-4907-87fd-6c719a6b4586:11，通过这个命令设置一个Hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824831.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>上述内容就代表“<br>8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端，已经对“myLock”这个锁Key完成了加锁。</p>
<p>接着会执行“pexpiremyLock 30000”命令，设置myLock这个锁Key的生存时间是30秒，加锁完成。</p>
<h3 id="2、锁互斥机制"><a href="#2、锁互斥机制" class="headerlink" title="2、锁互斥机制"></a>2、锁互斥机制</h3><p>这个时候，如果客户端2来尝试加锁，执行了同样的一段Lua脚本，会怎样？</p>
<p>第一个if判断会执行“exists myLock”，发现myLock这个锁Key已经存在了。</p>
<p>第二个if判断，判断myLock锁Key的Hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p>
<p>所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁Key的剩余生存时间。比如还剩15000毫秒的生存时间。此时客户端2会进入一个while循环，不停的尝试加锁。</p>
<h3 id="3、watch-dog自动延期机制"><a href="#3、watch-dog自动延期机制" class="headerlink" title="3、watch dog自动延期机制"></a>3、watch dog自动延期机制</h3><p>客户端1加锁的锁Key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p>
<p>只要客户端1加锁成功，就会启动一个watchdog看门狗，这个后台线程，会每隔10秒检查一下，如果客户端1还持有锁Key，就会不断的延长锁Key的生存时间。</p>
<h3 id="4、可重入加锁机制"><a href="#4、可重入加锁机制" class="headerlink" title="4、可重入加锁机制"></a>4、可重入加锁机制</h3><p>那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？如下代码：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824947.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>分析一下上面那段Lua脚本。第一个if判断肯定不成立，“exists myLock”会显示锁Key已经存在了。</p>
<p>第二个if判断会成立，因为myLock的Hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“<br>8743c9c0-0795-4907-87fd-6c719a6b4586:1”。</p>
<p>此时就会执行可重入加锁的逻辑，<code>incrby myLock 8743c9c0-0795-4907-87fd-6c71a6b4586:1</code>，通过这个命令，对客户端1的加锁次数，累加1。</p>
<p>此时myLock数据结构变为下面这样：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824834.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>myLock的Hash数据结构中的那个客户端ID，就对应着加锁的次数。</p>
<h3 id="5、释放锁机制"><a href="#5、释放锁机制" class="headerlink" title="5、释放锁机制"></a>5、释放锁机制</h3><p>如果执行lock.unlock，就可以释放分布式锁，此时的业务逻辑也是非常简单的。就是每次都对myLock数据结构中的那个加锁次数减1。</p>
<p>如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：“del myLock”命令，从Redis里删除这个Key。</p>
<p>而另外的客户端2就可以尝试完成加锁了。这就是所谓的分布式锁的开源Redisson框架的实现机制。</p>
<p>一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于Redis进行分布式锁的加锁与释放锁。</p>
<h3 id="6、上述Redis分布式锁的缺点"><a href="#6、上述Redis分布式锁的缺点" class="headerlink" title="6、上述Redis分布式锁的缺点"></a>6、上述Redis分布式锁的缺点</h3><p>上面那种方案最大的问题，就是如果你对某个Redis Master实例，写入了myLock这种锁Key的Value，此时会异步复制给对应的Master Slave实例。</p>
<p>但是这个过程中一旦发生Redis Master宕机，主备切换，Redis Slave变为了Redis Master。</p>
<p>会导致客户端2尝试加锁时，在新的Redis Master上完成加锁，客户端1也以为自己成功加锁。</p>
<p>此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。</p>
<p>所以这个就是Redis Cluster，或者是redis master-slave架构的主从异步复制导致的Redis分布式锁的最大缺陷：在Redis Master实例宕机的时候，可能导致多个客户端同时完成加锁。</p>
<h2 id="二、七张图彻底讲清楚ZooKeeper分布式锁的实现原理"><a href="#二、七张图彻底讲清楚ZooKeeper分布式锁的实现原理" class="headerlink" title="二、七张图彻底讲清楚ZooKeeper分布式锁的实现原理"></a><strong>二、七张图彻底讲清楚ZooKeeper分布式锁的实现原理</strong></h2><p>下面再聊一下ZooKeeper实现分布式锁的原理。同理，我是直接基于比较常用的Curator这个开源框架，聊一下这个框架对ZooKeeper（以下简称ZK）分布式锁的实现。</p>
<p>一般除了大公司是自行封装分布式锁框架之外，建议大家用这些开源框架封装好的分布式锁实现，这是一个比较快捷省事的方式。</p>
<h3 id="ZooKeeper分布式锁机制"><a href="#ZooKeeper分布式锁机制" class="headerlink" title="ZooKeeper分布式锁机制"></a><strong>ZooKeeper分布式锁机制</strong></h3><p>看看多客户端获取及释放ZK分布式锁的整个流程及背后的原理。首先看看下图，如果现在有两个客户端一起要争抢ZK上的一把分布式锁，会是个什么场景？</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824040.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>参见上图。ZK里有一把锁，这个锁就是ZK上的一个节点。两个客户端都要来获取这个锁，具体是怎么来获取呢？</p>
<p>假设客户端A抢先一步，对ZK发起了加分布式锁的请求，这个加锁请求是用到了ZK中的一个特殊的概念，叫做“临时顺序节点”。简单来说，就是直接在”my_lock”这个锁节点下，创建一个顺序节点，这个顺序节点有ZK内部自行维护的一个节点序号。</p>
<ul>
<li>比如第一个客户端来搞一个顺序节点，ZK内部会给起个名字叫做：xxx-000001。</li>
<li>然后第二个客户端来搞一个顺序节点，ZK可能会起个名字叫做：xxx-000002。</li>
<li>注意，最后一个数字都是依次递增的，从1开始逐次递增。ZK会维护这个顺序。</li>
</ul>
<p>所以这个时候，假如说客户端A先发起请求，就会搞出来一个顺序节点，大家看下图，Curator框架大概会弄成如下的样子：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824190.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>客户端A发起一个加锁请求，先在要加锁的node下搞一个临时顺序节点，这列长名字都是Curator框架自己生成出来的。</p>
<p>然后，那个最后一个数字是”1”。因为客户端A是第一个发起请求的，所以给他搞出来的顺序节点的序号是”1”。</p>
<p>接着客户端A创建完一个顺序节点。还没完，他会查一下”my_lock”这个锁节点下的所有子节点，并且这些子节点是按照序号排序的，这个时候他大概会拿到这么一个集合：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824863.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>接着客户端A会走一个关键性的判断：这个集合里创建的顺序节点，是否排在首位？</p>
<p>如果是的话，就可以加锁，因为明明我就是第一个来创建顺序节点的人，所以我就是第一个尝试加分布式锁的人啊！</p>
<p>加锁成功！看下图，再来直观的感受一下整个过程：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824239.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>接着假如说，客户端A都加完锁了，客户端B过来想要加锁了，这个时候他会干一样的事儿：先是在”my_lock”这个锁节点下创建一个临时顺序节点，此时名字会变成类似于：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824990.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824654.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>客户端B因为是第二个来创建顺序节点的，所以ZK内部会维护序号为”2”。</p>
<p>接着客户端B会走加锁判断逻辑，查询”my_lock”锁节点下的所有子节点，按序号顺序排列，此时他看到的类似于：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291824844.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>同时检查自己创建的顺序节点，是不是集合中的第一个？明显不是啊，此时第一个是客户端A创建的那个顺序节点，序号为”01”的那个。所以加锁失败！</p>
<p>加锁失败了以后，客户端B就会通过ZK的API对他的顺序节点的上一个顺序节点加一个监听器。ZK天然就可以实现对某个节点的监听。</p>
<p>这个节点加一个监听器，监听这个节点是否被删除等变化！大家看下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825817.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>接着，客户端A加锁之后，可能处理了一些代码逻辑，然后就会释放锁。那么，释放锁是个什么过程呢？</p>
<p>其实就是把自己在ZK里创建的那个顺序节点，也就是：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825850.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>这个节点删除。删除了那个节点之后，ZK会负责通知监听这个节点的监听器，也就是客户端B之前加的那个监听器，说：你监听的那个节点被删除了，有人释放了锁。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825495.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>此时客户端B的监听器感知到了上一个顺序节点被删除，也就是排在他之前的某个客户端释放了锁。</p>
<p>此时，就会通知客户端B重新尝试去获取锁，也就是获取”my_lock”节点下的子节点集合，此时为：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825393.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>集合里此时只有客户端B创建的唯一的一个顺序节点了！然后呢，客户端B判断自己居然是集合中的第一个顺序节点，Bingo！可以加锁了！直接完成加锁，运行后续的业务代码即可，运行完了之后再次释放锁。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825421.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>其实如果有客户端C、客户端D等N个客户端争抢一个ZK分布式锁，原理都是类似的：</p>
<ul>
<li>大家都是上来直接创建一个锁节点下的一个接一个的临时顺序节点。</li>
<li>如果自己不是第一个节点，就对自己上一个节点加监听器。</li>
<li>只要上一个节点释放锁，自己就排到前面去了，相当于是一个排队机制。</li>
<li>而且用临时顺序节点的另外一个用意就是，如果某个客户端创建临时顺序节点之后，不小心自己宕机了也没关系，ZK感知到那个客户端宕机，会自动删除对应的临时顺序节点，相当于自动释放锁，或者是自动取消自己的排队。</li>
</ul>
<p>最后，咱们来看下用Curator框架进行加锁和释放锁的一个过程：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825334.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>其实用开源框架就是方便。这个Curator框架的ZK分布式锁的加锁和释放锁的实现原理，就是上面我们说的那样子。</p>
<p>但是如果你要手动实现一套那个代码的话，要考虑到各种细节，异常处理等等。所以大家如果考虑用ZK分布式锁，可以参考下本文的思路。</p>
<h2 id="三、每秒上千订单场景下的分布式锁高并发优化实践"><a href="#三、每秒上千订单场景下的分布式锁高并发优化实践" class="headerlink" title="三、每秒上千订单场景下的分布式锁高并发优化实践"></a><strong>三、每秒上千订单场景下的分布式锁高并发优化实践</strong></h2><p>接着聊一个有意思的话题：每秒上千订单场景下，如何对分布式锁的并发能力进行优化？</p>
<p>首先，我们一起来看看这个场景题：</p>
<p>假如下单时，用分布式锁来防止库存超卖，但是是每秒上千订单的高并发场景，如何对分布式锁进行高并发优化来应对这个场景？</p>
<p>他说他当时没答上来，因为没做过没什么思路。其实我当时听到这个面试题心里也觉得有点意思，因为如果是我来面试候选人的话，给的范围会更大一些。比如，让面试的同学聊一聊电商高并发秒杀场景下的库存超卖解决方案，各种方案的优缺点以及实践，进而聊到分布式锁这个话题。</p>
<p>因为库存超卖问题是有很多种技术解决方案的，比如悲观锁，分布式锁，乐观锁，队列串行化，Redis原子操作，等等吧。但是既然那个面试官兄弟限定死了用分布式锁来解决库存超卖，我估计就是想问一个点：在高并发场景下如何优化分布式锁的并发性能。</p>
<p>面试官提问的角度还是可以接受的，因为在实际落地生产的时候，分布式锁这个东西保证了数据的准确性，但是他天然并发能力有点弱。</p>
<p>刚好我之前在自己项目的其他场景下，确实是做过高并发场景下的分布式锁优化方案，因此正好是借着这个朋友的面试题，把分布式锁的高并发优化思路，给大家来聊一聊。</p>
<p>1、库存超卖现象是怎么产生的？</p>
<p>先来看看如果不用分布式锁，所谓的电商库存超卖是啥意思？大家看下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825531.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>这个图其实很清晰了，假设订单系统部署在两台机器上，不同的用户都要同时买10台iPhone，分别发了一个请求给订单系统。</p>
<p>接着每个订单系统实例都去数据库里查了一下，当前iPhone库存是12台，大于了要买的10台数量。</p>
<p>于是每个订单系统实例都发送SQL到数据库里下单，然后扣减了10个库存，其中一个将库存从12台扣减为2台，另外一个将库存从2台扣减为-8台。</p>
<p>现在库存出现了负数！没有20台iPhone发给两个用户啊！怎么办？</p>
<p>2、用分布式锁如何解决库存超卖问题？</p>
<p>我们用分布式锁如何解决库存超卖问题呢？回忆一下上次我们说的那个分布式锁的实现原理：</p>
<p>同一个锁Key，同一时间只能有一个客户端拿到锁，其他客户端会陷入无限的等待来尝试获取那个锁，只有获取到锁的客户端才能执行下面的业务逻辑。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825552.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>代码如上图，分析一下为什么这样可以避免库存超卖？</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825409.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>大家可以顺着上面的那个步骤序号看一遍，马上就明白了。</p>
<p>从上图可以看到，只有一个订单系统实例可以成功加分布式锁，然后只有他一个实例可以查库存、判断库存是否充足、下单扣减库存，接着释放锁。释放锁之后，另外一个订单系统实例才能加锁，接着查库存，一下发现库存只有2台了，库存不足，无法购买，下单失败。不会将库存扣减为-8的。</p>
<p>3、有没其他方案解决库存超卖问题？</p>
<p>当然有！比如悲观锁，分布式锁，乐观锁，队列串行化，异步队列分散，Redis原子操作，等等，很多方案，我们对库存超卖有自己的一整套优化机制。但是前面说过，这篇文章就聊一个分布式锁的并发优化，不是聊库存超卖的解决方案，所以库存超卖只是一个业务场景而已。</p>
<p>4、分布式锁的方案在高并发场景下</p>
<p>现在我们来看看，分布式锁的方案在高并发场景下有什么问题？分布式锁一旦加了之后，对同一个商品的下单请求，会导致所有客户端都必须对同一个商品的库存锁Key进行加锁。</p>
<p>比如，对iPhone这个商品的下单，都必对“iphone_stock”这个锁Key来加锁。这样会导致对同一个商品的下单请求，就必须串行化，一个接一个的处理。大家再回去对照上面的图反复看一下，应该能想明白这个问题。</p>
<p>假设加锁之后，释放锁之前，查库存→创建订单→扣减库存，这个过程性能很高吧，算他全过程20毫秒，这应该不错了。那么1秒是1000毫秒，只能容纳50个对这个商品的请求依次串行完成处理。如一秒钟50个请求，都是对iPhone下单的，那么每个请求处理20毫秒，逐个来，最后1000毫秒正好处理完50个请求。</p>
<p>大家看下图，加深印象。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825561.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>所以看到这里，大家起码也明白了，简单的使用分布式锁来处理库存超卖问题，存在什么缺陷。</p>
<p>同一商品多用户同时下单时，会基于分布式锁串行化处理，导致没法同时处理同一个商品的大量下单的请求。这种方案应对那种低并发、无秒杀场景的普通小电商系统，可能还可以接受。</p>
<p>因为如果并发量很低，每秒就不到10个请求，没有瞬时高并发秒杀单个商品的场景的话，其实也很少会对同一个商品在1秒内瞬间下1000个订单，因为小电商系统没那场景。</p>
<p>5、如何对分布式锁进行高并发优化？</p>
<p>那么现在怎么办呢？面试官说，我现在就卡死，库存超卖就是用分布式锁来解决，而且一秒对一个iPhone下上千订单，怎么优化？</p>
<p>现在按照刚才的计算，你1秒钟只能处理针对iPhone的50个订单。其实说出来也很简单，相信很多人看过Java里的Concurrent Hash Map的源码和底层原理，应该知道里面的核心思路，就是分段加锁！</p>
<p>把数据分成很多个段，每个段是一个单独的锁，所以多个线程过来并发修改数据的时候，可以并发的修改不同段的数据。不至于说，同一时间只能有一个线程独占修改Concurrent Hash Map中的数据。</p>
<p>另外，Java8中新增了一个Long Adder类，也是针对Java7以前的Atomic Long进行的优化，解决的是CAS类操作在高并发场景下，使用乐观锁思路，会导致大量线程长时间重复循环。Long Adder中也采用了类似的分段CAS操作，失败则自动迁移到下一个分段进行CAS的思路。</p>
<p>其实分布式锁的优化思路也是类似的，之前我们是在另外一个业务场景下落地了这个方案到生产中，不是在库存超卖问题里用的。但是库存超卖这个业务场景不错，很容易理解，所以我们就用这个场景来说一下。</p>
<p>大家看下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291825472.jpeg" alt="再有人问你分布式锁，就把这个丢给他！"></p>
<p>这就是分段加锁。假如现在iPhone有1000个库存，完全可以给拆成20个库存段。</p>
<p>要是你愿意，可以在数据库的表里建20个库存字段，比如stock_01，stock_02，类似这样的，也可以在Redis之类的地方放20个库存Key。</p>
<p>总之，就是把你的1000件库存给他拆开，每个库存段是50件库存，比如stock_01对应50件库存，stock_02对应50件库存。</p>
<p>接着，每秒1000个请求过来了！此时可以自己写一个简单的随机算法，每个请求都是随机在20个分段库存里，选择一个进行加锁。</p>
<p>这样同时可以有最多20个下单请求一起执行，每个下单请求锁了一个库存分段，然后在业务逻辑里面，就对数据库或者是Redis中的那个分段库存进行操作即可，包括查库存→判断库存是否充足→扣减库存。</p>
<p>这相当于一个20毫秒，可以并发处理掉20个下单请求，那么1秒，也就可以依次处理掉20*50&#x3D;1000个对iPhone的下单请求了。</p>
<p>一旦对某个数据做了分段处理之后，有一个坑大家一定要注意：就是如果某个下单请求，咔嚓加锁，然后发现这个分段库存里的库存不足了。这时你得自动释放锁，然后立马换下一个分段库存，再次尝试加锁后尝试处理。这个过程一定要实现。</p>
<p>6、分布式锁并发优化方案有什么不足？</p>
<p>最大的不足是很不方便，实现太复杂：</p>
<ul>
<li>首先，你得对一个数据分段存储，一个库存字段本来好好的，现在要分为20个库存字段。</li>
<li>其次，你在每次处理库存的时候，还得自己写随机算法，随机挑选一个分段来处理。</li>
<li>最后，如果某个分段中的数据不足了，你还得自动切换到下一个分段数据去处理。</li>
</ul>
<p>这个过程都是要手动写代码实现的，还是有点工作量。不过我们确实在一些业务场景里，因为用到了分布式锁，然后又必须要进行锁并发的优化，又进一步用到了分段加锁的技术方案，效果当然是很好的了，一下子并发性能可以增长几十倍。</p>
<p>该优化方案的后续改进：以我们本文所说的库存超卖场景为例，你要是这么玩，会把自己搞的很痛苦！再次强调，我们这里的库存超卖场景，仅仅只是作为演示场景而已。</p>
<hr>
<p>转载自：<br><a href="https://www.toutiao.com/a6652439398560301575/?log_from=46dcd642af27c_1642770093145">https://www.toutiao.com/a6652439398560301575/?log_from=46dcd642af27c_1642770093145</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>微服务架构</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>&emsp;&emsp;什么是微服务架构，得先知道什么系统架构设计?<br>&emsp;&emsp;系统架构设计描述了在应用系统的内部，如何根据业务、技术、组织、灵活性、可扩展性以及可维护性等多种因素，将应用系统划分成不同的部分，并使这些部分彼此之间相互分工、相互协作，从而为用户提供某种特定的价值的方式。</p>
<h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>优点：<br>&emsp;&emsp;1、易于开发： 开发方式简单，IDE 支持好，方便运行和调试。<br>&emsp;&emsp;2、易于测试： 所有功能运行在一个进程中，一旦进程启动，便可以进行系统测试。<br>&emsp;&emsp;3、易于部署： 只需要将打好的一个软件包发布到服务器即可。<br>&emsp;&emsp;4、易于水平伸缩： 只需要创建一个服务器节点，配置好运行时环境，再将软件包发布到新服务器节点即可运行程序（当然也需要采取分发策略保证请求能有效地分发到新节点）。</p>
<p>缺点：<br>&emsp;&emsp;1、维护成本大： 当应用程序的功能越来越多、团队越来越大时，沟通成本、管理成本显著增加。当出现 bug 时，可能引起 bug 的原因组合越来越多，导致分析、定位和修复的成本增加；并且在对全局功能缺乏深度理解的情况下，容易在修复 bug 时引入新的 bug。<br>&emsp;&emsp;2、持续交付周期长： 构建和部署时间会随着功能的增多而增加，任何细微的修改都会触发部署流水线。<br>&emsp;&emsp;3、新人培养周期长： 新成员了解背景、熟悉业务和配置环境的时间越来越长。<br>&emsp;&emsp;4、技术选型成本高： 单块架构倾向于采用统一的技术平台或方案来解决所有问题，如果后续想引入新的技术或框架，成本和风险都很大。<br>&emsp;&emsp;5、可扩展性差： 随着功能的增加，垂直扩展的成本将会越来越大；而对于水平扩展而言，因为所有代码都运行在同一个进程，没办法做到针对应用程序的部分功能做独立的扩展。</p>
<span id="more"></span>

<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>&emsp;&emsp;微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务于服务间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p>
<h4 id="微服务架构的特性"><a href="#微服务架构的特性" class="headerlink" title="微服务架构的特性"></a>微服务架构的特性</h4><ol>
<li><p>单一职责<br>&emsp;&emsp;微服务架构中的每个服务，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。</p>
</li>
<li><p>轻量级通信<br> &emsp;&emsp;服务之间通过轻量级的通信机制实现互通互联，而所谓的轻量级，通常指语言无关、平台无关的交互方式。<br> &emsp;&emsp;对于轻量级通信的格式而言，比如熟悉的 XML 和 JSON，它们是语言无关、平台无关的；对于通信的协议而言，通常基于 HTTP，能让服务间的通信变得标准化、无状态化。REST（Representational State Transfer）就是实现服务间互相协作的轻量级通信机制之一。使用轻量级通信机制，可以让团队选择更适合的语言、工具或者平台来开发服务本身。</p>
</li>
<li><p>独立性<br> &emsp;&emsp;每个服务在应用交付过程中，独立地开发、测试和部署。<br> &emsp;&emsp;在单块架构中所有功能都在同一个代码库，功能的开发不具有独立性；当不同小组完成多个功能后，需要经过集成和回归测试，测试过程也不具有独立性；当测试完成后，应用被构建成一个包，如果某个功能存在 bug，将导致整个部署失败或者回滚。<br> &emsp;&emsp;在微服务架构中，每个服务都是独立的业务单元，与其他服务高度解耦，只需要改变当前服务本身，就可以完成独立的开发、测试和部署。</p>
</li>
<li><p>进程隔离<br> &emsp;&emsp;单块架构中，整个系统运行在同一个进程中，当应用进行部署时，必须停掉当前正在运行的应用，部署完成后再重启进程，无法做到独立部署。<br> &emsp;&emsp;有时候会将重复的代码抽取出来封装成组件，在单块架构中，组件通常的形态叫做共享库（如 jar 包或者 DLL），但是当程序运行时，所有组件最终也会被加载到同一进程中运行。<br> &emsp;&emsp;在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上。<br> &emsp;&emsp;理论上所有服务可以部署在同一个服务器节点，但是并不推荐这么做，因为微服务架构的主旨就是高度自治和高度隔离。</p>
</li>
</ol>
<h4 id="微服务架构的本质"><a href="#微服务架构的本质" class="headerlink" title="微服务架构的本质"></a>微服务架构的本质</h4><ol>
<li><p>服务作为组件<br>&emsp;&emsp;微服务也可以被认为是一种组件，但是跟传统组件的区别在于它可以独立部署，因此它的一个显著的优势。另外一个优点是，它在组件与组件之间定义了清晰的、语言无关、平台无关的规范接口，耦合度低，灵活性非常高。但它的不足之处是，分布式调用严重依赖于网络的可靠性和稳定性。</p>
</li>
<li><p>围绕业务组织团队<br>&emsp;&emsp;在单块架构中，企业一般会根据技能划分团队，在这种组织架构下，即便是简单的需求变更都有可能需要跨团队协作，沟通成本很高。而在微服务架构中，它提倡以业务为核心，按照业务能力来组织团队，团队中的成员具有多样性的技能。</p>
</li>
<li><p>关注产品而非项目<br>&emsp;&emsp;在单块架构中，应用基本上是基于“项目模式”构建的，即项目启动时从不同技能资源池中抽取相关资源组成团队，项目结束后释放所有资源。这种情况下团队成员缺乏主人翁意识和产品成就感。<br>&emsp;&emsp;在微服务架构中，提倡采用“产品模式”构建，即更倾向于让团队负责整个服务的生命周期，以便提供更优质的服务。</p>
</li>
<li><p>技术多样性<br>&emsp;&emsp;微服务架构中，提倡针对不同的业务特征选择合适的技术方案，有针对性的解决具体业务问题，而不是像单块架构中采用统一的平台或技术来解决所有问题。</p>
</li>
<li><p>业务数据独立<br>&emsp;&emsp;微服务架构提供自主管理其相关的业务数据，这样可以随着业务的发展提供数据接口集成，而不是以数据库的方式同其他服务集成。另外，随着业务的发展，可以方便地选择更合的工具管理或者迁移业务数据。</p>
</li>
<li><p>基础设施自动化<br>&emsp;&emsp;在微服务架构的实践过程中，对持续交付和部署流水线的要求很高，将促进企业不断寻找更高效的方式完成基础设施的自动化及 DevOps 运维能力的提升。</p>
</li>
</ol>
<h4 id="微服务架构的落地的挑战"><a href="#微服务架构的落地的挑战" class="headerlink" title="微服务架构的落地的挑战"></a>微服务架构的落地的挑战</h4><ol>
<li><p>分布式系统的复杂性<br>&emsp;&emsp;微服务架构是基于分布式的系统，而构建分布式系统必然会带来额外的开销。<br> &emsp;&emsp;  a、性能： 分布式系统是跨进程、跨网络的调用，受网络延迟和带宽的影响。<br> &emsp;&emsp;  b、可靠性： 由于高度依赖于网络状况，任何一次的远程调用都有可能失败，随着服务的增多还会出现更多的潜在故障点。因此，如何提高系统的可靠性、降低因网络引起的故障率，是系统构建的一大挑战。<br> &emsp;&emsp;  c、异步： 异步通信大大增加了功能实现的复杂度，并且伴随着定位难、调试难等问题。<br> &emsp;&emsp;  d、数据一致性： 要保证分布式系统的数据强一致性，成本是非常高的，需要在 C（一致性）A（可用性）P（分区容错性） 三者之间做出权衡。</p>
</li>
<li><p>运维成本<br>&emsp;&emsp;运维主要包括配置、部署、监控与告警和日志收集四大方面。微服务架构中，每个服务都需要独立地配置、部署、监控和收集日志，成本呈指数级增长。</p>
</li>
<li><p>自动化部署<br>&emsp;&emsp;在微服务架构中，每个服务都独立部署，交付周期短且频率高，人工部署已经无法适应业务的快速变化。因此如何有效地构建自动化部署体系，是微服务面临的另一个挑战。</p>
</li>
<li><p>DevOps 与组织架构<br>&emsp;&emsp;在微服务架构的实施过程中，开发人员和运维人员的角色发生了变化，开发者将承担起整个服务的生命周期的责任，包括部署和监控；而运维则更倾向于顾问式的角色，尽早考虑服务如何部署。因此，按需调整组织架构、构建全功能的团队，也是一个不小的挑战。</p>
</li>
<li><p>服务间的依赖测试<br>&emsp;&emsp;单块架构中，通常使用集成测试来验证依赖是否正常。而在微服务架构中，服务数量众多，每个服务都是独立的业务单元，服务主要通过接口进行交互，如何保证依赖的正常，是测试面临的主要挑战。</p>
</li>
<li><p>服务间的依赖管理<br>&emsp;&emsp;微服务架构中，服务数量众多，如何清晰有效地展示服务间的依赖关系也是个不小的挑战。</p>
</li>
</ol>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/bntX2jSQfEHy7/article/details/79081314">https://blog.csdn.net/bntX2jSQfEHy7/article/details/79081314</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>服务容错模式</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>[toc]<br>所谓模式，其实就是某种场景下一类问题及其解决方案的总结归纳，往往可以重用。模式可以指导我们完成任务，作出合理的系统设计方案，达到事半功倍的效果。而在服务容错这个方向，行业内已经有了不少实践总结出来的解决方案。</p>
<h2 id="超时与重试（Timeout-and-Retry）"><a href="#超时与重试（Timeout-and-Retry）" class="headerlink" title="超时与重试（Timeout and Retry）"></a>超时与重试（Timeout and Retry）</h2><p>超时模式，是一种最常见的容错模式。常见的有设置网络连接超时时间，一次RPC的响应超时时间等。在分布式服务调用的场景中，它主要解决了当依赖服务出现建立网络连接或响应延迟，不用无限等待的问题，调用方可以根据事先设计的超时时间中断调用，及时释放关键资源，如Web容器的连接数，数据库连接数等，避免整个系统资源耗尽出现拒绝对外提供服务这种情况。</p>
<p>重试模式，一般和超时模式结合使用，适用于对于下游服务的数据强依赖的场景（不强依赖的场景不建议使用！），通过重试来保证数据的可靠性或一致性，常用于因网络抖动等导致服务调用出现超时的场景。与超时时间设置结合使用后，需要考虑接口的响应时间分布情况，超时时间可以设置为依赖服务接口99.5%响应时间的值，重试次数一般1-2次为宜，否则会导致请求响应时间延长，拖累到整个系统。</p>
 <span id="more"></span>

<h2 id="限流-Rate-Limiting-Load-Shedder"><a href="#限流-Rate-Limiting-Load-Shedder" class="headerlink" title="限流(Rate Limiting&#x2F;Load Shedder)"></a>限流(Rate Limiting&#x2F;Load Shedder)</h2><p>限流模式，常用于下游服务容量有限，但又怕出现突发流量猛增（如恶意爬虫，节假日大促等）而导致下游服务因压力过大而拒绝服务的场景。常见的限流模式有控制并发和控制速率，一个是限制并发的数量，一个是限制并发访问的速率。</p>
<p>控制并发：属于一种较常见的限流手段，在工程实践中可以通过信号量机制（如Java中的Semaphore）来控制。举个例子：假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候就可以使用Semaphore来控制并发数。</p>
<p>控制速率：在工程实践中，常见的是使用令牌桶算法来实现这种模式，其他如漏桶算法也可以实现控制速率。</p>
<p>令牌桶算法是这么描述的：每秒会有r个令牌放入桶中，或者说，每过1&#x2F;r秒桶中增加一个令牌；桶中最多存放b个令牌，如果桶满了，新放入的令牌会被丢弃；当一个n字节的数据包到达时，消耗n个令牌，然后发送该数据包；如果桶中可用令牌小于n，则该数据包将被缓存或丢弃。</p>
<p>令牌桶控制的是一个时间窗口内通过的数据量，在API层面常说的QPS、TPS，正好是一个时间窗口内的请求量或者事务量，只不过时间窗口限定在1s罢了。以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。令牌桶的另外一个好处是可以方便的改变速度，一旦需要提高速率，则按需提高放入桶中的令牌的速率。</p>
<p>在的工程实践中，通常使用Guava中的Ratelimiter来实现控制速率。</p>
<h2 id="电路熔断器-Circuit-Breaker"><a href="#电路熔断器-Circuit-Breaker" class="headerlink" title="电路熔断器(Circuit Breaker)"></a>电路熔断器(Circuit Breaker)</h2><p>在工程实践中，偶尔会遇到一些服务由于网络连接超时，系统有异常或load过高出现暂时不可用等情况，导致对这些服务的调用失败，可能需要一段时间才能修复，这种对请求的阻塞可能会占用宝贵的系统资源，如：内存，线程，数据库连接等等，最坏的情况下会导致这些资源被消耗殆尽，使得系统里不相关的部分所使用的资源也耗尽从而拖累整个系统。在这种情况下，调用操作能够立即返回错误而不是等待超时的发生或者重试可能是一种更好的选择，只有当被调用的服务有可能成功时再去尝试。</p>
<p>熔断器模式可以防止我们的系统不断地尝试执行可能会失败的调用，使得我们的系统继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器模式也可以使我们系统能够检测错误是否已经修正，如果已经修正，系统会再次尝试调用操作。</p>
<p>​    在熔断器内部，往往有以下几种状态：</p>
<p>1）闭合（closed）状态：该状态下能够对目标服务或方法进行正常的调用。熔断器类维护了一个时间窗口内调用失败的次数，如果某次调用失败，则失败次数加1。如果最近失败次数超过了在给定的时间窗口内允许失败的阈值(可以是数量也可以是比例)，则熔断器类切换到断开(Open)状态。此时熔断器设置了一个计时器，当时钟超过了该时间，则切换到半断开（Half-Open）状态，该睡眠时间的设定是给了系统一次机会来修正导致调用失败的错误。</p>
<p>2）断开(Open)状态：在该状态下，对目标服务或方法的请求会立即返回错误响应，如果设置了fallback方法，则会进入fallback的流程。</p>
<p>3）半断开（Half-Open）状态：允许对目标服务或方法的一定数量的请求可以去调用服务。如果这些请求对服务的调用成功，那么可以认为之前导致调用失败的错误已经修正，此时熔断器切换到闭合状态（并且将错误计数器重置）；如果这一定数量的请求有调用失败的情况，则认为导致之前调用失败的问题仍然存在，熔断器切回到断开方式，然后开始重置计时器来给系统一定的时间来修正错误。半断开状态能够有效防止正在恢复中的服务被突然而来的大量请求再次拖垮。</p>
<p>在工程实践中，熔断器模式往往应用于服务的自动降级，在实现上主要基于Netflix开源的组件Hystrix来实现。</p>
<h2 id="舱壁隔离-Bulkhead-Isolation"><a href="#舱壁隔离-Bulkhead-Isolation" class="headerlink" title="舱壁隔离(Bulkhead Isolation)"></a>舱壁隔离(Bulkhead Isolation)</h2><p>在造船行业，往往使用此类模式对船舱进行隔离，利用舱壁将不同的船舱隔离起来，这样如果一个船舱破了进水，只损失一个船舱，其它船舱可以不受影响，而借鉴造船行业的经验，这种模式也在软件行业得到使用。</p>
<p>线程隔离(Thread Isolation)就是这种模式的常见的一个场景。例如，系统A调用了ServiceB&#x2F;ServiceC&#x2F;ServiceD三个远程服务，且部署A的容器一共有120个工作线程，采用线程隔离机制，可以给对ServiceB&#x2F;ServiceC&#x2F;ServiceD的调用各分配40个线程。当ServiceB慢了，给ServiceB分配的40个线程因慢而阻塞并最终耗尽，线程隔离可以保证给ServiceC&#x2F;ServiceD分配的80个线程可以不受影响。如果没有这种隔离机制，当ServiceB慢的时候，120个工作线程会很快全部被对ServiceB的调用吃光，整个系统会全部慢下来，甚至出现系统停止响应的情况。</p>
<p>这种Case在实践中经常遇到，如某接口由于数据库慢查询，外部RPC调用超时导致整个系统的线程数过高，连接数耗尽等。我们可以使用舱壁隔离模式，为这种依赖服务调用维护一个小的线程池，当一个依赖服务由于响应慢导致线程池任务满的时候，不会影响到其他依赖服务的调用，它的缺点就是会增加线程数。</p>
<hr>
<p>转载自：<br><a href="http://tech.meituan.com/service-fault-tolerant-pattern.html">http://tech.meituan.com/service-fault-tolerant-pattern.html</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>服务降级和服务熔断</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/</url>
    <content><![CDATA[<h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>&emsp;&emsp;在微服务架构中，微服务之间的数据交互通过远程调用完成，微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，此时如果链路上某个微服务的调用响应时间过长或者不可用，那么对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，导致“雪崩效应”。<br>&emsp;&emsp;服务熔断是应对雪崩效应的一种微服务链路保护机制。例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。同样，在微服务架构中，熔断机制也是起着类似的作用。当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p>
<p>&emsp;&emsp;在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。<br>&emsp;&emsp;服务熔断解决如下问题： 1. 当所依赖的对象不稳定时，能够起到快速失败的目的；2. 快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。</p>
<span id="more"></span>
<h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>&emsp;&emsp;服务降级是指 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，就是尽可能的把系统资源让给优先级高的服务。<br>&emsp;&emsp;资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证核心功能服务的可用性，都要对某些服务降级处理。比如当双11活动时，把交易无关的服务统统降级，如查看蚂蚁深林，查看历史订单等等。</p>
<p>&emsp;&emsp;服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，可以将一些 不重要 或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。<br>&emsp;&emsp;降级的方式可以根据业务来，可以延迟服务，比如延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行 ；或者在粒度范围内关闭服务，比如关闭相关文章的推荐。</p>
<p>&emsp;&emsp;</p>
<p>&emsp;&emsp;实现服务降级需要考虑几个问题</p>
<ul>
<li>1）那些服务是核心服务，哪些服务是非核心服务</li>
<li>2）那些服务可以支持降级，那些服务不能支持降级，降级策略是什么</li>
<li>3）除服务降级之外是否存在更复杂的业务放通场景，策略是什么？</li>
</ul>
<p>&emsp;&emsp;<br>&emsp;&emsp;自动降级分类<br>&emsp;&emsp;1）超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况<br>&emsp;&emsp;2）失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况<br>&emsp;&emsp;3）故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）<br>&emsp;&emsp;4）限流降级：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。</p>
<p>&emsp;&emsp;</p>
<h3 id="服务熔断和服务降级的区别："><a href="#服务熔断和服务降级的区别：" class="headerlink" title="服务熔断和服务降级的区别："></a>服务熔断和服务降级的区别：</h3><p>&emsp;&emsp;触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；<br>&emsp;&emsp;管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）<br>&emsp;&emsp;实现方式不太一样，服务降级具有代码侵入性(由控制器完成&#x2F;或自动降级)，熔断一般称为自我熔断。</p>
<p>降级是解决系统资源不足和海量业务请求之间的矛盾<br>        在暴增的流量请求下，对一些非核心流程业务、非关键业务，进行有策略的放弃，以此来释放系统资源，保证核心<br>业务的正常运行，尽量避免这种系统资源分配的不平衡，打破二八策略，让更多的机器资源，承载主要的业务请<br>求。服务降级不是一个常态策略，而是应对非正常情况下的应急策略。服务降级的结果，通常是对一些业务请求，<br>返回一个统一的结果，可以理解为是一种FailOver快速失败的策略。一般通过配置中心配置开关实现开启降级</p>
<p>熔断模式保护的是业务系统不被外部大流量或者下游系统的异常而拖垮。<br>        如果开启了熔断，订单服务可以在下游调用出现部分异常时，调节流量请求，比如在出现10%的失败后，减少<br>50%的流量请求，如果继续出现50%的异常，则减少80%的流量请求；相应的，在检测的下游服务正常后，首<br>先恢复30%的流量，然后是50%的流量，接下来是全部流量</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/llianlianpay/article/details/79768890">https://blog.csdn.net/llianlianpay/article/details/79768890</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>聊聊微服务的服务注册与发现</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>聊起微服务的服务注册与发现，很多人立马就会脱口而出 zk、etcd、consul、eureka 这些组件，进而聊到 CAP 如何取舍，性能如何，高可用和容灾是怎么实现的。</p>
<p>在这之前，站在组件使用者的角度，我想先问这么几个问题：</p>
<ul>
<li>注册的 IP 和端口怎么确定 ？</li>
<li>实现服务治理还需要注册哪些信息     ？</li>
<li>如何进行优雅的服务注册与服务下线     ？</li>
<li>注册服务的健康检查是如何做的     ？</li>
<li>当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知 ?</li>
<li>我能方便地查看某个应用发布和订阅了哪些服务，以及所订阅的服务有哪些节点吗     ？</li>
</ul>
<p>看完这些问题后，您也许会发现，对于服务注册与发现，首先应该关注的是服务注册发现本身的功能，然后才是性能和高可用。</p>
<p>一个好的服务注册发现中间件，应该是能完整地满足服务开发和治理的基础功能，然后才是性能和高可用。如果没有想清楚前面的功能，再高的可用性和性能都是浮云。最后，安全也同样重要。</p>
<ul>
<li>服务端的性能如何     ？</li>
<li>服务发现的容灾策略是怎样的     ？</li>
<li>当我的应用和服务发现中心的网络连接出现问题时，会对我的调用产生什么影响     ？</li>
<li>服务注册中心某台机器宕机或者全部宕机时，会对我的调用产生什么影响     ？</li>
<li>服务注册和发现的链路安全吗，有没有做好权限控制     ？</li>
</ul>
<p>下面将从 服务注册、服务发现、容灾和高可用三个大方面来回答这些问题的主流做法。</p>
<p>最后会介绍一下 ANS(Alibaba Naming Service) ， ANS 综合了这些解决方案中的优点，并在 EDAS(阿里巴巴企业级分布式应用服务) 中输出，目前完全免费！</p>
 <span id="more"></span>

<h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><h2 id="IP-和端口如何确定"><a href="#IP-和端口如何确定" class="headerlink" title="IP 和端口如何确定"></a>IP 和端口如何确定</h2><p>主流的 IP 获取有这几种方法。</p>
<ul>
<li>最简单粗暴的方式，手动配置需要注册的IP。当然这种方式基本无法在生产环境使用，因为微服务基本都是支持水平扩容多机部署的，在配置中写死 IP 地址的方式无法支持一份代码水平扩容，会给运维带来极大的成本。</li>
<li>通过遍历网卡的方式去获取，找到第一个不为本地环回地址的 IP 地址。绝大多数情况下，这个方式比较好用，dubbo 等框架采用的就是这种方法。</li>
<li>在一些网络规划比较好的标准化机房中，我们还可以通过手动指定网卡名，即 interfaceName 的方式来指定使用哪一块网卡所对应的 IP 地址进行注册。</li>
<li>当上述三种方式都不能有效解决问题的时候，有一个方法就是直接与服务注册中心建立 socket 连接，然后通过socket.getLocalAddress() 这种方式来获取本机的 IP。</li>
</ul>
<p>端口的获取，没有标准化的方案。</p>
<ul>
<li>如果是 RPC 应用，启动的时候都有一个配置来指定服务监听的端口， 注册的时候直接使用配置项的端口值。</li>
<li>传统的 WEB 容器所提供的 HTTP 的应用，同样也存在一个配置文件来配置容器的监听端口，注册时候直接使用配置项的端口值。</li>
<li>特别的，在 Java 应用的 Spring Boot 框架中，可以通过 EmbeddedServletContainerInitializedEvent.     getEmbeddedServletContainer().getPort()来获取。(Spring     Boot 版本为 1.x)。</li>
</ul>
<h2 id="实现服务治理还需要注册哪些信息-？"><a href="#实现服务治理还需要注册哪些信息-？" class="headerlink" title="实现服务治理还需要注册哪些信息 ？"></a>实现服务治理还需要注册哪些信息 ？</h2><p>简单地将 IP 和 port 信息注册上去，可以满足基本的服务调用的需求，但是在业务发展到一定程度的时候，我们还会有这些需求：</p>
<ul>
<li>想知道某个 HTTP 服务是否开启了 TLS。</li>
<li>对相同服务下的不同节点设置不同的权重，进行流量调度。</li>
<li>将服务分成预发环境和生产环境，方便进行AB Test功能。</li>
<li>不同机房的服务注册时加上机房的标签，以实现同机房优先的路由规则。</li>
</ul>
<p>这些高级功能的实现，本质上是依赖于客户端调用时候的负载均衡策略和调用策略，但是如果服务元数据没有注册上来，也只能是巧妇难为无米之炊。一个良好的服务注册中心在设计最初就应该支持这些扩展字段。</p>
<h2 id="如何进行优雅的服务注册与服务下线-？"><a href="#如何进行优雅的服务注册与服务下线-？" class="headerlink" title="如何进行优雅的服务注册与服务下线 ？"></a>如何进行优雅的服务注册与服务下线 ？</h2><p><strong>优雅发布</strong></p>
<p>虽然服务注册一般发生在服务的启动阶段，但是细分的话，服务注册应该在服务已经完全启动成功，并准备对外提供服务之后才能进行注册。</p>
<ul>
<li>有些 RPC 框架自身提供了方法来判断服务是否已经启动完成，如 Thrift ，我们可以通过 Server.isServing() 来判断。</li>
<li>有一些 RPC 框架本身没有提供服务是否启动完成的方式，这时我们可以通过检测端口是否已经处于监听状态来判断。</li>
<li>而对于 HTTP 服务，服务是否启动完毕也可以通过端口是否处于监听状态来判断。</li>
<li>特别的，在 Java 应用的 Spring Boot 框架中，可以通过事件通知的形式来通知容器已经启动完毕， EmbeddedServletContainerInitializedEvent 事件来通知容器已经启动完成 (Spring Boot 版本为 1.x)。</li>
</ul>
<p><strong>优雅下线</strong></p>
<p>绝大多数的服务注册中心都提供了健康检查功能，在应用停止后会自动摘除服务所对应的节点。但是我们也不能完全依赖此功能，应用应该在停止时主动调用服务注册中心的服务下线接口。</p>
<ul>
<li>在 Java 应用中，通用的服务下线接口调用一般使用 JVM Shutdown     Hook 的方式来实现。</li>
<li>特别的，在 Java 应用中的 Spring 框架中，可以通过 Spring Bean LifeCycle 来实现应用停止时主动调用服务下线接口。</li>
<li>当然上述两种方式还不够优雅，因为不能确保不出现 kill -9 这种粗暴的停止方式，而且应用调用服务下线接口也是尝试去调用，对于网络不通等异常场景并没有做异常处理。因此，调用客户端仍应该做好负载均衡与 failover 的处理。</li>
<li>更优雅的方式，先将即将停止的应用所对应的权重调成 0，此时上游将不再调用此应用。这时候的停止应用的操作对服务订阅者完全没有影响，当然这种场景需要订阅者实现按权重的负载均衡和运维部署工具深度结合。</li>
</ul>
<h2 id="服务的健康检查是如何做的-？"><a href="#服务的健康检查是如何做的-？" class="headerlink" title="服务的健康检查是如何做的 ？"></a>服务的健康检查是如何做的 ？</h2><p>健康检查分为客户端心跳和服务端主动探测两种方式。</p>
<ul>
<li>客户端心跳</li>
<li>客户端每隔一定时间主动发送“心跳”的方式来向服务端表明自己的服务状态正常，心跳可以是 TCP 的形式，也可以是 HTTP 的形式。</li>
<li>也可以通过维持客户端和服务端的一个 socket 长连接自己实现一个客户端心跳的方式。</li>
<li>ZooKeeper 并没有主动的发送心跳，而是依赖了组件本身提供的临时节点的特性，通过 ZooKeeper 连接的 session 来维持临时节点。</li>
</ul>
<p>但是客户端心跳中，长连接的维持和客户端的主动心跳都只是表明链路上的正常，不一定是服务状态正常。</p>
<p>服务端主动调用服务进行健康检查是一个较为准确的方式，返回结果成功表明服务状态确实正常。</p>
<ul>
<li>服务端主动探测</li>
<li>服务端调用服务发布者某个 HTTP 接口来完成健康检查。</li>
<li>对于没有提供 HTTP 服务的 RPC 应用，服务端调用服务发布者的接口来完成健康检查。</li>
<li>可以通过执行某个脚本的形式来进行综合检查。</li>
</ul>
<p>服务端主动探测也存在问题。服务注册中心主动调用 RPC 服务的某个接口无法做到通用性；在很多场景下服务注册中心到服务发布者的网络是不通的，服务端无法主动发起健康检查。</p>
<p>所以如何取舍，还是需要根据实际情况来决定，根据不同的场景，选择不同的策略。</p>
<h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><h2 id="怎么找到服务发现服务端的地址？"><a href="#怎么找到服务发现服务端的地址？" class="headerlink" title="怎么找到服务发现服务端的地址？"></a>怎么找到服务发现服务端的地址？</h2><ul>
<li>在应用的配置文件中指定服务注册中心的地址，类似于 zookeeper 和 eureka。</li>
<li>指定一个地址服务器的地址，然后通过这个地址服务器来获取服务注册中心的地址，地址服务器返回的结果会随着服务注册中心的扩缩容及时更新。</li>
</ul>
<h2 id="当服务有节点退出或新的节点加入时，订阅者如何及时收到通知-？"><a href="#当服务有节点退出或新的节点加入时，订阅者如何及时收到通知-？" class="headerlink" title="当服务有节点退出或新的节点加入时，订阅者如何及时收到通知 ？"></a>当服务有节点退出或新的节点加入时，订阅者如何及时收到通知 ？</h2><p>很经典的 Push 和 Pull 问题。</p>
<p>Push 的经典实现有两种，基于 socket 长连接的 notify，典型的实现如 zookeeper；另一种为 HTTP 连接所使用 Long Polling。</p>
<p>但是基于 socket 长连接的 notify 和基于 HTTP 协议的 Long Polling 都会存在notify消息丢失的问题。</p>
<p>所以通过 Pull 的方式定时轮询也必不可少，时间间隔的选择也很关键，频率越高服务注册中心所承受的压力也越大。需要结合服务端的性能和业务的规模进行权衡。</p>
<p>还有一种方式，真实的 Push，客户端开启一个 UDP server，服务注册中心通过 UDP 的方式进行数据推送，当然这个也受限于网络的连通性。</p>
<h2 id="能方便地查看发布和订阅了哪些服务，订阅的服务有哪些节点吗-？"><a href="#能方便地查看发布和订阅了哪些服务，订阅的服务有哪些节点吗-？" class="headerlink" title="能方便地查看发布和订阅了哪些服务，订阅的服务有哪些节点吗 ？"></a>能方便地查看发布和订阅了哪些服务，订阅的服务有哪些节点吗 ？</h2><ul>
<li>一个好的产品，用户使用体验和运维体验必须是优雅的，如果查看本机发布和订阅的服务，只能通过查看日志，甚至是 jmap 的方式来获取，显然体验非常糟糕。</li>
<li>服务注册中心应该提供了丰富的接口，支持根据应用名、IP、订阅服务名、发布服务名，来进行多层次的组合查询。</li>
<li>同时，客户端的内存里，同样也应该保留服务发布与订阅的各种信息，并提供方式供人方便地查询。</li>
<li>比如在 Java 中的 Spring Boot 的应用，可以结合 actuator endpoint，通过 HTTP 的方式来提供本机服务查询功能，查询此应用发布的服务，以及订阅的服务及各服务的对应节点。</li>
</ul>
<h1 id="容灾和高可用"><a href="#容灾和高可用" class="headerlink" title="容灾和高可用"></a>容灾和高可用</h1><h2 id="性能如何"><a href="#性能如何" class="headerlink" title="性能如何"></a>性能如何</h2><p>当服务节点数越来越多时，服务注册中心的性能会成为瓶颈，这时候就需要通过水平扩容来提升服务注册中心集群的性能。</p>
<ul>
<li>对于那些采用了类 Paxos 协议的强一致性的组件，如ZooKeeper，由于每次写操作需要过半的节点确认。水平扩容不能提升整个集群的写性能，只能提升整个集群的读性能。</li>
<li>而对于采用最终一致性的组件来说，水平扩容可以同时提升整个集群的写性能和读性能。</li>
</ul>
<h2 id="客户端容灾策略"><a href="#客户端容灾策略" class="headerlink" title="客户端容灾策略"></a>客户端容灾策略</h2><ol>
<li>首先，本地内存缓存，当运行时与服务注册中心的连接丢失或服务注册中心完全宕机，仍能正常地调用服务。</li>
<li>然后，本地缓存文件，当应用与服务注册中心发生网络分区或服务注册中心完全宕机后，应用进行了重启操作，内存里没有数据，此时应用可以通过读取本地缓存文件的数据来获取到最后一次订阅到的内容。</li>
<li>最后，本地容灾文件夹。正常的情况下，容灾文件夹内是没有内容的。当服务端完全宕机且长时间不能恢复，同时服务提供者又发生了很大的变更时，可以通过在容灾文件夹内添加文件的方式来开启本地容灾。此时客户端会忽略原有的本地缓存文件，只从本地容灾文件中读取配置。</li>
</ol>
<h2 id="服务端容灾与高可用"><a href="#服务端容灾与高可用" class="headerlink" title="服务端容灾与高可用"></a>服务端容灾与高可用</h2><ul>
<li>当有新节点加入集群时，节点启动后能自动添加到地址服务器中，并通过地址服务器找到其他节点，自动从其他节点同步数据，以达到数据的最终一致性。</li>
<li>当某个节点宕机时，此服务注册中心节点的信息会自动地址服务器中摘除，客户端能及时感知到此节点已下线。</li>
</ul>
<p>服务端的无状态性保证了服务的容灾和高可用可以做的很薄。</p>
<h2 id="服务端安全是如何做的-？"><a href="#服务端安全是如何做的-？" class="headerlink" title="服务端安全是如何做的 ？"></a>服务端安全是如何做的 ？</h2><p>链路安全，对于使用 HTTP 连接的服务注册中心，保护链路安全的最好方式是使用 HTTPS。而使用 TCP 连接的服务注册中心来说，由于应用层协议一般使用的是私有协议，不一定存在现成的 TLS 支持方案。</p>
<p>在业务安全方面，应该在每一次的发布、订阅、心跳，都带上鉴权的信息就行验签和鉴权，确保业务信息的安全性。</p>
<h1 id="Alibaba-Naming-Service"><a href="#Alibaba-Naming-Service" class="headerlink" title="Alibaba Naming Service"></a>Alibaba Naming Service</h1><p>ANS (Alibaba Naming Service) 是阿里巴巴中间件团队将多年业务实践沉淀打磨的开源产品。在服务注册与发现方面，ANS 综合了上述解决方案中的优点，是最适合云原生应用的服务注册与发现组件。<br> ANS 服务已经在 EDAS(阿里巴巴企业级分布式应用服务) 上线，目前已经提供 Spring Cloud Ans Starter 方便 Spring Cloud 用户直接使用一个安全的可靠的商业版服务注册与发现功能。ANS 能完美地支持 Eureka 的特性，而且目前完全免费！更多信息参见 <a href="https://help.aliyun.com/document_detail/72618.html?spm=a2c4g.11186623.6.683.eHnWsM">EDAS 帮助文档</a>。<a href="https://help.aliyun.com/document_detail/72618.html?spm=a2c4g.11186623.6.683.eHnWsM">https://help.aliyun.com/document_detail/72618.html?spm=a2c4g.11186623.6.683.eHnWsM</a></p>
<hr>
<p>转载自：<br><a href="http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/">http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>高并发系统限流</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在高并发系统时有三把利器用来保护系统：<strong>缓存</strong>、<strong>降级</strong>和<strong>限流</strong>。</p>
<p>缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；</p>
<p>而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；</p>
<p>而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发 &#x2F; 请求量，即限流。</p>
<p>  限流的目的是通过对并发访问 &#x2F; 请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。</p>
<p>一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如 nginx 的 limit_conn 模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如 Guava 的 RateLimiter 、 nginx 的 limit_req 模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制 MQ 的消费速率。另外还可以根据网络连接数、网络流量、 CPU 或内存负载等来限流。</p>
 <span id="more"></span>

<h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><h3 id="令牌桶算法-Token-Bucket"><a href="#令牌桶算法-Token-Bucket" class="headerlink" title="令牌桶算法(Token Bucket)"></a>令牌桶算法(Token Bucket)</h3><p>令牌桶算法最初来源于计算机网络。在网络传输数据时，为了防止网络拥塞，需限制流出网络的流量，使流量以比较均匀的速度向外发送。令牌桶算法就实现了这个功能，可控制发送到网络上数据的数目，并允许突发数据的发送。 </p>
<p>令牌桶算法是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。即按恒定1&#x2F;QPS时间间隔(如果QPS&#x3D;100,则间隔是10ms)往桶里加入Token,如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务。</p>
<h3 id="漏桶算法-Leaky-Bucket"><a href="#漏桶算法-Leaky-Bucket" class="headerlink" title="漏桶算法(Leaky Bucket)"></a>漏桶算法(Leaky Bucket)</h3><p>  漏桶作为计量工具时，可以用于流量整形和流量控制，漏桶算法是一个固定容量的漏桶，按照常量固定速率流出水滴，可以以任意速率流入水滴到漏桶，如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</p>
<p>  另外有时候还使用计数器来进行限流，主要用来限制总并发数，比如数据库连接池、线程池、秒杀的并发数；只要全局总请求数或者一定时间段的总请求数设定的阀值则进行限流，是简单粗暴的总数量限流，而不是平均速率限流。</p>
<h3 id="令牌桶和漏桶对比"><a href="#令牌桶和漏桶对比" class="headerlink" title="令牌桶和漏桶对比"></a>令牌桶和漏桶对比</h3><p>令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝；</p>
<p>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿 3 个令牌， 4 个令牌），并允许一定程度突发流量；漏桶限制的是常量流出速率（即流出速率是一个固定常量值），从而平滑突发流入速率；</p>
<h2 id="应用级限流"><a href="#应用级限流" class="headerlink" title="应用级限流"></a>应用级限流</h2><h3 id="限流总并发-连接-请求数"><a href="#限流总并发-连接-请求数" class="headerlink" title="限流总并发&#x2F;连接&#x2F;请求数"></a>限流总并发&#x2F;连接&#x2F;请求数</h3><p>对于一个应用系统来说一定会有极限并发&#x2F;请求数，即总有一个 TPS&#x2F;QPS 阀值，如果超了阀值则系统就会不响应用户请求或响应的非常慢，因此最好进行过载保护，防止大量请求涌入击垮系统。</p>
<p>如果使用过 Tomcat ，其 Connector 其中一种配置有如下几个参数：</p>
<ul>
<li><p>acceptCount ：如果 Tomcat 的线程都忙于响应，新来的连接会进入队列排队，如果超出排队大小，则拒绝连接；</p>
</li>
<li><p>maxConnections ： 瞬时最大连接数，超出的会排队等待；</p>
</li>
<li><p>maxThreads ： Tomcat 能启动用来处理请求的最大线程数，如果请求处理量一直远远大于最大线程数则可能会僵死。</p>
</li>
</ul>
<h3 id="限流总资源数"><a href="#限流总资源数" class="headerlink" title="限流总资源数"></a>限流总资源数</h3><p>  如果有的资源是稀缺资源（如数据库连接、线程），而且可能有多个系统都会去使用它，那么需要限制应用；可以使用池化技术来限制总资源数：连接池、线程池。比如分配给每个应用的数据库连接是 100 ，那么本应用最多可以使用 100 个资源，超出了可以等待或者抛异常。</p>
<h3 id="限流某个接口的总并发-请求数"><a href="#限流某个接口的总并发-请求数" class="headerlink" title="限流某个接口的总并发 &#x2F; 请求数"></a>限流某个接口的总并发 &#x2F; 请求数</h3><p>  如果接口可能会有突发访问情况，但又担心访问量太大造成崩溃，如抢购业务；这个时候就需要限制这个接口的总并发 &#x2F; 请求数总请求数了；因为粒度比较细，可以为每个接口都设置相应的阀值。可以使用 Java 中的 AtomicLong 进行限流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(atomic.incrementAndGet() &gt; 限流数) &#123;</span><br><span class="line">        <span class="comment">//拒绝请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    atomic.decrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适合对业务无损的服务或者需要过载保护的服务进行限流，如抢购业务，超出了大小要么让用户排队，要么告诉用户没货了，对用户来说是可以接受的。而一些开放平台也会限制用户调用某个接口的试用请求量，也可以用这种计数器方式实现。这种方式也是简单粗暴的限流，没有平滑处理，需要根据实际情况选择使用。</p>
<h3 id="限流某个接口的时间窗请求数"><a href="#限流某个接口的时间窗请求数" class="headerlink" title="限流某个接口的时间窗请求数"></a>限流某个接口的时间窗请求数</h3><p>  即一个时间窗口内的请求数，如想限制某个接口 &#x2F; 服务每秒 &#x2F; 每分钟 &#x2F; 每天的请求数&#x2F; 调用量。如一些基础服务会被很多其他系统调用，比如商品详情页服务会调用基础商品服务调用，但是怕因为更新量比较大将基础服务打挂，这时要对每秒 &#x2F; 每分钟的调用量进行限速；一种实现方式如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LoadingCache&lt;Long, AtomicLong&gt; counter =</span><br><span class="line">        CacheBuilder.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">                .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;Long, AtomicLong&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> AtomicLong <span class="title function_">load</span><span class="params">(Long seconds)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="type">long</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//得到当前秒long currentSeconds = System.currentTimeMillis() / 1000;</span></span><br><span class="line">    <span class="keyword">if</span>(counter.get(currentSeconds).incrementAndGet() &gt; limit) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;限流了:&quot;</span>+ currentSeconds);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//业务处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Guava 的 Cache 来存储计数器，过期时间设置为 2 秒（保证 1 秒内的计数器是有的），然后获取当前时间戳然后取秒数来作为 KEY 进行计数统计和限流，这种方式也是简单粗暴，刚才说的场景够用了。</p>
<h3 id="平滑限流某个接口的请求数"><a href="#平滑限流某个接口的请求数" class="headerlink" title="平滑限流某个接口的请求数"></a>平滑限流某个接口的请求数</h3><p>之前的限流方式都不能很好地应对突发请求，即瞬间请求可能都被允许从而导致一些问题；因此在一些场景中需要对突发请求进行整形，整形为平均速率请求处理（比如 5r&#x2F;s ，则每隔 200 毫秒处理一个请求，平滑了速率）。这个时候有两种算法满足我们的场景：令牌桶和漏桶算法。 Guava 框架提供了令牌桶算法实现，可直接拿来使用。</p>
<p>Guava RateLimiter 提供了令牌桶算法实现：平滑突发限流 (SmoothBursty) 和平滑预热限流 (SmoothWarmingUp) 实现。</p>
<p>SmoothBursty</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">System.out.println(limiter.acquire());</span><br></pre></td></tr></table></figure>

<p><code>RateLimiter.create(5) </code>表示桶容量为 5 且每秒新增 5 个令牌，即每隔 200 毫秒新增一个令牌；</p>
<p><code>limiter.acquire() </code>表示消费一个令牌，如果当前桶中有足够令牌则成功（返回值为 0 ），如果桶中没有令牌则暂停一段时间，比如发令牌间隔是 200 毫秒，则等待200 毫秒后再去消费令牌，这种实现将突发请求速率平均为了固定请求速率。</p>
<p>SmoothBursty 允许一定程度的突发，会有人担心如果允许这种突发，假设突然间来了很大的流量，那么系统很可能扛不住这种突发。因此需要一种平滑速率的限流工具，从而系统冷启动后慢慢的趋于平均固定速率（即刚开始速率小一些，然后慢慢趋于设置的固定速率）。 Guava 也提供了 SmoothWarmingUp 来实现这种需求，其可以认为是漏桶算法，但是在某些特殊场景又不太一样。</p>
<p>SmoothWarmingUp 创建方式： <code>RateLimiter.create(doublepermitsPerSecond, long warmupPeriod, TimeUnit unit)</code></p>
<p>permitsPerSecond 表示每秒新增的令牌数， warmupPeriod 表示在从冷启动速率过渡到平均速率的时间间隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter. create ( <span class="number">5</span> , <span class="number">1000</span> , TimeUnit. MILLISECONDS</span><br><span class="line">);</span><br></pre></td></tr></table></figure>





<h2 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h2><p>  分布式限流最关键的是要将限流服务做成原子化，而解决方案可以使使用 redis+lua或者 nginx+lua 技术进行实现，通过这两种技术可以实现的高并发和高性能。</p>
<h2 id="接入层限流"><a href="#接入层限流" class="headerlink" title="接入层限流"></a>接入层限流</h2><p>接入层通常指请求流量的入口，该层的主要目的有：负载均衡、非法请求过滤、请求聚合、缓存、降级、限流、 A&#x2F;B 测试、服务质量监控等等。</p>
<p>对于 Nginx 接入层限流可以使用 Nginx 自带了两个模块：</p>
<p>连接数限流模块ngx_http_limit_conn_module 和漏桶算法实现的请求限流模块ngx_http_limit_req_module 。</p>
<p>还可以使用 OpenResty 提供的 Lua 限流模块 lua-resty-limit-traffic 进行更复杂的限流场景。</p>
<p>limit_conn 用来对某个 KEY 对应的总的网络连接数进行限流，可以按照如 IP 、域名维度进行限流。 </p>
<p>limit_req 用来对某个 KEY 对应的请求的平均速率进行限流，并有两种用法：平滑模式（ delay ）和允许突发模式 (nodelay) 。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/xiaomin1991222/article/details/84827800">https://blog.csdn.net/xiaomin1991222/article/details/84827800</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>做系统架构的一些原则</title>
    <url>/2024/04/05/%E7%9B%AE%E5%BD%95%E5%BE%85%E5%AE%9A/%E5%81%9A%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="原则一：关注于真正的收益而不是技术本身"><a href="#原则一：关注于真正的收益而不是技术本身" class="headerlink" title="原则一：关注于真正的收益而不是技术本身"></a>原则一：关注于真正的收益而不是技术本身</h2><p>对于软件架构来说，我觉得第一重要的是架构的收益，如果不说收益，只是为了技术而技术，而没有任何意义。对于技术收益来说，我觉得下面这几个收益是非常重要的：</p>
<ul>
<li><strong>是否可以降低技术门槛加快整个团队的开发流程</strong>。能够加快整个团队的工程流程，快速发布，是软件工程一直在解决的问题，所以，系统架构需要能够进行并行开发，并行上线和并行运维，而不会让某个团队成为瓶颈点。（注：就算拖累团队的原因是组织构架，也不妨碍我们做出并行的系统架构设计）；</li>
<li><strong>是否可以让整个系统可以运行的更稳定</strong>。要让整个系统可以运行的更为的稳定，提升整个系统的 SLA，就需要对有计划和无计划的停机做相应的解决方案；</li>
<li><strong>是否可以通过简化和自动化降低成本</strong>。最高优化的成本是人力成本，人的成本除了慢和贵，还有经常不断的 human error。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。除此之外，是时间成本，资金成本。</li>
</ul>
<p>如果一个系统架构不能在上面三个事上起到作用，那就没有意义了。</p>
<span id="more"></span>

<h2 id="原则二：以应用服务和-API-为视角，而不是以资源和技术为视角"><a href="#原则二：以应用服务和-API-为视角，而不是以资源和技术为视角" class="headerlink" title="原则二：以应用服务和 API 为视角，而不是以资源和技术为视角"></a>原则二：以应用服务和 API 为视角，而不是以资源和技术为视角</h2><p>国内很多公司都会有很多分工，基本上都会分成运维和开发，运维又会分成基础运维和应用运维，开发则会分成基础核心开发和业务开发。</p>
<p>不同的分工会导致完全不同的视角和出发点。比如，基础运维和开发的同学更多的只是关注资源的利用率和性能，而应用运维和业务开发则更多关注的是应用和服务上的东西。这两者本来相关无事，但是因为分布式架构的演进，导致有一些系统已经说不清楚是基础层的还是应用层的了，比如像服务治理上的东西，里面即有底层基础技术，也需要业务的同学来配合，包括 k8s 也样，里面即有底层的如网络这样的技术，也有需要业务配合的 readniess和 liveness 这样的健康检查，以及业务应用需要 configMap 等等 ……</p>
<p><strong>这些东西都让我感觉到所谓 DevOps，其实就是因为很多技术和组件已经分不清是 Dev 还是 Ops 的了，所以，需要合并 Dev和 Ops</strong>。而且，整个组织和架构的优化，已经不能通过调优单一分工或是单一组件能够有很大提升的了。其需要有一种自顶向下的，整体规划，统一设计的方式，才能做到整体的提升（可以试想一下城市交通的优化，当城市规模到一定程度的时候，整体的性能你是无法通过优化几条路或是几条街区来完成的，你需要对整个城市做整体的功能体的规划才可能达到整体效率的提升）。而为了做到整体的提升，需要所有的人都要有一个统一的视角和目标，这几年来，我觉得这个目标就是——<strong>要站在 服务 和 对外API 的视角来看问题，而不是技术和底层的角度。</strong></p>
<h2 id="原则三：选择最主流和成熟的技术"><a href="#原则三：选择最主流和成熟的技术" class="headerlink" title="原则三：选择最主流和成熟的技术"></a>原则三：选择最主流和成熟的技术</h2><p>技术选型是一件很重要的事，技术一旦选错，那会导致整个架构需要做调整，而对架构的调整重来都不是一件简单的事，我在过去几年内，当系统越来越复杂的时候，用户把他们的 PHP，Python, .NET，或 Node.js 的架构完全都迁移到 Java + Go 的架构上来的案例不断的发生。这个过程还是非常痛苦的，但是你没有办法，当你的系统越来越复杂，越来越大时，你就再也不能在一些玩具技术上玩了，你需要的更为工业化的技术。</p>
<ul>
<li><strong>尽可能的使用更为成熟更为工业化的技术栈，而不是自己熟悉的技术栈</strong>。 所谓工业化的技术栈，你可以看看大多数公司使用的技术栈，比如：互联网，金融，电信……等等 ，大公司会有更多的技术投入，也需要更大规模的生产，所以，他们使用的技术通常来说都是比较工业化的。在技术选型上，千万不要被——“你看某个视频公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。</li>
<li><strong>选择全球流行的技术，而不是中国流行的技术</strong>。技术这个东西一定是一个全球化的东西，不是一个局域化的事。所以，一定要选国际化的会更好。另外，千万不要被某些公司的“特别案例”骗过去了，那怕这个案例很性感，关键还是要看解决问题的思路和采用的技术是否具有普世性。只有普世性的技术有更强的生命力。</li>
<li><strong>尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改</strong>。我见过好些个公司魔改开源软件，比如有个公司同魔改mesos，最后改着改着发现自己发明另一个 kubernetes。我还见过很多公司或技术团队喜欢自己发明自己的专用轮子，最后都会被主流开源软件所取代。完全没有必要。不重新发明轮子，不魔改，不是因为自己技术不能，而是因为，这个世界早已不是自己干所有事的年代了，这个时代是要想尽方法跟整个产业，整个技术社区融合和合作，这样才会有最大的收益。那些试图因为某个特例需要自成一套的玩法，短期没问题，但长期来说，我都不看好。</li>
<li><strong>绝大多数情况下，如无非常特殊要求，选 Java基本是不会错的</strong>。一方面，这是因为 Java 的业务开发的生产力是非常好的，而且有 Spring 框架保障，代码很难写烂，另外，Java 的社区太成熟了，你需要的各种架构和技术都可以很容易获得，技术红利实在是太大。这种运行在JVM上的语言有太多太多的好处了。在 Java 的技术栈上，你的架构风险和架构的成本（无论是人力成本，时间成本和资金成本）从长期来说都是最优的</li>
</ul>
<p>在我见过的公司中，好些公司的架构都被技术负责人个人的喜好、擅长和个人经验给绑架了，完全不是从一个客观的角度来进行技术选型。其实，从 0 到 1 的阶段，你用什么样的技术都行，如果你做一个简单的应用，没有事务处理没有复杂的交易流程，比如一些论坛、社交之类的应用，你用任何语言都行。但是如果有一天你的系统变复杂了，需要处理交易了，量也上来了，从 1 到 10，甚至从 10 到 100，你的开发团队也变大了，需要构建的系统越来越大，你可能会发现你只有一个选择，就是 Java。想想京东从.NET 到 Java，淘宝从 PHP 到 Java……</p>
<p>注，一些有主观喜好的人一定会对我上述对 Java 的描述感到不适，我还用一些证据说明一下——全中国所有的电商平台，几百家银行，三大电信运营商，所有的保险公司，劵商的系统，医院里的系统，电子政府系统，等等，基本都是用 Java 开发的，包括 AWS 的主流语言也是 Java，阿里云一开始用 C++&#x2F;Python 写控制系统，后面也开始用 Java ……你可能会说 B站是用 go语言，但是你可能不知道 B 站的电商和大数据是用 Java……懂着数据分析的同学，建议上各大招聘网站上搜一下 Java 的职位数量，你就知道某个技术是否主流和热门……</p>
<h2 id="原则四：完备性会比性能更重要"><a href="#原则四：完备性会比性能更重要" class="headerlink" title="原则四：完备性会比性能更重要"></a>原则四：完备性会比性能更重要</h2><p>我发现好些公司的架构师做架构的时候，首要考虑的是架构的性能是否能够撑得住多大多大的流量，而不是考虑系统的完备性和扩展性。所以，我已经多次见过这样的案例了，一开始直接使用 MongoDB 这样的非关系型数据库，或是把数据直接放在 Redis 里，而直接放弃关系型数据库的数据完备性的模型，而在后来需要在数据上进行关系查询的时候，发现 NoSQL 的数据库在 Join 上都表现的太差，然后就开始各种飞线，为了不做 Join 就开始冗余数据，然而自己又维护不好冗余数据后带来的数据一致性的问题，导致数据上的各种错乱丢失。</p>
<p>所以，我给如下的一些如下的架构原则：</p>
<ul>
<li><strong>使用最科学严谨的技术模型为主，并以不严谨的模型作为补充</strong>。对于上面那个案例来说，就是——永远使用完备支持 ACID 的关系型数据库，然后用 NoSQL 作补充，而不是完全放弃关系型数据库。这里的原则就是所谓的“先紧后松”，一开始紧了，你可以慢慢松，但是开始松了，以后你想紧再也紧不过来了。</li>
<li><strong>性能上的东西，总是有很多解的</strong>。我这么多年的经历告诉我，性能上的事，总是有解的，手段也是最多的，这个比起架构的完备性和扩展性来说真的不必太过担心。</li>
</ul>
<p>为了追求所谓的性能，把整个系统的完备性丢失掉，相当地得不偿失。</p>
<h2 id="原则五：制定并遵循服从标准、规范和最佳实践"><a href="#原则五：制定并遵循服从标准、规范和最佳实践" class="headerlink" title="原则五：制定并遵循服从标准、规范和最佳实践"></a>原则五：制定并遵循服从标准、规范和最佳实践</h2><p>这个原则是非常重要的，因为只有服从了标准，你的架构才能够有更好的扩展性。</p>
<p>比如：我经常性的见到很多公司的系统既没有服从业界标准，也没有形成自己公司的标准，感觉就像一群乌合之众一样。最典型的例子就是 HTTP 调用的状态返回码。业内给你的标准是 200表示成功，3xx 跳转，4xx 表示调用端出错，5xx 表示服务端出错，我实在是不明白为什么无论成功和失败大家都喜欢返回 200，然后在 body 里指出是否error（前两年我在微信公众号里看到一个有一定名气的互联网老兵推荐使用无论正确还是出错都返回 200 的做法，我在后台再三确认后，我发现这样的架构师真是害人不浅）。这样做最大的问题是——监控系统将在一种低效的状态下工作。监控系统需要把所有的网络请求包打开后才知道是否是错误，而且完全不知道是调用端出错还是服务端出错，于是一些像重试或熔断这样的控制系统完全不知道怎么搞（如果是 4xx错，那么重试或熔断是没有意义的，只有 5xx 才有意义）。<strong>有时候，我会有种越活越退步的感觉，错误码设计这种最基本最基础的东西为什么会没有？并且一个公司会任由着大家乱来？这些基础技能怎么就这样丢掉了？</strong></p>
<p>还有，我还见过一些公司，他们整个组织没有一个统一的用户 ID 的设计，各个系统之间同步用户的数据是通过用户的身份证 ID，是的，就是现实世界的身份证 ID，包括在网关上设置的用户白名单居然也是用身份证 ID。我对这个公司的内的用户隐私管理有很大的担忧。一个企业，一个组织，如果没有标准和规范，也就会有抽象，这一定是要出各种乱子的。</p>
<p>下面，我罗列一些你需要注意的标准和规范（包括但不限于）：</p>
<ul>
<li><strong>服务间调用的协议标准和规范</strong>。这其中包括 Restful API路径, HTTP 方法、状态码、标准头、自定义头等，返回数据 JSon Scheme……等。</li>
<li><strong>一些命名的标准和规范</strong>。这其中包括如：用户 ID，服务名、标签名、状态名、错误码、消息、数据库……等等</li>
<li><strong>日志和监控的规范</strong>。这其中包括：日志格式，监控数据，采样要求，报警……等等</li>
<li><strong>配置上的规范</strong>。这其中包括：操作系统配置、中间件配置，软件包……等等</li>
<li><strong>中间件使用的规范</strong>。数据库，缓存、消息队列……等等</li>
<li><strong>软件和开发库版本统一</strong>。整个组织架构内，软件或开发库的版本最好每年都升一次级，然后在各团队内统一。</li>
</ul>
<p>这里重要说一下两个事：</p>
<ul>
<li><strong>Restful API 的规范</strong>。我觉得是非常重要的，这里给两个我觉得写得最好的参考：<a href="https://github.com/paypal/api-standards/blob/master/api-style-guide.md">Paypal</a> 和 <a href="https://github.com/microsoft/api-guidelines">Microsoft</a> 。Restful API 有一个标准和规范最大的好处就是监视可以很容易地做各种统计分析，控制系统可以很容易的做流量编排和调度。</li>
<li><strong>另一个是服务调用链追踪</strong>。对于服务调用链追踪来说，基本上都是参考于 <a href="https://research.google/pubs/pub36356/">Google Dapper</a> 这篇论文，目前有很多的实现，最严格的实现是 <a href="https://zipkin.io/">Zipkin</a>，这也是 Spring Cloud Sleuth 的底层实现。Zipkin 贴近 Google Dapper 论文的好处在于——无状态，快速地把 Span 发出来，不消耗服务应用侧的内存和 CPU。这意味着，监控系统宁可自己死了也不能干扰实际应用。</li>
<li><strong>软件升级</strong>。我发现很多公司包括 BAT，他们完全没有软件升级的活动，全靠开发人员自发。然而，这种成体系的活动，是永远不可能靠大众的自发形成的。一个公司至少一年要有一次软件版本升级的review，然后形成软件版本的统一和一致，这样会极太简化系统架构的复杂度。</li>
</ul>
<h2 id="原则六：重视架构扩展性和可运维性"><a href="#原则六：重视架构扩展性和可运维性" class="headerlink" title="原则六：重视架构扩展性和可运维性"></a>原则六：重视架构扩展性和可运维性</h2><p>在我见过很多架构里，技术人员只考虑当下，但从来不考虑系统的未来扩展性和可运维性。所谓的管生不管养。如果你生下来的孩子胳膊少腿，严重畸形，那么未来是很难玩的。因为架构和软件不是写好就完的，是需要不断修改不断维护的，80%的软件成本都是在维护上。所以，如何让你的架构有更好的扩展性，可以更容易地运维，这个是比较重要的。所谓的扩展性，意味着，我可以很容易地加更多的功能，或是加入更多的系统，而所谓可运维，就是说我可以对线上的系统做任意的变更。扩展性要求的是有标准规范且不耦合的业务架构，可运维性要求的则是可控的能力，也就是一组各式各样的控制系统。</p>
<ul>
<li><strong>通过服务编排架构来降低服务间的耦合</strong>。比如：通过一个业务流程的专用服务，或是像 Workflow，Event Driven Architecture ， Broker，Gateway，Service Discovery 等这类的的中间件来降低服务间的依赖关系。</li>
<li><strong>通过服务发现或服务网关来降低服务依赖所带来的运维复杂度</strong>。服务发现可以很好的降低相关依赖服务的运维复杂度，让你可以很轻松的上线或下线服务，或是进行服务伸缩。</li>
<li><strong>一定要使用各种软件设计的原则</strong>。比如：像SOLID这样的原则，IoC&#x2F;DIP，SOA 或 Spring Cloud 等 架构的最佳实践，分布式系统架构的相关实践，……等等</li>
</ul>
<h2 id="原则七：对控制逻辑进行全面收口"><a href="#原则七：对控制逻辑进行全面收口" class="headerlink" title="原则七：对控制逻辑进行全面收口"></a>原则七：对控制逻辑进行全面收口</h2><p>所有的程序都会有两种逻辑，一种是业务逻辑，一种是控制逻辑，业务逻辑就是完成业务的逻辑，控制逻辑是辅助，比如你用多线程，还是用分布式，是用数据库还是用文件，如何配置、部署，运维、监控，事务控制，服务发现，弹性伸缩，灰度发布，高并发，等等，等等 ……这些都是控制逻辑，跟业务逻辑没有一毛钱关系。控制逻辑的技术深度会通常会比业务逻辑要深一些，门槛也会要高一些，所以，最好要专业的程序员来负责控制逻辑的开发，统一规划统一管理，进行收口。这其中包括：</p>
<ul>
<li><strong>流量收口</strong>。包括南北向和东西向的流量的调度，主要通过流量网关，开发框架 SDK或 Service Mesh 这样的技术。</li>
<li><strong>服务治理收口</strong>。包括：服务发现、健康检查，配置管理、事务、事件、重试、熔断、限流……主要通过开发框架 SDK – 如：Spring Cloud，或服务网格Service Mesh等技术。</li>
<li><strong>监控数据收口</strong>。包括：日志、指标、调用链……主要通过一些标准主流的探针，再加上后台的数据清洗和数据存储来完成，最好是使用无侵入式的技术。监控的数据必须统一在一个地方进行关联，这样才会产生信息。</li>
<li><strong>资源调度有应用部署的收口</strong>。包括：计算、网络和存储的收口，主要是通过容器化的方案，如k8s来完成。</li>
<li><strong>中间件的收口</strong>。包括：数据库，消息，缓存，服务发现，网关……等等。这类的收口方式一般要在企业内部统一建立一个共享的云化的中间件资源池。</li>
</ul>
<p>对此，这里的原则是：</p>
<ul>
<li><strong>你要选择容易进行业务逻辑和控制逻辑分离的技术</strong>。这里，Java 的 JVM+字节码注入+AOP 式的Spring 开发框架，会带给你太多的优势。</li>
<li><strong>你要选择可以享受“前人种树，后人乘凉”的有技术红利的技术</strong>。如：有庞大社区而且相互兼容的技术，如：Java, Docker, Ansible，HTTP，Telegraf&#x2F;Collectd……</li>
<li><strong>中间件你要使用可以 支持HA集群和多租户的技术</strong>。这里基本上所有的主流中间件都会支持 HA 集群方式的。</li>
</ul>
<h2 id="原则八：不要迁就老旧系统的技术债务"><a href="#原则八：不要迁就老旧系统的技术债务" class="headerlink" title="原则八：不要迁就老旧系统的技术债务"></a>原则八：不要迁就老旧系统的技术债务</h2><p>我发现很多公司都很非常大的技术债务，这些债务具体表现如下：</p>
<ul>
<li><strong>使用老旧的技术</strong>。比如，使用HTTP1.0， Java 1.6，Websphere，ESB，基于 socket的通讯协议，过时的模型……等等</li>
<li><strong>不合理的设计</strong>。比如，在 gateway 中写大量的业务逻辑，单体架构，数据和业务逻辑深度耦合，错误的系统架构（把缓存当数据库，用消息队列同步数据）……等等</li>
<li><strong>缺少配套设施</strong>。比如，没有自动化测试，没有好的软件文档，没有质量好的代码，没有标准和规范……等等</li>
</ul>
<p>来找我寻求技术帮助的人都有各种各样的问题。我都会对他们苦口婆心地说同样的一句话——“<strong>如果你是来找我 case-by-case 解决问题，我兴趣不大，因为，你们千万不要寄希望能够很简单的把一辆夏利车改成一辆法拉利跑车，或是把一栋地基没打好的歪楼搞正。以前欠下的技术债，都得要还，没打好的地基要重新打，没建配套设施都要建。这些基础设施如果不按照正确科学的方式建立的话，你是不可能有一个好的的系统，我也没办法帮你 case-by-case 的解决问题……</strong>”，一开始，他们都会对我说，没问题，我们就是要还债，但是，最后发现要还的债真多，有点承受不了，就开始现原形了。</p>
<p>他们开始为自己的“欠的技术债”找各种合理化的理由——给你解释各种各样的历史原因和不得以而为之的理由。谈着谈着，让我有一种感觉——他们希望得到一种什么都不改什么都不付出的方式就可以进步的心态，他们宁可让新的技术 low 下来迁就于这些技术债，把新的技术滥用地乱七八糟的。有一个公司，他们的系统架构和技术选型基本都搞错了，使用错误的模型构建系统，导致整个系统的性能非常之差，也才几千万条数据，但他们想的不是还债，不是把地基和配套设施建好，而且要把楼修的更高，上更多的系统——他们觉得现有的系统挺好，性能问题的原因是他们没一个大数据平台，所以要建大数据平台……</p>
<p>我见过很多很多公司，包括大如 BAT 这样的公司，都会在原来的技术债上进行更多的建设，然后，技术债越来越大，利息越来越大，最终成为一个高利贷，再也还不了（我在《<a href="https://coolshell.cn/articles/11656.html">开发团队的效率</a>》一文中讲过一个 WatchDog 的架构模式，一个系统烂了，不是去改这个系统，而是在旁边建一个系统来看着它，我很难理解为什么会有这样的逻辑，也许是为了要解决更多的就业……）</p>
<p>这里有几个原则和方法我是非常坚持的，分享给大家：</p>
<ul>
<li><strong>与其花大力气迁就技术债务，不如直接还技术债。是所谓的长痛不如短痛。</strong></li>
<li><strong>建设没有技术债的“新城区”，并通过“<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer">防腐层</a> ”的架构模型，不要让技术债侵入“新城区”</strong>。</li>
</ul>
<h2 id="原则九：不要依赖自己的经验，要依赖于数据和学习"><a href="#原则九：不要依赖自己的经验，要依赖于数据和学习" class="headerlink" title="原则九：不要依赖自己的经验，要依赖于数据和学习"></a>原则九：不要依赖自己的经验，要依赖于数据和学习</h2><p>有好些人来找我跟我说他们的技术问题，然后希望我能够给他们一个答案。我说，我需要了解一下你现有系统的情况，也就是需要先做个诊断，我只有得到这些数据后，我才可能明白真正的原因是什么 ，我才可能给你做出一个比较好的技术方案。我个人觉得这是一种对对方负责的方法，因为技术手段太多了，所有的技术手段都有适应的场景，并且有各种 trade-off，所以，只有调研完后才能做出决定。这跟医生看病是一样的，确诊病因不能靠经验，还是要靠诊断数据。在科学面前，所有的经验都是靠不住的……</p>
<p>另外，如果有一天你在做技术决定的时候，开始凭自己以往的经验，那么你就已经不可能再成长了。人都是不可能通过不断重复过去而进步的，人的进步从来都是通过学习自己不知道的东西。所以，千万不要依赖于自己的经验做决定。做任何决定之前，最好花上一点时间，上网查一下相关的资料，技术博客，文章，论文等 ，同时，也看看各个公司，或是各个开源软件他们是怎么做的？然后，比较多种方案的 Pros&#x2F;Cons，最终形成自己的决定，这样，才可能做出一个更好的决定。</p>
<h2 id="原则十：千万要小心-X-–-Y-问题，要追问原始需求"><a href="#原则十：千万要小心-X-–-Y-问题，要追问原始需求" class="headerlink" title="原则十：千万要小心 X – Y 问题，要追问原始需求"></a>原则十：千万要小心 X – Y 问题，要追问原始需求</h2><p>对于 <a href="https://coolshell.cn/articles/10804.html">X-Y 问题</a>，也就是说，用户为了解决 X问题，他觉得用 Y 可以解，于是问我 Y 怎么搞，结果搞到最后，发现原来要解决的 X 问题，这个时候最好的解决方案不是 Y，而是 Z。 这种 X-Y 问题真是相当之多，见的太多太多了。所以，每次用户来找我的时候，我都要不断地追问什么是 X 问题。</p>
<p>比如，好些用户都会来问我他们要一个大数据流式处理，结果追问具体要解决什么样的问题时，才发现他们的问题是因为服务中有大量的状态，需要把相同用户的数据请求放在同一个服务上处理，而且设计上导致一个慢函数拖慢整个应用服务。最终就是做一下性能调优就好了，根本没有必要上什么大数据的流式处理。</p>
<p>我很喜欢追问为什么 ，这种追问，会让客户也跟着来一起重新思考。比如，有个客户来找我评估的一个技术架构的决定，从理论上来说，好像这个架构在用户的这个场景下非常不错。但是，这个场景和这个架构是我职业生涯从来没有见过的。于是，我开始追问这个为什么会是这么一个场景？当我追问的时候，我发现用户都感到这个场景的各种不合理。最后引起了大家非常深刻的研讨，最终用户把那个场景修正后，而架构就突然就变成了一个常见且成熟的的模型……</p>
<h2 id="原则十一：激进胜于保守，创新与实用并不冲突"><a href="#原则十一：激进胜于保守，创新与实用并不冲突" class="headerlink" title="原则十一：激进胜于保守，创新与实用并不冲突"></a>原则十一：激进胜于保守，创新与实用并不冲突</h2><p>我对技术的态度是比较激进的，但是，所谓的激进并不是瞎搞，也不是见新技术就上，而是积极拥抱会改变未来的新技术，如：Docker&#x2F;Go，我就非常快地跟进，但是像区块链或是 Rust 这样的，我就不是很积极。因为，其并没有命中我认为的技术趋势的几个特征（参看《<a href="https://coolshell.cn/articles/18190.html">Go,Docker 和新技术</a> 》）。当然，我也不是不喜欢的就不学了，我对区块链和 Rust 我一样学习，我也知道这些技术的优势，但我不会大规模使用它们。另外，我也尊重保守的决定，这里面没有对和错。但是，我个人觉得对技术激进的态度比起保守来说有太多的好处了。一方面来说，对于用户来说，很大程度上来说，新技术通常都表面有很好的竞争力，而且我见太多这样成功的公司都在积极拥抱新的技术的，而保守的通常来说都越来越不好。</p>
<p>有一些人会跟我说，我们是实用主义，我们不需要创新，能解决当下的问题就好，所以，我们不需要新技术，现有的技术用好就行了。这类的公司，他们的技术设计第一天就在负债，虽然可以解决当下问题，但是马上就会出现新的问题，然后他们会疲于解决各种问题。最后呢，最后还是会走到新的技术上。</p>
<p>这里的逻辑很简单 —— <strong>进步永远来自于探索，探索是要付出代价的，但是收益更大</strong>。对我而言，不敢冒险才是最大的冒险，不敢犯错才是最大的错误，害怕失去会让你失去的更多……</p>
<hr>
<p>转载自：<br><a href="https://coolshell.cn/articles/21672.html">https://coolshell.cn/articles/21672.html</a></p>
]]></content>
      <categories>
        <category>目录待定</category>
      </categories>
  </entry>
  <entry>
    <title>DirectByteBuffer</title>
    <url>/2024/03/05/Java/Java%E8%BF%9B%E9%98%B6/DirectByteBuffer/</url>
    <content><![CDATA[<p><strong>堆外内存</strong><br>&emsp;&emsp;堆外内存是相对于堆内内存的一个概念。堆内内存是由JVM所管控的Java进程内存，我们平时在Java中创建的对象都处于堆内内存中，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理它们的内存。那么堆外内存就是存在于JVM管控之外的一块内存区域，因此它是不受JVM的管控。<br>&emsp;&emsp;可以使用ByteBuffer等类来操纵堆外内存了，使用ByteBuffer分配本地内存则非常简单，直接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocateDirect(10 * 1024 * 1024);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以通过指定JVM参数来确定堆外内存大小限制：<code>-XX:MaxDirectMemorySize=512m</code><br>&emsp;&emsp;对于这种direct buffer内存不够的时候会抛出错误： <code>java.lang.OutOfMemoryError: Direct buffer memory</code><br>&emsp;&emsp;堆外内存泄露的问题定位通常比较麻烦，可以借助google-perftools这个工具，它可以输出不同方法申请堆外内存的数量。</p>
<p> </p>
<p>&emsp;&emsp;使用ByteBuffer堆外内存时，必须要由我们自己释放；必须先释放堆内存中的对象(引用)，才能释放堆外内存，但是我们又不能强制JVM释放堆内存。例如：<code>ByteBuffer bb = ByteBuffer.allocateDirect(1024)</code>，这段代码的执行会在堆外占用1k的内存，Java堆内只会占用一个对象的指针引用的大小，堆外的这1k的空间只有当bb对象被回收时，才会被回收，这里会发现一个明显的不对称现象，就是堆外可能占用了很多，而堆内没占用多少，导致还没触发GC，那就很容易出现Direct Memory造成物理内存耗光。<br>&emsp;&emsp;再者，假设堆内 ByteBuffer对象的引用升级到了老年代，导致这个引用会长期存在无法回收，这时堆外的内存将长期无法得到回收。</p>
 <span id="more"></span>

<p><strong>堆外内存分配</strong><br>&emsp;&emsp;堆外内存申请：<code>ByteBuffer.allocateDirect(cap);</code><br>&emsp;&emsp;进行内存申请的时候，会调用：<code>DirectByteBuffer(int cap)</code>构造函数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(int cap) &#123;                   // package-private</span><br><span class="line">     super(-1, 0, cap, cap);</span><br><span class="line">     boolean pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">     int ps = Bits.pageSize();</span><br><span class="line">     long size = Math.max(1L, (long)cap + (pa ? ps : 0));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     // 保留总分配内存(按页分配)的大小和实际内存的大小</span><br><span class="line">     Bits.reserveMemory(size, cap);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     long base = 0;</span><br><span class="line">     try &#123;</span><br><span class="line">         base = unsafe.allocateMemory(size);</span><br><span class="line">     &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">         Bits.unreserveMemory(size, cap);</span><br><span class="line">         throw x;</span><br><span class="line">     &#125;</span><br><span class="line">     unsafe.setMemory(base, size, (byte) 0);</span><br><span class="line">     if (pa &amp;&amp; (base % ps != 0)) &#123;</span><br><span class="line">         // Round up to page boundary</span><br><span class="line">         address = base + ps - (base &amp; (ps - 1));</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         address = base;</span><br><span class="line">     &#125;</span><br><span class="line">     // 构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收</span><br><span class="line">     //以实现当DirectByteBuffer被垃圾回收时，堆外内存也会被释放</span><br><span class="line">     cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</span><br><span class="line">     att = null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// These methods should be called whenever direct memory is allocated or</span><br><span class="line">// freed.  They allow the user to control the amount of direct memory</span><br><span class="line">// which a process may access.  All sizes are specified in bytes.</span><br><span class="line">static void reserveMemory(long size, int cap) &#123;</span><br><span class="line">    synchronized (Bits.class) &#123;</span><br><span class="line">        // 获取最大可以申请的对外内存大小，默认值是64MB</span><br><span class="line">        // 可以通过参数-XX:MaxDirectMemorySize=&lt;size&gt;设置这个大小</span><br><span class="line">        if (!memoryLimitSet &amp;&amp; VM.isBooted()) &#123;</span><br><span class="line">            maxMemory = VM.maxDirectMemory();</span><br><span class="line">            memoryLimitSet = true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // -XX:MaxDirectMemorySize限制的是用户申请的大小，而不考虑对齐情况</span><br><span class="line">        // 所以使用两个变量来统计：</span><br><span class="line">        //     reservedMemory：真实的目前保留的空间</span><br><span class="line">        //     totalCapacity：目前用户申请的空间</span><br><span class="line">        if (cap &lt;= maxMemory - totalCapacity) &#123;</span><br><span class="line">            reservedMemory += size;</span><br><span class="line">            totalCapacity += cap;</span><br><span class="line">            count++;</span><br><span class="line">            return;  // 如果空间足够，更新统计变量后直接返回</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果已经没有足够空间，则尝试GC</span><br><span class="line">    System.gc();</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">    &#125; catch (InterruptedException x) &#123;</span><br><span class="line">        // Restore interrupt status</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (Bits.class) &#123;</span><br><span class="line">        // GC后再次判断，如果还是没有足够空间，则抛出OOME</span><br><span class="line">        if (totalCapacity + cap &gt; maxMemory)</span><br><span class="line">            throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);</span><br><span class="line">        reservedMemory += size;</span><br><span class="line">        totalCapacity += cap;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Bits.reserveMemory用于在系统中保存总分配内存(按页分配)的大小和实际内存的大小。该方法不管是直接内存的分配还是释放都会被调用，会检查直接内存的大小。如果空间不足，会调用<code>System.gc()</code>尝试释放内存，然后再进行判断，如果还是没有足够的空间，抛出OOME。<code>System.gc()</code>会触发一个FULL GC，当然前提是没有显示的设置<code>-XX:+DisableExplicitGC</code>来禁用显式GC。<br>&emsp;&emsp;最后，DirectByteBuffer使用Cleaner机制进行空间回收。</p>
<p>&emsp;&emsp;注意，这里之所以用使用FULL GC的很重要的一个原因是：System.gc()会对新生代的老生代都会进行内存回收，这样会比较彻底地回收DirectByteBuffer对象以及它们关联的堆外内存。<br>&emsp;&emsp;sun.misc.Unsafe.allocateMemory这个函数是通过JNI调用C的malloc来申请内存；<br>申请内存时，可以通过<code>-XX:+PageAlignDirectMemory</code>指定申请的内存是否需要按页对齐，默认不对其；</p>
<p>堆外内存回收<br>&emsp;&emsp;Cleaner是PhantomReference的子类，并通过自身的next和prev字段维护的一个双向链表。PhantomReference的作用在于跟踪垃圾回收过程，并不会对对象的垃圾回收过程造成任何的影响。<br>&emsp;&emsp;所以cleaner &#x3D; Cleaner.create(this, new Deallocator(base, size, cap))用于对当前构造的DirectByteBuffer对象的垃圾回收过程进行跟踪。<br>&emsp;&emsp;当DirectByteBuffer对象从pending状态变为 enqueue状态时，会触发Cleaner的clean()，而Cleaner的clean()的方法会实现通过unsafe对堆外内存的释放。也可以直接调用directByteBuffer.cleaner().clean()来主动释放：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Cleaner.java</span><br><span class="line"> public void clean() &#123;</span><br><span class="line">     if(remove(this)) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             this.thunk.run();</span><br><span class="line">         &#125; catch (final Throwable var2) &#123;</span><br><span class="line">             AccessController.doPrivileged(new PrivilegedAction() &#123;</span><br><span class="line">                 public Void run() &#123;</span><br><span class="line">                     if(System.err != null) &#123;</span><br><span class="line">                         (new Error(&quot;Cleaner terminated abnormally&quot;, var2)).printStackTrace();</span><br><span class="line">                     &#125;</span><br><span class="line"> </span><br><span class="line">                     System.exit(1);</span><br><span class="line">                     return null;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里的thunk即DirectByteBuffer构造函数中指定的Deallocator：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class Deallocator</span><br><span class="line">    implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    private static Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"> </span><br><span class="line">    private long address;</span><br><span class="line">    private long size;</span><br><span class="line">    private int capacity;</span><br><span class="line"> </span><br><span class="line">    private Deallocator(long address, long size, int capacity) &#123;</span><br><span class="line">        assert (address != 0);</span><br><span class="line">        this.address = address;</span><br><span class="line">        this.size = size;</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (address == 0) &#123;</span><br><span class="line">            // Paranoia</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">        address = 0;</span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：sun.misc.Unsafe.freeMemory方法使用C标准库的free函数释放内存空间。</p>
<p>默认情况下，可以申请的DirectByteBuffer大小为Runtime.getRuntime().maxMemory()，而这个值等于可用的最大Java堆大小，也就是我们-Xmx参数指定的值。</p>
<p>参考：<a href="http://www.importnew.com/29817.html">http://www.importnew.com/29817.html</a></p>
<p><a href="https://blog.csdn.net/liuxiao723846/article/details/89814005">https://blog.csdn.net/liuxiao723846/article/details/89814005</a></p>
<p><a href="http://www.jianshu.com/p/007052ee3773">http://www.jianshu.com/p/007052ee3773</a></p>
<p>主动分配和回收堆外内存：</p>
<p>ByteBuffer byteBuffer &#x3D; ByteBuffer.allocateDirect();</p>
<p>((DirectBuffer)byteBuffer).cleaner().clean();</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>leaf分布式id生成-号段模式原理</title>
    <url>/2024/06/10/%E7%9B%AE%E5%BD%95%E5%BE%85%E5%AE%9A/leaf%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90-%E5%8F%B7%E6%AE%B5%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="基于mysql最简单分布式ID实现"><a href="#基于mysql最简单分布式ID实现" class="headerlink" title="基于mysql最简单分布式ID实现"></a>基于mysql最简单分布式ID实现</h2><p>mysql自带自增主键功能，我们可以建一个表，主键id设置成自增，然后需要获取id，就往该表中插入一条数据，获取一下新增id即可。<br>这种方式优点就是简单。缺点也很明显</p>
<ul>
<li>随着时间推移，表中数据越来越多，毕竟获得一个id就要插入一条数据。</li>
<li>所有获取id的都去请求这个数据库，很显然，高并发场景下单机会很乏力。</li>
</ul>
<span id="more"></span>

<h2 id="flickr分布式id解决方案"><a href="#flickr分布式id解决方案" class="headerlink" title="flickr分布式id解决方案"></a>flickr分布式id解决方案</h2><p>针对1.1基于mysql实现的分布式id各种缺点，flickr公司提出了一种基于mysql生成分布式id的解决方案。我们先看下它是怎么做的。<br>先创建一个表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `Tickets64` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL auto_increment,</span><br><span class="line">  `stub` char(1) NOT NULL default &#x27;&#x27;,</span><br><span class="line">  PRIMARY KEY  (`id`),</span><br><span class="line">  UNIQUE KEY `stub` (`stub`)</span><br><span class="line">) ENGINE=MyISAM</span><br></pre></td></tr></table></figure>

<p>该表有2个字段，id就是bigint类型的mysql自增主键，stub作业务key。每次获取分布式id的时候，根据业务id执行下面这两条sql就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPLACE INTO Tickets64 (stub) VALUES (‘a’);</span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></table></figure>

<p>第1行就是更新a这条数据的主键id，如果这个stub存在a的话，就更新一下这个id，不存在就新插入一条。</p>
<p>可以测试下，比如现在表中有这么一条数据。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240611145736.png" alt="REPLACE INTO"></p>
<p>执行： REPLACE INTO Tickets64 (stub) VALUES (‘a’);</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240611145749.png" alt="在这里插入图片描述"></p>
<p>如果这个stub存在a的话，就更新一下这个id。</p>
<p>不存在就新插入一条：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240611145811.png" alt="在这里插入图片描述"></p>
<p>第2行就是获取当前connection最新插入的id。</p>
<p>到这里，1.1方案 缺点1数据量越来越多的问题就解决了。对于缺点2，单机高并发问题，它也提出来解决方案。<br>那就是多机器部署。使用多台mysql数据库，通过设置自增步长与起始id 达到多台数据库协调生成分布式id。</p>
<p>比如使用2台mysql，分别有一张Tickets64 表。这个时候，设置表的自增主键步长是2，mysql-01表中的起始id是1 ，mysql-02表中的id起始是2。这样他们的id就错开了。不同mysql实例生成的id就是这个样子。<br>这样就完美解决了单机高并发乏力的问题。</p>
<p>但是问题又来了！！！要搞几台mysql实例来用作分布式id生成，一开始业务量小，搞多了资源浪费，搞少了后期大流量的时候，还是扛不住，到时候再想加机器，就得调整自增步长，起始id，就会非常麻烦，非常麻烦，扩展性非常差。虽然flicker解决方案存在扩展性问题，但是一般公司还是可以使用的。</p>
<h2 id="号段-mysql"><a href="#号段-mysql" class="headerlink" title="号段+mysql"></a>号段+mysql</h2><p>到这里看看leaf是怎样基于号段+mysql实现的分布式id生成的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `leaf_alloc` (</span><br><span class="line">  `biz_tag` varchar(128) COLLATE utf8_unicode_ci NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `max_id` bigint(20) NOT NULL DEFAULT &#x27;1&#x27;,</span><br><span class="line">  `step` int(11) NOT NULL,</span><br><span class="line">  `description` varchar(256) COLLATE utf8_unicode_ci DEFAULT NULL,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`biz_tag`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>biz_tag ：就是业务标识<br>max_id：既是起始id也是最大id<br>step：步长或者是段长<br>description：描述，这个不用管<br>update_time：更新时间，这个不用管</p>
</blockquote>
<p>比如说要整一个订单id生成的，这个时候插入一条数据即可。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240611150557.png" alt="在这里插入图片描述"><br>这个时候我就要生成id，leaf是这样做的：</p>
<ol>
<li><p>先去判断内存中 有没有这个biz_tag对应的atomicInteger，没有就执行这两个sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update leaf_alloc set max_id=max_id+step where biz_tag=&#x27;order&#x27;;</span><br><span class="line">select * from leaf_alloc where biz_tag=&#x27;order&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240611150618.png" alt="在这里插入图片描述"></p>
<p>可以看到，这个时候数据库中的max_id就变成了3001，同时还将 max_id 与step 查到leaf服务内存中。将max_id与step相加之前的那个值设置到一个原子类中。将现在的max_id设置到一个max变量中。</p>
</li>
<li><p>下次来获取order的分布式id，看 atomicInteger中的数值小于max 值，直接就拿atomicInteger 进行累加了。直到atomicInteger大于max ,这个时候再重复执行一次步骤1。</p>
</li>
</ol>
<p>这样大部分的生成id都是在leaf服务中完成的，只有很少请求是在数据库完成的，而且step数值越大，对mysql压力就会越小，因为都是在leaf服务中完成的自增长。而且leaf 支持集群部署，mysql行锁保证多leaf实例更新同一条数据不会出现问题，同时扩展由mysql 转向了leaf服务，保证高并发，多数leaf服务内存完成id生成，保证高性能，集群部署，保证高可用。</p>
<p>这里也存在几个问题 ：</p>
<ul>
<li>当id生成服务id号段用光了，去mysql 中申请号段慢的问题，会造成一卡一卡的感觉。</li>
<li>这种预占号段，一旦id生成服务挂了&#x2F;停了，再起来的时候，号段就丢了（毕竟是放在服务内存中的），而且是永久丢了。</li>
<li>强依赖数据库，数据库单机问题，瓶颈问题。</li>
</ul>
<p>解决：</p>
<ul>
<li>第一个问题解决方案就是 在id 生成服务中 对每个号段生成一个阈值，一旦号段使用到了这个阈值，就起个后台线程将下个号段先申请过来，这也就是双buffer 缓冲机制，不管是美团的leaf 还是滴滴的tinyid 都用了这种机制，保证高并发，高性能。<br>还有就是 增加id生成服务实例数量， 加大step ，减少申请号段次数， 你由原来一次申请1000个id 变成一次申请10000个id ，减少db交互。</li>
<li>第二个问题 号段丢了，这个说实话，也没办法，不能保证完全连续，关键完全连续也没啥用。而且号段模式只是趋势递增的。</li>
<li>第三个问题 ，如果是性能瓶颈的话，还好说，拿biz 这个字段进行分库分表。 单机问题的话，只能就是主从了。</li>
</ul>
<p><strong>总结</strong><br>leaf基于服务内存的增长，保证了高性能，基于mysql的行锁，可实现多leaf服务并发修改同一条数据场景下不会出现问题，支持集群部署，保证高并发，同时扩展由mysql转向服务本身，保证高扩展性，只能说巧妙，要说它的缺点，就是leaf服务宕机，会出现id不连续的情况，某段id丢失，集群部署获取id的时候，同一时刻会出现忽大忽小的情况，但是整体是呈现增长趋势的。</p>
<p>转载自：<br><a href="https://inetyoung.blog.csdn.net/article/details/118423254">https://inetyoung.blog.csdn.net/article/details/118423254</a><br><a href="https://inetyoung.blog.csdn.net/article/details/119935951">https://inetyoung.blog.csdn.net/article/details/119935951</a></p>
]]></content>
      <categories>
        <category>目录待定</category>
      </categories>
  </entry>
  <entry>
    <title>Java堆外内存排查</title>
    <url>/2024/03/05/Java/Java%E8%BF%9B%E9%98%B6/Java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>&emsp;&emsp;运行在docker上的一个服务，在某个版本之后，占用的内存开始增长，直到docker分配的内存上限，但是并不会OOM。使用ps查看进程使用的内存和虚拟内存 ( Linux内存管理 )。除了虚拟内存比较高达到17GB以外，实际使用的内存RSS也夸张的达到了7GB，远远超过了-Xmx的设定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root]$ ps -p 75 -o rss,vsz  </span><br><span class="line">RSS    VSZ 7152568 17485844</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><p>&emsp;&emsp;明显的，是有堆外内存的使用，了解到基础软件涉及到netty，netty会用到一些DirectByteBuffer，第一轮排查采用如下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=75.dump 75 通过分析堆内存找到DirectByteBuffer的引用和大小</span><br><span class="line">部署一个升级基础软件之前的版本，持续观察</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;结果还是出现了内存超用的问题。</p>
 <span id="more"></span>
<p>pmap<br>&emsp;&emsp;为了进一步分析问题，使用pmap查看进程的内存分配，通过RSS升序序排列。结果发现除了地址000000073c800000上分配的3GB堆以外，还有数量非常多的64M一块的内存段，还有巨量小的物理内存块映射到不同的虚拟内存段上。但到现在为止，不知道里面的内容是什么，是通过什么产生的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root]$ pmap -x 75  | sort -n -k3</span><br><span class="line">.....省略N行</span><br><span class="line">0000000040626000   55488   55484   55484 rwx--    [ anon ]</span><br><span class="line">00007fa07c000000   65536   55820   55820 rwx--    [ anon ]</span><br><span class="line">00007fa044000000   65536   55896   55896 rwx--    [ anon ]</span><br><span class="line">00007fa0c0000000   65536   56304   56304 rwx--    [ anon ]</span><br><span class="line">00007f9db8000000   65536   56360   56360 rwx--    [ anon ]</span><br><span class="line">00007fa0b8000000   65536   56836   56836 rwx--    [ anon ]</span><br><span class="line">00007fa084000000   65536   57916   57916 rwx--    [ anon ]</span><br><span class="line">00007f9ec4000000   65532   59752   59752 rwx--    [ anon ]</span><br><span class="line">00007fa008000000   65536   60012   60012 rwx--    [ anon ]</span><br><span class="line">000000073c800000 3119140 2488596 2487228 rwx--    [ anon ]</span><br><span class="line"> </span><br><span class="line">total kB        17629516 7384476 7377520</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;应用程序大量申请64M大内存块的原因是由Glibc的一个版本升级引起的，通过<code>export MALLOC_ARENA_MAX=4</code>可以解决VSZ占用过高的问题。虽然这也是一个问题，但却不是想要的，因为增长的是物理内存，而不是虚拟内存。</p>
<p>NMT<br>&emsp;&emsp;幸运的是 JDK1.8有Native Memory Tracker可以帮助定位。通过在启动参数上加入<code>-XX:NativeMemoryTracking=detail</code>就可以启用。在命令行执行jcmd可查看内存分配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#jcmd 75 VM.native_memory summary</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;虽然pmap得到的内存地址和NMT大体能对的上，但仍然有不少内存去向成谜。虽然是个好工具但问题并不能解决。</p>
<p>perf<br>&emsp;&emsp;使用 perf record -g -p 55 开启监控栈函数调用。运行一段时间后Ctrl+C结束，会生成一个文件perf.data。执行perf report -i perf.data查看报告。发现进程大量执行bzip相关函数。<br>&emsp;&emsp;进程调用了Java_java_util_zip_Inflater_inflatBytes() 申请了内存，仅有一小部分调用Deflater释放内存。与pmap内存地址相比对，确实是bzip在搞鬼。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>&emsp;&emsp;java项目搜索zip定位到代码，发现确实有相关bzip压缩解压操作，而且GZIPInputStream有个地方没有close。<br>&emsp;&emsp;GZIPInputStream使用Inflater申请堆外内存，Deflater释放内存，调用close()方法来主动释放。如果忘记关闭，Inflater对象的生命会延续到下一次GC。在此过程中，堆外内存会一直增长。<br>&emsp;&emsp;原代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public byte[] decompress ( byte[] input) throws IOException &#123;</span><br><span class="line">                ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">                IOUtils.copy(new GZIPInputStream(new ByteArrayInputStream(input)), out);</span><br><span class="line">                return out.toByteArray();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;修改后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public byte[] decompress(byte[] input) throws IOException &#123;</span><br><span class="line">       ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">       GZIPInputStream gzip = new GZIPInputStream(new ByteArrayInputStream(input));</span><br><span class="line">       IOUtils.copy(gzip, out);</span><br><span class="line">       gzip.close();</span><br><span class="line">       return out.toByteArray();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;经观察，问题解决。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/lycyingO/article/details/80854669">https://blog.csdn.net/lycyingO/article/details/80854669</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>Archetype&amp;Specification&amp;Publish-Subscribe</title>
    <url>/2015/09/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Archetype&amp;Specification&amp;Publish-Subscribe/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="Archetype"><a href="#Archetype" class="headerlink" title="Archetype"></a>Archetype</h2><p>Archetype设计模式的目的是将业务处理逻辑和具体实现分离，所以至少需要两个参与者：Decorator和Delegate，它们都实现同一个接口，Decorator负责处理业务逻辑，而Delegate负责具体的实现，在Decorator的通用业务逻辑处理过程中，会把具体实现委派给Delegate。</p>
 <span id="more"></span>

<p>假设系统中有一个记录各种事件的接口：</p>
<p>EventRecorder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventRecorder</span> &#123;</span><br><span class="line">	<span class="comment">// 记录事件的内容</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入两个抽象类来达到处理逻辑和具体实现分离的目的：</p>
<p>EventRecorderDelegate.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EventRecorderDelegate</span> <span class="keyword">implements</span> <span class="title class_">EventRecorder</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventRecorderDecorator.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">class</span> <span class="title class_">EventRecorderDecorator</span> <span class="keyword">implements</span> <span class="title class_">EventRecorder</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> EventRecorderDelegate delegate;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDelegate</span><span class="params">(EventRecorderDelegate delegate)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面是两个简单的逻辑处理（Decorator）类：</p>
<p>ComplicateEventRecorder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComplicateEventRecorder</span> <span class="keyword">extends</span> <span class="title class_">EventRecorderDecorator</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String event)</span>&#123;</span><br><span class="line">        <span class="comment">// 附加当前的日期到事件的内容中</span></span><br><span class="line">        event = System.currentTimeMillis() + event;</span><br><span class="line">        <span class="comment">// 附加当前异常信息到事件的内容中</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 附加当前的env</span></span><br><span class="line">        event = event+System.getenv();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录事件的内容</span></span><br><span class="line">        delegate.record(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SimpleEventRecorder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleEventRecorder</span> <span class="keyword">extends</span> <span class="title class_">EventRecorderDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String event)</span> &#123;</span><br><span class="line">		<span class="comment">// 附加当前的日期到事件的内容中</span></span><br><span class="line">		event = System.currentTimeMillis() + event;</span><br><span class="line">		<span class="comment">// 记录事件的内容</span></span><br><span class="line">		delegate.record(event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步都交给了EventRecorderDelegate对象，这一步就是之前所说的“具体实现”:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecordEventToDatabase</span> <span class="keyword">extends</span> <span class="title class_">EventRecorderDelegate</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String event)</span> &#123;</span><br><span class="line">		<span class="comment">// 将记录写入到数据库中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecordEventToFile</span> <span class="keyword">extends</span> <span class="title class_">EventRecorderDelegate</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String event)</span> &#123;</span><br><span class="line">		<span class="comment">// 将记录写入到文件中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面是一个生成事件记录对象的工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventRecorderFactory</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> EventRecorder <span class="title function_">create</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> flag)</span> &#123;</span><br><span class="line">		<span class="type">EventRecorderDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">EventRecorderDecorator</span> <span class="variable">decorator</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (type == <span class="number">0</span>)</span><br><span class="line">			decorator = <span class="keyword">new</span> <span class="title class_">SimpleEventRecorder</span>();</span><br><span class="line">		<span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">			decorator = <span class="keyword">new</span> <span class="title class_">ComplicateEventRecorder</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">			delegate = <span class="keyword">new</span> <span class="title class_">RecordEventToDatabase</span>();</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">			delegate = <span class="keyword">new</span> <span class="title class_">RecordEventToFile</span>();</span><br><span class="line">		<span class="comment">// 设置代理</span></span><br><span class="line">		decorator.setDelegate(delegate);</span><br><span class="line">		<span class="keyword">return</span> decorator;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从举的例子中可以看到，有2种业务处理逻辑，有2个具体实现，它们组成了4种事件记录方式。</p>
<h2 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h2><p>在一个较为复杂的业务流程中，某些条件的满足与否决定了业务逻辑的走向，可以把这些条件抽离出来，使得任意个条件以某种关系进行组合，从而灵活地对业务逻辑进行定制。另外，在查询、过滤等应用场合中，也可以预定义多个条件，使用这些条件的组合来处理查询逻辑，而不是使用逻辑判断语句来处理，那样只会让代码变得复杂。</p>
<p> 在Specification设计模式中，一个条件就是一个specification，多个specification通过串联的方式以某种逻辑关系形成一个组合式的specification。首先看一下整体的UML图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240606170453.png" alt="image-20240323232946144"></p>
<p>下面是Specification接口的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Specification</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Object params)</span>;</span><br><span class="line"></span><br><span class="line">	Specification <span class="title function_">and</span><span class="params">(Specification other)</span>;</span><br><span class="line"></span><br><span class="line">	Specification <span class="title function_">or</span><span class="params">(Specification other)</span>;</span><br><span class="line"></span><br><span class="line">	Specification <span class="title function_">not</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它定义了各个条件间可用的关系：与、或、非，这三个关系所对应方法的返回值都是Specification自身，目的是为了实现 Specification之间的串联（chaining），从而形成一个关系表达式。isSatisfiedBy就是判定方法， 参数是一个Object，支持任意类型。</p>
<p>下面来看CompositSpecification的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CompositeSpecification</span> <span class="keyword">implements</span> <span class="title class_">Specification</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Specification <span class="title function_">and</span><span class="params">(Specification other)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AndSpecification</span>(<span class="built_in">this</span>, other);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Specification <span class="title function_">not</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NotSpecification</span>(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Specification <span class="title function_">or</span><span class="params">(Specification other)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrSpecification</span>(<span class="built_in">this</span>, other);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Object params)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>它实现了Specification接口的关系判定方法，而isSatisfiedBy则仍是抽象方法，需要派生类来具体实现。下面是三个分别实现了与、或、非关系判定的派生类的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndSpecification</span> <span class="keyword">extends</span> <span class="title class_">CompositeSpecification</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Specification b;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Specification a;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AndSpecification</span><span class="params">(Specification a, Specification b)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.a = a;</span><br><span class="line">		<span class="built_in">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Object params)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a.isSatisfiedBy(params) &amp;&amp; b.isSatisfiedBy(params);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSpecification</span> <span class="keyword">extends</span> <span class="title class_">CompositeSpecification</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Specification a;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">NotSpecification</span><span class="params">(Specification a)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.a = a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Object params)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> !a.isSatisfiedBy(params);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrSpecification</span> <span class="keyword">extends</span> <span class="title class_">CompositeSpecification</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Specification b;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Specification a;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">OrSpecification</span><span class="params">(Specification a, Specification b)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.a = a;</span><br><span class="line">		<span class="built_in">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Object params)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a.isSatisfiedBy(params) || b.isSatisfiedBy(params);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这些类就构成了Specification模式的核心部分，下面来看一个例子：</p>
<p>先定义一个男人：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Men</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> married; <span class="comment">// 是否已婚</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> cars; <span class="comment">// 拥有车的数量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> houses; <span class="comment">// 拥有房子的数量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Men</span><span class="params">(String name, <span class="type">int</span> cars, <span class="type">int</span> houses, <span class="type">boolean</span> married)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.cars = cars;</span><br><span class="line">		<span class="built_in">this</span>.houses = houses;</span><br><span class="line">		<span class="built_in">this</span>.married = married;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后定义选男人的几个条件:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasCarsSpecification</span> <span class="keyword">extends</span> <span class="title class_">CompositeSpecification</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Object params)</span> &#123;</span><br><span class="line">          <span class="type">Men</span> <span class="variable">m</span> <span class="operator">=</span> (Men)params;</span><br><span class="line">          <span class="keyword">return</span> m.cars &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasHousesSpecification</span> <span class="keyword">extends</span> <span class="title class_">CompositeSpecification</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Object params)</span> &#123;</span><br><span class="line">		<span class="type">Men</span> <span class="variable">m</span> <span class="operator">=</span> (Men) params;</span><br><span class="line">		<span class="keyword">return</span> m.houses &gt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarriedSpecification</span> <span class="keyword">extends</span> <span class="title class_">CompositeSpecification</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfiedBy</span><span class="params">(Object params)</span> &#123;</span><br><span class="line">		<span class="type">Men</span> <span class="variable">m</span> <span class="operator">=</span> (Men) params;</span><br><span class="line">		<span class="keyword">return</span> m.married;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>好，下面有位女嘉宾开始选它心目中的男人了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">		Men[] candidates = &#123; <span class="keyword">new</span> <span class="title class_">Men</span>(<span class="string">&quot;李精英&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">false</span>),</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">Men</span>(<span class="string">&quot;王老五&quot;</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="literal">true</span>), <span class="keyword">new</span> <span class="title class_">Men</span>(<span class="string">&quot;赵白领&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>),</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">Men</span>(<span class="string">&quot;West_Link&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>) &#125;;</span><br><span class="line"></span><br><span class="line">		<span class="type">HasHousesSpecification</span> <span class="variable">hasHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HasHousesSpecification</span>();</span><br><span class="line">		<span class="type">HasCarsSpecification</span> <span class="variable">hasCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HasCarsSpecification</span>();</span><br><span class="line">		<span class="type">MarriedSpecification</span> <span class="variable">married</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarriedSpecification</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">Specification</span> <span class="variable">spec</span> <span class="operator">=</span> hasHouse.and(hasCar).and(married.not());</span><br><span class="line">		<span class="keyword">for</span> (Men men : candidates) &#123;</span><br><span class="line">			<span class="keyword">if</span> (spec.isSatisfiedBy(men))</span><br><span class="line">				System.out.println(men.name);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Specification spec &#x3D; hasHouse.and(hasCar).and(married.not())这行代码可以看出这位女嘉宾选择了有车并且有房的未婚男子，所以打印结果为：李精英。</p>
<h2 id="Publish-Subscribe"><a href="#Publish-Subscribe" class="headerlink" title="Publish-Subscribe"></a>Publish-Subscribe</h2><p>很多项目中都有消息分发或者事件通知机制，尤其是模块化程度高的项目。例如在办公自动化系统 中，有些子系统对于新建用户这一事件很感兴趣，权限模块希望为这个新用户设置默认的权限，报表模块希望重新生成当月的报表，诸如此类的代码都写到新建用户 的业务逻辑后面，会加大耦合度，可维护性降低，并且对于每个模块都是一个独立工程的情况，这种方式更是不可取。</p>
<p>对于简单的情形，观察者模式就适用了，如果系统中有很多地方都需要收发消息，那么它就不适用了，否则会造成类数量的膨胀，增加类的复杂性，这时候就需要一种更集中的机制，Publish- Subscribe机制是个不错的选择，它的耦合性低，各个参与者之间毫无关联。每 一个消息都有一个唯一标识，一般都用字符串来描述，比如用户管理模块中新添加了一个用户，于是它发送了一个消息：&#x2F;UserManagment&#x2F;User&#x2F;Add，消息的其他信息可以放置到一个Map中。下面是一个最简单的消息订阅接口：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageSubscriber</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRecived</span><span class="params">(String message, Map params)</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当订阅的消息发出后，MessageSubscriber的onRecived方法就会被调 用，消息相关的特定信息存储在参数params中。 一个消息可以被多个对象订阅，一个对象可以订阅多个消息，所以onRecived的第一个参数是消息的名称，如果对象订阅了多个消息，可能需要根据消息类 型来进行具体的操作。</p>
<p>下面消息发送的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessagePublisher</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> MessagePublisher singleton;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ArrayList&lt;MessageSubscriber&gt;&gt; subscribers;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">MessagePublisher</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> MessagePublisher <span class="title function_">instance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (singleton == <span class="literal">null</span>)</span><br><span class="line">			singleton = <span class="keyword">new</span> <span class="title class_">MessagePublisher</span>();</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String message, MessageSubscriber subscriber)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (subscriber == <span class="literal">null</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (subscribers == <span class="literal">null</span>)</span><br><span class="line">			subscribers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, ArrayList&lt;MessageSubscriber&gt;&gt;();</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;MessageSubscriber&gt; subscriberList = subscribers.get(message);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (subscriberList == <span class="literal">null</span>) &#123;</span><br><span class="line">			subscriberList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageSubscriber&gt;();</span><br><span class="line">			subscribers.put(message, subscriberList);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		subscriberList.add(subscriber);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(String message, Map params)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (subscribers == <span class="literal">null</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		ArrayList&lt;MessageSubscriber&gt; subscriberList = subscribers.get(message);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (subscriberList == <span class="literal">null</span> || subscriberList.isEmpty())</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (MessageSubscriber topicSubscriber : subscriberList)</span><br><span class="line">			topicSubscriber.onRecived(message, params);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>该类中主要包含两个方 法：register用来注册消息订阅者，publish用来发送消息。这样，对某个事件感兴趣的模块就可以通过MessagePublisher来订阅 这个相关的消息，而产生事件的模块就可以通过MessagePublisher将其发布出去。</p>
<p>测试示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.publishsubscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">MessagePublisher</span> <span class="variable">messagePublisher</span> <span class="operator">=</span> MessagePublisher.instance();</span><br><span class="line">		messagePublisher.register(<span class="string">&quot;/User/Add&quot;</span>, <span class="keyword">new</span> <span class="title class_">ASubscriber</span>());</span><br><span class="line">		messagePublisher.register(<span class="string">&quot;/User/Del&quot;</span>, <span class="keyword">new</span> <span class="title class_">BSubscriber</span>());</span><br><span class="line">		Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">		params.put(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;001&quot;</span>);</span><br><span class="line">		params.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">		messagePublisher.publish(<span class="string">&quot;/User/Add&quot;</span>, params);</span><br><span class="line">		messagePublisher.publish(<span class="string">&quot;/User/Del&quot;</span>, params);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ASubscriber</span> <span class="keyword">implements</span> <span class="title class_">MessageSubscriber</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRecived</span><span class="params">(String message, Map params)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;ASubscriber : message=&quot;</span> + message + <span class="string">&quot;, content = &quot;</span></span><br><span class="line">				+ params);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSubscriber</span> <span class="keyword">implements</span> <span class="title class_">MessageSubscriber</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRecived</span><span class="params">(String message, Map params)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;BSubscriber : message=&quot;</span> + message + <span class="string">&quot;, content = &quot;</span></span><br><span class="line">				+ params);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASubscriber订阅“&#x2F;User&#x2F;Add”的内容，BSubscriber订阅“&#x2F;User&#x2F;Del”的内容。当messagePublisher发布时消息时，订阅该消息的将会执行onRecived()方法。</p>
<hr>
<p>转载自：</p>
<p><a href="http://blog.csdn.net/m13666368773/article/details/7472126">http://blog.csdn.net/m13666368773/article/details/7472126</a><br><a href="http://blog.csdn.net/m13666368773/article/details/7472140">http://blog.csdn.net/m13666368773/article/details/7472140</a><br><a href="http://blog.csdn.net/m13666368773/article/details/7472157">http://blog.csdn.net/m13666368773/article/details/7472157</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Java8 Lambdas实现原理</title>
    <url>/2024/03/05/Java/Java%E8%BF%9B%E9%98%B6/Java8%20Lambdas%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Lambda表达式到底被编译成了什么，JVM会在编译时和运行时对Lambda表达式动手脚。</p>
<ul>
<li><p>编译时：Lambda 表达式会生成一个方法， 方法实现了表达式的代码逻辑；生成invokedynamic指令，调用bootstrap方法，由<code>java.lang.invoke.LambdaMetafactory.metafactory</code>方法实现。</p>
</li>
<li><p>运行时：invokedynamic指令调用metafactory方法。 它会返回一个CallSite, 此CallSite返回目标类型的一个匿名实现类， 此类关联编译时产生的方法；lambda表达式调用时会调用匿名实现类关联的方法。</p>
</li>
</ul>
 <span id="more"></span>

<p>下面来个简单的ambda表达式的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Consumer&lt;String&gt; c = s -&gt; System.out.println(s);</span><br><span class="line">		c.accept(<span class="string">&quot;hello lambda&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javap查看生成的字节码<code> javap -c -p -v Test.class</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /Test.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified Jun <span class="number">23</span>, <span class="number">2017</span>; size <span class="number">1057</span> bytes</span><br><span class="line">  MD5 checksum eab4179ef0e9aed7da4c1dd221300e1f</span><br><span class="line">  Compiled from <span class="string">&quot;Test.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">8.</span>#<span class="number">19</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = InvokeDynamic      #<span class="number">0</span>:#<span class="number">25</span>         <span class="comment">// #0:accept:()Ljava/util/function/Consumer;</span></span><br><span class="line">   ......</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: invokedynamic #<span class="number">2</span>,  <span class="number">0</span>              <span class="comment">// InvokeDynamic #0:accept:()Ljava/util/function/Consumer;</span></span><br><span class="line">         <span class="number">5</span>: astore_1</span><br><span class="line">         <span class="number">6</span>: aload_1</span><br><span class="line">         <span class="number">7</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello lambda</span></span><br><span class="line">         <span class="number">9</span>: invokeinterface #<span class="number">4</span>,  <span class="number">2</span>            <span class="comment">// InterfaceMethod java/util/function/Consumer.accept:(Ljava/lang/Object;)V</span></span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">6</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">14</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">5</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: aload_0</span><br><span class="line">         <span class="number">4</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">7</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test.java&quot;</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> #<span class="number">52</span>= #<span class="number">51</span> of #<span class="number">55</span>; <span class="comment">//Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class="line">BootstrapMethods:</span><br><span class="line">  <span class="number">0</span>: #<span class="number">21</span> invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #<span class="number">22</span> (Ljava/lang/Object;)V</span><br><span class="line">      #<span class="number">23</span> invokestatic Test.lambda$main$<span class="number">0</span>:(Ljava/lang/String;)V</span><br><span class="line">      #<span class="number">24</span> (Ljava/lang/String;)V</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第41行可以看出来，Lambda表达式体被生成一个称之为<code>lambda$main$0</code>的方法，它调用<code>System.out.println</code>输出传入的参数。在main方法中，原lambda表达式处产生了一条<code>invokedynamic #2, 0</code>，#2也就是后面的注释<code>InvokeDynamic #0:accept:()Ljava/util/function/Consumer</code>，0 是占位符号，无用。</p>
<p>每一个invokedynamic指令的实例叫做一个动态调用点(dynamic call site), 动态调用点最开始是未链接状态(unlinked:表示还未指定该调用点要调用的方法), 动态调用点依靠引导方法来链接到具体的方法。</p>
<p>引导方法是由编译器生成，在运行期当JVM第一次遇到invokedynamic指令时, 会调用引导方法来将invokedynamic指令所指定的名字(方法名,方法签名)和具体的执行代码(目标方法)链接起来，引导方法的返回值永久的决定了调用点的行为。引导方法的返回值类型是<code>java.lang.invoke.CallSite</code>，一个invokedynamic指令关联一个CallSite, 将所有的调用委托到CallSite当前的target(MethodHandle)。</p>
<p>找到<code>#2 = InvokeDynamic   #0:#25 </code>表示要执行 #0 处的指令，#0 位置即BootstrapMethods：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BootstrapMethods:</span><br><span class="line">  <span class="number">0</span>: #<span class="number">21</span> invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #<span class="number">22</span> (Ljava/lang/Object;)V</span><br><span class="line">      #<span class="number">23</span> invokestatic Test.lambda$main$<span class="number">0</span>:(Ljava/lang/String;)V</span><br><span class="line">      #<span class="number">24</span> (Ljava/lang/String;)V</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Lambda表达式具体的转换是通过<code>java.lang.invoke.LambdaMetafactory.metafactory</code>实现的， 静态参数依照lambda表达式和目标类型不同而不同。来看LambdaMetafactory.metafactory的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title function_">metafactory</span><span class="params">(MethodHandles.Lookup caller,</span></span><br><span class="line"><span class="params">                                   String invokedName,</span></span><br><span class="line"><span class="params">                                   MethodType invokedType,</span></span><br><span class="line"><span class="params">                                   MethodType samMethodType,</span></span><br><span class="line"><span class="params">                                   MethodHandle implMethod,</span></span><br><span class="line"><span class="params">                                   MethodType instantiatedMethodType)</span></span><br><span class="line">        <span class="keyword">throws</span> LambdaConversionException &#123;</span><br><span class="line">    AbstractValidatingLambdaMetafactory mf;</span><br><span class="line">    mf = <span class="keyword">new</span> <span class="title class_">InnerClassLambdaMetafactory</span>(caller, invokedType,</span><br><span class="line">                                         invokedName, samMethodType,</span><br><span class="line">                                         implMethod, instantiatedMethodType,</span><br><span class="line">                                         <span class="literal">false</span>, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);</span><br><span class="line">    mf.validateMetafactoryArgs();</span><br><span class="line">    <span class="keyword">return</span> mf.buildCallSite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    这里需要六个参数，按顺序描述如下：</p>
<ol>
<li><p>MethodHandles.Lookup caller : 代表查找上下文与调用者的访问权限, 使用invokedynamic指令时, JVM会自动自动填充这个参数</p>
</li>
<li><p>String invokedName : 要实现的方法的名字, 使用invokedynamic时, JVM自动帮我们填充(填充内容来自常量池InvokeDynamic.NameAndType.Name), 在这里JVM为我们填充为 “apply”, 即Consumer.accept方法名.</p>
</li>
<li><p>MethodType invokedType : 调用点期望的方法参数的类型和返回值的类型(方法signature). 使用invokedynamic指令时, JVM会自动自动填充这个参数(填充内容来自常量池<code>InvokeDynamic.NameAndType.Type</code>), 在这里参数为String, 返回值类型为Consumer, 表示这个调用点的目标方法的参数为String, 然后invokedynamic执行完后会返回一个即Consumer实例.</p>
</li>
<li><p>MethodType samMethodType : 函数对象将要实现的接口方法类型, 这里运行时, 值为 (Object)Object 即 Consumer.accept方法的类型(泛型信息被擦除).<code>#67 (Ljava/lang/Object;)V</code></p>
</li>
<li><p>MethodHandle implMethod : 一个直接方法句柄(DirectMethodHandle), 描述在调用时将被执行的具体实现方法 (包含适当的参数适配, 返回类型适配, 和在调用参数前附加上捕获的参数), 在这里为 <code>#70 invokestatic Lambda.lambda$0:(Ljava/lang/String;)V </code>方法的方法句柄.</p>
</li>
<li><p>MethodType instantiatedMethodType : 函数接口方法替换泛型为具体类型后的方法类型, 通常和 samMethodType 一样, 不同的情况为泛型。比如函数接口方法定义为 void accept(T t) T为泛型标识, 这个时候方法类型为(Object)Void, 在编译时T已确定, 即T由String替换, 这时samMethodType就是 (Object)Void, 而instantiatedMethodType为<code>(String)Void</code>。</p>
</li>
</ol>
<p>第4, 5, 6 三个参数来自class文件中的，如上面引导方法字节码中Method arguments后面的三个参数就是将应用于4, 5, 6的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method arguments:</span><br><span class="line">  #<span class="number">22</span> (Ljava/lang/Object;)V</span><br><span class="line">  #<span class="number">23</span> invokestatic Test.lambda$main$<span class="number">0</span>:(Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">24</span> (Ljava/lang/String;)V</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>metafactory返回的CallSite实际是由InnerClassLambdaMetafactory的buildCallSite来生成。生成之前会调用validateMetafactoryArgs方法校验目标类型(SAM)方法的参数&#x2F;和产生的方法的参数&#x2F;返回值类型是否一致。InnerClassLambdaMetafactory.buildCallSite方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CallSite <span class="title function_">buildCallSite</span><span class="params">()</span> <span class="keyword">throws</span> LambdaConversionException &#123;</span><br><span class="line">       <span class="keyword">final</span> Class&lt;?&gt; innerClass = spinInnerClass();</span><br><span class="line">       <span class="keyword">if</span> (invokedType.parameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">		..... <span class="comment">//调用构造函数初始化一个SAM的实例</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstantCallSite</span>(MethodHandles.constant(samBase, inst));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           UNSAFE.ensureClassInitialized(innerClass);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstantCallSite</span>(</span><br><span class="line">                       MethodHandles.Lookup.IMPL_LOOKUP</span><br><span class="line">                            .findStatic(innerClass, NAME_FACTORY, invokedType));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    函数spinInnerClass 构建了这个内部类，也就是生成了一<code>个Lambda$$Lambda$1/716157500 </code>这样的内部类,这个类是在运行的时候构建的，并不会保存在磁盘中，如果想看到这个构建的类，可以通过设置环境参数</p>
<p>其中spinInnerClass调用asm框架动态的产生SAM实现的内部类，这个类是在运行的时候构建的，并不会保存在磁盘中，如果想看到这个构建的类，可以通过设置环境参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;jdk.internal.lambda.dumpProxyClasses&quot;</span>,  <span class="string">&quot;.&quot;</span>);   </span><br></pre></td></tr></table></figure>

<p>会在指定的路径”.”即当前运行路径上生成这个内部类。这个实现类的的方法将会调用编译时产生的那个实现方法，即<code>lambda$main$0</code>。</p>
<p>​    现在将这个内部类生成在磁盘上，代码里加上参数后运行Test.class，在目录上会多了<code>Test$$Lambda$1.class</code>文件，<code>javap -p -v Test$$Lambda$1.class</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /Test$$Lambda$<span class="number">1.</span><span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified Jun <span class="number">23</span>, <span class="number">2017</span>; size <span class="number">392</span> bytes</span><br><span class="line">  MD5 checksum 4ab389fb5e490e8e0070d0b11a9c71b9</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test$$Lambda$1</span> <span class="keyword">implements</span> <span class="title class_">java</span>.util.function.Consumer</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_FINAL, ACC_SUPER, ACC_SYNTHETIC</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Utf8               Test$$Lambda$<span class="number">1</span></span><br><span class="line">   ……</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> Test$$Lambda$<span class="number">1</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">10</span>                 <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(java.lang.Object)</span>;</span><br><span class="line">    descriptor: (Ljava/lang/Object;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: checkcast     #<span class="number">15</span>                 <span class="comment">// class java/lang/String</span></span><br><span class="line">         <span class="number">4</span>: invokestatic  #<span class="number">21</span>                 <span class="comment">// Method Test.lambda$main$0:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">7</span>: <span class="keyword">return</span></span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      <span class="number">0</span>: #<span class="number">13</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    这个类implements实现了Consumer接口，accept方法实际上调用了<code>Test.lambda$main$0</code>静态函数，也就是表达式中的函数块。</p>
<p>如果，使用的是方法引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	Consumer&lt;String&gt; c  = System.out::println;</span><br><span class="line">	c.accept(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码是不会产生一个类似” lambda$main$0”新方法。 因为LambdaMetafactory会直接使用这个引用的方法。</p>
<p>总结</p>
<p>使用invokedynamic指令，运行时调用LambdaMetafactory.metafactory动态的生成内部类，实现了接口，内部类里的调用方法块并不是动态生成的，只是在原class里已经编译生成了一个静态的方法，内部类只需要调用该静态方法</p>
<hr>
<p>参考：<br><a href="http://colobu.com/2014/11/06/secrets-of-java-8-lambda/">http://colobu.com/2014/11/06/secrets-of-java-8-lambda/</a><br><a href="http://blog.csdn.net/raintungli/article/details/54910152">http://blog.csdn.net/raintungli/article/details/54910152</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>MemorySafeLinkedBlockingQueue</title>
    <url>/2024/03/05/Java/Java%E8%BF%9B%E9%98%B6/MemorySafeLinkedBlockingQueue/</url>
    <content><![CDATA[<p>前几天在一个开源项目的 github 里面看到这样的一个 pr：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291654875.png" alt="500efdf515ee1c0dfca67a7544aeb993.png"></p>
<p>光是看这个名字，里面有个 MemorySafe，我就有点陷进去了。我先给你看看这个东西：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291654870.png" alt="64726d0b970a92e9d5033b1c1c85a441.png"></p>
<p>这是阿里巴巴开发规范中截的图。为什么不建议使用  FixedThreadPool 和 SingleThreadPool 呢？</p>
<p>因为队列太长了，请求会堆积，请求一堆积，容易造成 OOM。前面提到的线程池用的队列，使用 LinkedBlockingQueue 是可能会导致 OOM 的。</p>
<p>如果想避免这个 OOM 就需要在初始化的时候指定一个合理的值。“合理的值”，听起来轻描淡写的四个字，但是这个值到底是多少呢，基本上说不准。</p>
<p>所以，当我看到 pr 上的 MemorySafeLinkedBlockingQueue 这个名字的时候，我就陷进去了。在 LinkedBlockingQueue 前面加上了 MemorySafe 这个限定词。表示这是一个内存安全的 LinkedBlockingQueue。</p>
 <span id="more"></span>



<h2 id="MemorySafeLBQ"><a href="#MemorySafeLBQ" class="headerlink" title="MemorySafeLBQ"></a>MemorySafeLBQ</h2><p>在这个 pr 里面我们看一下它主要是想干个什么事儿：</p>
<blockquote>
<p><a href="https://github.com/apache/dubbo/pull/10021">https://github.com/apache/dubbo/pull/10021</a></p>
</blockquote>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291654944.png" alt="d2c5091c2db4ef055a76b64cab3a28a4.png"></p>
<p>提供代码的哥们是这样描述它的功能的：</p>
<blockquote>
<p>可以完全解决因为 LinkedBlockingQueue 造成的 OOM 问题，而且不依赖 instrumentation，比 MemoryLimitedLinkedBlockingQueue 更好用。</p>
</blockquote>
<p>然后可以看到这次提交涉及到 7 个文件。</p>
<p>实际上真正核心的代码是这两个：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291654952.png" alt="c3b7a7b3b6d8a51e89326c85688c928b.png"></p>
<p>这两个类的名字太长了，所以先约定一下，在本文中，<strong>用 MemoryLimitedLBQ 来代替 MemoryLimitedLinkedBlockingQueue。用 MemorySafeLBQ 来代替MemorySafeLinkedBlockingQueue。</strong></p>
<p>可以看到，在 pr 里面它还提到了“比 MemoryLimitedLBQ 更好用”。也就是说，它是用来替代MemoryLimitedLBQ 这个类的。这个类从命名上也看得出来，也是一个 LinkedBlockingQueue，但是它的限定词是 MemoryLimited，可以限制内存的。</p>
<p>我找了一下，这个类对应的 pr 是这个：</p>
<blockquote>
<p><a href="https://github.com/apache/dubbo/pull/9722">https://github.com/apache/dubbo/pull/9722</a></p>
</blockquote>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291655177.png" alt="83e3e144a7a45ca85d700dd76ef185a6.png"></p>
<p>在这个 pr 里面，有大佬问他：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291655954.png" alt="ab41be4e9ada53e26163845e73b7ce85.png"></p>
<p>你这个新队列实现的意义或目的是什么？你能不能说出当前版本库中需要被这个队列取代的队列？这样我们才好决定是否使用这个队列。</p>
<p>也就是说他只是提交了一个新的队列，但是并没有说到应用场景是什么，导致官方不知道该不该接受这个 pr。于是，他补充了一个回复：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291655270.png" alt="2f8119d73b1280bc373d1f916d8eabfa.png"></p>
<p>就是拿的 FixedThreadPool 做的示例。在这个里面，就使用了无参的 LinkedBlockingQueue，所以会有 OOM 的风险。那么就可以使用 MemoryLimitedLBQ 来代替这个队列。比如，我可以限制这个队列可以使用的最大内存为 100M，通过限制内存的方式来达到避免 OOM 的目的。</p>
<p>MemoryLimitedLBQ 的队列，它可以限制这个队列最大可以占用的内存。然后，由于某些原因，又出现了一个叫做 MemorySafeLBQ 的队列，宣称比它更好用，所以来取代它。</p>
<p>所以，接下来我就要梳理清楚三个问题：</p>
<ul>
<li>MemoryLimitedLBQ 的实现原理是什么？</li>
<li>MemorySafeLBQ 的实现原理是什么？</li>
<li>MemorySafeLBQ 为什么比 MemoryLimitedLBQ 更好用？</li>
</ul>
<h2 id="MemoryLimitedLBQ"><a href="#MemoryLimitedLBQ" class="headerlink" title="MemoryLimitedLBQ"></a>MemoryLimitedLBQ</h2><p>别看这个玩意我是在 Dubbo 的 pr 里面看到的，但是它本质上是一个队列的实现方式。所以，完全可以脱离于框架而存在。先给看看 MemoryLimitedLBQ 这个类，它就是继承自 LinkedBlockingQueue，然后重写了它的几个核心方法。</p>
<p>只是自定义了一个 memoryLimiter 的对象，然后每个核心方法里面都操作了 memoryLimiter 对象：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291655112.png" alt="ef3a4e438f8bd35d4d926678f0a801c2.png"></p>
<p>所以真正的秘密就藏在 memoryLimiter 对象里面。</p>
<p>比如， put 方法：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291655168.png" alt="d5f09c59abc30ce53846ebc5f9b482ea.png"></p>
<p>这里面调用了 memoryLimiter 对象的 acquireInterruptibly 方法。</p>
<p>在解读 acquireInterruptibly 方法之前，先关注一下它的几个成员变量：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291655778.png" alt="49917dfbe2b33105bdff5c00c01499fd.png"></p>
<ul>
<li>memoryLimit 就是表示这个队列最大所能容纳的大小。</li>
<li>memory 是 LongAdder 类型，表示的是当前已经使用的大小。</li>
<li>acquireLock、notLimited、releaseLock、notEmpty 是锁相关的参数，从名字上可以知道，往队列里面放元素和释放队列里面的元素都需要获取对应的锁。</li>
<li>inst 这个参数是 Instrumentation 类型的。</li>
</ul>
<p>前面几个参数至少我还很眼熟的，但是这个 inst 就有点奇怪了。这玩意日常开发中基本上用不上，但是用好了，这就是个黑科技了。很多工具都是基于这个玩意来实现的，比如大名鼎鼎的 Arthas。</p>
<p>它可以更加方便的做字节码增强操作，允许我们对已经加载甚至还没有被加载的类进行修改的操作，实现类似于性能监控的功能。可以说 Instrumentation 就是 memoryLimiter 的关键点：</p>
<p>比如在 memoryLimiter 的 acquireInterruptibly 方法里面，它是这样的用的：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291655352.png" alt="f72cb536e65232796a7882ba9300f135.png"></p>
<p>看方法名称你也知道了，get 这个 object 的 size，这个 object 就是方法的入参，也就是要放入到队列里面的元素。</p>
<p>为了证明我没有乱说，我带你看看这个方法上的注释：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291655269.png" alt="fc058db325bd2b040d1ceb01e14c3be9.png"></p>
<blockquote>
<p>an implementation-specific approximation of the amount of storage consumed by the specified object</p>
</blockquote>
<p>返回指定对象所消耗的存储量的一个特定实现的近似值。</p>
<p>再说的直白点就是你传进来的这个对象，在内存里面到底占用了多长的长度，这个长度不是一个非常精确的值。</p>
<p>所以，理解了 inst.getObjectSize(e) 这行代码，我们再仔细看看 acquireInterruptibly 是怎么样的：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291655162.png" alt="4b180b7c3192f17a83aaf5e756e33ec4.png"></p>
<p>首先，两个标号为 ① 的地方，表示操作这个方法是要上锁的，整个 try 里面的方法是线程安全的。然后标号为 ② 的里面干了什么事儿？</p>
<p>就是计算 memory 这个 LongAdder 类型的 sum 值加上当前这个对象的值之后，是不是大于或者等于 memoryLimit。如果计算后的值真的超过了 memoryLimit，那么说明需要阻塞一下下了，调用 notLimited.await() 方法。</p>
<p>如果没有超过 memoryLimit，说明还能往队列里面放东西，那么就更新 memory 的值。</p>
<p>接着到了标号为 ③ 的地方。</p>
<p>来到这里，再次判断一下当前已经使用的值是否没有超过 memoryLimit，如果是的话，就调用 notLimited.signal() 方法，唤醒一下之前由于 memoryLimit 参数限制导致不能放入的对象。</p>
<p>整个逻辑非常的清晰。</p>
<p>而整个逻辑里面的核心逻辑就是调用 Instrumentation 类型的 getObjectSize 方法获得当前放入对象的一个 size，并判断当前已经使用的值加上这个 size 之后，是否大于了我们设置的最大值。</p>
<p>所以，你用脚趾头猜也能猜到了，在 release 方法里面，肯定也是计算当前对象的 size，然后再从 memory 里面减出去：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291655699.png" alt="f997242fd68beecd4b0dcf7312dfa40b.png"></p>
<p>然后，你再次审视一下这个 acquireInterruptibly 方法的 try 代码块里面的逻辑，你有没有发现什么 BUG：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291656178.png" alt="e96c7804cd42a038bdb32bb020fec6ea.png"></p>
<p>如果你没反应过来，那我再提个醒：你认真的分析一下 sum 这个局部变量是不是有点不妥？</p>
<p>你要是还没反应过来，那我直接给你上个代码。后面有一次提交，是把 sum 修改为了 memory.sum() ：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291656301.png" alt="fd8adcb4a2c4070ad6b4c29d01e4d1fc.png"></p>
<p>为什么这样改呢？</p>
<p>这个地方是个 BUG，还是个死循环的 BUG。前面代码截图中还出现了一个链接，就是说的这个 BUG：</p>
<blockquote>
<p><a href="https://github.com/apache/incubator-shenyu/pull/3335">https://github.com/apache/incubator-shenyu/pull/3335</a></p>
</blockquote>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291656947.png" alt="03e43b0ce068de7554ae0120f127671d.png"></p>
<p>另外，你可以看到链接中的项目名称是 incubator-shenyu，这是一个开源的 API 网关：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291656250.png" alt="2b3f0b224e08913bd1a6cb1091702156.png"></p>
<p><strong>本文中的 MemoryLimitedLBQ 和 MemorySafeLBQ 最先都是出自这个开源项目。</strong></p>
<h2 id="MemorySafeLBQ-1"><a href="#MemorySafeLBQ-1" class="headerlink" title="MemorySafeLBQ"></a>MemorySafeLBQ</h2><p>前面了解了 MemoryLimitedLBQ 的基本原理。接下来我带你看看 MemorySafeLBQ 这个玩意。它的源码可以通过这个链接直接获取到：</p>
<blockquote>
<p><a href="https://github.com/apache/dubbo/pull/10021/files">https://github.com/apache/dubbo/pull/10021/files</a></p>
</blockquote>
<p>也是拿出来就可以放到自己的项目跑，把文件作者修改为自己的名字的那种。让我们回到最开始的地方：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291656123.png" alt="504bb5afb6042e7ee43f1d04be30c17a.png"></p>
<p>这个 pr 里面说了，我搞 MemorySafeLBQ 出来，就是为了替代 MemoryLimitedLBQ 的，因为我比它好用，而且我还不依赖于 Instrumentation。</p>
<p>但是看了源码之后，会发现其实思路都是差不多的。只不过 MemorySafeLBQ 属于是反其道而行之。怎么个“反其道”法呢？看一下源码：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291656655.png" alt="d4d6cb2f5f9b25ccb99a9f63bbaebd18.png"></p>
<p>MemorySafeLBQ 还是继承自 LinkedBlockingQueue，只是多了一个自定义的成员变量，叫做 maxFreeMemory，初始值是 256 * 1024 * 1024。</p>
<p>maxFreeMemory，最大的剩余内存，默认是 256M。前面一节讲的 MemoryLimitedLBQ 限制的是这个队列最多能使用多少空间，是站在队列的角度。而 MemorySafeLBQ 限制的是 JVM 里面的剩余空间。比如默认就是当整个 JVM 只剩下 256M 可用内存的时候，再往队列里面加元素我就不让你加了。</p>
<p>因为整个内存都比较吃紧了，队列就不能无限制的继续添加了，从这个角度来规避了 OOM 的风险。</p>
<p>这样的一个反其道而行之。</p>
<p>另外，它说它不依赖 Instrumentation 了，那么它怎么检测内存的使用情况呢？</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291656743.png" alt="d2acbf34c6547db09661a08e8ccb0a99.png"></p>
<p>使用的是 ManagementFactory 里面的 MemoryMXBean。这个 MemoryMXBean 其实你一点也不陌生。JConsole 你用过吧？</p>
<p>所以，确实它没有使用 Instrumentation，但是它使用了 ManagementFactory。目的都是为了获取内存的运行状态。那么怎么看出来它比 MemoryLimitedLBQ 更好用呢？</p>
<p>我看了，关键方法就是这个 hasRemainedMemory，在调用 put、offer 方法之前就要先调用这个方法：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291656304.png" alt="cffada06024ce9b5e5f9d0ebcbe892cf.png"></p>
<p>而且你看 MemorySafeLBQ 只是重写了放入元素的 put、offer 方法，并不关注移除元素。</p>
<p>为什么呢？</p>
<p>因为它的设计理念是只关心添加元素时候的剩余空间大小，它甚至都不会去关注当前这个元素的大小。</p>
<p>而还记得前面讲的 MemoryLimitedLBQ 吗？它里面还计算了每个元素的大小，然后搞了一个变量来累加。</p>
<p>MemoryLimitedLBQ 的 hasRemainedMemory 方法里面也只有一行代码，其中 maxFreeMemory 是类初始化的时候就指定好了。那么关键的代码就是 MemoryLimitCalculator.maxAvailable()。</p>
<p>所以我们看看 MemoryLimitCalculator 的源码。</p>
<p>这个类的源码写的非常的简单，我全部截完都只有这么一点内容，全部加起来也就是 20 多行代码：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291656305.png" alt="818cd9c85157c97b683c27d30b43b21a.png"></p>
<p>而整个方法的核心就是我框起来的 static 代码块，里面一共有三行代码。</p>
<p>第一行是调用 refresh 方法，也就是对 maxAvilable 这个参数进行重新赋值，这个参数代表的意思是当前还可以使用的 JVM 内存。</p>
<p>第二行是注入了一个每 50ms 运行一次的定时任务。到点了，就触发一下 refresh 方法，保证 maxAvilable 参数的准实时性。</p>
<p>第三行是加入了 JVM 的 ShutdownHook，停服务的时候需要把这个定时任务给停了，达到优雅停机的目的。</p>
<p>核心逻辑就这么点。</p>
<p>从我的角度来说，确实是比 MemoryLimitedLBQ 使用起来更简单，更好用。</p>
<p>最后，再看看作者提供的 MemorySafeLBQ 测试用例，我补充了一点注释，很好理解，自己去品，不再多说：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291656451.png" alt="0667c24c7695b82cb9a005df6bb3be41.png"></p>
<h2 id="它是你的了"><a href="#它是你的了" class="headerlink" title="它是你的了"></a>它是你的了</h2><p>文章里面提到的 MemoryLimitedLBQ 和 MemorySafeLBQ，我说了，这两个玩意是完全独立于框架的，代码直接粘过来就可以用。</p>
<p>代码也没几行，不管是用 Instrumentation 还是 ManagementFactory，核心思想都是限制内存。</p>
<p>思路扩展一下，比如我们有的项目里面用 Map 来做本地缓存，就会放很多元素进去，也会有 OOM 的风险，那么通过前面说的思路，是不是就找到了一个问题的解决方案？</p>
<p>所以，思路是很重要的，掌握到了这个思路，面试的时候也能多掰扯几句嘛。</p>
<p>再比如，我看到这个玩意的时候，联想到了之前写过的线程池参数动态调整。</p>
<p>就拿 MemorySafeLBQ 这个队列来说，它里面的 maxFreeMemory 这个参数，可不可以做成动态调整的？不外乎就是把之前的队列长度可调整修改为了队列占用的内存空间可调整。一个参数的变化而已，实现方案可以直接套用。</p>
<hr>
<p>转载自：<br><a href="https://xuliugencn.blog.csdn.net/article/details/125229930?spm=1001.2014.3001.5502">https://xuliugencn.blog.csdn.net/article/details/125229930?spm=1001.2014.3001.5502</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2024/03/05/Java/Java%E8%BF%9B%E9%98%B6/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><p><code>ConcurrentSkipListMap</code>类实现了一个基于跳表（Skip List）算法的并发有序映射，在并发环境中非常有用，尤其是当需要保持键值对的排序顺序，并且多个线程可能同时读写映射时。</p>
<p>假如，有一个在线购物平台，其中有一个功能是根据商品的评分对商品进行排序，用户可以看到按评分从高到低排列的商品列表，并且这个列表需要实时更新，因为其他用户可能正在对商品进行评分。在这个场景中，可以使用ConcurrentSkipListMap来存储商品ID和对应的评分，可以将评分作为键（因为需要根据评分进行排序），将商品ID作为值，每当有新评分时，可以安全地更新映射，而不需要担心并发问题，由于ConcurrentSkipListMap支持多个线程可以同时读写映射，而不会导致数据不一致或需要额外的同步措施。</p>
<p>ConcurrentSkipListMap类实现了SortedMap接口，提供了基于跳表算法的有序键值对存储，其优点在于高效的并发访问性能，能够在多线程环境下保持良好的读写吞吐量，特别适合需要高并发的场景，此外，ConcurrentSkipListMap的插入、删除和查找操作都具有对数级别的平均时间复杂度，使得它在处理大量数据时依然能够保持较快的响应速度。</p>
<p>相较于其他数据结构，如ConcurrentHashMap，ConcurrentSkipListMap的内存占用通常更高，因为它需要维护跳表的多层结构，此外，在高并发写入的场景下，ConcurrentSkipListMap的性能可能会略逊于专门优化过的哈希表实现。</p>
<p>在技术方案选型上，如果应用程序需要维护一个有序的键值对集合，并且这个集合会被多个线程并发访问，那么ConcurrentSkipListMap是一个很好的选择。但如果对内存占用有严格要求，或者写入操作远多于读取操作，那么可能需要考虑其他更适合的数据结构。</p>
<h2 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h2><p><code>ConcurrentSkipListSet</code>类在多线程环境下，它能够轻松应对大量的插入、删除和查找操作，同时保持数据的完整性和一致性，其内部基于跳表数据结构的实现，确保了即使在处理大规模数据时，也能具有出色的性能表现。</p>
<p><code>ConcurrentSkipListSet</code>类实现了一个基于<code>SkipList</code>（跳表）算法的可排序的并发集合，<code>SkipList</code>是一种可以在对数预期时间内完成搜索、插入、删除等操作的数据结构，通过维护多个指向其他元素的“跳跃”链接来实现高效查找。</p>
<p><code>ConcurrentSkipListSet</code> 类实现了 <code>SortedSet</code> 接口，内部基于 Skip List（跳表）数据结构，并提供了高效的并发访问，这个类能够保证元素的有序性，并且允许并发修改。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p><code>ConcurrentLinkedQueue</code>类它利用无锁算法，确保在多线程环境下元素的快速入队和出队，且不会因队列满而阻塞生产者，无界设计让数据流动更自由，非常适合高并发、大数据量的处理场景，是构建响应迅速、可扩展并发系统的理想选择。</p>
<p><code>ConcurrentLinkedQueue</code>类主要用来解决在多线程环境下对队列进行安全并发访问的问题。它采用了一种不同的策略，基于无锁<code>（lock-free）</code>算法实现，通过原子操作和<code>CAS（Compare-and-Swap）</code>等机制来保证线程安全，这种策略允许多个线程同时访问队列，而不需要进行加锁和等待，从而大大提高了并发性能。</p>
<h2 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h2><p><code>ConcurrentLinkedDeque</code>类提供了线程安全的双端队列操作，支持高效的并发访问，因此在多线程环境下，可以放心地在队列的两端添加或移除元素，而不用担心数据的一致性问题。同时，它的内部实现采用了无锁算法，从而避免了传统锁带来的性能开销。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>通过方法引用获取属性名的底层逻辑是什么？</title>
    <url>/2024/06/08/Java/Java%E8%BF%9B%E9%98%B6/%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>在用MyBatis-Plus时，构造 where 条件的时候，可以直接通过方法引用的方式去指定属性名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Book&gt; qw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.eq(Book::getId, <span class="number">2</span>);</span><br><span class="line">List&lt;Book&gt; list = bookMapper.selectList(qw);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br></pre></td></tr></table></figure>

<p><code>Book::getId</code>这就是方法引用，为什么 MP 通过 <code>Book::getId</code> 就可以识别出来这里的属性名。</p>
<span id="more"></span>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>顺着 qw.eq 这个方法往下看，这个方法在执行的过程中几经辗转会来到 getColumnCache 方法中，这个方法就是解析出来属性值的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ColumnCache <span class="title function_">getColumnCache</span><span class="params">(SFunction&lt;T, ?&gt; column)</span> &#123;</span><br><span class="line">    <span class="type">LambdaMeta</span> <span class="variable">meta</span> <span class="operator">=</span> LambdaUtils.extract(column);</span><br><span class="line">    <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> PropertyNamer.methodToProperty(meta.getImplMethodName());</span><br><span class="line">    Class&lt;?&gt; instantiatedClass = meta.getInstantiatedClass();</span><br><span class="line">    tryInitCache(instantiatedClass);</span><br><span class="line">    <span class="keyword">return</span> getColumnCache(fieldName, instantiatedClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先这里先将传入的 Lambda 表达式通过 LambdaUtils.extract 方法解析出来一个 LambdaMeta 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; LambdaMeta <span class="title function_">extract</span><span class="params">(SFunction&lt;T, ?&gt; func)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. IDEA 调试模式下 lambda 表达式是一个代理</span></span><br><span class="line">    <span class="keyword">if</span> (func <span class="keyword">instanceof</span> Proxy) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IdeaProxyLambdaMeta</span>((Proxy) func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 反射读取</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> func.getClass().getDeclaredMethod(<span class="string">&quot;writeReplace&quot;</span>);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReflectLambdaMeta</span>((SerializedLambda) method.invoke(func), func.getClass().getClassLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// 3. 反射失败使用序列化的方式读取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShadowLambdaMeta</span>(com.baomidou.mybatisplus.core.toolkit.support.SerializedLambda.extract(func));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块的重点其实就在反射读取这块，这是从传入的 Lambda 中找到了一个名为 writeReplace 的方法，并且通过反射执行了这个方法，然后将执行结果封装为一个 ReflectLambdaMeta 对象返回。</p>
<p>接下来回到 getColumnCache 方法中，继续通过<br><code>String fieldName = PropertyNamer.methodToProperty(meta.getImplMethodName()); </code><br>获取到属性名称。</p>
<p>这里有一个 <code>meta.getImplMethodName()</code> 方法，这个方法的拿到的其实就是 Lambda 表达式中的方法名，也就是 getId，然后再通过 <code>PropertyNamer.methodToProperty</code> 对这个方法名进行处理，最终拿到属性名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">methodToProperty</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;is&quot;</span>)) &#123;</span><br><span class="line">        name = name.substring(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;get&quot;</span>) || name.startsWith(<span class="string">&quot;set&quot;</span>)) &#123;</span><br><span class="line">        name = name.substring(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReflectionException</span>(</span><br><span class="line">            <span class="string">&quot;Error parsing property name &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;.  Didn&#x27;t start with &#x27;is&#x27;, &#x27;get&#x27; or &#x27;set&#x27;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name.length() == <span class="number">1</span> || name.length() &gt; <span class="number">1</span> &amp;&amp; !Character.isUpperCase(name.charAt(<span class="number">1</span>))) &#123;</span><br><span class="line">        name = name.substring(<span class="number">0</span>, <span class="number">1</span>).toLowerCase(Locale.ENGLISH) + name.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解析的过程其实就是把方法名的前缀 get&#x2F;set&#x2F;is 这些去掉，然后剩余的字符串首字母小写之后返回。</p>
<p>这就是传入 <code>Book::getId</code>，最终能够拿到 id 这个名称的原因。</p>
<p>现在的问题变成了 writeReplace 方法究竟是个什么方法？</p>
<h2 id="writeReplace"><a href="#writeReplace" class="headerlink" title="writeReplace"></a>writeReplace</h2><p>这个方法其实是系统底层自动生成的。可以将 Lambda 表达式在运行时生成的字节码保存下来，然后进行反编译，这样就能够看到 writeReplace 方法了。如果需要将 Lambda 运行时生成的字节码保存，需要在启动参数中添加如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Djdk.internal.lambda.dumpProxyClasses=/Users/sang/workspace/code/mp_demo/lambda/</span><br></pre></td></tr></table></figure>

<p>等于号后面的部分是指定生成的字节码的保存位置，大家可以根据自己的实际情况去配置。</p>
<p>以本文一开头的 Lambda 表达式为例，最终生成的字节码反编译之后，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MpDemo02ApplicationTests$$Lambda$1164</span> <span class="keyword">implements</span> <span class="title class_">SFunction</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MpDemo02ApplicationTests$$Lambda$<span class="number">1164</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Book)var1).getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title function_">writeReplace</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SerializedLambda</span>(MpDemo02ApplicationTests.class, <span class="string">&quot;com/baomidou/mybatisplus/core/toolkit/support/SFunction&quot;</span>, <span class="string">&quot;apply&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>, <span class="number">5</span>, <span class="string">&quot;org/javaboy/mp_demo02/model/Book&quot;</span>, <span class="string">&quot;getId&quot;</span>, <span class="string">&quot;()Ljava/lang/Integer;&quot;</span>, <span class="string">&quot;(Lorg/javaboy/mp_demo02/model/Book;)Ljava/lang/Object;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，apply 方法实际上是重写的接口的方法，在这个方法中将传入的对象强转为 Book 类型，然后调用其 getId 方法。</p>
<p>反编译之后多了一个 writeReplace 方法，这个方法的返回值是一个 SerializedLambda，这个 SerializedLambda 对象其实就是对 Lambda 表达式的描述。基本上每个参数都能做到见名知意，这里说一下第七个参数，值是 getId，这个参数的变量名是 implMethodName，这就是 Lambda 表达式中给出来的变量名。这也是第一小节中，<code>meta.getImplMethodName()</code> 所获取到的值。</p>
<p>这下就清楚了，为什么写了<code>Book::getId</code>就能拿到属性名了。</p>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><p>在 <code>qw.eq(Book::getId, 2);</code> 方法中，第一个参数是一个 SFunction 的实例，那直接给一个 SFunction 的实例，不用 Lambda。注意，这种写法不对！</p>
<p>原因在于经过前面的源码分析之后，MP 中根据 <code>Book::getId</code> 去获取属性名称，一个关键点是利用 Lambda 在执行的时候生成的字节码去获取，如果没有用 Lambda，那也就不会生成所谓的 Lambda 字节码，也就不存在 writeReplace 方法，按照前文所分析的源码，就无法获取到属性名称。</p>
<p>那不用方法引用行不行？像下面这样写行不行？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Book&gt; qw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">qw.eq(b -&gt; b.getId(), <span class="number">2</span>);</span><br><span class="line">List&lt;Book&gt; list = bookMapper.selectList(qw);</span><br><span class="line">System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br></pre></td></tr></table></figure>

<p>这也是一个 Lambda，但是如果这样写了，运行之后就会报错。为什么呢？来看下这个 Lambda 生成的字节码反编译之后是什么样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MpDemo02ApplicationTests$$Lambda$1164</span> <span class="keyword">implements</span> <span class="title class_">SFunction</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MpDemo02ApplicationTests$$Lambda$<span class="number">1164</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MpDemo02ApplicationTests.lambda$test18$3fed5817$<span class="number">1</span>((Book)var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title function_">writeReplace</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SerializedLambda</span>(MpDemo02ApplicationTests.class, <span class="string">&quot;com/baomidou/mybatisplus/core/toolkit/support/SFunction&quot;</span>, <span class="string">&quot;apply&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>, <span class="number">6</span>, <span class="string">&quot;org/javaboy/mp_demo02/MpDemo02ApplicationTests&quot;</span>, <span class="string">&quot;lambda$test18$3fed5817$1&quot;</span>, <span class="string">&quot;(Lorg/javaboy/mp_demo02/model/Book;)Ljava/lang/Object;&quot;</span>, <span class="string">&quot;(Lorg/javaboy/mp_demo02/model/Book;)Ljava/lang/Object;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先 apply 方法生成的就不一样，apply 里边调用了 <code>MpDemo02ApplicationTests.lambda$test18$3fed5817$1</code> 方法，传入了 Book 对象作为参数。这个方法内容相当于就是 <code>return book.getId();</code>。<br>然后在 writeReplace 方法中，返回 SerializedLambda 对象的时候，implMethodName 的值就是 lambda$test18$3fed5817$1 了。回到本文一开始的源码分析中，会发现这样的方法名就无法提取出来想要的属性名。所以这种写法也不对。</p>
<p>从这里大家也可以看到，类似于<code>b -&gt; b.getId()</code>这样的 Lambda，和方法引用 <code>Book::getId</code> 在底层是不同的。</p>
<p>再举个例子，比如下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; out1 = System.out::println;</span><br><span class="line">        out1.accept(<span class="string">&quot;javaboy&quot;</span>);</span><br><span class="line">        Consumer&lt;String&gt; out2 = s -&gt; System.out.println(s);</span><br><span class="line">        out2.accept(<span class="string">&quot;江南一点雨&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个输出，第一个是一个方法引用，第二个则是一个常规的 Lambda 表达式。这两个执行起来效果是一致的，但是底层原理不同。</p>
<p>先来看第一个底层生成的 Lambda 字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01$$Lambda$14</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PrintStream arg$<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Demo01$$Lambda$<span class="number">14</span>(PrintStream var1) &#123;</span><br><span class="line">        <span class="built_in">this</span>.arg$<span class="number">1</span> = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arg$<span class="number">1.</span>println((String)var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里把 System.out 的值 PrintStream 作为构造函数的参数传进来赋值给 arg$1 变量，当调用 accept 方法的时候，再调用 arg$1.println 方法将字符串输出。</p>
<p>对于第二个底层生成的 Lambda 字节码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01$$Lambda$16</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Demo01$$Lambda$<span class="number">16</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        Demo01.lambda$main$<span class="number">0</span>((String)var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里有一个新的 lambda$main$0 方法，这个方法的底层逻辑其实就是我们自定义 Lambda 的时候写的<code>System.out.println(s)</code>。</p>
<hr>
<p>转载自：<a href="https://wangsong.blog.csdn.net/article/details/137512589">https://wangsong.blog.csdn.net/article/details/137512589</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/HashMap/</url>
    <content><![CDATA[<p>Map是映射表，基本思想是键-值(对)关联，可以使用键来查找值。一般常见的Map有HashMap,LinkedHashMap,TreeMap,WeakHashMap,ConcurrentHashMap,IdentityHashMap。</p>
<ul>
<li><p>HashMap不多说，最常见，非线程安全的。</p>
</li>
<li><p>LinkedHashMap取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序。只比HashMap慢一点；而在迭代访问时反应更快，因为它使用的链表维护内部次序。</p>
</li>
<li><p>TreeMap基于红黑树的实现。查看“键”或“键值对”时，它们会被排序(次序由Comparable或者Comparator决定)。</p>
</li>
<li><p>WeakHashMap弱键(weak key)映射，允许释放映射所指向的对象。如果映射之外没有引用指向某个“键”，则此“键”对应的值可以被垃圾回收器回收。</p>
</li>
<li><p>ConcurrentHashMap一种线程安全的Map。</p>
</li>
<li><p>IdentityHashMap使用&#x3D;&#x3D;代替equals()对“键”进行比较的散列映射。意思是key在逻辑上可以相等，但是物理地址不能相等。</p>
</li>
</ul>
 <span id="more"></span>

<p>要对Map更深入的理解，下面代码有助于理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> Object[][] pairs;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyMap</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">		pairs = <span class="keyword">new</span> <span class="title class_">Object</span>[length][<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (index &gt;= pairs.length) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		pairs[index++] = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; key, value &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (key.equals(pairs[i][<span class="number">0</span>])) &#123;</span><br><span class="line">				<span class="keyword">return</span> (V) pairs[i][<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>但实际上，HashMap的实现不那么简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认初始化大小16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>; <span class="comment">// 默认加载因子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount; <span class="comment">// 修改次数</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HashMap的桶是用数组来定的<code>Node&lt;K,V&gt;[] table</code>，但是是根据key进行hash来确定index，即是哪个桶table[index]。每个桶内的元素是<code>Node&lt;K,V&gt;</code>，用链表来存储。也就是说如果由于hash值一样，在桶内是一个链表来存储key-value。</p>
<p>来看put源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​       首先看table是否初始化过，之后根据hash值定位到对应的Node[]中位置，如果该位置的值不存在，直接加入新节点。如果该位置的值存在，说明该位置对应的节点有多个，则分情况讨论：1.该位置的第一个节点即要追寻的目标节点；2.该位置的节点已经退化为了红黑树（链节点的个数超过8个）；3.该位置还是单链，向后遍历寻找目标节点。</p>
<p>​	注意，这里就会存在数据覆盖的线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>​        具体原因：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第1行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</p>
<p>​        除此之外，还有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">++modCount;</span><br></pre></td></tr></table></figure>

<p>​        还是线程A、B，这两个线程同时进行put操作时，假设当前HashMap的zise大小为10，当线程A执行到这行代码时，从主内存中获得size的值为10后准备进行+1操作，但是由于时间片耗尽只好让出CPU，线程B快乐的拿到CPU还是从主内存中拿到size的值10进行+1操作，完成了put操作并将size&#x3D;11写回主内存，然后线程A再次拿到CPU并继续执行(此时size的值仍为10)，当执行完put操作后，还是将size&#x3D;11写回内存，此时，线程A、B都执行了一次put操作，但是size的值只增加了1，所有说还是由于数据覆盖又导致了线程不安全。</p>
<p>​	HashMap的扩容机制resize()是比较关键的地方，一般resize()方法的调用是在这些情况：1. table第一次初始化；2. table容量不够，size &gt; threshold；3. 当tab.length &lt; 64, 而Hash冲突过多，linked nodes退化为tree。HashMap使用数组存储元素的，Java里的数组是无法自动扩容的，因此扩容方法是使用一个新的数组代替已有的容量小的数组。</p>
<p>​        JDK1.8中也有了改进，解决了JDK1.7中高并发时resize时的死循环（HashMap也不是针对高并发场合的）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​       扩容时使用的是2次幂的扩展，即长度扩为原来2倍，所以经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。例如：oldCap是10…00, 而newCap是oldCap的2倍，e.Hash &amp; oldCap&#x3D;&#x3D;0的话，e.Hash &amp; (oldCap-1)与e.hash &amp; (newCap -1)的值是一样。</p>
<p>​        在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看e.hash &amp; (newCap -1)的值是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。还有一点，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，这也是死循环的原因所在。而JDK1.8则不会倒置。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>ASM</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/ASM/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/lijingyao8206/article/details/46430403">https://blog.csdn.net/lijingyao8206/article/details/46430403</a><br><a href="https://blog.csdn.net/lijingyao8206/article/details/46483815">https://blog.csdn.net/lijingyao8206/article/details/46483815</a><br><a href="https://blog.csdn.net/lijingyao8206/article/details/46715409">https://blog.csdn.net/lijingyao8206/article/details/46715409</a></p>
<p>ASM是一个提供字节码解析和操作的框架。可以用于解析和生成字节码。</p>
<p>解析<br>要解析的类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Programmer &#123;</span><br><span class="line"></span><br><span class="line">    public void code() &#123;</span><br><span class="line">        System.out.println(&quot;I&#x27;m a Programmer,Just Coding.....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ClassPrintVisitor 类继承自ClassVisitor类来打印解析类的类名，父类名以及“is”开头的属性和方法。 </p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClassPrintVisitor extends ClassVisitor &#123;</span><br><span class="line"></span><br><span class="line">    public ClassPrintVisitor() &#123;</span><br><span class="line">        super(Opcodes.ASM7);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void visit(int version, int access, String name,</span><br><span class="line">            String signature, String superName, String[] interfaces) &#123;</span><br><span class="line">        System.out.println(name + &quot; extends &quot; + superName + &quot; &#123;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public FieldVisitor visitField(int access, String name, String desc,</span><br><span class="line">            String signature, Object value) &#123;</span><br><span class="line">        if (name.startsWith(&quot;name&quot;)) &#123;</span><br><span class="line">            System.out.println(&quot; field: &quot; + name + &quot; &quot; + desc);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MethodVisitor visitMethod(int access, String name,</span><br><span class="line">            String desc, String signature, String[] exceptions) &#123;</span><br><span class="line">        System.out.println(&quot; method: &quot; + name + &quot; &quot; + desc);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void visitEnd() &#123;</span><br><span class="line">        System.out.println(&quot;&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是测试类ClassesPrintTest 。将一个ClassPrintVisitor 对象传给ClassReader。ClassReader作为一个解析事件的producer 并且由ClassPrintVisitor去消费（处理打印逻辑）。accept()方法就将Task 字节码进行解析，然后调用ClassPrintVisitor 的方法。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void visit() throws Exception &#123;</span><br><span class="line">    ClassReader cr = new ClassReader(&quot;com.zero.jdk_cglib.asm.Programmer&quot;);</span><br><span class="line">    cr.accept(new ClassPrintVisitor(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com/zero/jdk_cglib/asm/Programmer extends java/lang/Object &#123;</span><br><span class="line"> field: name Ljava/lang/String;</span><br><span class="line"> method: &lt;init&gt; ()V</span><br><span class="line"> method: code ()V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AsmGenerator &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class clazz = new ClassLoader() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">                byte[] b = classBytes();</span><br><span class="line">                return defineClass(name, b, 0, b.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.findClass(null);</span><br><span class="line"></span><br><span class="line">        //测试加载是否成功，打印class 对象的名称</span><br><span class="line">        System.out.println(clazz.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        //实例化一个Programmer对象</span><br><span class="line">        Object o = clazz.newInstance();</span><br><span class="line">        clazz.getMethod(&quot;code&quot;, null).invoke(o, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static byte[] classBytes() &#123;</span><br><span class="line">        ClassWriter classWriter = new ClassWriter(0);</span><br><span class="line">        // 通过visit方法确定类的头部信息</span><br><span class="line">        classWriter.visit(Opcodes.V1_8,// java版本</span><br><span class="line">                Opcodes.ACC_PUBLIC,// 类修饰符</span><br><span class="line">                &quot;Programmer&quot;, // 类的全限定名</span><br><span class="line">                null, &quot;java/lang/Object&quot;, null);</span><br><span class="line"></span><br><span class="line">        //创建构造函数</span><br><span class="line">        MethodVisitor mv = classWriter.visitMethod(Opcodes.ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);</span><br><span class="line">        mv.visitCode();</span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, 0);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">        mv.visitInsn(Opcodes.RETURN);</span><br><span class="line">        mv.visitMaxs(1, 1);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line"></span><br><span class="line">        // 定义code方法</span><br><span class="line">        MethodVisitor methodVisitor = classWriter.visitMethod(Opcodes.ACC_PUBLIC, &quot;code&quot;, &quot;()V&quot;,</span><br><span class="line">                null, null);</span><br><span class="line">        methodVisitor.visitCode();</span><br><span class="line">        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;,</span><br><span class="line">                &quot;Ljava/io/PrintStream;&quot;);</span><br><span class="line">        methodVisitor.visitLdcInsn(&quot;I&#x27;m a Programmer,Just Coding.....&quot;);</span><br><span class="line">        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;,</span><br><span class="line">                &quot;(Ljava/lang/String;)V&quot;);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.RETURN);</span><br><span class="line">        methodVisitor.visitMaxs(2, 2);</span><br><span class="line">        methodVisitor.visitEnd();</span><br><span class="line">        classWriter.visitEnd();</span><br><span class="line">        // 使classWriter类已经完成</span><br><span class="line">        // 将classWriter转换成字节数组写到文件里面去</span><br><span class="line">        byte[] data = classWriter.toByteArray();</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * public class Programmer &#123;</span><br><span class="line">     *     public void code() &#123;</span><br><span class="line">     *         System.out.println(&quot;I&#x27;m a Programmer,Just Coding.....&quot;);</span><br><span class="line">     *     &#125;</span><br><span class="line">     * &#125;</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>   ASM的Core API 中给我们提供了一些工具类，都在 org.objectweb.asm.util包中。有TraceClassVisitor、CheckClassAdapter、ASMifier、Type等。通过这些工具类，能更方便实现我们的动态生成字节码逻辑。这里就简述一下TraceClassVisitor 。</p>
<p>   TraceClassVisitor 顾名思义，我们可以“trace”也就是打印一些信息，这些信息就是ClassWriter 提供给我们的byte字节数组。因为我们阅读一个二进制字节流还是比较难以理解和解析一个类文件的结构。TraceClassVisitor通过初始化一个classWriter 和一个Printer对象，来实现打印我们需要的字节流信息。通过TraceClassVisitor 我们能更好地比较两个类文件，更轻松得分析class的数据结构。</p>
<p>  下面看个例子，我们用TraceClassVisitor 来打印Task 类信息。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>Java Parser介绍</title>
    <url>/2024/07/06/Java/Java%E6%8F%90%E9%AB%98/Java%20Parser%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Java-Parser基本信息"><a href="#Java-Parser基本信息" class="headerlink" title="Java Parser基本信息"></a>Java Parser基本信息</h1><p>JavaParser是一个Java库，用于将Java源代码解析为抽象语法树（AST），在AST基础上进行类型推断<strong>分析</strong>，支持修改AST从而生成新的Java文件内容（<strong>解析</strong>、<strong>修改</strong>和<strong>生成</strong> Java 代码）。官网：<a href="https://javaparser.org/">https://javaparser.org</a></p>
<p>通过使用JavaParser，你可以执行以下任务：</p>
<ul>
<li>分析Java源代码并获取详细信息。</li>
<li>修改现有的Java代码，并生成新的Java源代码。</li>
<li>自动化代码转换和重构任务。</li>
<li>构建静态代码分析工具。</li>
</ul>
<p>JavaParser的特点</p>
<ul>
<li>基于ANTLR 4的高性能解析器。ANTLR 4是一个流行的词法分析器和语法分析器生成器，用于构建语言、工具和服务。</li>
<li>完全符合Java语法规则。JavaParser遵循最新的Java语言规范，支持Java 8至17的所有版本。</li>
<li>简洁易用的API。JavaParser提供了清晰、直观的API，使您可以轻松地在Java代码上工作。</li>
<li>广泛的生态系统。JavaParser与其他流行的技术（如Junit、Mockito和Checkstyle）兼容，拥有丰富的生态系统。</li>
<li>开源免费。JavaParser是根据Apache 2.0许可证发布的，可以自由使用和扩展。</li>
</ul>
<span id="more"></span>



<h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><p>JavaParser 的主要构成由以下几个组件组成：</p>
<ol>
<li><p><strong>Lexer（词法分析器）</strong>：词法分析器的作用是读取源代码文本，并将其分解成一系列的词法单元（tokens），如关键字、标识符、字面量、运算符等。这是解析过程的第一步。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240701165316.png" alt="img"><br>通常不需要显式调用，JavaParser将具体的细节实现隐藏在内部，调用方只需要使用api即可完成源码到AST的转换。具体可以翻阅<code>com.github.javaparser.GeneratedJavaParser</code></p>
</li>
<li><p><strong>Parser（语法解析器）</strong>：语法分析器接收词法分析器生成的tokens，并根据Java语言的语法规则将它们组合成各种语法结构，如表达式、语句、类定义等。这个过程构建出一个抽象语法树（AST）。<code>com.github.javaparser.JavaParser</code> 这是最常用的类。</p>
</li>
<li><p><strong>AST（抽象语法树</strong>）：AST 是 JavaParser 的核心数据结构，它以层次化的方式表示了源代码的结构。AST 由一系列的节点组成，每个节点表示源代码中的一个元素，如类、方法、字段、表达式等。每个节点都包含有关该元素的信息，例如名称、类型、修饰符等。</p>
<p>AST是后续操作（如遍历、分析、修改）的基础，也是使用方操作最频繁的类。<code>com.github.javaparser.ast.CompilationUnit</code>是一个非常重要的类，它代表了Java源代码文件的根节点，是这个结构的抽象表示，包含整个文件的结构，例如：</p>
<blockquote>
<ul>
<li><p>包声明（Package Declaration）</p>
</li>
<li><p>导入声明（Imports）</p>
</li>
<li><p>类型声明（Type Declarations），这可能是类、接口、枚举或注解</p>
</li>
<li><p>注释（Comments）</p>
</li>
<li><p>任何顶级的注解</p>
</li>
</ul>
</blockquote>
<p>通过操作CompilationUnit提供的公有方法，可以访问和修改文件中的元素。包括：</p>
<blockquote>
<ul>
<li><p>获取和设置包声明</p>
</li>
<li><p>获取和添加导入声明</p>
</li>
<li><p>获取和添加类型声明</p>
</li>
<li><p>获取和添加注释</p>
</li>
<li><p>使用访问者模式来遍历AST中的节点</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240701165741.png" alt="img"></p>
<ol start="4">
<li><p><strong>Visitors（访问器）</strong>：顾名思义，这是一个采用访问者模式设计的组件，可以用于遍历和操作 AST 。开发者可以编写自定义的 Visitors，通过遍历 AST 来访问特定类型的节点，执行代码分析、重构、生成等任务。	<code>com.github.javaparser.ast.visitor.GenericVisitor</code>和<code>com.github.javaparser.ast.visitor.VoidVisitor</code>这两个访问器提供了默认实现，如果需要自定义访问器，可以继承它们来实现自己的业务逻辑。</p>
</li>
<li><p><strong>Printer（打印器）</strong>：Printer 用于将 AST 转换回 Java 源代码的字符串表示形式。它可以将修改后的 AST 打印回原始源代码文件，或将 AST 打印为格式化的代码字符串。</p>
</li>
</ol>
<h1 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h1><h2 id="CompilationUnit"><a href="#CompilationUnit" class="headerlink" title="CompilationUnit"></a>CompilationUnit</h2><p>Javaparser解析java代码后会生成AST(abstract syntax tree，抽象语法树)，CompilationUnit（编译单元）是每个java文件被解析后直接生成的对象，是读取和操作java文件的入口。CompilationUnit包含了整棵AST的Node，可以理解为AST的根节点。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141044912.png" alt="在这里插入图片描述"></p>
<p>上图根据代码画出了CompilationUnit的结构中包含了三个子节点，一个package申明，一个import申明，一个类定义。上图并没有完整的描述整个语法树，绿色三角形的部分被省略了，下图展示了省略的MethodDeclatation部分：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240709152343.png" alt="img"></p>
<p>通过其四个节点，我们可看出其返回类型是void，方法名是main，方法参数是String args，以及其方法体：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240709152410.png" alt="img"></p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>AST的Node，对于java中的类、接口、注解、方法、入参、赋值语句、注释、if条件、注释等都是一种Node，如果Node表示的代码块能继续细化分割，就在其子节点列表NodeList中，Node是读取和操作AST的基本单元。</p>
<p>Node的部分子类：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240701170159.png" alt="在这里插入图片描述"></p>
<p>这些Node类和其表示的java代码（每个类的注释中有，官方文档附录B中有全部的Node类及其示例）</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240701170212.png" alt="在这里插入图片描述"></p>
<h2 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h2><p>Javaparser使用访问者模式来访问或修改Node，当需要修改Node时，Node本身不需要额外增加方法，而是通过创建一个Visitor，在Visitor中定义好需要修改什么，用Node调用方法接收我们创建的Visitor完成修改。</p>
<h3 id="Visitable和两类Visitor接口"><a href="#Visitable和两类Visitor接口" class="headerlink" title="Visitable和两类Visitor接口"></a>Visitable和两类Visitor接口</h3><p>为了实现这种模式，作者设计了两类接口，一个是Visitable，一个是Visitor（根据有无返回值，分为GenericVisitor和VoidVisitor）。</p>
<p>（1）所有可访问的Node都实现了Visitable接口，这个接口有两个accept方法，用于接收Visitor以及外部参数arg，外部参数可用于收集遍历到的东西。</p>
<p>（2）所有Node实现Visitable接口的方法都是传递自身实例和外部arg。</p>
<p>（3）针对不同类型Node，实现GenericVisitor接口中对应的方法就能访问这种类型的Node。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240701170348.png" alt="在这里插入图片描述"></p>
<p>也就是说我们用Node实例调用它的accept方法，传入一个编写好的Visitor，Visitor中的实现方法就能访问这个Node。</p>
<h3 id="VoidVisitorAdapter"><a href="#VoidVisitorAdapter" class="headerlink" title="VoidVisitorAdapter"></a>VoidVisitorAdapter</h3><p>当我们只需要访问java代码而不需要做修改时，直接继承VoidVisitorAdapter。这个抽象类对VoidVisitor做了默认实现，通过递归执行accept方法来达到遍历整个AST的目的。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240701170415.png" alt="在这里插入图片描述"></p>
<p>上图中对CompilationUnit的import（引包）、module（java高版本模块）、package（所属包）、type（定义的类型class、interface、enum、annotation）、comment（注释）分别遍历执行accept，而其中的每一种Node又会遍历子节点执行accept。</p>
<p>例如下图访问class和interface的ClassOrInterfaceDeclaration的方法，分别遍历它涵盖的节点。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240701170452.png" alt="在这里插入图片描述"></p>
<h3 id="ModifierVisitor"><a href="#ModifierVisitor" class="headerlink" title="ModifierVisitor"></a>ModifierVisitor</h3><p>与VoidVisitorAdapter不同的是，ModifierVisitor继承带返回值的GenericVisitor，其返回值用于返回修改后的节点。如下图所示，遍历各项子节点以后，将返回值作为修改后的对象重新赋值。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240701170524.png" alt="在这里插入图片描述"></p>
<hr>
<p>参考：<br><a href="https://cloud.tencent.com/developer/news/740798">https://cloud.tencent.com/developer/news/740798</a><br><a href="https://blog.csdn.net/gitblog_00089/article/details/136705307">https://blog.csdn.net/gitblog_00089/article/details/136705307</a><br><a href="https://blog.csdn.net/qq_40800602/article/details/134446052">https://blog.csdn.net/qq_40800602/article/details/134446052</a><br><a href="https://blog.csdn.net/JDDTechTalk/article/details/136053986">https://blog.csdn.net/JDDTechTalk/article/details/136053986</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>Java8下的ConcurrentHashMap新操作</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/Java8%E4%B8%8B%E7%9A%84ConcurrentHashMap%E6%96%B0%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="更新值"><a href="#更新值" class="headerlink" title="更新值"></a>更新值</h1><p>在Java7时，对ConcurrentHashMap进行线程安全的更新操作需要使用循环来处理（可以参见<a href="http://blog.csdn.net/zero__007/article/details/49833819%EF%BC%89%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8Java8%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9A%84%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95%E3%80%82">http://blog.csdn.net/zero__007/article/details/49833819），但是在Java8中提供了更方便的原子更新方法。</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">compute</span><span class="params">(K key, BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span></span><br><span class="line">  </span><br><span class="line">  对于指定key做remappingFunction函数调用，remappingFunction函数返回值即为新的value，如果返回值为<span class="literal">null</span>，则从map中删除对应的key。compute返回key更新后的值（remappingFunction函数返回值）</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="built_in">super</span> K, ? extends V&gt; mappingFunction)</span></span><br><span class="line"></span><br><span class="line">  如果指定的key不存在，对该key做mappingFunction函数操作，mappingFunction函数返回值不为<span class="literal">null</span>，则将对应的k-v放到map中，否则不操作。如果key不存在computeIfAbsent返回值同mappingFunction，如果key存在返回key对应的value（此时mappingFunction不会调用）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">computeIfPresent</span><span class="params">(K key, BiFunction&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span></span><br><span class="line"></span><br><span class="line">类似与computeIfAbsent，仅对已经存在的key才计算新value。同样，如果remappingFunction返回值为<span class="literal">null</span>，会删除对应的k-v。</span><br></pre></td></tr></table></figure>

<span id="more"></span>



<p>compute示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Integer&gt; count = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">endLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    count.put(<span class="string">&quot;b&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Integer oldValue, newValue;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                count.compute(<span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;String, Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String k, Integer v)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            endLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        endLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count.compute(<span class="string">&quot;b&quot;</span>, (k, v) -&gt; &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot; --- &quot;</span> + v);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">    System.out.println(count.compute(<span class="string">&quot;a&quot;</span>, (k, v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>));</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b --- 4</span><br><span class="line">null</span><br><span class="line">101</span><br><span class="line">&#123;a=101&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个新的操作merge：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">merge</span><span class="params">(K key, V value, BiFunction&lt;? <span class="built_in">super</span> V, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span></span><br><span class="line"></span><br><span class="line">当key为尚未存在，直接插入对应value，remappingFunction不会被调用；否则，对oldValue与value做remappingFunction函数，结果作为新的newValue插入到map中。同样<span class="literal">null</span>结果会删除对应的k-v。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>merge与compute不同之处在于，若key不存在，merge传入的函数不会调用，而compute传入的函数会有调用。</p>
<p>注意：使用merge或则compute方法时，所传入的函数不应该进行大量的工作。当该函数运行时，其它一些更新映射的操作可能会被阻塞。当然，该函数也不应该更新映射的其它部分。</p>
<h1 id="批量数据操作："><a href="#批量数据操作：" class="headerlink" title="批量数据操作："></a>批量数据操作：</h1><p>search 会对每个键和（或）值应用一个函数，直到该函数返回一个非null的结果，然后search会终止并返回该函数的结果。</p>
<p>reduce会通过提供的累计函数，将所有的键和（或）值组合起来。</p>
<p>forEach会对所有的键和（或）值应用一个函数。</p>
<p>具体的函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">searchKeys/reduceKeys/forEachkey</span><br><span class="line">searchValues/reduceValues/forEachValue</span><br><span class="line">search/reduce/forEach</span><br><span class="line">searchEntries/reduceEntries/forEachEntry</span><br></pre></td></tr></table></figure>

<p>在使用这几个操作时需要指定一个并行阈值。如果希望操作在一个线程中，使用Long.MAX_VALUE作为阈值。</p>
<p>示例：</p>
<p>找到第一个出现次数超过1000的单词，需要搜索键和值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> map.search(threshold, (k, v) -&gt; v &gt; <span class="number">1000</span> ? k : <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>



<p>遍历所有键和值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach(threshold, (k , v) -&gt; sout(k + “ - ” + v));</span><br></pre></td></tr></table></figure>



<p>或则可以接收一个转换&#x2F;过滤函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map.forEach(threshold, </span><br><span class="line">    (k, v) -&gt; v &gt; <span class="number">1000</span> ? k + “ - ” + v, </span><br><span class="line">    <span class="literal">null</span>,<span class="comment">//null不会被传递给消费者函数</span></span><br><span class="line">    System.out::println);<span class="comment">//消费者</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%88JDK%20%E5%92%8CCGLIB%EF%BC%8CJavassist%EF%BC%8CASM%EF%BC%89/</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>&emsp;&emsp;Java动态代理类位于Java.lang.reflect包下，一般主要涉及到以下两个类：<br>&emsp;&emsp;<code>InvocationHandler</code>：该接口中仅定义了一个invoke方法。<br>&emsp;&emsp;每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;第一个参数obj一般是指要代理的类，method是被代理的方法，args为该方法的参数数组。这个抽象方法在代理类中动态实现。</p>
<p>&emsp;&emsp;<code>Proxy</code>：该类的作用就是用来动态创建一个代理对象的类，其中主要包含以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组.</span><br><span class="line">public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) </span><br><span class="line">    throws IllegalArgumentException&#123;…&#125;</span><br><span class="line"></span><br><span class="line">//返回代理类的一个实例，返回后的代理类可以当作被代理类使用.</span><br><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, </span><br><span class="line">    InvocationHandler h) throws IllegalArgumentException&#123;…&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;loader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载。<br>&emsp;&emsp;interfaces: 一个Interface对象的数组，表示的是要给需要代理的对象提供一组什么接口，如果提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样就能调用这组接口中的方法了。<br>&emsp;&emsp;h: 一个InvocationHandler对象，表示的是当这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上。</p>
<p>&emsp;&emsp;<code>Proxy.newProxyInstance (ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>做了以下几件事.<br>&emsp;&emsp;(1)根据参数 loader 和 interfaces 调用 getProxyClass(loader, interfaces) 创建代理类<code>$Proxy0</code>. <code>$Proxy0</code>类实现了interfaces的接口,并继承了Proxy类.<br>&emsp;&emsp;(2)实例化 <code>$Proxy0</code> 并在构造方法中把loader传过去, 接着 <code>$Proxy0</code> 调用父类Proxy的构造器,为h赋值。接着把得到的 <code>$Proxy0</code> 实例强制转换成代理类. 当执行代理类的方法时,就调用了 <code>$Proxy0</code> 类中的方法.在执行代理类方法中,调用父类Proxy中的h的invoke()方法.即InvocationHandler.invoke()。</p>
<span id="more"></span>

<p>&emsp;&emsp;示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.zero;</span><br><span class="line"></span><br><span class="line">public interface IHello &#123;</span><br><span class="line">	void say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.zero;</span><br><span class="line"></span><br><span class="line">public class HelloImpl implements IHello &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void say() &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		System.out.println(&quot;Say hello!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.zero;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class JDKProxyHandler implements InvocationHandler &#123;</span><br><span class="line">	// 这个就是我们要代理的真实对象</span><br><span class="line">	private Object realObject;</span><br><span class="line"></span><br><span class="line">	// 构造方法，给我们要代理的真实对象赋初值</span><br><span class="line">	public JDKProxyHandler(Object target) &#123;</span><br><span class="line">		this.realObject = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		System.out.println(&quot;jdk...invoke() begin&quot;);</span><br><span class="line">		System.out.println(method);</span><br><span class="line">		Object result = method.invoke(realObject, args);</span><br><span class="line">		System.out.println(&quot;jdk...invoke() end&quot;);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.zero;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class JDKProxyTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		HelloImpl impl = new HelloImpl();</span><br><span class="line">		// 这里把handler与impl新生成的代理类相关联</span><br><span class="line">		JDKProxyHandler handler = new JDKProxyHandler(impl);</span><br><span class="line">		 // 获得代理类($Proxy0 extends Proxy implements IHello)的实例.</span><br><span class="line">		IHello hello = (IHello) Proxy.newProxyInstance(impl.getClass()</span><br><span class="line">				.getClassLoader(), impl.getClass().getInterfaces(), handler);</span><br><span class="line">		// 这里无论访问哪个方法，都是会把请求转发到handler.invoke</span><br><span class="line">		hello.say();</span><br><span class="line">		System.out.println(hello.getClass());</span><br><span class="line">    //class com.sun.proxy.$Proxy0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;JDK的动态代理机制只能代理实现了接口的类，而没有实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，它的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。 </p>
<p>&emsp;&emsp;示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.zero.jdk_cglib;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class CGlibProxyHander implements MethodInterceptor &#123;</span><br><span class="line">	private Object target;</span><br><span class="line">	</span><br><span class="line">	// target不必须使用接口</span><br><span class="line">	public Object createProxyInstance(Object target) &#123;</span><br><span class="line">		this.target = target;</span><br><span class="line"></span><br><span class="line">		Enhancer enhancer = new Enhancer();</span><br><span class="line">		// 实际上是继承了目标类，覆盖目标类所有非final方法，再基础上添加新的代码</span><br><span class="line">		// 使用Enhancer可以对任意类生成代理类，</span><br><span class="line">		// 只要enhancer.setSuperclass(this.target.getClass());</span><br><span class="line">		// 其实质是代理类是目标类的子类。</span><br><span class="line">		enhancer.setSuperclass(this.target.getClass());</span><br><span class="line"></span><br><span class="line">		// 设置回调，这里相当于是对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实行intercept()方法进行拦截</span><br><span class="line">		enhancer.setCallback(this);</span><br><span class="line">		return enhancer.create();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 从参数构成上，intercept的输入参数比invoke多1个，其实前3个参数对象的含义与invoke的含义是相同的</span><br><span class="line">	// 第一个参数表示调用方法来自哪个对象；</span><br><span class="line">	// 第二个参数表示调用方法的Method对象；</span><br><span class="line">	// 第三个参数表示此次调用的输入参数列表；</span><br><span class="line">	// 多出来的参数是 MethodProxy 类型的，它应该是cglib生成用来代替Method对象的一个对象，</span><br><span class="line">	// 使用MethodProxy比调用JDK自身的Method直接执行方法效率会有提升</span><br><span class="line">	@Override</span><br><span class="line">	public Object intercept(Object object, Method method, Object[] args,</span><br><span class="line">			MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">		Object result = null;</span><br><span class="line">		System.out.println(&quot;CGlib代理 &quot; + method.getName() + &quot;()方法&quot;);</span><br><span class="line">		result = methodProxy.invoke(this.target, args);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.zero;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class CGlibProxyTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		HelloImpl impl = new HelloImpl();</span><br><span class="line">		CGlibProxyHander hander = new CGlibProxyHander();</span><br><span class="line">		</span><br><span class="line">		IHello hello = (IHello) hander.createProxyInstance(impl);</span><br><span class="line">		hello.say();</span><br><span class="line">		System.out.println(hello.getClass());</span><br><span class="line">    // class com.sun.proxy.$Proxy0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除了上面介绍的两种代理方式，还有一个方式是byte buddy，是基于ASM实现。mockito其核心就是基于byte buddy实现的，可以动态生成mock类。</p>
<p>&emsp;&emsp;上面都是使用代理的方式做类增强。由于JVM通过字节码的二进制信息加载类的，在运行时期可以按照Java虚拟机规范对class文件的组织规则生成对应的二进制字节码。再把这个二进制数据加载转换成对应的类，这样也可以完成动态代理，做到类增强。当前有很多开源框架可以完成这些功能，如ASM，Javassist。</p>
<p>&emsp;&emsp;</p>
<h3 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h3><p>&emsp;&emsp;ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。<br>&emsp;&emsp;不过ASM在创建class字节码的过程中，操纵的级别是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。</p>
<p>&emsp;&emsp;下面通过ASM 生成下面类Programmer的class字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.objectweb.asm.ClassWriter;</span><br><span class="line">import org.objectweb.asm.MethodVisitor;</span><br><span class="line">import org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">public class AsmGenerator &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class clazz = new ClassLoader() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">                byte[] b = classBytes();</span><br><span class="line">                return defineClass(name, b, 0, b.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.findClass(null);</span><br><span class="line"></span><br><span class="line">        //测试加载是否成功，打印class 对象的名称</span><br><span class="line">        System.out.println(clazz.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        //实例化一个Programmer对象</span><br><span class="line">        Object o = clazz.newInstance();</span><br><span class="line">        clazz.getMethod(&quot;code&quot;, null).invoke(o, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static byte[] classBytes() &#123;</span><br><span class="line">        ClassWriter classWriter = new ClassWriter(0);</span><br><span class="line">        // 通过visit方法确定类的头部信息</span><br><span class="line">        classWriter.visit(Opcodes.V1_8,// java版本</span><br><span class="line">                Opcodes.ACC_PUBLIC,// 类修饰符</span><br><span class="line">                &quot;Programmer&quot;, // 类的全限定名</span><br><span class="line">                null, &quot;java/lang/Object&quot;, null);</span><br><span class="line"></span><br><span class="line">        //创建构造函数</span><br><span class="line">        MethodVisitor mv = classWriter.visitMethod(Opcodes.ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);</span><br><span class="line">        mv.visitCode();</span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, 0);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, &quot;java/lang/Object&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">        mv.visitInsn(Opcodes.RETURN);</span><br><span class="line">        mv.visitMaxs(1, 1);</span><br><span class="line">        mv.visitEnd();</span><br><span class="line"></span><br><span class="line">        // 定义code方法</span><br><span class="line">        MethodVisitor methodVisitor = classWriter.visitMethod(Opcodes.ACC_PUBLIC, &quot;code&quot;, &quot;()V&quot;,</span><br><span class="line">                null, null);</span><br><span class="line">        methodVisitor.visitCode();</span><br><span class="line">        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;,</span><br><span class="line">                &quot;Ljava/io/PrintStream;&quot;);</span><br><span class="line">        methodVisitor.visitLdcInsn(&quot;I&#x27;m a Programmer,Just Coding.....&quot;);</span><br><span class="line">        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;,</span><br><span class="line">                &quot;(Ljava/lang/String;)V&quot;);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.RETURN);</span><br><span class="line">        methodVisitor.visitMaxs(2, 2);</span><br><span class="line">        methodVisitor.visitEnd();</span><br><span class="line">        classWriter.visitEnd();</span><br><span class="line">        // 使classWriter类已经完成</span><br><span class="line">        // 将classWriter转换成字节数组写到文件里面去</span><br><span class="line">        byte[] data = classWriter.toByteArray();</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * public class Programmer &#123;</span><br><span class="line">     *     public void code() &#123;</span><br><span class="line">     *         System.out.println(&quot;I&#x27;m a Programmer,Just Coding.....&quot;);</span><br><span class="line">     *     &#125;</span><br><span class="line">     * &#125;</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Javassist："><a href="#Javassist：" class="headerlink" title="Javassist："></a>Javassist：</h3><p>&emsp;&emsp;Javassist是一个开源的分析、编辑和创建Java字节码的类库。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。<br>&emsp;&emsp;下面通过Javassist创建上述的Programmer类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.zero.jdk_cglib.javassist;</span><br><span class="line"></span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import javassist.CtClass;</span><br><span class="line">import javassist.CtMethod;</span><br><span class="line">import javassist.CtNewMethod;</span><br><span class="line"></span><br><span class="line">public class AssistGenerator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        //创建Programmer类</span><br><span class="line">        CtClass cc= pool.makeClass(&quot;com.zero.Programmer&quot;);</span><br><span class="line">        //定义code方法</span><br><span class="line">        CtMethod method = CtNewMethod.make(&quot;public void code()&#123;&#125;&quot;, cc);</span><br><span class="line">        //插入方法代码</span><br><span class="line">        method.insertBefore(&quot;System.out.println(\&quot;I&#x27;m a Programmer,Just Coding.....\&quot;);&quot;);</span><br><span class="line">        cc.addMethod(method);</span><br><span class="line">        //保存生成的字节码</span><br><span class="line">//        cc.writeFile(&quot;d://temp&quot;);</span><br><span class="line"></span><br><span class="line">        Class clazz =  cc.toClass();</span><br><span class="line">        //测试加载是否成功，打印class 对象的名称</span><br><span class="line">        System.out.println(clazz.getCanonicalName());</span><br><span class="line">        //实例化一个Programmer对象</span><br><span class="line">        Object o = clazz.newInstance();</span><br><span class="line">        clazz.getMethod(&quot;code&quot;, null).invoke(o, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>Joiner、Strings、Splitter使用</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/Joiner%E3%80%81Strings%E3%80%81Splitter%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//padEnd 尾填充</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> Strings.padEnd(a, <span class="number">7</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">System.out.println(b); <span class="comment">// 12345xx</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//padStart 头填充</span></span><br><span class="line">String a=<span class="string">&quot;12345&quot;</span>;</span><br><span class="line">String b=Strings.padStart(a, <span class="number">7</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">System.out.println(b); <span class="comment">// xx12345</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Strings.isNullOrEmpty  空校验</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Strings.isNullOrEmpty(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Strings.nullToEmpty  如果为null 转为&quot;&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> Strings.nullToEmpty(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Strings.emptyToNull  如果为&quot;&quot; 转为null</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> Strings.emptyToNull(a);</span><br><span class="line">System.out.println(b); <span class="comment">// null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Strings.repeat  重复字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> Strings.repeat(a, <span class="number">3</span>);</span><br><span class="line">System.out.println(b); <span class="comment">// 123123123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Strings.commonPrefix 获取a,b左公共部分字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abcdsfsfs&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;abc3sfsd&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> Strings.commonPrefix(a, b);</span><br><span class="line">System.out.println(c); <span class="comment">// abc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Strings.commonSuffix 获取a,b右公共部分字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;faaxyz&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;fwefxyz&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> Strings.commonSuffix(a, b);</span><br><span class="line">System.out.println(c); <span class="comment">// xyz</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <span id="more"></span>



<h1 id="Joiner"><a href="#Joiner" class="headerlink" title="Joiner"></a>Joiner</h1> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .on(&quot;; &quot;)以; 分隔 .skipNulls()忽略null</span></span><br><span class="line"><span class="type">Joiner</span> <span class="variable">joiner</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;; &quot;</span>).skipNulls();</span><br><span class="line"><span class="type">String</span> <span class="variable">aString</span> <span class="operator">=</span> joiner.join(<span class="string">&quot;aaa&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">System.out.println(aString);<span class="comment">// aaa; bbb; ccc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// useForNull(String)方法可以给定某个字符串来替换null</span></span><br><span class="line">joiner = Joiner.on(<span class="string">&quot;; &quot;</span>).useForNull(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">aString = joiner.join(<span class="string">&quot;aaa&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">System.out.println(aString);<span class="comment">// aaa; ccc; bbb; ccc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> Joiner.on(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">        .withKeyValueSeparator(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">        .join(ImmutableMap.of(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;zero&quot;</span>));</span><br><span class="line">System.out.println(a); <span class="comment">// id=001&amp;name=zero</span></span><br></pre></td></tr></table></figure>



<h1 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h1> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拆分字符串为List集合</span></span><br><span class="line"><span class="type">Splitter</span> <span class="variable">splitter</span> <span class="operator">=</span> Splitter.on(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;a,b,c&quot;</span>;</span><br><span class="line">List&lt;String&gt; list = splitter.splitToList(str);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//omitEmptyStrings()-----从结果中自动忽略空字符串</span></span><br><span class="line"><span class="comment">//trimResults()-----移除结果字符串的前后空白</span></span><br><span class="line"><span class="comment">//trimResults(CharMatcher)-----给定匹配器，移除结果字符串的前导匹配字符和尾部匹配字符</span></span><br><span class="line"><span class="comment">//limit(int)-----限制拆分出的字符串数量</span></span><br><span class="line">Iterable&lt;String&gt; strsIt = Splitter.on(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        .trimResults()</span><br><span class="line">        .omitEmptyStrings()</span><br><span class="line">        .split(<span class="string">&quot;, a,,b,&quot;</span>);<span class="comment">//[a, b]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; m = Splitter.on(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">        .withKeyValueSeparator(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">        .split(<span class="string">&quot;id=001&amp;name=zero&quot;</span>);</span><br><span class="line">System.out.println(m); <span class="comment">//&#123;id=001, name=zero&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>java Process对象</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/java%20Process%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><strong>Process对象.waitFor()的阻塞问题</strong></p>
<p>有时需要在程序中调用可执行程序或脚本命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(shPath);</span><br><span class="line"><span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();</span><br></pre></td></tr></table></figure>

<p>Runtime.getRuntime()返回当前应用程序的Runtime对象，该对象的exec()方法指示Java虚拟机创建一个子进程执行指定的可执行程序，并返回与该子进程对应的Process对象实例。通过Process可以控制该子进程的执行或获取该子进程的信息。</p>
<p>它的所有标准io(即stdin，stdout，stderr)操作都将通过三个流(getOutputStream()，getInputStream()，getErrorStream())重定向到父进程。父进程使用这些流来提供到子进程的输入和获得从子进程的输出。因为输入和输出流提供有限的缓冲区大小，如果读写子进程的输出流或输入流出现失败，当缓冲区满之后将无法继续写入数据，则可能导致子进程阻塞，最终造成阻塞在waifor()这里。</p>
<span id="more"></span>

<p>针对这种情况，解法是要清空getInputStream()和getErrorStream()这两个流。而且两个流的清空一定是异步的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drainInBackground</span><span class="params">(<span class="keyword">final</span> InputStream is)</span> &#123;  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;  </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;  </span><br><span class="line">                    <span class="keyword">try</span>&#123;  </span><br><span class="line">                        <span class="keyword">while</span>( is.read() &gt;= <span class="number">0</span> );  </span><br><span class="line">                    &#125; <span class="keyword">catch</span>(IOException e)&#123;   </span><br><span class="line">                        <span class="comment">// return on IOException                  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;).start();  </span><br><span class="line">        &#125;  </span><br></pre></td></tr></table></figure>



<p>   还有一种解法是用ProcessBuilder来创建Process对象，必须要使用ProcessBuilder的redirectErrorStream方法。redirectErrorStream方法设置为ture的时候，会将getInputStream()，getErrorStream()两个流合并，自动会清空流，无需自己处理。如果是false，getInputStream()，getErrorStream()两个流分开，就必须自己处理，程序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    ProcessBuilder pbuilder=<span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;ping&quot;</span>,<span class="string">&quot;192.168.0.125&quot;</span>);  </span><br><span class="line">    pbuilder.redirectErrorStream(<span class="literal">true</span>);  </span><br><span class="line">    process=pbuilder.start();  </span><br><span class="line">    reader=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()));  </span><br><span class="line">    String line=<span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">while</span>((line=reader.readLine())!=<span class="literal">null</span>)&#123;  </span><br><span class="line">        System.out.println(line);  </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="type">int</span> result=process.waitFor();  </span><br><span class="line">    System.out.println(result);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">    <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>&emsp;&emsp;JAVA反射机制是在运行状态中,对于任意一个类,都能够得到这个类的所有属性和方法;对于任意一个对象,都能够调用它的任意一个方法;这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>&emsp;&emsp;简而言之，反射就是可以通过名称来得到对象(类,属性,方法)的技术。</p>
<h3 id="一．获取类对应的Class对象"><a href="#一．获取类对应的Class对象" class="headerlink" title="一．获取类对应的Class对象"></a>一．获取类对应的Class对象</h3><ol>
<li>getClass()方式: Object类中的方法,每个类都拥有此方法，如: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String str = new String();</span><br><span class="line">Class cls = str.getClass();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.类名.class方式，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class cls = String.class;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Class.forName()方式，如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">		Class cls = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">		// TODO Auto-generated catch block</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h3 id="二．构造一个类的实例"><a href="#二．构造一个类的实例" class="headerlink" title="二．构造一个类的实例"></a>二．构造一个类的实例</h3><ol>
<li><p>调用无参的构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class cls = Student.class;</span><br><span class="line">try &#123;</span><br><span class="line">	Student stu = (Student) cls.newInstance();</span><br><span class="line">&#125; catch (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">	// TODO Auto-generated catch block</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用有参的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	Class cls = Class.forName(&quot;com.zero.Student&quot;);</span><br><span class="line">	//指定参数的Class,来决定调用那个构造函数</span><br><span class="line">	Constructor cons = cls.getConstructor(String.class, int.class);</span><br><span class="line">	Student stu = (Student) cons.newInstance(&quot;zero&quot;, 10);</span><br><span class="line">&#125; catch (InstantiationException | IllegalAccessException</span><br><span class="line">		| ClassNotFoundException | NoSuchMethodException</span><br><span class="line">		| SecurityException | IllegalArgumentException | InvocationTargetException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三．对象的属性操作"><a href="#三．对象的属性操作" class="headerlink" title="三．对象的属性操作"></a>三．对象的属性操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class cls = Student.class;// 首先得到class</span><br><span class="line">Field[] fields = cls.getFields(); // 只能获取public修饰的field</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">	System.out.println(field.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fields = cls.getDeclaredFields(); // 获取所有声明过的field</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">	System.out.println(field.getName());</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">Student stu = new Student(&quot;zero&quot;, 12);</span><br><span class="line">Field stuFiled = stu.getClass().getDeclaredField(&quot;name&quot;); // 获取private的field</span><br><span class="line">stuFiled.setAccessible(true);// private访问权限打开，否则抛出java.lang.IllegalAccessException</span><br><span class="line">System.out.println(stuFiled.get(stu));// 获取stu的name</span><br><span class="line">	</span><br><span class="line">Student student = Student.class.newInstance();</span><br><span class="line">Field sFiled = Student.class.getDeclaredField(&quot;name&quot;);</span><br><span class="line">sFiled.setAccessible(true);</span><br><span class="line">sFiled.set(student, &quot;zero123&quot;);// 为name字段设置值</span><br><span class="line">System.out.println(sFiled.get(student));</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="四．类方法操作"><a href="#四．类方法操作" class="headerlink" title="四．类方法操作"></a>四．类方法操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  Method[] methods = Student.class.getMethods();</span><br><span class="line">for (Method method : methods) &#123; // 只获取Student的public修饰的method，以及Object的public修饰的method</span><br><span class="line">	System.out.println(method.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Method[] methodss = Student.class.getDeclaredMethods();</span><br><span class="line">for (Method method : methodss) &#123; // 只获取Student所有的method，不包括Object的method</span><br><span class="line">	System.out.println(method.getName());</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">try &#123;</span><br><span class="line">	Student student = new Student();</span><br><span class="line">	Method setMethod = student.getClass().getDeclaredMethod(</span><br><span class="line">			&quot;setGender&quot;, String.class);//获取参数为String的setGender方法</span><br><span class="line">	setMethod.invoke(student,&quot;man&quot;);</span><br><span class="line">	</span><br><span class="line">	Method getMethod = student.getClass().getDeclaredMethod(</span><br><span class="line">			&quot;getGender&quot;);//获取getGender方法</span><br><span class="line">	getMethod.setAccessible(true);//getGender方法是private，应该打开访问权限</span><br><span class="line">	String gender = (String) getMethod.invoke(student);</span><br><span class="line">	System.out.println(gender);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;来剖析一下<code>Method#invoke()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">    throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">       InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    if (!override) &#123;</span><br><span class="line">        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             // read volatile</span><br><span class="line">    if (ma == null) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    return ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以最终调用了<code>MethodAccessor.invoke</code>方法，MethodAccessor 是一个接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MethodAccessor &#123;</span><br><span class="line">    Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;调试代码可以发现看到 MethodAccessor 的实现类是委托类DelegatingMethodAccessorImpl，它的 invoke 函数非常简单，就是把调用委托给了真正的实现类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DelegatingMethodAccessorImpl extends MethodAccessorImpl &#123;</span><br><span class="line">    private MethodAccessorImpl delegate;</span><br><span class="line"></span><br><span class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl var1) &#123;</span><br><span class="line">        this.setDelegate(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        return this.delegate.invoke(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setDelegate(MethodAccessorImpl var1) &#123;</span><br><span class="line">        this.delegate = var1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;DelegatingMethodAccessorImpl中的delegate即NativeMethodAccessorImpl，真正的调用是NativeMethodAccessorImpl：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class NativeMethodAccessorImpl extends MethodAccessorImpl &#123;</span><br><span class="line">    private final Method method;</span><br><span class="line">    private DelegatingMethodAccessorImpl parent;</span><br><span class="line">    private int numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        this.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());</span><br><span class="line">            this.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return invoke0(this.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setParent(DelegatingMethodAccessorImpl var1) &#123;</span><br><span class="line">        this.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static native Object invoke0(Method var0, Object var1, Object[] var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;NativeMethodAccessorImpl中会用numInvocations记录方法调用的次数，当次数小于<code>ReflectionFactory.inflationThreshold</code>(默认15)次时，直接调用invoke0方法，则是一个 native 的函数。<br>&emsp;&emsp;15 次以后会走新的逻辑，使用 MethodAccessorGenerator（ASM的方式）生成一个新类，并将该类设置为DelegatingMethodAccessorImpl的delegate，这样下次直接调用的是新类的方法。</p>
<p>&emsp;&emsp;为什么要采用 0 ~ 15 次使用 native 方式来调用，15 次以后使用 ASM 新生成的类来处理反射的调用呢？这是因为JNI native 调用的方式要比动态生成类调用的方式慢 20 倍，但是又由于第一次字节码生成的过程比较慢。如果反射仅调用一次的话，采用生成字节码的方式反而比 native 调用的方式慢 3 ~ 4 倍。<br>&emsp;&emsp;很多情况下，反射只会调用一次，设置了<code>sun.reflect.inflationThreshold </code>这个阈值，反射方法调用超过这个阈值时，采用 ASM 生成新的类，保证后面的调用比 native 要快。如果小于 15 次的情况下，还不如生成直接 native 来的简单直接，还不造成额外类的生成、校验、加载。这种方式被称为 inflation 机制。<br>&emsp;&emsp;JVM 与 inflation 相关的属性有两个，一个是<code>sun.reflect.inflationThreshold</code>，还有一个是否禁用 inflation的属性 <code>sun.reflect.noInflation</code>，默认值为 false。如果把这个值设置成true 的话，从第 0 次开始就使用动态生成类的方式来调用反射方法了，不会使用 native 的方式。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>javapoet:方便快捷地生成.class文件</title>
    <url>/2024/07/06/Java/Java%E6%8F%90%E9%AB%98/javapoet%20%E6%96%B9%E4%BE%BF%E5%BF%AB%E6%8D%B7%E5%9C%B0%E7%94%9F%E6%88%90.class%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>[toc]<br>javapoet可以更加快捷地生成字节码，实现原理其实也就是对JavaAPT的封装，然而Javapoet有一个局限性，就是只能生成新的.class文件，却无法修改原有的类，这也是它的一大局限性所在。接下来就让我们看看它的使用方法把。</p>
<h2 id="01-简单使用"><a href="#01-简单使用" class="headerlink" title="01 简单使用"></a>01 简单使用</h2><p>使用之前要先引入这个库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compile &#x27;com.squareup:javapoet:1.7.0&#x27;</span><br></pre></td></tr></table></figure>
<p>javapoet是用来生成代码的，需要借助如下几个常用类</p>
<table>
<thead>
<tr>
<th align="left">类名</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MethodSpec</td>
<td align="left">代表一个构造函数或方法声明</td>
</tr>
<tr>
<td align="left">TypeSpec</td>
<td align="left">代表一个类，接口，或者枚举声明</td>
</tr>
<tr>
<td align="left">FieldSpec</td>
<td align="left">代表一个成员变量，一个字段声明</td>
</tr>
<tr>
<td align="left">JavaFile</td>
<td align="left">包含一个顶级类的Java文件</td>
</tr>
<tr>
<td align="left">ParameterSpec</td>
<td align="left">用来创建参数</td>
</tr>
<tr>
<td align="left">AnnotationSpec</td>
<td align="left">用来创建注解</td>
</tr>
<tr>
<td align="left">ClassName</td>
<td align="left">用来包装一个类</td>
</tr>
<tr>
<td align="left">TypeName</td>
<td align="left">类型，如在添加返回值类型是使用 TypeName.VOID</td>
</tr>
</tbody></table>
<p>除此之外 JavaPoet提供了一套自定义的字符串格式化规则，常用的有</p>
<table>
<thead>
<tr>
<th align="left">格式化规则</th>
<th align="left">表示含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$L</td>
<td align="left">字面量</td>
</tr>
<tr>
<td align="left">$S</td>
<td align="left">字符串</td>
</tr>
<tr>
<td align="left">$T</td>
<td align="left">类、接口</td>
</tr>
<tr>
<td align="left">$N</td>
<td align="left">变量</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="02-使用进阶"><a href="#02-使用进阶" class="headerlink" title="02 使用进阶"></a>02 使用进阶</h2><p><strong>方法&amp;控制流</strong></p>
<ul>
<li>添加方法 <code>addcode</code> 和 <code>addstatement</code> 对与无需类引入的极简代码可以直接使用<code>addCode</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodSpec</span> <span class="variable">main</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">    .addCode(<span class="string">&quot;&quot;</span></span><br><span class="line">        + <span class="string">&quot;int total = 0;\n&quot;</span></span><br><span class="line">        + <span class="string">&quot;for (int i = 0; i &lt; 10; i++) &#123;\n&quot;</span></span><br><span class="line">        + <span class="string">&quot;  total += i;\n&quot;</span></span><br><span class="line">        + <span class="string">&quot;&#125;\n&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>生成的是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要是需要import的方法，如上面的<code>.addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)</code> 就需要使用<code>.addStatement</code>来声明</p>
<ul>
<li>更优雅的流控制</li>
</ul>
<p><code>beginControlFlow</code> 流开启 <code>addStatement</code> 处理语句 <code>endControlFlow()</code>流结束。如上面的用流改写就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodSpec</span> <span class="variable">main</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">    .addStatement(<span class="string">&quot;int total = 0&quot;</span>)</span><br><span class="line">    .beginControlFlow(<span class="string">&quot;for (int i = 0; i &lt; 10; i++)&quot;</span>)</span><br><span class="line">    .addStatement(<span class="string">&quot;total += i&quot;</span>)</span><br><span class="line">    .endControlFlow()</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>



<p><strong>占位符</strong></p>
<p>javapoet里面提供了占位符来帮助我们更好地生成代码 <code>$L 字面常量（Literals）</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MethodSpec <span class="title function_">computeRange</span><span class="params">(String name, <span class="type">int</span> from, <span class="type">int</span> to, String op)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> MethodSpec.methodBuilder(name)</span><br><span class="line">      .returns(<span class="type">int</span>.class)</span><br><span class="line">      .addStatement(<span class="string">&quot;int result = 0&quot;</span>)</span><br><span class="line">      .beginControlFlow(<span class="string">&quot;for (int i = $L; i &lt; $L; i++)&quot;</span>, from, to)</span><br><span class="line">      .addStatement(<span class="string">&quot;result = result $L i&quot;</span>, op)</span><br><span class="line">      .endControlFlow()</span><br><span class="line">      .addStatement(<span class="string">&quot;return result&quot;</span>)</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是一个for循环，op负责加减乘除等符号</p>
<p><code>$S 字符串常量（String）</code></p>
<p><code>$T 类型(Types)</code></p>
<p>最大的特点是自动导入包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodSpec</span> <span class="variable">today</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;today&quot;</span>)</span><br><span class="line">    .returns(Date.class)</span><br><span class="line">    .addStatement(<span class="string">&quot;return new $T()&quot;</span>, Date.class)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">TypeSpec</span> <span class="variable">helloWorld</span> <span class="operator">=</span> TypeSpec.classBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">    .addMethod(today)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">JavaFile</span> <span class="variable">javaFile</span> <span class="operator">=</span> JavaFile.builder(<span class="string">&quot;com.example.helloworld&quot;</span>, helloWorld)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">javaFile.writeTo(System.out);</span><br></pre></td></tr></table></figure>

<p>生成的代码如下，而且会自动导包:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  Date <span class="title function_">today</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$N 命名(Names)</code> 通常指我们自己生成的方法名或者变量名等等，比如这样的代码块:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">byteToHex</span><span class="params">(<span class="type">int</span> b)</span> &#123;</span><br><span class="line">  <span class="type">char</span>[] result = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];</span><br><span class="line">  result[<span class="number">0</span>] = hexDigit((b &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>);</span><br><span class="line">  result[<span class="number">1</span>] = hexDigit(b &amp; <span class="number">0xf</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">hexDigit</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">char</span>) (i &lt; <span class="number">10</span> ? i + <span class="string">&#x27;0&#x27;</span> : i - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以传递<code>hexDigit()</code>来代替。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodSpec</span> <span class="variable">hexDigit</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;hexDigit&quot;</span>)</span><br><span class="line">    .addParameter(<span class="type">int</span>.class, <span class="string">&quot;i&quot;</span>)</span><br><span class="line">    .returns(<span class="type">char</span>.class)</span><br><span class="line">    .addStatement(<span class="string">&quot;return (char) (i &lt; 10 ? i + &#x27;0&#x27; : i - 10 + &#x27;a&#x27;)&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">MethodSpec</span> <span class="variable">byteToHex</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;byteToHex&quot;</span>)</span><br><span class="line">    .addParameter(<span class="type">int</span>.class, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">    .returns(String.class)</span><br><span class="line">    .addStatement(<span class="string">&quot;char[] result = new char[2]&quot;</span>)</span><br><span class="line">    .addStatement(<span class="string">&quot;result[0] = $N((b &gt;&gt;&gt; 4) &amp; 0xf)&quot;</span>, hexDigit)</span><br><span class="line">    .addStatement(<span class="string">&quot;result[1] = $N(b &amp; 0xf)&quot;</span>, hexDigit)</span><br><span class="line">    .addStatement(<span class="string">&quot;return new String(result)&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>



<p><strong>获取对应类</strong></p>
<p>有两种方式:</p>
<ul>
<li>ClassName.bestGuess(“类全名称”) 返回ClassName对象，这里的类全名称表示的类必须要存在，会自动导入相应的包</li>
<li>ClassName.get(“包名”，”类名”) 返回ClassName对象，不检查该类是否存在</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassName</span> <span class="variable">hoverboard</span> <span class="operator">=</span> ClassName.get(<span class="string">&quot;com.mattel&quot;</span>, <span class="string">&quot;Hoverboard&quot;</span>);</span><br><span class="line"><span class="type">ClassName</span> <span class="variable">list</span> <span class="operator">=</span> ClassName.get(<span class="string">&quot;java.util&quot;</span>, <span class="string">&quot;List&quot;</span>);</span><br><span class="line"><span class="type">ClassName</span> <span class="variable">arrayList</span> <span class="operator">=</span> ClassName.get(<span class="string">&quot;java.util&quot;</span>, <span class="string">&quot;ArrayList&quot;</span>);</span><br><span class="line"><span class="type">TypeName</span> <span class="variable">listOfHoverboards</span> <span class="operator">=</span> ParameterizedTypeName.get(list, hoverboard);</span><br><span class="line"></span><br><span class="line"><span class="type">MethodSpec</span> <span class="variable">beyond</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;beyond&quot;</span>)</span><br><span class="line">    .returns(listOfHoverboards)</span><br><span class="line">    .addStatement(<span class="string">&quot;$T result = new $T&lt;&gt;()&quot;</span>, listOfHoverboards, arrayList)</span><br><span class="line">    .addStatement(<span class="string">&quot;result.add(new $T())&quot;</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">&quot;result.add(new $T())&quot;</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">&quot;result.add(new $T())&quot;</span>, hoverboard)</span><br><span class="line">    .addStatement(<span class="string">&quot;return result&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>然后生成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mattel.Hoverboard;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  List&lt;Hoverboard&gt; <span class="title function_">beyond</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Hoverboard&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">Hoverboard</span>());</span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">Hoverboard</span>());</span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">Hoverboard</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>构建类的元素</strong></p>
<ul>
<li>方法</li>
</ul>
<p>方法的修饰，如<code>Modifiers.ABSTRACT</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodSpec</span> <span class="variable">flux</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;flux&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">TypeSpec</span> <span class="variable">helloWorld</span> <span class="operator">=</span> TypeSpec.classBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addMethod(flux)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>这将会生成如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">flux</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然Methods需要和<code>MethodSpec.Builder</code>配置来增加方法参数、异常、javadoc、注解等。</p>
<ul>
<li>构造器</li>
</ul>
<p>这个其实也是个函数方法而已，因此可以使用MethodSpec来生成构造器方法。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodSpec</span> <span class="variable">flux</span> <span class="operator">=</span> MethodSpec.constructorBuilder()</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addParameter(String.class, <span class="string">&quot;greeting&quot;</span>)</span><br><span class="line">    .addStatement(<span class="string">&quot;this.$N = $N&quot;</span>, <span class="string">&quot;greeting&quot;</span>, <span class="string">&quot;greeting&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">TypeSpec</span> <span class="variable">helloWorld</span> <span class="operator">=</span> TypeSpec.classBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(String.class, <span class="string">&quot;greeting&quot;</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .addMethod(flux)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>将会生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String greeting;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HelloWorld</span><span class="params">(String greeting)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.greeting = greeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>参数(重要)</li>
</ul>
<p>之前我们是通过<code>addstatement</code>直接设置参数，其实参数也有自己的一个专用类<code>ParameterSpec</code>，我们可以使用<code>ParameterSpec.builder()</code>来生成参数，然后MethodSpec的addParameter去使用，这样更加优雅。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ParameterSpec</span> <span class="variable">android</span> <span class="operator">=</span> ParameterSpec.builder(String.class, <span class="string">&quot;android&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.FINAL)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">MethodSpec</span> <span class="variable">welcomeOverlords</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;welcomeOverlords&quot;</span>)</span><br><span class="line">    .addParameter(android)</span><br><span class="line">    .addParameter(String.class, <span class="string">&quot;robot&quot;</span>, Modifier.FINAL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>生成的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">welcomeOverlords</span><span class="params">(<span class="keyword">final</span> String android, <span class="keyword">final</span> String robot)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微复杂点的类型 比如泛型 、Map之类的，需要了解下JavaPoet定义的几种专门描述类型的类</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141046397.png" alt="img"></p>
<p>常见的有</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">生成的类型</th>
<th align="left">JavaPoet 写法</th>
<th align="left">也可以这么写 （等效的 Java 写法）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">内置类型</td>
<td align="left">int</td>
<td align="left">TypeName.INT</td>
<td align="left">int.class</td>
</tr>
<tr>
<td align="left">数组类型</td>
<td align="left">int[]</td>
<td align="left">ArrayTypeName.of(int.class)</td>
<td align="left">int[].class</td>
</tr>
<tr>
<td align="left">需要引入包名的类型</td>
<td align="left">java.io.File</td>
<td align="left">ClassName.get(“java.io”, “File”)</td>
<td align="left">java.io.File.class</td>
</tr>
<tr>
<td align="left">参数化类型 （ParameterizedType</td>
<td align="left">List</td>
<td align="left">ParameterizedTypeName.get(List.class, String.class)</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">类型变量 （WildcardType） 用于声明泛型</td>
<td align="left">T</td>
<td align="left">TypeVariableName.get(“T”)</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">通配符类型</td>
<td align="left">? extends String</td>
<td align="left">WildcardTypeName.subtypeOf(String.class)</td>
<td align="left">-</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Build input type, format as :</span></span><br><span class="line"><span class="comment"> *Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="type">ParameterizedTypeName</span> <span class="variable">inputMapTypeOfRoot</span> <span class="operator">=</span> ParameterizedTypeName.get(</span><br><span class="line">            ClassName.get(Map.class),</span><br><span class="line">            ClassName.get(String.class),</span><br><span class="line">            ParameterizedTypeName.get(</span><br><span class="line">                    ClassName.get(Class.class),</span><br><span class="line">                    WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *Map&lt;String, RouteMeta&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ParameterizedTypeName</span> <span class="variable">inputMapTypeOfGroup</span> <span class="operator">=</span> ParameterizedTypeName.get(</span><br><span class="line">            ClassName.get(Map.class),</span><br><span class="line">            ClassName.get(String.class),</span><br><span class="line">            ClassName.get(RouteMeta.class)</span><br><span class="line">    );        </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *Build input param name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ParameterSpec</span> <span class="variable">rootParamSpec</span> <span class="operator">=</span> ParameterSpec.builder(inputMapTypeOfRoot, <span class="string">&quot;routes&quot;</span>).build();</span><br><span class="line">    <span class="type">ParameterSpec</span> <span class="variable">groupParamSpec</span> <span class="operator">=</span> ParameterSpec.builder(inputMapTypeOfGroup, <span class="string">&quot;atlas&quot;</span>).build();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>生成参数类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ARouter$Root$app</span> <span class="keyword">implements</span> <span class="title class_">IRouteRoot</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> &#123;</span><br><span class="line">    routes.put(<span class="string">&quot;service&quot;</span>, ARouter$Group$service.class);</span><br><span class="line">    routes.put(<span class="string">&quot;test&quot;</span>, ARouter$Group$test.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ARouter$Group$service</span> <span class="keyword">implements</span> <span class="title class_">IRouteGroup</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> &#123;</span><br><span class="line">    atlas.put(<span class="string">&quot;/service/hello&quot;</span>, RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, <span class="string">&quot;/service/hello&quot;</span>, <span class="string">&quot;service&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/service/json&quot;</span>, RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, <span class="string">&quot;/service/json&quot;</span>, <span class="string">&quot;service&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">&quot;/service/single&quot;</span>, RouteMeta.build(RouteType.PROVIDER, SingleService.class, <span class="string">&quot;/service/single&quot;</span>, <span class="string">&quot;service&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字段</li>
</ul>
<p>可以使用FieldSpec去声明字段，然后加到Method中处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FieldSpec</span> <span class="variable">android</span> <span class="operator">=</span> FieldSpec.builder(String.class, <span class="string">&quot;android&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">TypeSpec</span> <span class="variable">helloWorld</span> <span class="operator">=</span> TypeSpec.classBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(android)</span><br><span class="line">    .addField(String.class, <span class="string">&quot;robot&quot;</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>然后生成代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String android;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String robot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常Builder可以更加详细的创建字段的内容，比如javadoc、annotations或者初始化字段参数等，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FieldSpec</span> <span class="variable">android</span> <span class="operator">=</span> FieldSpec.builder(String.class, <span class="string">&quot;android&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .initializer(<span class="string">&quot;$S + $L&quot;</span>, <span class="string">&quot;Lollipop v.&quot;</span>, <span class="number">5.0d</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>对应生成的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">android</span> <span class="operator">=</span> <span class="string">&quot;Lollipop v.&quot;</span> + <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口</li>
</ul>
<p>接口方法必须是PUBLIC ABSTRACT并且接口字段必须是PUBLIC STATIC FINAL ，使用<code>TypeSpec.interfaceBuilder</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TypeSpec</span> <span class="variable">helloWorld</span> <span class="operator">=</span> TypeSpec.interfaceBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addField(FieldSpec.builder(String.class, <span class="string">&quot;ONLY_THING_THAT_IS_CONSTANT&quot;</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)</span><br><span class="line">        .initializer(<span class="string">&quot;$S&quot;</span>, <span class="string">&quot;change&quot;</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(<span class="string">&quot;beep&quot;</span>)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">        .build())</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>

<p>生成的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">ONLY_THING_THAT_IS_CONSTANT</span> <span class="operator">=</span> <span class="string">&quot;change&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">beep</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承父类 实现接口</li>
</ul>
<p>接口代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.javapoet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestInterface</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T testPara)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExtendesClass</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javapoet实现接口并且继承父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ClassName</span>  <span class="variable">InterfaceName</span> <span class="operator">=</span> ClassName.get(<span class="string">&quot;com.test.javapoet&quot;</span>,<span class="string">&quot;TestInterface&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassName</span> <span class="variable">superinterface</span> <span class="operator">=</span> ClassName.bestGuess(<span class="string">&quot;com.test.javapoet.TestClass&quot;</span>);</span><br><span class="line">    <span class="comment">//ClassName superinterface = ClassName.get(&quot;com.test.javapoet&quot;,&quot;aa&quot;);</span></span><br><span class="line"></span><br><span class="line">    TypeSpec.<span class="type">Builder</span> <span class="variable">spec</span> <span class="operator">=</span> TypeSpec.classBuilder(<span class="string">&quot;TestImpl&quot;</span>)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">            <span class="comment">// 添加接口，ParameterizedTypeName的参数1是接口，参数2是接口的泛型</span></span><br><span class="line">            .addSuperinterface(ParameterizedTypeName.get(InterfaceName, superinterface)) </span><br><span class="line">            <span class="comment">//使用ClassName.bestGuess会自动导入包</span></span><br><span class="line">            .superclass(ClassName.bestGuess(<span class="string">&quot;com.zs.javapoet.test.TestExtendesClass&quot;</span>));</span><br><span class="line"></span><br><span class="line">    MethodSpec.<span class="type">Builder</span> <span class="variable">methodSpec</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">            .addAnnotation(Override.class)</span><br><span class="line">            .returns(TypeName.VOID)</span><br><span class="line">            .addParameter(superinterface, <span class="string">&quot;testPara&quot;</span>)</span><br><span class="line">            .addStatement(<span class="string">&quot;System.out.println(hello)&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="type">TypeSpec</span> <span class="variable">typeSpec</span> <span class="operator">=</span> spec.addMethod(methodSpec.build()).build();</span><br><span class="line"></span><br><span class="line">    <span class="type">JavaFile</span> <span class="variable">file</span> <span class="operator">=</span> JavaFile.builder(<span class="string">&quot;com.zs.javapoet&quot;</span>, typeSpec).build();</span><br><span class="line">    file.writeTo(System.out);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.javapoet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> com.zs.javapoet.test.TestExtendesClass;</span><br><span class="line">    <span class="keyword">import</span> java.lang.Override;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestImpl</span> <span class="keyword">extends</span> <span class="title class_">TestExtendesClass</span> <span class="keyword">implements</span> <span class="title class_">TestInterface</span>&lt;TestClass&gt; &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(TestClass testPara)</span> &#123;</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举类型</li>
</ul>
<p>使用<code>TypeSpec.enumBuilder</code>来创建，使用<code>addEnumConstant</code>来添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TypeSpec</span> <span class="variable">helloWorld</span> <span class="operator">=</span> TypeSpec.enumBuilder(<span class="string">&quot;Roshambo&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addEnumConstant(<span class="string">&quot;ROCK&quot;</span>)</span><br><span class="line">    .addEnumConstant(<span class="string">&quot;SCISSORS&quot;</span>)</span><br><span class="line">    .addEnumConstant(<span class="string">&quot;PAPER&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>生成的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Roshambo</span> &#123;</span><br><span class="line">  ROCK,</span><br><span class="line"></span><br><span class="line">  SCISSORS,</span><br><span class="line"></span><br><span class="line">  PAPER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更复杂的类型也可以支持，如重写、注解等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TypeSpec</span> <span class="variable">helloWorld</span> <span class="operator">=</span> TypeSpec.enumBuilder(<span class="string">&quot;Roshambo&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addEnumConstant(<span class="string">&quot;ROCK&quot;</span>, TypeSpec.anonymousClassBuilder(<span class="string">&quot;$S&quot;</span>, <span class="string">&quot;fist&quot;</span>)</span><br><span class="line">        .addMethod(MethodSpec.methodBuilder(<span class="string">&quot;toString&quot;</span>)</span><br><span class="line">            .addAnnotation(Override.class)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC)</span><br><span class="line">            .addStatement(<span class="string">&quot;return $S&quot;</span>, <span class="string">&quot;avalanche!&quot;</span>)</span><br><span class="line">            .build())</span><br><span class="line">        .build())</span><br><span class="line">    .addEnumConstant(<span class="string">&quot;SCISSORS&quot;</span>, TypeSpec.anonymousClassBuilder(<span class="string">&quot;$S&quot;</span>, <span class="string">&quot;peace&quot;</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addEnumConstant(<span class="string">&quot;PAPER&quot;</span>, TypeSpec.anonymousClassBuilder(<span class="string">&quot;$S&quot;</span>, <span class="string">&quot;flat&quot;</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addField(String.class, <span class="string">&quot;handsign&quot;</span>, Modifier.PRIVATE, Modifier.FINAL)</span><br><span class="line">    .addMethod(MethodSpec.constructorBuilder()</span><br><span class="line">        .addParameter(String.class, <span class="string">&quot;handsign&quot;</span>)</span><br><span class="line">        .addStatement(<span class="string">&quot;this.$N = $N&quot;</span>, <span class="string">&quot;handsign&quot;</span>, <span class="string">&quot;handsign&quot;</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>生成代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Roshambo</span> &#123;</span><br><span class="line">  ROCK(<span class="string">&quot;fist&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;avalanche!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  SCISSORS(<span class="string">&quot;peace&quot;</span>),</span><br><span class="line"></span><br><span class="line">  PAPER(<span class="string">&quot;flat&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String handsign;</span><br><span class="line"></span><br><span class="line">  Roshambo(String handsign) &#123;</span><br><span class="line">    <span class="built_in">this</span>.handsign = handsign;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名内部类</li>
</ul>
<p>需要使用<code>Type.anonymousInnerClass(&quot;&quot;)</code>,通常可以使用$L占位符来指代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TypeSpec</span> <span class="variable">comparator</span> <span class="operator">=</span> TypeSpec.anonymousClassBuilder(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    .addSuperinterface(ParameterizedTypeName.get(Comparator.class, String.class))</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(<span class="string">&quot;compare&quot;</span>)</span><br><span class="line">        .addAnnotation(Override.class)</span><br><span class="line">        .addModifiers(Modifier.PUBLIC)</span><br><span class="line">        .addParameter(String.class, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        .addParameter(String.class, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">        .returns(<span class="type">int</span>.class)</span><br><span class="line">        .addStatement(<span class="string">&quot;return $N.length() - $N.length()&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="type">TypeSpec</span> <span class="variable">helloWorld</span> <span class="operator">=</span> TypeSpec.classBuilder(<span class="string">&quot;HelloWorld&quot;</span>)</span><br><span class="line">    .addMethod(MethodSpec.methodBuilder(<span class="string">&quot;sortByLength&quot;</span>)</span><br><span class="line">        .addParameter(ParameterizedTypeName.get(List.class, String.class), <span class="string">&quot;strings&quot;</span>)</span><br><span class="line">        .addStatement(<span class="string">&quot;$T.sort($N, $L)&quot;</span>, Collections.class, <span class="string">&quot;strings&quot;</span>, comparator)</span><br><span class="line">        .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>生成代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sortByLength</span><span class="params">(List&lt;String&gt; strings)</span> &#123;</span><br><span class="line">  Collections.sort(strings, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.length() - b.length();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义匿名内部类的一个特别棘手的问题是参数的构造。在上面的代码中我们传递了不带参数的空字符串。TypeSpec.anonymousClassBuilder(“”)。</p>
<ul>
<li>注解</li>
</ul>
<p>注解使用起来比较简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodSpec</span> <span class="variable">toString</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;toString&quot;</span>)</span><br><span class="line">    .addAnnotation(Override.class)</span><br><span class="line">    .returns(String.class)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC)</span><br><span class="line">    .addStatement(<span class="string">&quot;return $S&quot;</span>, <span class="string">&quot;Hoverboard&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>生成代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hoverboard&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过<code>AnnotationSpec.builder()</code> 可以对注解设置属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodSpec</span> <span class="variable">logRecord</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;recordEvent&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addAnnotation(AnnotationSpec.builder(Headers.class)</span><br><span class="line">        .addMember(<span class="string">&quot;accept&quot;</span>, <span class="string">&quot;$S&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>)</span><br><span class="line">        .addMember(<span class="string">&quot;userAgent&quot;</span>, <span class="string">&quot;$S&quot;</span>, <span class="string">&quot;Square Cash&quot;</span>)</span><br><span class="line">        .build())</span><br><span class="line">    .addParameter(LogRecord.class, <span class="string">&quot;logRecord&quot;</span>)</span><br><span class="line">    .returns(LogReceipt.class)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>代码生成如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Headers(</span></span><br><span class="line"><span class="meta">    accept = &quot;application/json; charset=utf-8&quot;,</span></span><br><span class="line"><span class="meta">    userAgent = &quot;Square Cash&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line">LogReceipt <span class="title function_">recordEvent</span><span class="params">(LogRecord logRecord)</span>;</span><br></pre></td></tr></table></figure>

<p>注解同样可以注解其他注解，通过$L引用如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MethodSpec</span> <span class="variable">logRecord</span> <span class="operator">=</span> MethodSpec.methodBuilder(<span class="string">&quot;recordEvent&quot;</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)</span><br><span class="line">    .addAnnotation(AnnotationSpec.builder(HeaderList.class)</span><br><span class="line">        .addMember(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;$L&quot;</span>, AnnotationSpec.builder(Header.class)</span><br><span class="line">            .addMember(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;$S&quot;</span>, <span class="string">&quot;Accept&quot;</span>)</span><br><span class="line">            .addMember(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;$S&quot;</span>, <span class="string">&quot;application/json; charset=utf-8&quot;</span>)</span><br><span class="line">            .build())</span><br><span class="line">        .addMember(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;$L&quot;</span>, AnnotationSpec.builder(Header.class)</span><br><span class="line">            .addMember(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;$S&quot;</span>, <span class="string">&quot;User-Agent&quot;</span>)</span><br><span class="line">            .addMember(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;$S&quot;</span>, <span class="string">&quot;Square Cash&quot;</span>)</span><br><span class="line">            .build())</span><br><span class="line">        .build())</span><br><span class="line">    .addParameter(LogRecord.class, <span class="string">&quot;logRecord&quot;</span>)</span><br><span class="line">    .returns(LogReceipt.class)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>生成代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HeaderList(&#123;</span></span><br><span class="line"><span class="meta">    @Header(name = &quot;Accept&quot;, value = &quot;application/json; charset=utf-8&quot;),</span></span><br><span class="line"><span class="meta">    @Header(name = &quot;User-Agent&quot;, value = &quot;Square Cash&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">LogReceipt <span class="title function_">recordEvent</span><span class="params">(LogRecord logRecord)</span>;</span><br></pre></td></tr></table></figure>





<hr>
<p>转载自：<br><a href="https://cloud.tencent.com/developer/article/1918448">https://cloud.tencent.com/developer/article/1918448</a></p>
<p>更多阅读：<br><a href="https://zhuanlan.zhihu.com/p/374640828">JDK编译时注解处理器结合Javapoet动态生成模板化Java源文件</a><br><a href="https://segmentfault.com/a/1190000044557383">基于javaPoet的缓存key优化实践</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>关于Java NIO的Selector</title>
    <url>/2024/07/06/Java/Java%E6%8F%90%E9%AB%98/%E5%85%B3%E4%BA%8EJava%20NIO%E7%9A%84Selector/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Selector-简介"><a href="#Selector-简介" class="headerlink" title="Selector 简介"></a>Selector 简介</h1><p>Selector（选择器）是 Channel 的多路复用器，它可以同时监控多个 Channel 的 IO 状况，允许单个线程来操作多个 Channel。如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240712204746.png" alt="img"></p>
<p>Selector 的作用是什么？</p>
<p>Selector 提供选择执行已经就绪的任务的能力。从底层来看，Selector 提供了询问 Channel 是否已经准备好执行每个 I&#x2F;O 操作的能力。Selector 允许单线程处理多个 Channel。仅用单个线程来处理多个 Channels 的好处是，只需要更少的线程来处理 Channel 。事实上，可以只用一个线程处理所有的通道，这样会大量的减少线程之间上下文切换的开销。</p>
<span id="more"></span>

<h1 id="Selector-的使用"><a href="#Selector-的使用" class="headerlink" title="Selector 的使用"></a>Selector 的使用</h1><p>使用 Selector 的主要流程如下：</p>
<ol>
<li>打开 Selector</li>
<li>将 Channel 注册到 Selector 中，并设置要监听的事件</li>
<li>轮询处理 IO 操作</li>
</ol>
<h2 id="打开-Selector"><a href="#打开-Selector" class="headerlink" title="打开 Selector"></a>打开 Selector</h2><p>和 SocketChannel 相似，调用 Selector.open() 就可以打开一个选择器实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>



<h2 id="注册-Selector"><a href="#注册-Selector" class="headerlink" title="注册 Selector"></a>注册 Selector</h2><p>为了将 Channel 和 Selector 配合使用，我们需要将 Channel 注册到对应的 Selector 上，调用 SelectableChannel.register() 方法来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector,Selectionkey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p>这里有一个要注意的地方，所有注册到 Selector 中的 Channel 都必须是非阻塞的。怎么判断 Channel 是否可以设置为非阻塞呢？判断它是否继承了SelectableChannel，SelectableChannel 是一个抽象类，它提供了实现 Channel 的可选择性所需要的公共方法。而 FileChannel 没有继承 SelectableChannel ，所以它不能使用 Selector。</p>
<p>register() 提供了两个参数，一个是要注册的 Selector 是谁，第二个参数是对什么事件感兴趣。事件类型有四种：</p>
<ul>
<li><p>连接 : SelectionKey.OP_CONNECT</p>
</li>
<li><p>接收 : SelectionKey.OP_ACCEPT</p>
</li>
<li><p>可读 : SelectionKey.OP_READ</p>
</li>
<li><p>可写 : SelectionKey.OP_WRITE</p>
</li>
</ul>
<p>如果感兴趣的事件不止一个，则可以使用“位运算 | ” 来组合多个事件，如： <code>SelectionKey.OP_CONNECT | SelectionKey.OP_ACCEPT</code>。</p>
<p>需要提醒的是，Selector 关注的不是 Channel 的操作，而是 Channel的某个操作的一种就绪状态。一旦 Channel 具备完成某个操作的条件，表示该 Channel 的某个操作已经就绪，就可以被 Selector 查询到，程序可以对该 Channel 进行对应的操作。比如说，某个 SocketChannel 可以连接到一个服务器，则处于“连接就绪”（OP_CONNECT）。某给 ServerSocketChannel 可以接收新的连接，则处理“接收就绪”（SelectionKey.OP_ACCEPT）。</p>
<h2 id="轮询处理-IO-操作"><a href="#轮询处理-IO-操作" class="headerlink" title="轮询处理 IO 操作"></a>轮询处理 IO 操作</h2><p>将 Channel 注册到 Selector 并关注相对应的时间后，就可以轮询处理 IO 事件了。</p>
<p>Selector 提供了方法 select()，该方法可以查询出已经就绪的 Channel操作，如果没有事件发生，则该方法会一直阻塞，直到有事件。select() 有三个重载方法：</p>
<ul>
<li>select(): 阻塞到至少有一个通道在你注册的事件上就绪了。·</li>
<li>select(long timeout)：和select()一样，但最长阻塞事件为timeout毫秒。</li>
<li>selectNow():非阻塞，只要有通道就绪就立刻返回。</li>
</ul>
<p>select() 返回值为 int 类型，该值表示有多少 Channel 的操作已经就绪，更准确地说是上一次 select() 到这一次 select() 方法之间的时间段内，有多少 Channel 变成了就绪状态。</p>
<p>当 select() 返回后，如果返回值大于 0 ，则可以调用 selectedKeys() 方法，该方法返回一个 Set 集合，该集合是一个 SelectionKey 的集合，SelectionKey 表示的是可选择通道 SelectableChannel 和一个特定的 Selector之间的注册关系。</p>
<ul>
<li><p>SelectionKey 是一个抽象类，表示 SelectableChannel 在 Selector 中注册的标识.每个 Channel 向 Selector 注册时,都将会创建一个selectionKey</p>
</li>
<li><p>SelectionKey 是 SelectableChannel 与 Selector 的建立关系，并维护了 Channel 事件</p>
</li>
<li><p>可以通过 cancel() 方法取消 key，取消的 key 不会立即从 Selector 中移除,而是添加到 cancelledKeys 中,在下一次 select() 操作时移除它.所以在调用某个 key 时,需要使用 isValid 进行校验。</p>
</li>
</ul>
<p>SelectionKey 提供了两个非常重要的 “Set”：interest set 和 ready set。</p>
<ul>
<li>interest set 表示感兴趣的事件，我们可以通过以下方式获取：<br>int interestSet &#x3D; selectionKey.interestOps();<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInAccept</span>  <span class="operator">=</span> interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInConnect</span> <span class="operator">=</span> interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInRead</span>    <span class="operator">=</span> interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInWrite</span>   <span class="operator">=</span> interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></li>
<li>ready set：代表了 Channel 所准备好了的操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readySet</span> <span class="operator">=</span> selectionKey.readyOps();</span><br><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>


<p>以下代码是一个处理 IO 操作的完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    selector.select();</span><br><span class="line">    </span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">            <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            <span class="comment">// a channel is ready for writing</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这段代码非常重要，后面演示</span></span><br><span class="line">        key.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一段非常重要的代码 key.remove()，这行代码表示，我已经在处理该 IO 事件了，需要删除。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建 ServerSocketChannel</span></span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为非阻塞</span></span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 8081 端口</span></span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8081</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 Selector</span></span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 SocketChannel 注册到  Selector</span></span><br><span class="line">    <span class="comment">// 通常我们都是先注册一个 OP_ACCEPT 事件, 然后在 OP_ACCEPT 到来时, 再将这个 Channel 的 OP_READ</span></span><br><span class="line">    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// select 方法，一直阻塞直到有事件发生</span></span><br><span class="line">        selector.select();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 I/O 操作就绪的 SelectionKey, 通过 SelectionKey 可以知道哪些 Channel 的哪类 I/O 操作已经就绪</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一个 SelectionKey 后，我们要将其删除掉，表示我们已经处理了这个事件</span></span><br><span class="line">            iterator.remove();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                <span class="comment">// 连接时间发生</span></span><br><span class="line">                <span class="comment">// 当客户端连接服务端的时候，我们需要服务单与之建立连接</span></span><br><span class="line">                <span class="comment">// 需要注意的是在 OP_ACCEPT 事件中, 从 key.channel() 返回的 Channel 是 ServerSocketChannel</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="comment">// 需要从 socketChannel 获取 SocketChanel</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> socketChannel.accept();</span><br><span class="line">                log.info(<span class="string">&quot;&#123;&#125; 建立连接&quot;</span>,clientChannel);</span><br><span class="line">                <span class="comment">// 设置 clientChannel 为非阻塞</span></span><br><span class="line">                clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                clientChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                <span class="comment">// 获取的为 SocketChannel</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> clientChannel.read(byteBuffer);</span><br><span class="line">                <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 小于 0 表示客户端断开连接，需要关闭该 SocketChannel</span></span><br><span class="line">                    log.info(<span class="string">&quot;&#123;&#125;，断开了连接&quot;</span>,clientChannel);</span><br><span class="line">                    clientChannel.close();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">                    <span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>).decode(byteBuffer);</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">&quot;&#123;&#125;，发来了消息,消息内容是:&#123;&#125;&quot;</span>,clientChannel,charBuffer.toString());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务端接收消息后，给客户端发送给客户端</span></span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>).encode(string);</span><br><span class="line">                    clientChannel.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (writeBuffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="comment">// 如果不能一次性发完只需要触发 write 事件去发</span></span><br><span class="line">                        key.attach(writeBuffer);</span><br><span class="line">                        key.interestOps(key.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable() &amp;&amp; key.isValid()) &#123;</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">                clientChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                    <span class="comment">// 如果已完，则只无须关注 write 事件</span></span><br><span class="line">                    key.attach(<span class="literal">null</span>);</span><br><span class="line">                    key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>分析为什么要：key.remove()<br>这里拿上面那个问题来说明，为什么要加这 key.remove() 代码呢？首先这段代码的意思是说获取一个 SelectionKey 后，我们需要将其删除，表示我们已经对该 IO 事件进行了处理，如果没有这样代码会有什么后果呢？报 NullPointerException！</p>
<p>为什么会这样呢？这里我们来梳理整个流程。</p>
<ul>
<li>首先服务端创建一个 Selector，该 Selector 与 ServerSocketChannel 绑定，且关注 accept 事件。如下</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240712205800.png" alt="img"></p>
<ul>
<li><p>当客户端发起连接时，selector.selectedKeys() 会返回 Set 集合，该集合包含了已经准备就绪的 SelectionKey，这个时候只有连接事件，相对应的 SelectionKey 为 2b71fc7e</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240712205818.png" alt="img"></p>
</li>
<li><p>当服务端与客户端建立连接后，绑定 Selector 并关注 read 事件。这里需要注意的是 Selector 并不会主动去删除 SelectionKey，它只会增加，所以这个时候 Selector 里面有两个 SelectionKey，一个是 2b71fc7e（accept），一个是 1de0aca6（read）。建立连接后，事件处理完成，会该事件与之对应的事件去掉，也就是 2b71fc7e 的 SelectionKey 绑定的 ServerSocketChannel ，但是 Selector 里面对应的 SelectionKey 还是存在的。</p>
</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240712210605.png" alt="img"></p>
<ul>
<li><p>当客户端给服务端发送消息时，服务端监测到有事件发生，会将发生时间的 SelectionKey@1de0aca6 加入到 selectedKey 中，如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240712210623.png" alt="img"></p>
</li>
<li><p>在迭代过程第一次取的是 SelectionKey@1de0aca6，这个是读事件，可以正常读，打印客户端发送过来的，但是第二次读取的是 SelectionKey@2b71fc7e，但是这个 Key 与之相绑定的事件已经处理了，它为 null，那肯定会报 NullPointerException。所以在使用 NIO 时一定要主动删除已经处理过的 SelectionKey ，既主动调用 key.remove()，删除该 SelectionKey。</p>
</li>
</ul>
<hr>
<p>原文链接：<br><a href="https://blog.csdn.net/chenssy/article/details/134407984">https://blog.csdn.net/chenssy/article/details/134407984</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>对象属性copy</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7copy/</url>
    <content><![CDATA[<h3 id="1-对象属性拷贝的常见方式及其性能"><a href="#1-对象属性拷贝的常见方式及其性能" class="headerlink" title="1.对象属性拷贝的常见方式及其性能"></a>1.对象属性拷贝的常见方式及其性能</h3><p>&emsp;&emsp;在日常编码中，经常会遇到DO、DTO对象之间的转换，如果对象本身的属性比较少的时候，那么采用Hard Code工作量也不大，但如果对象的属性比较多的情况下，Hard Code效率就比较低。这时候就要使用其它工具类来进行对象属性的拷贝。<br>&emsp;&emsp;常用的对象属性拷贝的方式和性能测试如下：</p>
<table>
<thead>
<tr>
<th align="left">拷贝方式</th>
<th>copy次数1000</th>
<th>copy次数100000</th>
<th>copy次数1000000</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Hard Code</td>
<td>1 ms</td>
<td>18 ms</td>
<td>43 ms</td>
</tr>
<tr>
<td align="left">net.sf.cglib.beans.BeanCopier#copy</td>
<td>117 ms</td>
<td>107 ms</td>
<td>110 ms</td>
</tr>
<tr>
<td align="left">org.springframework.beans.BeanUtils#copyProperties</td>
<td>137 ms</td>
<td>246 ms</td>
<td>895 ms</td>
</tr>
<tr>
<td align="left">org.apache.commons.beanutils.PropertyUtils#copyProperties</td>
<td>212 ms</td>
<td>601 ms</td>
<td>7869 ms</td>
</tr>
<tr>
<td align="left">org.apache.commons.beanutils.BeanUtils#copyProperties</td>
<td>275 ms</td>
<td>1732 ms</td>
<td>12380 ms</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;结论：采用Hard Code方式进行对象属性Copy性能最佳；采用<code>net.sf.cglib.beans.BeanCopier#copy</code>方式进行对象属性copy性能最稳定；而<code>org.apache.commons.beanutils.BeanUtils.copyProperties</code> 方式在数据量大时性能下降最厉害。所以在日常编程中遇到具有较多属性的对象进行属性复制时优先考虑采用<code>net.sf.cglib.beans.BeanCopier#copy</code>。</p>
<p>&emsp;&emsp;以上的数据之所以产生巨大差距的原因在于其实现原理与方式的不同而导致的，Hard Code直接调用getter &amp; setter方法值，cglib采用的是字节码技术，而后三种均采用反射的方式。前两者性能优异众所周知，但为何同样采用反射的方式进行属性Copy时产生的差异如此巨大呢？ </p>
<span id="more"></span>

<h3 id="2-Introspector"><a href="#2-Introspector" class="headerlink" title="2.Introspector"></a>2.Introspector</h3><p>&emsp;&emsp;<code>org.apache.commons.beanutils.BeanUtils</code>与<code>org.springframework.beans.BeanUtils</code>均采用反射技术实现，也都调用了Java关于反射的高级API——Introspector(内省)。Introspector(内省)是jdk提供的用于描述Java bean支持的属性、方法以及事件的工具；利用此类可得到BeanInfo接口的实现对象:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanInfo beanInfo = Introspector.getBeanInfo(Client.class);</span><br><span class="line"></span><br><span class="line">BeanDescriptor beanDescriptor = beanInfo.getBeanDescriptor();</span><br><span class="line">System.out.println(beanDescriptor.getBeanClass());</span><br><span class="line"></span><br><span class="line">PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">for(PropertyDescriptor descriptor: descriptors) &#123;</span><br><span class="line">    Method readMethod = descriptor.getReadMethod();</span><br><span class="line">    Method writeMethod = descriptor.getWriteMethod();</span><br><span class="line"></span><br><span class="line">    System.out.println(descriptor.getName()); // address</span><br><span class="line">    System.out.println(readMethod); // public java.lang.String xxx.Client.getAddress()</span><br><span class="line">    System.out.println(writeMethod); // public void xxx.Client.setAddress(java.lang.String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>getBeanDescriptor()</code>返回的BeanDescriptor提供了java bean的一些全局的信息，如class类型、类名称等。<code>getPropertyDescriptors()</code>返回PropertyDescriptor[]，PropertyDescriptor描述了java bean中一个属性和它们的getter &amp; setter方法的SoftReference。</p>
<p>&emsp;&emsp;</p>
<h3 id="3-BeanCopier-copy的使用"><a href="#3-BeanCopier-copy的使用" class="headerlink" title="3.BeanCopier#copy的使用"></a>3.BeanCopier#copy的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client client = new Client();</span><br><span class="line">client.setAddress(&quot;adc&quot;);</span><br><span class="line">client.setEmail(&quot;@163.com&quot;);</span><br><span class="line">BeanCopier copier = BeanCopier.create(Client.class, ClientDO.class, false);</span><br><span class="line">ClientDO clientDO = new ClientDO();</span><br><span class="line">copier.copy(client, clientDO, null);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>BeanCopier#copy</code>的使用示例有很多，注意BeanCopier只拷贝名称和类型都相同的属性，使用Converter可以解决类型不同的字段拷贝。<br>&emsp;&emsp;那么，如果字段名称不一样，但是需要<code>BeanCopier#copy</code>来拷贝怎么弄呢？这里给一个解法，可能不是最优解。我们知道<code>BeanCopier#copy</code>是使用了asm来生成了一个转换类来做属性的拷贝，只要修改生成的类里面的逻辑即可，来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static BeanCopier create(Class source, Class target, boolean useConverter) &#123;</span><br><span class="line">    Generator gen = new Generator();</span><br><span class="line">    gen.setSource(source);</span><br><span class="line">    gen.setTarget(target);</span><br><span class="line">    gen.setUseConverter(useConverter);</span><br><span class="line">    return gen.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;默认情况下，使用了<code>net.sf.cglib.beans.BeanCopier.Generator</code>，注意它是ClassGenerator的实现类，那么在生成类的使用就会调用它的generateClass方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void generateClass(ClassVisitor v) &#123;</span><br><span class="line">    Type sourceType = Type.getType(source);</span><br><span class="line">    Type targetType = Type.getType(target);</span><br><span class="line">    ClassEmitter ce = new ClassEmitter(v);</span><br><span class="line">    ce.begin_class(Constants.V1_2,</span><br><span class="line">                   Constants.ACC_PUBLIC,</span><br><span class="line">                   getClassName(),</span><br><span class="line">                   BEAN_COPIER,</span><br><span class="line">                   null,</span><br><span class="line">                   Constants.SOURCE_FILE);</span><br><span class="line"></span><br><span class="line">    EmitUtils.null_constructor(ce);</span><br><span class="line">    CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, COPY, null);</span><br><span class="line">    PropertyDescriptor[] getters = ReflectUtils.getBeanGetters(source);</span><br><span class="line">    PropertyDescriptor[] setters = ReflectUtils.getBeanSetters(target);</span><br><span class="line"></span><br><span class="line">    Map names = new HashMap();</span><br><span class="line">    for (int i = 0; i &lt; getters.length; i++) &#123;</span><br><span class="line">        names.put(getters[i].getName(), getters[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Local targetLocal = e.make_local();</span><br><span class="line">    Local sourceLocal = e.make_local();</span><br><span class="line">    if (useConverter) &#123;</span><br><span class="line">        e.load_arg(1);</span><br><span class="line">        e.checkcast(targetType);</span><br><span class="line">        e.store_local(targetLocal);</span><br><span class="line">        e.load_arg(0);                </span><br><span class="line">        e.checkcast(sourceType);</span><br><span class="line">        e.store_local(sourceLocal);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        e.load_arg(1);</span><br><span class="line">        e.checkcast(targetType);</span><br><span class="line">        e.load_arg(0);</span><br><span class="line">        e.checkcast(sourceType);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; setters.length; i++) &#123;</span><br><span class="line">        PropertyDescriptor setter = setters[i];</span><br><span class="line">        PropertyDescriptor getter = (PropertyDescriptor)names.get(setter.getName());</span><br><span class="line">        if (getter != null) &#123;</span><br><span class="line">            MethodInfo read = ReflectUtils.getMethodInfo(getter.getReadMethod());</span><br><span class="line">            MethodInfo write = ReflectUtils.getMethodInfo(setter.getWriteMethod());</span><br><span class="line">            if (useConverter) &#123;</span><br><span class="line">                Type setterType = write.getSignature().getArgumentTypes()[0];</span><br><span class="line">                e.load_local(targetLocal);</span><br><span class="line">                e.load_arg(2);</span><br><span class="line">                e.load_local(sourceLocal);</span><br><span class="line">                e.invoke(read);</span><br><span class="line">                e.box(read.getSignature().getReturnType());</span><br><span class="line">                EmitUtils.load_class(e, setterType);</span><br><span class="line">                e.push(write.getSignature().getName());</span><br><span class="line">                e.invoke_interface(CONVERTER, CONVERT);</span><br><span class="line">                e.unbox_or_zero(setterType);</span><br><span class="line">                e.invoke(write);</span><br><span class="line">            &#125; else if (compatible(getter, setter)) &#123;</span><br><span class="line">                e.dup2();</span><br><span class="line">                e.invoke(read);</span><br><span class="line">                e.invoke(write);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e.return_value();</span><br><span class="line">    e.end_method();</span><br><span class="line">    ce.end_class();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;asm不熟悉也不要紧，关键在于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PropertyDescriptor setter = setters[i];</span><br><span class="line">PropertyDescriptor getter = (PropertyDescriptor)names.get(setter.getName());</span><br><span class="line">if (getter != null) &#123;</span><br><span class="line">    MethodInfo read = ReflectUtils.getMethodInfo(getter.getReadMethod());</span><br><span class="line">    MethodInfo write = ReflectUtils.getMethodInfo(setter.getWriteMethod());</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;根据target中的setter的name，即字段名，去source中取getter，取不到就拉倒。那比如target有个字段是gender，但是实际对应source字段应该是sex，实际上可以在gender这个字段上加一个注解，值是sex，用注解值去source中取getter，然后做后面流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PropertyDescriptor getter = (PropertyDescriptor) names.get(setter.getName());</span><br><span class="line">if (getter == null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Field field = target.getDeclaredField(setter.getName());</span><br><span class="line">        Alias alias = field.getAnnotation(Alias.class);</span><br><span class="line">        if (alias != null) &#123;</span><br><span class="line">            getter = (PropertyDescriptor) names.get(alias.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (NoSuchFieldException err) &#123;</span><br><span class="line">        err.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为了避免对源码的修改，可以自定义一个ConsumerGenerator extends BeanCopier.Generator，在创建BeanCopier时使用ConsumerGenerator生成。</p>
<p>&emsp;&emsp;<br>参考：<a href="https://blog.csdn.net/u010209217/article/details/84837821#1__2">https://blog.csdn.net/u010209217/article/details/84837821#1__2</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>前缀匹配的工具类</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>转载自：<a href="https://blog.csdn.net/bohu83/article/details/126427401">https://blog.csdn.net/bohu83/article/details/126427401</a></p>
<p>有这样业务场景：对于一个主题subject，想看有哪些group订阅了。而对于消费者来说，订阅的时候就是需要支持前缀匹配的，比如XXX.order.pay,支持订阅XXX.order 就能获取消息。通常这就需要使用前缀匹配，可以使用Java库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.googlecode.concurrent-trees&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;concurrent-trees&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.6.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>使用的数据结构是基数树，而不是以为的字典树，基数树与字典树的区别在于基数树将单词压缩了, 节点变得更少，解决了字典树高度问题。</p>
<span id="more"></span>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291635783.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>自定义ClassLoader实现隔离运行不同版本jar包</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/%E8%87%AA%E5%AE%9A%E4%B9%89ClassLoader%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E8%BF%90%E8%A1%8C%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACjar%E5%8C%85/</url>
    <content><![CDATA[<p>现在假定有这样一个需求，实现针对集群（比如 Hadoop 集群）版本为 V1 与 V2 的对应的执行程序，那么假定有如下项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executor-Parent: 提供基础的 Maven 引用，可利用 Maven 一键打包所有的子模块/项目</span><br><span class="line">Executor-Common: 提供基础的接口，已经有公有的实现等</span><br><span class="line">Executor-Proxy: 执行不同版本程序的代理程序</span><br><span class="line">Executor-V1: 版本为V1的执行程序</span><br><span class="line">Executor-V2: 版本为V2的执行程序</span><br></pre></td></tr></table></figure>
<p>这里为了更凸显 ClassLoader 的实现，不做 Executor-Parent 的实现，同时为了简便，也没有设置包名。</p>
<ol>
<li>Executor-Common<br>在 Executor-Common 中提供一个接口，声明执行的具体方法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">    void execute(final String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<p>这里的方法使用了基础类型 String，实际中可能会使用自定义的类型，那么在 Porxy 的实现中则需要使用自定义的 ClassLoader 来加载参数，并使用反射来获取方法（后面会有一个简单的示例）。回到之前的示例，这里同时提供一个抽象的实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AbstractExecutor implements Executor &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void execute(final String name) &#123;</span><br><span class="line">        this.handle(new Handler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handle() &#123;</span><br><span class="line">                System.out.println(&quot;V:&quot; + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void handle(Handler handler) &#123;</span><br><span class="line">        handler.call();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected abstract class Handler &#123;</span><br><span class="line">        public void call() &#123;</span><br><span class="line">            ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            // 临时更改 ClassLoader</span><br><span class="line">            Thread.currentThread().setContextClassLoader(AbstractExecutor.class.getClassLoader());</span><br><span class="line">            handle();</span><br><span class="line">            // 还原为之前的 ClassLoader</span><br><span class="line">            Thread.currentThread().setContextClassLoader(oldClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public abstract void handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要临时更改当前线程的 ContextClassLoader, 以应对扩展程序中可能出现的如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"> </span><br><span class="line">classLoader.loadClass(...);</span><br></pre></td></tr></table></figure>

<p>因为它们会获取当前线程的 ClassLoader 来加载 class，而当前线程的ClassLoader极可能是App ClassLoader而非自定义的ClassLoader, 也许是为了安全起见，但是这会导致它可能加载到启动项目中的class（如果有），或者发生其它的异常，所以我们在执行时需要临时的将当前线程的ClassLoader设置为自定义的ClassLoader，以实现绝对的隔离执行。</p>
<ol start="2">
<li><p>Executor-V1 &amp; Executor-V2<br>Executor-V1 和 Executor-V2 依赖了 Executor-Common.jar，并实现了 Executor 接口的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExecutorV1 extends AbstractExecutor &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void execute(final String name) &#123;</span><br><span class="line">        this.handle(new Handler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handle() &#123;</span><br><span class="line">                System.out.println(&quot;V1:&quot; + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ExecutorV2 extends AbstractExecutor &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void execute(final String name) &#123;</span><br><span class="line">        this.handle(new Handler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handle() &#123;</span><br><span class="line">                System.out.println(&quot;V2:&quot; + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里仅仅是打印了它们的版本信息，实际中，它们可能需要引入不同的版本的 Jar 包，然后根据这些 Jar 包完成相应的操作。</p>
</li>
<li><p>Executor-Proxy<br>Executor-Proxy 利用自定义的 ClassLoader 和反射来实现加载与运行 ExecutorV1 和 ExecutorV2 中 Executor 接口的实现，而 ExecutorV1 和 ExecutorV2 将以 jar 包的形式被分别放置在 ${Executor-Proxy_HOME}\ext\v1 和 ${Executor-Proxy_HOME}\ext\v2 目录下，其中自定义的 ClassLoader 实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StandardExecutorClassLoader extends URLClassLoader &#123;</span><br><span class="line">    private final static String baseDir = System.getProperty(&quot;user.dir&quot;) + File.separator + &quot;ext&quot; + File.separator;</span><br><span class="line">    </span><br><span class="line">    public StandardExecutorClassLoader(String version) &#123;</span><br><span class="line">    	super(new URL[] &#123;&#125;, null); // 将 Parent 设置为 null</span><br><span class="line">    	</span><br><span class="line">    	loadResource(version);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    	// 测试时可打印看一下</span><br><span class="line">    	System.out.println(&quot;Class loader: &quot; + name);</span><br><span class="line">    	return super.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return super.findClass(name);</span><br><span class="line">        &#125; catch(ClassNotFoundException e) &#123;</span><br><span class="line">            return StandardExecutorClassLoader.class.getClassLoader().loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void loadResource(String version) &#123;</span><br><span class="line">    	String jarPath = baseDir + version;</span><br><span class="line">    	</span><br><span class="line">    	// 加载对应版本目录下的 Jar 包</span><br><span class="line">    	tryLoadJarInDir(jarPath);</span><br><span class="line">    	// 加载对应版本目录下的 lib 目录下的 Jar 包</span><br><span class="line">    	tryLoadJarInDir(jarPath + File.separator + &quot;lib&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void tryLoadJarInDir(String dirPath) &#123;</span><br><span class="line">    	File dir = new File(dirPath);</span><br><span class="line">    	// 自动加载目录下的jar包</span><br><span class="line">    	if (dir.exists() &amp;&amp; dir.isDirectory()) &#123;</span><br><span class="line">    		for (File file : dir.listFiles()) &#123;</span><br><span class="line">    			if (file.isFile() &amp;&amp; file.getName().endsWith(&quot;.jar&quot;)) &#123;</span><br><span class="line">    				this.addURL(file);</span><br><span class="line">    				continue;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void addURL(File file) &#123;</span><br><span class="line">    	try &#123;</span><br><span class="line">    		super.addURL(new URL(&quot;file&quot;, null, file.getCanonicalPath()));</span><br><span class="line">    	&#125; catch (MalformedURLException e) &#123;</span><br><span class="line">    		e.printStackTrace();</span><br><span class="line">    	&#125; catch (IOException e) &#123;</span><br><span class="line">    		e.printStackTrace();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>StandardExecutorClassLoader 在实例化时，会自动加载扩展目录下与其lib目录下的 jar 包，这里之所以要加载 lib 目录下的 jar，是为了加载扩展的依赖包。</p>
<p>有了StandardExecutorClassLoader，我们还需要一个调用各版本程序的代理类ExecutorPorxy，其实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line">public class ExecutorProxy implements Executor &#123;</span><br><span class="line">    private String version;</span><br><span class="line">    private StandardExecutorClassLoader classLoader;</span><br><span class="line">    </span><br><span class="line">    public ExecutorProxy(String version) &#123;</span><br><span class="line">        this.version = version;</span><br><span class="line">        classLoader = new StandardExecutorClassLoader(version);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void execute(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // Load ExecutorProxy class</span><br><span class="line">            Class&lt;?&gt; executorClazz = classLoader.loadClass(&quot;Executor&quot; + version.toUpperCase());</span><br><span class="line">            Object executorInstance = executorClazz.newInstance();</span><br><span class="line">            Method method = executorClazz.getMethod(&quot;execute&quot;, String.class);</span><br><span class="line">            method.invoke(executorInstance, name);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是一个比较简单的实现，因为通过反射调用的方法的参数是基本类型，在实际中，更多的可能是自定义的参数，那么这时候则需要先通过自定义的 ClassLoader 加载其 Class，然后才能去获取对应的方法，下面是一个省去上下文的一个例子（不能直接运行）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void call() throws IOException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Load HBaseApi class</span><br><span class="line">        Class&lt;?&gt; hbaseApiClazz = loadHBaseApiClass();</span><br><span class="line">        Object hbaseApiInstance = hbaseApiClazz.newInstance();</span><br><span class="line"> </span><br><span class="line">        // Load parameter class</span><br><span class="line">        Class&lt;?&gt; paramClazz = classLoader.loadClass(VO_PACKAGE_PATH + &quot;.&quot; + sourceParame.getClass().getSimpleName());</span><br><span class="line">        </span><br><span class="line">        // Transition parameter to targeParameter from sourceParameter </span><br><span class="line">        Object targetParam = BeanUtils.transfrom(paramClazz, sourceParame);</span><br><span class="line">        </span><br><span class="line">        // Get function</span><br><span class="line">        Method method = hbaseApiClazz.getMethod(methodName, paramClazz);</span><br><span class="line">        // Invoke function by targetParam</span><br><span class="line">        method.invoke(hbaseApiInstance, targetParam);</span><br><span class="line">        </span><br><span class="line">    &#125; catch(ClassNotFoundException | NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行<br>将ExecutorV1 和 ExecutorV2分别打包，并将其打包后的 jar包与其依赖（lib目录下）放入 Executor-Proxy 项目的 ext\v1 和 ext\v2 目录下，在 Executor-Proxy 项目中则可以使用 Junit 进行测试：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExecutorTest &#123;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void testExecuteV1() &#123;</span><br><span class="line">        Executor executor = new ExecutorProxy(&quot;v1&quot;);</span><br><span class="line">        executor.execute(&quot;TOM&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void testExecuteV2() &#123;</span><br><span class="line">        Executor executor = new ExecutorProxy(&quot;v2&quot;);</span><br><span class="line">        executor.execute(&quot;TOM&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>打印结果最终分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execute testExecuteV1():</span><br><span class="line"> </span><br><span class="line">V1:TOM</span><br><span class="line"></span><br><span class="line">execute testExecuteV2():</span><br><span class="line"> </span><br><span class="line">V2:TOM</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>总结<br>总的来说，实现隔离允许指定 jar 包，主要需要做到以下几点：</li>
</ol>
<p>自定义 ClassLoader，使其 Parent &#x3D; null，避免其使用系统自带的 ClassLoader 加载 Class。<br>在调用相应版本的方法前，更改当前线程的 ContextClassLoader，避免扩展包的依赖包通过Thread.currentThread().getContextClassLoader()获取到非自定义的 ClassLoader 进行类加载<br>通过反射获取 Method 时，如果参数为自定义的类型，一定要使用自定义的 ClassLoader 加载参数获取 Class，然后在获取 Method，同时参数也必须转化为使用自定义的 ClassLoade 加载的类型（不同 ClassLoader 加载的同一个类不相等）<br>实际运用中，往往容易做到第一点或第三点，而忽略第二点，比如使用 HBase 相关包时。</p>
<p>当然，这只是一种解决的方式，我们仍然可以使用微服务来达到同样甚至更棒的效果，</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/yongqi_wang/article/details/125783257">https://blog.csdn.net/yongqi_wang/article/details/125783257</a><br><a href="https://blog.csdn.net/t894690230/article/details/73252331">https://blog.csdn.net/t894690230/article/details/73252331</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>stop the world案例</title>
    <url>/2024/04/01/Java/JVM/stop%20the%20world%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="一、遇到的问题"><a href="#一、遇到的问题" class="headerlink" title="一、遇到的问题"></a>一、遇到的问题</h3><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291316004.webp"><br>Total time for which application threads were stop 超级长时间，这行日志代表什么，以及为什么时间会这么长 ?</p>
<span id="more"></span>



<h3 id="二、日志的含义"><a href="#二、日志的含义" class="headerlink" title="二、日志的含义"></a>二、日志的含义</h3><p>当GC发生时，每个线程只有进入了SafePoint才算是真正挂起，也就是真正的停顿，这个日志的含义是整个GC过程中STW的时间，配置了  <strong>-XX:+PrintGCApplicationStoppedTime</strong>  这个参数才会打印这个信息。<br><strong>重点：</strong> 第一个 2.81 seconds 是JVM启动后的秒数?，第二个 2.68 seconds 是 JVM发起STW的开始到结束的时间。特别地，如果是GC引发的STW，这条内容会紧挨着出现在GC log的下面。</p>
<p>日志统计脚本： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f xxx.gc.log | grep &#x27;application threads were stopped&#x27; | awk &#x27;$(NF-6)&gt;0.05&#x27;</span><br></pre></td></tr></table></figure>



<h3 id="三、安全点是什么"><a href="#三、安全点是什么" class="headerlink" title="三、安全点是什么"></a>三、安全点是什么</h3><p>从线程角度看，safepoint可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这个位置暂停，比如发生GC时，需要暂停暂停所以活动线程，但是线程在这个时刻，还没有执行到一个安全点，所以该线程应该继续执行，到达下一个安全点的时候暂停，等待GC结束。</p>
<ol>
<li>从线程的角度，安全点是代码执行中的一些特殊位置，当线程执行到这些特殊的位置，如果此时在GC，那么在这个地方线程会暂停，直到GC结束。</li>
<li>GC的时候要挂起所有活动的线程，因此线程挂起，会选择在到达安全点的时候挂起。</li>
<li>安全点这个特殊的位置保存了线程上下文的全部信息。说白了，在进入安全点的时候打印日志信息能看出线程此刻都在干嘛。</li>
</ol>
<p>有关安全点的详细说明，请移步：<br><a href="https://www.jianshu.com/p/c79c5e02ebe6">JVM源码分析之安全点safepoint</a></p>
<h3 id="四、什么时候会STW？（换句话说什么时候会触发进入安全点？）"><a href="#四、什么时候会STW？（换句话说什么时候会触发进入安全点？）" class="headerlink" title="四、什么时候会STW？（换句话说什么时候会触发进入安全点？）"></a>四、什么时候会STW？（换句话说什么时候会触发进入安全点？）</h3><ul>
<li>Garbage collection pauses（垃圾回收）</li>
<li>JIT相关，比如Code deoptimization, Flushing code cache</li>
<li>Class redefinition (e.g. javaagent，AOP代码植入的产生的instrumentation)</li>
<li>Biased lock revocation 取消偏向锁</li>
<li>Various debug operation (e.g. thread dump or deadlock check) dump 线程</li>
</ul>
<h3 id="五、STW的说明"><a href="#五、STW的说明" class="headerlink" title="五、STW的说明"></a>五、STW的说明</h3><p>配置 <code>-XX:+PrintSafepointStatistics  –XX:PrintSafepointStatisticsCount=1</code> 参数，虚拟机会打印如下日志文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmop [threads: total initially_running wait_to_block]  [time: spin block sync cleanup vmop] page_trap_count  370337.312: GenCollectForAllocation     [  1070     2       3  ]   [ 8830   0 8831   1  24  ] </span><br></pre></td></tr></table></figure>
<blockquote>
<p>-XX:+PrintSafepointStatistics 打印安全点统计信息，<br>-XX:PrintSafepointStatisticsCount&#x3D;n 设置打印安全点统计信息的次数；</p>
</blockquote>
<h4 id="5-1-日志分析"><a href="#5-1-日志分析" class="headerlink" title="5.1 日志分析"></a>5.1 日志分析</h4><ol>
<li><strong>vmop：</strong> 引发STW的原因，以及触发时间。该项常见的输出有：RevokeBias、BulkRevokeBias、Deoptimize、G1IncCollectionPause。数字370337.312是虚拟机启动后运行的秒数。GC log可以根据该项内容定位Total time for which application threads…引发的详细信息。</li>
<li><strong>total ：</strong> STW发生时，JVM存在的线程数目，这里的值是1070。</li>
<li><strong>initially_running ：</strong> STW发生时，仍在运行的线程数，这里的值是2。这项是Spin阶段的 时间来源。</li>
<li><strong>wait_to_block ：</strong> STW需要阻塞的线程数目，这里的值是3。这项是block阶段的时间来源</li>
<li><strong>sync</strong> &#x3D; spin + block + 其他。</li>
</ol>
<h4 id="5-2-由日志可以看出，safepoint的执行分为四个阶段"><a href="#5-2-由日志可以看出，safepoint的执行分为四个阶段" class="headerlink" title="5.2 由日志可以看出，safepoint的执行分为四个阶段"></a>5.2 由日志可以看出，safepoint的执行分为四个阶段</h4><ol>
<li>Spin阶段。因为jvm在决定进入全局safepoint的时候，有的线程在安全点上，而有的线程不在安全点上，这个阶段是等待未在安全点上的用户线程进入安全点。</li>
<li>Block阶段。即使进入safepoint，用户线程这时候仍然是running状态，保证用户不在继续执行，需要将用户线程阻塞。</li>
<li>Cleanup。这个阶段是JVM做的一些内部的清理工作。</li>
<li>VM Operation. JVM 执行的一些全局性工作，例如 GC, 代码反优化。</li>
</ol>
<h4 id="5-3-vmop-输出说明"><a href="#5-3-vmop-输出说明" class="headerlink" title="5.3 vmop 输出说明"></a>5.3 vmop 输出说明</h4><p>RevokeBias、BulkRevokeBias、偏向锁取消情况。<br>Deoptimize、<br>G1IncCollectionPause GC GC 执行情况。</p>
<h4 id="5-4-优化说明"><a href="#5-4-优化说明" class="headerlink" title="5.4 优化说明"></a>5.4 优化说明</h4><p>分析 -XX:+PrintSafepointStatistics –XX:PrintSafepointStatisticsCount&#x3D;1 产生的日志信息基本上STW的原因都是RevokeBias或者BulkRevokeBias。</p>
<p>这个是撤销偏向锁操作，虽然每次暂停的 时间很短，但是特别频繁出现也会很耗时。一些高并发的系统中，禁掉JVM偏向锁优化，可以提升系统的吞吐量。</p>
<p>禁用偏向锁的参数为: -XX:-UseBiasedLocking</p>
<p>还有一种常见会有长时间STW：</p>
<p>当发生GC时，有线程迟迟进入不到safepoint进行阻塞，导致其他已经停止的线程也一直等待，VM Thread也在等待所有的Java线程挂起才能开始GC，这里需要分析业务代码中是否存在有界的大循环逻辑，可能在JIT优化时，这些循环操作没有插入safepoint检查。</p>
<hr>
<p>转载自：<br><a href="https://zhuanlan.zhihu.com/p/91937583">https://zhuanlan.zhihu.com/p/91937583</a><br><a href="https://xie.infoq.cn/article/60db3144cb07afba7060bd36f">https://xie.infoq.cn/article/60db3144cb07afba7060bd36f</a><br><a href="https://zhuanlan.zhihu.com/p/91937583">https://zhuanlan.zhihu.com/p/91937583</a><br><a href="https://blog.csdn.net/iter_zc/article/details/41892567">https://blog.csdn.net/iter_zc/article/details/41892567</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>三色标记法与读写屏障</title>
    <url>/2024/04/01/Java/JVM/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E4%B8%8E%E8%AF%BB%E5%86%99%E5%B1%8F%E9%9A%9C/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="1-垃圾回收的简单回顾"><a href="#1-垃圾回收的简单回顾" class="headerlink" title="1. 垃圾回收的简单回顾"></a>1. 垃圾回收的简单回顾</h2><p>关于垃圾回收算法，基本就是那么几种：标记-清除、标记-复制、标记-整理。在此基础上可以增加分代（新生代&#x2F;老年代），每代采取不同的回收算法，以提高整体的分配和回收效率。</p>
<p>无论使用哪种算法，<strong>标记总是必要的一步</strong>。垃圾回收器的工作流程大体如下：</p>
<ul>
<li><ol>
<li><strong>标记</strong>出哪些对象是存活的，哪些是垃圾（可回收）；</li>
</ol>
</li>
<li><ol start="2">
<li>进行<strong>回收</strong>（清除&#x2F;复制&#x2F;整理），如果有移动过对象（复制&#x2F;整理），还需要更新引用。</li>
</ol>
</li>
</ul>
<p>本文着重来看下<strong>标记</strong>的部分的。CMS和G1都使用了三色标记法。</p>
<span id="more"></span>

<h2 id="2-三色标记法"><a href="#2-三色标记法" class="headerlink" title="2. 三色标记法"></a>2. 三色标记法</h2><h3 id="2-1-基本算法"><a href="#2-1-基本算法" class="headerlink" title="2.1 基本算法"></a>2.1 基本算法</h3><p>要找出存活对象，根据可达性分析，从GC Roots开始进行遍历访问，可达的则为存活对象：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291128129.webp"></p>
<p>最终结果：A&#x2F;D&#x2F;E&#x2F;F&#x2F;G 可达。</p>
<p>我们把遍历对象图<strong>过程</strong>中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色：</p>
<ul>
<li><strong>白色</strong>：尚未访问过。</li>
<li><strong>黑色</strong>：本对象已访问过，而且本对象 引用到 的其他对象 也全部访问过了。</li>
<li><strong>灰色</strong>：本对象已访问过，但是本对象 引用到 的其他对象 尚未全部访问完。全部访问后，会转换为黑色。</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291131390.webp"></p>
<p>&emsp;&emsp;<br><strong>三色标记遍历过程：</strong><br>假设现在有白、灰、黑三个集合（表示当前对象的颜色），其遍历访问过程为：</p>
<ol>
<li>初始时，所有对象都在 【白色集合】中；</li>
<li>将GC Roots 直接引用到的对象 挪到 【灰色集合】中；</li>
<li>从灰色集合中获取对象：<br> 3.1.  将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；<br> 3.2.  将本对象 挪到 【黑色集合】里面。</li>
<li>重复步骤3，直至【灰色集合】为空时结束。</li>
<li>结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。</li>
</ol>
<blockquote>
<p>注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。</p>
</blockquote>
<p>当Stop The World （以下简称 STW）时，对象间的引用 是不会发生变化的，可以轻松完成标记。而当需要支持并发标记时，即标记期间应用线程还在继续跑，<strong>对象间的引用可能发生变化</strong>，<strong>多标</strong>和<strong>漏标</strong>的情况就有可能发生。</p>
<p>&emsp;&emsp;</p>
<h3 id="2-2-多标-浮动垃圾"><a href="#2-2-多标-浮动垃圾" class="headerlink" title="2.2 多标-浮动垃圾"></a>2.2 多标-浮动垃圾</h3><p>假设已经遍历到E（变为灰色了），此时应用执行了 <code>objD.fieldE = null</code> ：D &gt; E 的引用断开。</p>
<img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291135285.png" style="zoom:50%;" />



<p>此刻之后，对象E&#x2F;F&#x2F;G是“应该”被回收的。然而因为<strong>E已经变为灰色</strong>了，其仍会被<strong>当作存活对象</strong>继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即<strong>本轮GC不会回收这部分内存</strong>。</p>
<p>这部分本应该回收 但是 没有回收到的内存，被称之为“<strong>浮动垃圾</strong>”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。</p>
<p>另外，针对并发标记开始后的<strong>新对象</strong>，通常的做法是直接全部<strong>当成黑色</strong>，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。</p>
<p>&emsp;&emsp;</p>
<h3 id="2-3-漏标-读写屏障"><a href="#2-3-漏标-读写屏障" class="headerlink" title="2.3 漏标-读写屏障"></a>2.3 漏标-读写屏障</h3><p>假设GC线程已经遍历到E（变为灰色了），此时应用线程先执行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">G</span> <span class="operator">=</span> objE.fieldG; </span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 灰色E 断开引用 白色G </span></span><br><span class="line">objD.fieldG = G;  <span class="comment">// 黑色D 引用 白色G</span></span><br></pre></td></tr></table></figure>
<p>E &gt; G 断开，D引用 G。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291137318.webp"></p>
<p>此时切回GC线程继续跑，因为<strong>E已经没有对G的引用了，所以不会将G放到灰色集合</strong>；尽管因为D重新引用了G，但因为<strong>D已经是黑色</strong>了，不会再重新做遍历处理。<br>最终导致的结果是：G会一直停留在白色集合中，<strong>最后被当作垃圾进行清除</strong>。这直接<strong>影响到了应用程序的正确性</strong>，是不可接受的。</p>
<hr>
<p>不难分析，漏标只有<strong>同时满足</strong>以下两个条件时才会发生：</p>
<blockquote>
<ul>
<li>条件一：灰色对象 断开了 白色对象的引用（直接或间接的引用）；即灰色对象 原来成员变量的引用 发生了变化。</li>
<li>条件二：黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。</li>
</ul>
</blockquote>
<p>从<strong>代码的角度</strong>看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">G</span> <span class="operator">=</span> objE.fieldG; <span class="comment">// 1.读</span></span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 2.写</span></span><br><span class="line">objD.fieldG = G;     <span class="comment">// 3.写</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>读取</strong> 对象E的成员变量fieldG的引用值，即对象G；</li>
<li>对象E 往其成员变量fieldG，<strong>写入</strong> null值。</li>
<li>对象D 往其成员变量fieldG，<strong>写入</strong> 对象G ；</li>
</ol>
<p>我们只要在上面这三步中的任意一步中做一些“手脚”，<strong>将对象G记录起来，然后作为灰色对象再进行遍历</strong>即可。比如放到一个特定的集合，等初始的GC Roots遍历完（并发标记），该集合的对象 遍历即可（重新标记）。</p>
<blockquote>
<p><strong>重新标记是需要STW的</strong>，因为应用程序一直在跑的话，该集合可能会一直增加新的对象，导致永远都跑不完。当然，并发标记期间也可以将该集合中的大部分先跑了，从而缩短重新标记STW的时间，这个是优化问题了。</p>
</blockquote>
<p>写屏障用于拦截第二和第三步；而读屏障则是拦截第一步。它们的拦截的目的很简单：就是在读写前后，将对象G给记录下来。</p>
<p>&emsp;&emsp;</p>
<h4 id="2-3-1-写屏障（Store-Barrier）"><a href="#2-3-1-写屏障（Store-Barrier）" class="headerlink" title="2.3.1 写屏障（Store Barrier）"></a>2.3.1 写屏障（Store Barrier）</h4><p>给某个对象的成员变量赋值时，其底层代码大概长这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param field 某对象的成员变量，如 D.fieldG</span></span><br><span class="line"><span class="comment">* @param new_value 新值，如 null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> &#123; </span><br><span class="line">    *field = new_value; <span class="comment">// 赋值操作</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>所谓的写屏障，其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> &#123;  </span><br><span class="line">    pre_write_barrier(field); <span class="comment">// 写屏障-写前操作</span></span><br><span class="line">    *field = new_value; </span><br><span class="line">    post_write_barrier(field, value);  <span class="comment">// 写屏障-写后操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-写屏障-增量更新"><a href="#1-写屏障-增量更新" class="headerlink" title="(1) 写屏障 + 增量更新"></a>(1) 写屏障 + 增量更新</h5><p>当对象D的成员变量的引用发生变化时（<code>objD.fieldG = G;</code>），我们可以利用写屏障，将D<strong>新的成员变量引用</strong>对象G记录下来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">post_write_barrier</span><span class="params">(oop* field, oop new_value)</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span>($gc_phase == GC_CONCURRENT_MARK &amp;&amp; !isMarkd(field)) &#123;</span><br><span class="line">      remark_set.add(new_value); <span class="comment">// 记录新引用的对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【<strong>当有新引用插入进来时，记录下新的引用对象</strong>】<br>这种做法的思路是：<strong>针对新增的引用</strong>，将其记录下来等待遍历，即增量更新（Incremental Update）。达到的效果是D由黑色变灰色。</p>
<blockquote>
<p>增量更新破坏了条件二：【黑色对象 重新引用了 该白色对象】，从而保证了不会漏标。</p>
</blockquote>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291138538.png"></p>
<h5 id="2-写屏障-SATB"><a href="#2-写屏障-SATB" class="headerlink" title="(2) 写屏障 + SATB"></a>(2) 写屏障 + SATB</h5><p>当对象E的成员变量的引用发生变化时（<code>objE.fieldG = null;</code>），我们可以利用写屏障，将E<strong>原来成员变量的引用</strong>对象G记录下来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pre_write_barrier</span><span class="params">(oop* field)</span> &#123;</span><br><span class="line">    oop old_value = *field; <span class="comment">// 获取旧值</span></span><br><span class="line">    remark_set.add(old_value); <span class="comment">// 记录 原来的引用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【当<strong>原来成员变量的引用发生变化之前，记录下原来的引用对象</strong>】<br>这种做法的思路是：<strong>尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB）</strong>，当<strong>某个时刻</strong> 的GC Roots确定后，<strong>当时</strong>的对象图就已经确定了。<br>比如 <strong>当时</strong> D是引用着G的，那后续的标记也应该是按照这个时刻的对象图走（D引用着G）。如果期间发生变化，则可以记录起来，保证标记依然按照原本的视图来。</p>
<blockquote>
<p>SATB破坏了条件一：【灰色对象 断开了 白色对象的引用】，从而保证了不会漏标。</p>
</blockquote>
<hr>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291138660.png"></p>
<p>使用SATB的原因：<br>1.因为增量更新会在重新标记的时候将从黑色变成灰色的对象在扫描一遍，会更费时。<br>2.使用SATB就会大大减少扫描对象，原因是只多扫描在GC堆栈中发生改变的引用（和G1的一个RSet进行配合，RSet为每个）</p>
<h4 id="2-3-2-读屏障（Load-Barrier）"><a href="#2-3-2-读屏障（Load-Barrier）" class="headerlink" title="2.3.2 读屏障（Load Barrier）"></a>2.3.2 读屏障（Load Barrier）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">oop <span class="title function_">oop_field_load</span><span class="params">(oop* field)</span> &#123;</span><br><span class="line">    pre_load_barrier(field); <span class="comment">// 读屏障-读取前操作</span></span><br><span class="line">    <span class="keyword">return</span> *field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读屏障是直接针对第一步：<code>var G = objE.fieldG;</code>，当读取成员变量时，一律记录下来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pre_load_barrier</span><span class="params">(oop* field, oop old_value)</span> &#123;  </span><br><span class="line">  <span class="keyword">if</span>($gc_phase == GC_CONCURRENT_MARK &amp;&amp; !isMarkd(field)) &#123;</span><br><span class="line">      oop old_value = *field;</span><br><span class="line">      remark_set.add(old_value); <span class="comment">// 记录读取到的对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法是保守的，但也是安全的。因为条件二中【黑色对象 重新引用了 该白色对象】，重新引用的前提是：得获取到该白色对象，此时已经读屏障就发挥作用了。</p>
<p>&emsp;&emsp;</p>
<h3 id="2-4-三色标记法与现代垃圾回收器"><a href="#2-4-三色标记法与现代垃圾回收器" class="headerlink" title="2.4 三色标记法与现代垃圾回收器"></a>2.4 三色标记法与现代垃圾回收器</h3><p>现代追踪式（可达性分析）的垃圾回收器几乎都借鉴了三色标记的算法思想，尽管实现的方式不尽相同：比如白色&#x2F;黑色集合一般都不会出现（但是有其他体现颜色的地方）、灰色集合可以通过栈&#x2F;队列&#x2F;缓存日志等方式进行实现、遍历方式可以是广度&#x2F;深度遍历等等。</p>
<p>对于读写屏障，以Java HotSpot VM为例，其并发标记时对漏标的处理方案如下：</p>
<ul>
<li><strong>CMS：写屏障 + 增量更新</strong></li>
<li><strong>G1：写屏障 + SATB</strong></li>
<li><strong>ZGC：读屏障</strong></li>
</ul>
<p>工程实现中，读写屏障还有其他功能，比如写屏障可以用于记录跨代&#x2F;区引用的变化，读屏障可以用于支持移动对象的并发执行等。功能之外，还有性能的考虑，所以对于选择哪种，每款垃圾回收器都有自己的想法。</p>
<blockquote>
<p>值得注意的是，CMS中使用的增量更新，在重新标记阶段，除了需要遍历 写屏障的记录，还需要重新扫描遍历GC Roots（当然标记过的无需再遍历了），这是由于CMS对于astore_x等指令不添加写屏障的原因，具体可参考<a href="https://links.jianshu.com/go?to=https://hllvm-group.iteye.com/group/topic/44529">这里</a>。</p>
</blockquote>
<hr>
<p>转载自：<a href="https://www.jianshu.com/u/b5a7e092f589">https://www.jianshu.com/u/b5a7e092f589</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>集合间互相转化</title>
    <url>/2024/03/05/Java/Java%E6%8F%90%E9%AB%98/%E9%9B%86%E5%90%88%E9%97%B4%E4%BA%92%E7%9B%B8%E8%BD%AC%E5%8C%96/</url>
    <content><![CDATA[<p>[toc]<br>Java8之前集合之间互相转化，例如List -&gt; Map需要写许多代码，但是Java8之后可以使用Lambda表达式简化代码。<br>示例：</p>
<h1 id="1-List-Map"><a href="#1-List-Map" class="headerlink" title="1.List&lt;T&gt; ---&gt; Map&lt;K, V&gt;"></a>1.<code>List&lt;T&gt; ---&gt; Map&lt;K, V&gt;</code></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream().collect(</span><br><span class="line">        Collectors.toMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String e)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String e)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> e.hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例中，Collectors.toMap接收两个Function参数，第一个Function是生成key，第二个Function是生成value，两个Function&lt;T，X&gt;的第一个泛型参数类型是对应的list的类型，这里即是String。</p>
<p>使用Lambda表达式简化后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream().collect(</span><br><span class="line">        Collectors.toMap(e -&gt; e, e -&gt; e.hashCode())); </span><br></pre></td></tr></table></figure>

<span id="more"></span> 

<h1 id="2-List-Map"><a href="#2-List-Map" class="headerlink" title="2.List&lt;T&gt; ---&gt; Map&lt;K, List&lt;T&gt;&gt;"></a>2.<code>List&lt;T&gt; ---&gt; Map&lt;K, List&lt;T&gt;&gt;</code></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;zero&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; map = list.stream().collect(</span><br><span class="line">        Collectors.groupingBy(e -&gt; e.length()));</span><br><span class="line"><span class="comment">//&#123;4=[zero], 5=[world, hello]&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-List-List"><a href="#3-List-List" class="headerlink" title="3.List&lt;T&gt; ---&gt; List&lt;R&gt;"></a>3.<code>List&lt;T&gt; ---&gt; List&lt;R&gt;</code></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;zero&quot;</span>, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line">List&lt;Integer&gt; list2 = list.stream().map(e -&gt; e.hashCode()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//[3735208, 3329]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="4-List-Set"><a href="#4-List-Set" class="headerlink" title="4.List&lt;T&gt; ---&gt; Set&lt;R&gt;"></a>4.<code>List&lt;T&gt; ---&gt; Set&lt;R&gt;</code></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;zero&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">Set&lt;Integer&gt; set = list.stream().map(e -&gt; e.length()).collect(Collectors.toSet());</span><br><span class="line"><span class="comment">//[4, 5]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>Java提高</category>
      </categories>
  </entry>
  <entry>
    <title>内存溢出的几种原因和解决办法</title>
    <url>/2024/04/01/Java/JVM/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><strong>java.lang.OutOfMemoryError: …java heap space…</strong></p>
<p>也就是当你看到heap相关的时候就肯定是堆栈溢出了，此时如果代码没有问题的情况下，适当调整-Xmx和-Xms是可以避免的，不过一定是代码没有问题的前提，为什么会溢出呢，要么代码有问题，要么访问量太多并且每个访问的时间太长或者数据太多，导致数据释放不掉，因为垃圾回收器是要找到那些是垃圾才能回收，这里它不会认为这些东西是垃圾，自然不会去回收了；主意这个溢出之前，可能系统会提前先报错关键字为：</p>
<p><code>java.lang.OutOfMemoryError:GC over head limit exceeded</code></p>
<p>这种情况是当系统处于高频的GC状态，而且回收的效果依然不佳的情况，就会开始报这个错误，这种情况一般是产生了很多不可以被释放的对象，有可能是引用使用不当导致，或申请大对象导致，但是java heap space的内存溢出有可能提前不会报这个错误，也就是可能内存就直接不够导致，而不是高频GC.</p>
<span id="more"></span>



<p><strong>java.lang.OutOfMemoryError: PermGen space</strong></p>
<p>原因：系统的代码非常多或引用的第三方包非常多、或代码中使用了大量的常量、或通过intern注入常量、或者通过动态代码加载等方法，导致常量池的膨胀，虽然JDK 1.5以后可以通过设置对永久带进行回收，但是我们希望的是这个地方是不做GC的，它够用就行，所以一般情况下今年少做类似的操作，所以在面对这种情况常用的手段是：增加-XX:PermSize和-XX:MaxPermSize的大小。</p>
<p><strong>java.lang.OutOfMemoryError: Direct buffer memory</strong><br>如果你在直接或间接使用了ByteBuffer中的allocateDirect方法的时候，而不做clear的时候就会出现类似的问题，常规的引用程序IO输出存在一个内核态与用户态的转换过程，也就是对应直接内存与非直接内存，如果常规的应用程序你要将一个文件的内容输出到客户端需要通过OS的直接内存转换拷贝到程序的非直接内存（也就是heap中），然后再输出到直接内存由操作系统发送出去，而直接内存就是由OS和应用程序共同管理的，而非直接内存可以直接由应用程序自己控制的内存，jvm垃圾回收不会回收掉直接内存这部分的内存，所以要注意了哦。</p>
<p><strong>java.lang.StackOverflowError</strong></p>
<p>这个参数直接说明一个内容，就是-Xss太小了，我们申请很多局部调用的栈针等内容是存放在用户当前所持有的线程中的，线程在jdk 1.4以前默认是256K，1.5以后是1M，如果报这个错，只能说明-Xss设置得太小，当然有些厂商的JVM不是这个参数，本文仅仅针对Hotspot VM而已；不过在有必要的情况下可以对系统做一些优化，使得-Xss的值是可用的。</p>
<p><strong>java.lang.OutOfMemoryError: unable to create new native thread</strong></p>
<p>上面第四种溢出错误，已经说明了线程的内存空间，其实线程基本只占用heap以外的内存区域，也就是这个错误说明除了heap以外的区域，无法为线程分配一块内存区域了，这个要么是内存本身就不够，要么heap的空间设置得太大了，导致了剩余的内存已经不多了，而由于线程本身要占用内存，所以就不够用了，说明了原因，如何去修改，不用我多说，你懂的。</p>
<p><strong>java.lang.OutOfMemoryError: request {} byte for {}out of swap</strong></p>
<p>这类错误一般是由于地址空间不够而导致。</p>
<p>六大类常见溢出已经说明JVM中99%的溢出情况，要逃出这些溢出情况非常困难，除非一些很怪异的故障问题会发生，比如由于物理内存的硬件问题，导致了code cache的错误（在由byte code转换为native code的过程中出现，但是概率极低），这种情况内存 会被直接crash掉，类似还有swap的频繁交互在部分系统中会导致系统直接被crash掉，OS地址空间不够的话，系统根本无法启动，呵呵；JNI的滥用也会导致一些本地内存无法释放的问题，所以尽量避开JNI；socket连接数据打开过多的socket也会报类似：IOException: Too many open files等错误信息。</p>
<p>JNI就不用多说了，尽量少用，除非你的代码太牛B了，我无话可说，呵呵，这种内存如果没有在被调用的语言内部将内存释放掉（如C语言），那么在进程结束前这些内存永远释放不掉，解决办法只有一个就是将进程kill掉。</p>
<p>另外GC本身是需要内存空间的，因为在运算和中间数据转换过程中都需要有内存，所以你要保证GC的时候有足够的内存哦，如果没有的话GC的过程将会非常的缓慢。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Redis Sentinel哨兵机制</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/Redis/Redis%20Sentinel%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="什么是redis-sentinel"><a href="#什么是redis-sentinel" class="headerlink" title="什么是redis sentinel"></a>什么是redis sentinel</h1><p>哨兵在redis集群架构中是一个非常重要的组件，其主要功能有下面这些：</p>
<ul>
<li>集群监控，即时刻监控着redis的master和slave进程是否是在正常工作。</li>
<li>消息通知，就是说当它发现有redis实例有故障的话，就会发送消息给管理员</li>
<li>故障自动转移，如果redis master 节点宕机了的话，它就会将请求转到slave 节点上，slave升为master。</li>
<li>充当配置中心，如果发生了故障转移，它会通知将master的新地址写在配置中心告诉客户端。</li>
</ul>
<p>&emsp;&emsp;<br>sentinel 本身也是分布式部署的，是一个集群去运行的并且节点间相互协调工作，那它是怎么来监控redis的呢？</p>
<blockquote>
<ol>
<li>当发生故障转移的时候，只有大部分哨兵节点同意(选主)才会判断你这个master是真的宕机</li>
<li>如果哨兵部分节点挂了的话，整个哨兵集群依然能工作，这也是确保自身能高可用</li>
</ol>
</blockquote>
<p>哨兵集群至少要 3 个节点，来确保自己的健壮性;redis主从 + sentinel的架构，是不会保证数据的零丢失的，它是为了保证redis集群的高可用。</p>
<span id="more"></span>
<h1 id="三个监控任务"><a href="#三个监控任务" class="headerlink" title="三个监控任务"></a>三个监控任务</h1><p>哨兵节点通过三个定时监控任务监控 Redis 数据节点的服务可用性。</p>
<h2 id="①info-命令"><a href="#①info-命令" class="headerlink" title="①info 命令"></a>①info 命令</h2><img src='https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171057727.webp'>

<p>每隔 10 秒，每个哨兵节点都会向主、从 Redis 数据节点发送 info 命令，获取新的拓扑结构信息。Redis 拓扑结构信息包括了：</p>
<blockquote>
<p>本节点角色：主或从<br>主从节点的地址、端口信息</p>
</blockquote>
<p>这样，哨兵节点就能从 info 命令中自动获取到从节点信息，因此那些后续才加入的从节点信息不需要显式配置就能自动感知。</p>
<h2 id="②向-sentinel-hello-频道同步信息"><a href="#②向-sentinel-hello-频道同步信息" class="headerlink" title="②向 __sentinel__:hello 频道同步信息"></a>②向 <code>__sentinel__:hello</code> 频道同步信息</h2><p>通过redis的pub&#x2F;sub，每隔 2 秒，每个哨兵节点将会向 Redis 数据节点的<code>__sentinel__:hello</code> 这个channel里同步自身得到的主节点信息以及当前哨兵节点的信息。<br>由于其他哨兵节点也订阅了这个channel，因此实际上这个操作可以交换哨兵节点之间关于主节点以及哨兵节点的信息。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171102920.webp" alt="图片"></p>
<p>这一操作实际上完成了两件事情：</p>
<blockquote>
<p>发现新的哨兵节点：如果有新的哨兵节点加入，此时保存下来这个新哨兵节点的信息，后续与该哨兵节点建立连接。<br>交换主节点的状态信息，作为后续客观判断主节点下线的依据。</p>
</blockquote>
<h2 id="③向数据节点做心跳探测"><a href="#③向数据节点做心跳探测" class="headerlink" title="③向数据节点做心跳探测"></a>③向数据节点做心跳探测</h2><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171102181.webp" alt="图片"></p>
<p>每隔 1 秒，每个哨兵节点向主、从数据节点以及其他 Sentinel 节点发送 Ping 命令做心跳探测，这个心跳探测是后续主观判断数据节点下线的依据。</p>
<p>&emsp;&emsp;</p>
<h1 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h1><h2 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h2><p>上面三个监控任务中的第三个探测心跳任务，如果在配置的 down-after-milliseconds 之后没有收到有效回复，那么就认为该数据节点“主观下线（sdown）”。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171102335.webp" alt="图片"></p>
<p>为什么称为“主观下线”？因为在一个分布式系统中，有多个机器在一起联动工作，网络可能出现各种状况，仅凭一个节点的判断还不足以认为一个数据节点下线了，这就需要后面的“客观下线”。</p>
<h2 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h2><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171103672.jpeg" alt="图片"></p>
<p>当一个哨兵节点认为主节点主观下线时，该哨兵节点需要通过”sentinel is-master-down-by addr”命令向其他哨兵节点咨询该主节点是否下线了，如果有超过半数的哨兵节点都回答了下线，此时认为主节点“客观下线”。</p>
<p>&emsp;&emsp;</p>
<h1 id="切主流程"><a href="#切主流程" class="headerlink" title="切主流程"></a>切主流程</h1><h2 id="选举哨兵领导者"><a href="#选举哨兵领导者" class="headerlink" title="选举哨兵领导者"></a>选举哨兵领导者</h2><p>当主节点客观下线时，需要选举出一个哨兵节点做为哨兵领导者，以完成后续选出新的主节点的工作。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171103439.webp" alt="图片">这个选举的大体思路是：</p>
<blockquote>
<ol>
<li>每个哨兵节点通过向其他哨兵节点发送”sentinel is-master-down-by addr”命令来申请成为哨兵领导者。</li>
<li>而每个哨兵节点在收到一个”sentinel is-master-down-by addr”命令时，只允许给第一个节点投票，其他节点的该命令都会被拒绝。</li>
<li>如果一个哨兵节点收到了半数以上的同意票，则成为哨兵领导者。</li>
<li>如果前面三步在一定时间内都没有选出一个哨兵领导者，将重新开始下一次选举。</li>
</ol>
</blockquote>
<p>可以看到，这个选举领导者的流程很像 Raft 中选举 Leader 的流程。</p>
<p>&emsp;&emsp;</p>
<h2 id="选出新的主节点"><a href="#选出新的主节点" class="headerlink" title="选出新的主节点"></a>选出新的主节点</h2><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171103592.jpeg" alt="图片"></p>
<p>在剩下的 Redis 从节点中，按照以下顺序来选择新的主节点：</p>
<blockquote>
<ul>
<li>过滤掉“不健康”的数据节点：比如主观下线、断线的从节点、五秒内没有回复过哨兵节点 Ping 命令的节点、与主节点失联的从节点。</li>
<li>选择 Slave-Priority（从节点优先级）最高的从节点，如果存在则返回，不存在则继续后面的流程。</li>
<li>选择复制偏移量最大的从节点，这意味着这个从节点上面的数据最完整，如果存在则返回，不存在则继续后面的流程。</li>
<li>到了这里，所有剩余从节点的状态都是一样的，选择 runid 最小的从节点。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="提升新的主节点"><a href="#提升新的主节点" class="headerlink" title="提升新的主节点"></a>提升新的主节点</h2><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171103618.webp" alt="图片"></p>
<p>选择了新的主节点之后，还需要最后的流程让该节点成为新的主节点：</p>
<blockquote>
<ul>
<li>哨兵领导者向上一步选出的从节点发出“slaveof no one”命令，让该节点成为主节点。</li>
<li>哨兵领导者向剩余的从节点发送命令，让它们成为新主节点的从节点。</li>
<li>哨兵节点集合会将原来的主节点更新为从节点，当其恢复之后命令它去复制新的主节点的数据。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
<h1 id="主备切换中的数据丢失问题"><a href="#主备切换中的数据丢失问题" class="headerlink" title="主备切换中的数据丢失问题"></a>主备切换中的数据丢失问题</h1><h2 id="1-主从异步复制导致的数据丢失"><a href="#1-主从异步复制导致的数据丢失" class="headerlink" title="1. 主从异步复制导致的数据丢失"></a>1. 主从异步复制导致的数据丢失</h2><p>redis master 和slave 数据复制是异步的，和的MySQL差不多，这样就有可能会出现部分数据还没有复制到slave中，master就挂掉了，那么这部分的数据就会丢失了。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171104604.webp" alt="img"></p>
<h2 id="2-脑裂导致的数据丢失"><a href="#2-脑裂导致的数据丢失" class="headerlink" title="2. 脑裂导致的数据丢失"></a>2. 脑裂导致的数据丢失</h2><p>脑裂其实就是网络分区导致的现象，比如，master机器网络突然不正常了发生了网络分区，和其他的slave机器不能正常通信了，其实master并没有挂，但是哨兵会认为master挂掉了，client可能还在继续写master，还没来得及更新到新的master，那这部分数据就会丢失。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171057191.png" alt="img"></p>
<p>上面的两个数据丢失的问题，那该怎么去解决呢？其实也很简单，只需要在配置中加两个配置就行了，如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 1 # 要求至少一个slave</span><br><span class="line">min-slaves-max-lag 10 # 数据复制和同步的延迟不能超过10s</span><br></pre></td></tr></table></figure>
<p>来分析下，加上了这两个配置是怎么解决数据丢失问题的。核心思想就是：一旦所有的slave节点，在数据复制和同步时延迟了超过10秒的话，那么master它就不会再接客户端的请求了，这样就会有效减少大量数据丢失的发生。</p>
<h2 id="如何减少异步复制数据的丢失"><a href="#如何减少异步复制数据的丢失" class="headerlink" title="如何减少异步复制数据的丢失"></a><strong>如何减少异步复制数据的丢失</strong></h2><p>当slave在数据复制的时候，发现返回的ACK时延太长达到了 min-slaves-max-lag 配置，这个时候就会认为如果master宕机就会导致大量数据丢失，所以就提前进行了预测，就不再去接收客户端的任何请求了，来将丢失的数据降低在可控范围内。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171057295.png" alt="img"></p>
<h2 id="减少脑裂数据的丢失"><a href="#减少脑裂数据的丢失" class="headerlink" title="减少脑裂数据的丢失"></a><strong>减少脑裂数据的丢失</strong></h2><ol>
<li>如果master出现了脑裂，和其他的slave失去了通信，不能继续给指定数量的slave发送数据。</li>
<li>slave超过10秒没有给自己返回ack消息。</li>
<li>master就会拒绝客户端的写请求</li>
</ol>
<hr>
<p>转载自：<br><a href="https://zhuanlan.zhihu.com/p/95678924">https://zhuanlan.zhihu.com/p/95678924</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&mid=2655824267&idx=1&sn=dfe90cb364d884a6197a1621cf553786&chksm=bd74e45c8a036d4abc741237c65c80ca5a0f3bd976e6c5ebe077dc2e517fccba4d07b8a0b7bf&xtrack=1&scene=90&subscene=93&sessionid=1557915135&clicktime=1557915141&ascene=56&devicetype=android-27&version=2700043a&nettype=WIFI&abtest_cookie=BAABAAoACwASABMABQAjlx4AyZkeANyZHgD1mR4AAJoeAAAA&lang=zh_CN&pass_ticket=ej3eAEgovFuxG01K43k1aKaxiH6Ze9CZOQaEU9Fz4zUyLRvpG06zHSJ/BG9uj0K8&wx_header=1">https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655824267&amp;idx=1&amp;sn=dfe90cb364d884a6197a1621cf553786&amp;chksm=bd74e45c8a036d4abc741237c65c80ca5a0f3bd976e6c5ebe077dc2e517fccba4d07b8a0b7bf&amp;xtrack=1&amp;scene=90&amp;subscene=93&amp;sessionid=1557915135&amp;clicktime=1557915141&amp;ascene=56&amp;devicetype=android-27&amp;version=2700043a&amp;nettype=WIFI&amp;abtest_cookie=BAABAAoACwASABMABQAjlx4AyZkeANyZHgD1mR4AAJoeAAAA&amp;lang=zh_CN&amp;pass_ticket=ej3eAEgovFuxG01K43k1aKaxiH6Ze9CZOQaEU9Fz4zUyLRvpG06zHSJ%2FBG9uj0K8&amp;wx_header=1</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 单机模式，主从模式，哨兵模式(sentinel)，集群模式(cluster)优缺点分析</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/Redis/Redis%20%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F(sentinel)%EF%BC%8C%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F(cluster)%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Redis 的几种常见使用方式包括：</p>
<ul>
<li>单机模式</li>
<li>主从模式</li>
<li>哨兵模式(sentinel)</li>
<li>集群模式(cluster)</li>
<li>第三方模式</li>
</ul>
<p>&emsp;&emsp;</p>
<h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p>
<p><strong>优点：</strong></p>
<ol>
<li>架构简单，部署方便。</li>
<li>高性价比：缓存使用时无需备用节点(单实例可用性可以用 supervisor 或 crontab 保证)，当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务。</li>
<li>高性能。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>不保证数据的可靠性。</li>
<li>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务。</li>
<li>高性能受限于单核 CPU 的处理能力(Redis 是单线程机制)，CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。</li>
</ol>
 <span id="more"></span>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>Redis 采用主从(可以多从)部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，可以实现同时对外提供服务和读写分离策略。</p>
<p><strong>优点：</strong></p>
<ol>
<li>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行;另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题。</li>
<li>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>故障恢复复杂，如果没有 RedisHA 系统(需要开发)，当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐。</li>
<li>主库的写能力受到单机的限制，可以考虑分片。</li>
<li>主库的存储能力受到单机的限制，可以考虑 Pika。</li>
<li>原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿; 又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机; 主库节点生成备份文件导致服务器磁盘 IO 和 CPU(压缩)资源消耗; 发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</li>
</ol>
<p>&emsp;&emsp;</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Redis Sentinel 是 2.8 版本后推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1(n&gt;&#x3D;1)的奇数个。</p>
<p><strong>优点：</strong></p>
<ol>
<li>Redis Sentinel 集群部署简单。</li>
<li>能够解决 Redis 主从模式下的高可用切换问题。</li>
<li>很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求。</li>
<li>可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>部署相对 Redis 主从模式要复杂一些，原理理解更繁琐。</li>
<li>资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供服务。</li>
<li>Redis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。</li>
<li>不能解决读写分离问题，实现起来相对复杂。</li>
</ol>
<p>&emsp;&emsp;</p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>Redis Cluster 是 3.0 版后推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。Redis Cluster 集群节点最小配置 6 个节点以上(3 主 3 从)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p>
<p><strong>优点：</strong></p>
<ol>
<li>无中心架构。</li>
<li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除。</li>
<li>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升。</li>
<li>降低运维成本，提高系统的扩展性和可用性。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</li>
<li>节点会因为某些原因发生阻塞(阻塞时间大于 clutser-node-timeout)，被判断下线，这种 failover 是没有必要的。</li>
<li>数据通过异步复制，不保证数据的强一致性。</li>
<li>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</li>
<li>Slave 在集群中充当“冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。</li>
<li>Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。</li>
<li>Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。</li>
<li>Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。</li>
<li>不支持多数据库空间，单机下的 redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</li>
<li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li>
<li>避免产生 hot-key，导致主库节点成为系统的短板。</li>
<li>避免产生 big-key，导致网卡撑爆、慢查询等。</li>
<li>重试时间应该大于 cluster-node-time 时间。</li>
<li>Redis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。</li>
</ol>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/lipei1220/article/details/111823684">https://blog.csdn.net/lipei1220/article/details/111823684</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis持久化之RDB和AOF</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB%E5%92%8CAOF/</url>
    <content><![CDATA[<p>[toc]<br>&emsp;&emsp;Redis的强劲性能很大程度上是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中以某种形式同步到硬盘中，这一过程就是持久化。<br>&emsp;&emsp;Redis支持两种方式的持久化，一种是<code>RDB（Redis DataBase）</code>方式，一种是<code>AOF（Append Only File）</code>方式。可以单独使用其中一种或将二者结合使用。RDB可以理解是基于全量模式的持久化，AOF是基于增量模式的持久化。</p>
 <span id="more"></span>

<h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><p>&emsp;&emsp;RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间和改动的键的个数。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。<br>&emsp;&emsp;RDB是Redis默认采用的持久化方式。打开 <code>redis.conf</code> 文件，找到 SNAPSHOTTING 对应内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>save &lt;指定时间间隔&gt; &lt;执行指定次数更新操作&gt;</code>，满足条件就将内存中的数据同步到硬盘中。官方出厂配置默认是 900秒内有1个更改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的数据快照写入磁盘。<br>&emsp;&emsp;默认的rdb文件路径是当前目录,文件名是<code>dump.rdb</code>,可以在配置文件中修改路径和文件名,分别是dir和dbfilename</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir ./ # rdb文件存储路径</span><br><span class="line">dbfilename dump.rdb # rdb文件名</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果没有触发自动快照,需要对Redis执行手动快照操作,<code>SAVE</code>和<code>BGSAVE</code>命令来手动快照,两个命令的区别是前者是由主进程进行快照,会阻塞其他请求,后者是通过fork子进程进行快照。<br>&emsp;&emsp;注意:由于Redis使用fork来复制一份当前进程,那么子进程就会占有和主进程一样的内存资源,比如说主进程8G内存,那么在备份的时候,必须保证有16G的内存,要不然会启用虚拟内存,性能非常的差。</p>
<h4 id="快照的过程"><a href="#快照的过程" class="headerlink" title="快照的过程"></a>快照的过程</h4><p>（1）Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；<br>（2）父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；<br>（3）当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。 </p>
<p>&emsp;&emsp;在执行fork的时候操作系统会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。<br>&emsp;&emsp;通过上述过程可以发现Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得可以通过定时备份RDB文件来实现Redis数据库备份。<br>&emsp;&emsp;RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。Redis默认是开启压缩的。<br>&emsp;&emsp;Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。<br>&emsp;&emsp;通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。</p>
<p><strong>核心思路</strong>：fork一个子进程，只有在父进程发生写操作修改内存数据时，才会真正去分配内存空间，并复制内存数据，而且也只是复制被修改的内存页中的数据，并不是全部内存数据；</p>
<ul>
<li>Redis中执行BGSAVE命令生成RDB文件时，本质就是调用Linux中的fork()命令，Linux下的fork()系统调用实现了copy-on-write写时复制；</li>
<li>fork()是类Unix操作系统上创建线程的主要方法，fork用于<strong>创建子进程</strong>（等同于当前进程的副本）；</li>
<li>copy-on-write技术，在fork出子进程后，与父进程共享内存空间，两者只是虚拟空间不同，但是其对应的物理空间是同一个；</li>
<li>fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。之后主进程使用复制的内存页，子进程还是用之前的内存页。</li>
</ul>
<blockquote>
<p>CopyOnWrite的好处：<br>     1、减少分配和复制资源时带来的瞬时延迟；<br>     2、减少不必要的资源分配；<br>CopyOnWrite的缺点：<br>     1、如果父子进程都需要进行大量的写操作，会产生大量的分页错误（页异常中断page-fault）;</p>
</blockquote>
<h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><p>&emsp;&emsp;RDB 持久化触发分为手动和自动两种方式，其中手动方式有两种：save 命令和 bgsave 命令。</p>
<blockquote>
<ul>
<li>save 命令：阻塞 Redis 服务，直到整个 RDB 持久化完成。RDB 是全量持久化，如果内存的数据量大，则造成长时间的阻塞，这样势必会影响业务。所以一般不推荐采用这种方式。</li>
<li>bgsave 命令：该模式下的 RDB 持久化由子进程完成.Redis 进程接收到该命令后，会 fork 操作创建一个子进程,持久化过程由子进程完成。Redis 服务阻塞只会发生在 fork 阶段，而且该阶段时间过程一般都会很短。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;自动触发的方式是：<code>save m n</code>。该方式在 redis.conf 中进行了说明，m 表示“间隔时间”，n 表示 “变更次数”，只有同时符合这两个条件才会触发，否则“变更次数”会被继续累加到下一个“间隔时间”上。同时，该方式也不会阻塞。</p>
<h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p>&emsp;&emsp;AOF(append only file)持久化是以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。<br>&emsp;&emsp;默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes </span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改。<br>&emsp;&emsp;AOF的工作流程操作有：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）。</p>
<h4 id="AOF流程"><a href="#AOF流程" class="headerlink" title="AOF流程"></a>AOF流程</h4><p>1） 所有的写入命令会追加到aof_buf（缓冲区）中。<br>2） AOF缓冲区根据对应的策略向硬盘做同步操作。<br>3） 随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。<br>4） 当Redis服务重启时，可以加载AOF文件进行数据恢复。</p>
<h5 id="命令写入"><a href="#命令写入" class="headerlink" title="命令写入"></a>命令写入</h5><p>&emsp;&emsp;AOF命令写入的内容直接是文本协议格式。AOF文件是纯文本文件，其内容正是Redis客户端向Redis发送的原始通信协议的内容。例如set hello world 这条命令，在AOF缓冲区会追加如下文本：<br><code>\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n</code><br>&emsp;&emsp;介绍关于AOF的连个疑惑：<br>&emsp;&emsp;1） AOF为什么直接采用文本协议格式？可能的理由如下：<br>&emsp;&emsp; •	文本协议具有很好的兼容性。<br>&emsp;&emsp; •	开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免二次处理开销。<br>&emsp;&emsp; •	文本协议具有可读性，方便直接修改和处理。<br>&emsp;&emsp;2） AOF为什么把命令追加到aof_buf中？Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。</p>
<h5 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h5><p>&emsp;&emsp;虽然每次执行更改数据库内容的操作时，AOF都会将命令记录在AOF文件中，但是事实上，由于操作系统的缓存机制，数据并没有真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每30秒会执行一次同步操作，以便将硬盘缓存中的内容真正地 写入硬盘，在这30秒的过程中如果系统异常退出则会导致硬盘缓存中的数据丢失。一般来讲启用AOF持久化的应用都无法容忍这样的损失，这就需要Redis在写入AOF文件后主动要求系统将缓存内容同步到硬盘中。<br>&emsp;&emsp;Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># appendfsync always 每次都同步(最安全但是最慢)</span><br><span class="line">appendfsync everysec 每秒同步(默认的同步策略)</span><br><span class="line"># appendfsync no 不主动同步,由操作系统来决定(最快但是不安全)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;配置为<code>always</code>时，每次写入都要同步AOF文件，在一般的STAT硬盘上，Redis只能支持大约几百TPS写入，这是最安全也是最慢的方式，显然跟Redis高性能特性背道而驰，不建议配置。<br>&emsp;&emsp;配置为<code>no</code>,由于操作系统每次同步AOF文件的周期，（即每30秒一次），而且会极大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。<br>&emsp;&emsp;配置为<code>everysec</code>,是建议的同步策略，也是默认配置，做到兼顾性能和数据安全性，理论上只有在系统突然宕机的情况下丢失1s的数据。（严格来说最多丢失1s数据是不准确）</p>
<h5 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h5><p>&emsp;&emsp;随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。<br>&emsp;&emsp;重写后的AOF文件为什么可以变小？有如下原因：<br>&emsp;&emsp;1）进程内已经超时的数据不再写文件。<br>&emsp;&emsp;2）旧的AOF文件含有无效命令，如del key1、set a 111、set a 222等。重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。<br>&emsp;&emsp;3) 多条写命令可以合并为一个，如lpush list a、lpush list b、 lpush list c 可以转化为：lpush list a b c。为了防止合并的数据过大造成客户端缓冲区溢出，对于list、set、hash、zset等类型，以64个元素为界拆分为多条。<br>&emsp;&emsp;<br>&emsp;&emsp;AOF重写降低了文件占用空间，除此之外，另一个目的是：更小的AOF文件可以更快地被Redis加载。<br>&emsp;&emsp;AOF重写过程可以手动触发和自动触发：</p>
<blockquote>
<p>手动触发：直接调用 bgrewriteaof 命令<br>自动触发：根据<code>auto-aof-rewrite-min-size</code>和<code>auto-aof-rewrite-percentage</code>参数确定自动触发时机</p>
<blockquote>
<p>auto-aof-rewrite-min-size: 限制了允许重写的最小AOF文件,通常在AOF文件很小的时候即使其中有些冗余命令也可是可以忽略的。<br>auto-aof-rewrite-percentage: 当前的AOF文件大小超过上一次重写的AOF文件大小的百分之多少时会再次进行重写,如果之前没有重写过,则以启动时的AOF大小为依据。</p>
</blockquote>
</blockquote>
<p>&emsp;&emsp;注意，执行AOF重写请求时，父进程依然响应命令，Redis使用”AOF重写缓冲区”保存这部分新数据，防止新AOF文件生成期间丢失这部分数据。</p>
<p>&emsp;&emsp;文件重写流程如下（参考 《Redis 开发与运维》）：<br><img src='https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407141152178.png'><br>&emsp;&emsp;1. Redis 服务接收到 bgrewriteaof 命令的时候，会做两步检查。</p>
<blockquote>
<p>如果当前进程正在执行 AOF 重写，则直接返回。<br>如果有进程正在执行 bgsave，那么需要等待 bgsave 执行完毕后再执行 AOF 重写。</p>
</blockquote>
<p>&emsp;&emsp;2. Redis 进程会 fork 一个子进程执行 AOF 重写，成功后，Redis 服务继续响应命令，不会影响 Redis 原有的 AOF 流程（即命令写入 aof_buf 缓冲区和缓冲区的数据刷进硬盘）。<br>&emsp;&emsp;3. 在子进程重写过程中，Redis 主进程会将收到的命令也会写入 <strong>AOF 重写缓冲区</strong>（即命令写入  aof_buf 缓冲区 和 AOF 重写缓冲区），这个缓冲区和 aof_buf 缓冲区不一样，需要区分，这样做的目的是为了防止重写过程中数据的丢失。<br>&emsp;&emsp;4. 由于使用写时复制技术（copy-on-write），子进程只能拿到父进程在 fork 子进程时刻的文件进行重写。子进程根据内存快照，按照命令重写规则将命令重写到新的文件中。这里需要注意的是每次写入硬盘的数据量不能太大，否则容易导致硬盘阻塞，该值由 aof-rewrite-incremental-fsync 控制，默认为 32M。<br>&emsp;&emsp;5. 子进程完成 AOF 重写后会给发消息给 Redis 主进程，主进程则会将 AOF 重写缓冲区的数据追加写进新的文件，然后用新的 AOF 文件 替换老的文件。当然，在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。<br>&emsp;&emsp;6. 完成 AOF 重写。</p>
<ul>
<li><strong>为什么AOF重写不复用原AOF日志</strong>？</li>
</ul>
<p>两方面原因：</p>
<ol>
<li>父子进程写同一个文件会产生竞争问题，影响父进程的性能。</li>
<li>如果AOF重写过程中失败了，相当于污染了原本的AOF文件，无法做恢复数据使用。</li>
</ol>
<h5 id="重启加载"><a href="#重启加载" class="headerlink" title="重启加载"></a>重启加载</h5><p>&emsp;&emsp;AOF和RDB文件都可以用于服务器重启时的数据恢复。AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF&#x2F;RDB文件城后，Redis启动成功；AOF&#x2F;RDB文件存在错误时，Redis启动失败并打印错误信息。</p>
<h3 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h3><h4 id="RDB-的优缺点"><a href="#RDB-的优缺点" class="headerlink" title="RDB 的优缺点"></a>RDB 的优缺点</h4><p>优点：<br>&emsp;&emsp;1 适合大规模的数据恢复。<br>&emsp;&emsp;2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。<br>&emsp;&emsp;3 RDB 文件是一个非常紧凑的二进制文件，所以加载的速度回快于 AOF 方式<br>&emsp;&emsp;4 RDB 文件代表着 Redis 服务器的某一个时刻的全量数据，所以它非常适合做冷备份和全量复制的场景</p>
<p>缺点：<br>&emsp;&emsp;1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。<br>&emsp;&emsp;2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件。<br>&emsp;&emsp;3 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p>所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。</p>
<h4 id="AOF-的优缺点"><a href="#AOF-的优缺点" class="headerlink" title="AOF 的优缺点"></a>AOF 的优缺点</h4><p>优点：数据的完整性和一致性更高<br>缺点：对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;RDB与AOF二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。<br>&emsp;&emsp;Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/cool_summer_moon/article/details/80525302">https://blog.csdn.net/cool_summer_moon/article/details/80525302</a><br><a href="https://blog.csdn.net/rickiyeat/article/details/53610535">https://blog.csdn.net/rickiyeat/article/details/53610535</a><br><a href="https://blog.csdn.net/a1007720052/article/details/79126253">https://blog.csdn.net/a1007720052/article/details/79126253</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>记一次线上数据库死锁定位</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/MySQL/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>在开发过程中，操作数据库总会涉及到批量操作。有些批量操作可以利用multiquery更新数据库，但有些不可，例如对于同一张表不同字段的多行更新。我们经常会把这种操作放到一个事务里面，由于都是按照主键更新，所以性能上不会有大问题，例如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(List&lt;DAO&gt; daoList)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (DAO dao : daoList) &#123;</span><br><span class="line">        daoMapper.updateByPrimaryKeySelective(dao);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <span id="more"></span>

<p>但是如果不注意的话，会出现数据库死锁，利用MySql自带的innodb引擎监控日志（show engine innodb status）,看到最近的死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2017-09-28 00:19:24 0x7f70134b1700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 205776344, ACTIVE 71 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1136, 7 row lock(s), undo log entries 85</span><br><span class="line">MySQL thread id 2552, OS thread handle 140118527325952, query id 17080031 xxx.xx.xx.xxx sql</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 15 page no 135560 n bits 200 index PRIMARY of table `db`.`table` trx id 205776344 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 67 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030313032315354463132333833373937; asc 170928001021STF12383797;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 30000008370881; asc 0   7  ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 205775866, ACTIVE 129 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">7 lock struct(s), heap size 1136, 93 row lock(s), undo log entries 149</span><br><span class="line">MySQL thread id 2544, OS thread handle 140119336752896, query id 17080690 xxx.xx.xx.xxx sql</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 15 page no 135560 n bits 200 index PRIMARY of table `afbet`.`t_facts_market_stateful_messages` trx id 205775866 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303930395354463132333833303738; asc 170928000909STF12383078;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Record lock, heap no 9 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303931305354463132333833303837; asc 170928000910STF12383087;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Record lock, heap no 12 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303931345354463132333833313037; asc 170928000914STF12383107;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 30000008371103; asc 0   7  ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Record lock, heap no 14 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303931345354463132333833313336; asc 170928000914STF12383136;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 30000008370ad3; asc 0   7  ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Record lock, heap no 15 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303931365354463132333833313332; asc 170928000916STF12383132;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 3000000837103d; asc 0   7 =;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Record lock, heap no 16 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303931385354463132333833313934; asc 170928000918STF12383194;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 300000083708e4; asc 0   7  ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 17 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303932305354463132333833323135; asc 170928000920STF12383215;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 300000083714e1; asc 0   7  ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Record lock, heap no 18 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303932305354463132333833323137; asc 170928000920STF12383217;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 3000000837141b; asc 0   7  ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Record lock, heap no 19 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303932305354463132333833323138; asc 170928000920STF12383218;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 30000008370deb; asc 0   7  ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Record lock, heap no 21 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303932345354463132333833323733; asc 170928000924STF12383273;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 30000008370a0d; asc 0   7  ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Record lock, heap no 67 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030313032315354463132333833373937; asc 170928001021STF12383797;;</span><br><span class="line"> 1: len 6; hex 00000c43e3fa; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 30000008370881; asc 0   7  ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 15 page no 135559 n bits 112 index PRIMARY of table `db`.`table` trx id 205775866 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 39 PHYSICAL RECORD: n_fields 12; compact format; info bits 0</span><br><span class="line"> 0: len 23; hex 3137303932383030303834395354463132333833303332; asc 170928000849STF12383032;;</span><br><span class="line"> 1: len 6; hex 00000c43e5d8; asc    C  ;;</span><br><span class="line"> 2: len 7; hex 2a0000080726b6; asc *    &amp; ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure>
<p>发现有两个Transaction发生死锁</p>
<p><strong>原因</strong>：<br>批量更新，并且每个dao可以多线程更新（在不同事务内同时请求更新），而且没有按照一定顺序。例如事务1更新id为1，2，3的数据，事务2更新id为3，2，1的数据，这样就会发生死锁</p>
<p><strong>修改方案</strong>：<br>按顺序更新，例如把入参改为TreeSet，并且dao对象实现Comparable接口</p>
<hr>
<p>转载自：<br><a href="https://zhanghaoxin.blog.csdn.net/article/details/78255670">https://zhanghaoxin.blog.csdn.net/article/details/78255670</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis主从复制</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<h3 id="一-旧版复制"><a href="#一-旧版复制" class="headerlink" title="一. 旧版复制"></a>一. 旧版复制</h3><p>&emsp;&emsp;Redis 的复制功能分为 <strong>同步（sync）</strong>和 <strong>命令传播（command propagate）</strong> 两个操作。</p>
<p>&emsp;&emsp;同步是从服务器对主服务器发送 SYNC 命令来完成， 以下是 SYNC 命令的执行步骤：</p>
<blockquote>
<p>从服务器连接主服务器，发送SYNC命令；<br>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；<br>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；<br>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；<br>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；<br>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</p>
</blockquote>
<img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171107801.png" width=60% hight=60%>

<p>&emsp;&emsp;命令传播，也可以说是增量复制，主要是指主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。当从服务器执行了相同的写命令之后， 主从服务器将再次回到一致状态。</p>
<span id="more"></span>

<p><strong>同步策略</strong><br>&emsp;&emsp;主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。<br>&emsp;&emsp;旧版本全量复制功能，其最大的问题是从服务器断线重连时，即便在从服务器上已经有一部分数据了，也需要进行全量复制，这样做的效率很低。</p>
<h3 id="二-新版本复制"><a href="#二-新版本复制" class="headerlink" title="二. 新版本复制"></a>二. 新版本复制</h3><p>&emsp;&emsp;在Redis中，从服务器对主服务器的复制可以分为以下两种情况：</p>
<ul>
<li>初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同；</li>
<li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。</li>
</ul>
<p>&emsp;&emsp;对于初次复制来说，旧版复制功能能够很好地完成任务，但对于断线后重复制来说，旧版复制功能虽然也能让主从服务器重新回到一致状态，但效率却非常低。<br>&emsp;&emsp;Redis 2.8 新添加的部分重同步功能可以解决这个问题。使用PSYNC命令代替SYNC命令来执行复制时的同步操作。</p>
<p>&emsp;&emsp;PSYNC命令具有 <strong>完整重同步（full resynchronization）</strong>和 <strong>部分重同步（partial resynchronization）</strong>两种模式：<br>&emsp;&emsp;其中 完整重同步 用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步；<br>&emsp;&emsp;而 部分重同步 则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</p>
<p>&emsp;&emsp;部分重同步 通过复制偏移量、复制积压缓冲区、服务器运行 ID 三个部分来实现。</p>
<p>&emsp;&emsp;<strong>复制偏移量</strong><br>&emsp;&emsp;执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量：</p>
<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值+N；</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值+N；</li>
</ul>
<p>&emsp;&emsp;通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态：如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的；相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171108198.png" width=60% hight=60%></p>
<p>&emsp;&emsp;<strong>复制积压缓冲区</strong><br>&emsp;&emsp;复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。<br>&emsp;&emsp;当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，如图所示。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171108289.png" width=60% hight=60%><br>&emsp;&emsp;因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p>
<ul>
<li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作；</li>
<li>相反，如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<p>&emsp;&emsp;Redis为复制积压缓冲区设置的默认大小为1MB，如果主服务器需要执行大量写命令，又或者主从服务器断线后重连接所需的时间比较长，那么这个大小也许并不合适。如果复制积压缓冲区的大小设置得不恰当，那么PSYNC命令的复制重同步模式就不能正常发挥作用，因此，正确估算和设置复制积压缓冲区的大小非常重要。复制积压缓冲区的最小大小可以根据<code>second*write_size_per_second</code>来估算。</p>
<p>&emsp;&emsp;<strong>服务器运行ID</strong><br>&emsp;&emsp;除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID（run ID）。<br>&emsp;&emsp;每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID；运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3。</p>
<p>&emsp;&emsp;当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来（注意是从服务器保存了主服务器的ID）。当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：</p>
<ul>
<li>如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作；</li>
<li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。</li>
</ul>
<h4 id="Psync-命令流程"><a href="#Psync-命令流程" class="headerlink" title="Psync 命令流程"></a>Psync 命令流程</h4><p>&emsp;&emsp;下面开始分析 Psync 命令的流程：<br>&emsp;&emsp;如果从服务器之前没有复制过任何主服务器，那么从服务器就会向主服务器发送 psync 命令，请求主服务器进行数据的全量同步。<br>&emsp;&emsp;否则，如果前面从服务器已经同步过部分数据，那么从服务器向主服务器发送 <code>psync &lt;runid&gt; &lt;offset&gt;</code>命令，其中 runid 是上一次主服务器的运行 id，offset 是当前从服务器的复制偏移量。</p>
<p>&emsp;&emsp;前面两种情况主服务器收到 Psync 命令之后，会出现以下三种可能：<br>&emsp;&emsp;1. 主服务器返回<code>+fullresync &lt;runid&gt; &lt;offset&gt;</code>回复，表示主服务器要求与从服务器进行完整的数据全量同步操作。其中，runid 是当前主服务器运行 id，而 offset 是当前主服务器的复制偏移量。<br>&emsp;&emsp;2. 如果主服务器应答 <code>+continue</code>，那么表示主服务器与从服务器进行部分数据同步操作，将从服务器缺失的数据同步过来即可。<br>&emsp;&emsp;3. 如果主服务器应答 -err，那么表示主服务器版本低于 2.8，识别不了 Psync 命令，此时从服务器将向主服务器发送 Sync 命令，执行完整的全量数据同步。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/bohu83/article/details/85074845">https://blog.csdn.net/bohu83/article/details/85074845</a> </p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis的线程模型</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/Redis/Redis%20%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>Redis 的线程模型其实是分两块的：</p>
<ul>
<li><p>Redis 6.0 之前的单线程模型。其实从 4.0 开始，Redis 并不是严格意义上的单线程模型，因为 Redis 除了主线程外，也有一些后台的线程或者子进程在处理任务（例如清理脏数据、生成快照、AOF 重写），这个时候大家所说的单线程应该是 Redis 的主线程模型。</p>
</li>
<li><p>Redis 6.0 之后的多线程模型。Redis 在 6.0 之后引入了一种多线程模型，用于处理网络 I&#x2F;O 的任务。</p>
</li>
</ul>
<p>所以，你的回答要涉及这两个方面。</p>
<ul>
<li>Redis 的单线程是指Redis 在执行一次命令时是单线程的。其过程包括「接收客户端请求 -&gt; 解析请求 -&gt;数据读写等操作-&gt;返回结果给客户端」，这个过程是由一个主线程来完成的，这也是我们常说 Redis 是单线程的原因。Redis 的模型是基于单线程事件驱动模型，内部使用文件事件处理器，而这个文件事件处理是单线程的，也就决定了 Redis 是单线程的。其核心原理是：采用 IO多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</li>
<li>随着底层网络硬件越来越好，Redis 的性能瓶颈逐渐体现在网络 I&#x2F;O 的读写上，单个线程处理网络 I&#x2F;O 读写的速度跟不上底层网络硬件执行的速度。所以为了提高 Redis 的性能，在 Redis 6.0 引入多线程模型，该多线程模型只用来处理网络数据的读写和协议解析，执行读写命令的仍然是单线程。</li>
</ul>
<span id="more"></span>

<h2 id="Redis-线程模型详解"><a href="#Redis-线程模型详解" class="headerlink" title="Redis 线程模型详解"></a>Redis 线程模型详解</h2><h3 id="Redis-的单线程模型"><a href="#Redis-的单线程模型" class="headerlink" title="Redis 的单线程模型"></a>Redis 的单线程模型</h3><p>Redis 的单线程是指Redis 在执行一次命令时是单线程的。Redis 客户端与服务端的模型可以简化如下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171124232.jpeg" alt="img"></p>
<p>步骤2 执行命令为单线程，其过程包括「接收客户端请求 -&gt; 解析请求 -&gt;数据读写等操作-&gt;返回结果给客户端」，这个过程是由一个主线程来完成的，这也是我们常说 Redis 是单线程的原因。</p>
<p>从 Redis 的内部设计来说，Redis 是基于 Reactor 模式开发了自己的网络事件处理器，这个处理器称之为文件事件处理器，而这个文件事件处理器是单线程的，这就决定了 Redis 是单线程的。文件事件处理器包含 5 个部分：</p>
<ul>
<li>多个 socket：Redis 网络通信的起点，Redis 服务器为每个连接的客户端维护一个套接字，用于接收请求和发送响应。</li>
<li>IO 多路复用程序：文件事件处理器的核心。它负责监控所有套接字并确定哪些套接字准备好进行读写操作。</li>
<li>任务队列：处理的任务的队列。</li>
<li>文件事件分派器：当 I&#x2F;O 多路复用程序确定某个套接字准备好读写时，文件事件分派器负责将这个事件分派给相应的事件处理器。</li>
<li>事件处理器：Redis 对不同类型的文件事件定义了相应的事件处理器。当特定类型的事件发生时，对应的事件处理器会被触发以处理这些事件。</li>
</ul>
<p>多个 socket 会产生不同的操作，每个操作对应一个不同的文件事件， IO 多路复用程序会监听多个 socket，将产生的事件放入到任务队列中排队，文件事件分派器每次从任务队列中获取一个事件，将其转发给对应的事件处理器进行处理。如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171125836.jpeg" alt="img"></p>
<p><strong>客户端与 Redis 服务端建立连接的过程</strong></p>
<ul>
<li>Redis sever 启动时，会把 AE_READABLE 事件与连接应答处理器关联。</li>
<li>当客户端向 Redis 发起连接时，这是 Server Socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到该事件后将 socket信息压入到任务队列中。</li>
<li>文件事件分派器每次从任务队列中取一个 socket ，将其交给事件处理器，由于在 Redis 初始化时 AE_READABLE 是与连接应答处理器关联，所以就由连接应答处理器来处理该事件。</li>
<li>连接应答处理器会创建一个与该客户端通信的 Socket（我们这里叫 socket1），并将 socket1 的 AE_READABLE 事件与命令请求处理器关联。</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171125775.jpeg" alt="img"></p>
<p><strong>客户端发送请求给 Redis 服务端过程</strong></p>
<ul>
<li>客户端发送读写请求（比如 set key value）给服务端，首先会在对应的 Socket（socket1）上面产生一个 AE_READABLE事件，IO 多路复用程序监听到该事件后将 socket信息压入到任务队列中。</li>
<li>文件事件分派器从任务队列中取 Socket 信息转发给事件处理器，由于建立连接时 socket1 的 AE_READABLE 事件已经与命令请求处理器关联了，所以文件事件分派器将命令请求处理器。</li>
<li>命令处理器读取该 Socket 的相关信息后执行相关命令，操作完成后，会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171125314.jpeg" alt="img"></p>
<ul>
<li>如果客户端已经准备好了接收结果，那么 socket1 会产生一个 AE_WRITABLE，IO 多路复用程序将 Socket 压入队列，然后由文件事件派发器转发给事件处理器。</li>
<li>由于 socket1 的AE_WRITABLE 事件与命令回复处理器关联，所以由命令回复处理器处理，命令回复处理器将准备好的相应数据写入socket01(socket连接是双向的)，返回给客户端，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171126310.jpeg" alt="img"></p>
<h2 id="Redis-的-I-O-多线程模型"><a href="#Redis-的-I-O-多线程模型" class="headerlink" title="Redis 的 I&#x2F;O 多线程模型"></a>Redis 的 I&#x2F;O 多线程模型</h2><p>我们 Redis 是基于内存操作，内存的响应时长大约为 100 纳秒，单线程的 Redis 处理数据的极限是 80,000 到 100,000 QPS，对于绝大多数的场景来说，单线程的 Redis 其实是已经够用了。</p>
<p>但是，随着底层网络硬件越来越好，Redis 的性能瓶颈逐渐体现在 I&#x2F;O 的读写上（CPU 从来都不是 Redis 的性能瓶颈），单个线程处理网络 I&#x2F;O 读写的速度跟不上底层网络硬件执行的速度。所以，为了提高 Redis 的整体性能，在 6.0 引入多线程，注意，引入的多线程模型只⽤来处理处理网络数据的读写和协议解析，对于 Redis 的读写命令，依然是单线程处理。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171126103.jpeg" alt="img"></p>
<p>Redis 6.0 引入 I&#x2F;O 多线程模型后，将一个命令的执行分为了两部分：</p>
<ul>
<li>Socket 读写和请求解析使用多线程处理，多个 socket 读写可以并⾏化</li>
<li>执行请求依然还是使用主线程，存内存操作，在高效的同时也保证了安全性。</li>
</ul>
<p>主要流程如下：</p>
<ol>
<li>主线程负责接收并建立（多个）连接请求，获取 socket 后放入全局等待处理队列；</li>
<li>主线程处理完这些事件之后，通过RR（Round Robin 轮询）将可读 socket 分配给这些 IO 线程；</li>
<li>主线程阻塞，等待 IO 线程完成命令的读取、解析；</li>
<li>主线程执⾏ IO 线程读取和解析出来的 Redis 请求命令，并将结果写到输出缓冲区；</li>
<li>主线程阻塞，等待 IO 线程将命令执⾏结果写回 socket（客户端）；</li>
<li>主线程执行所有命令并清空整个等待队列，等待客户端后续的请求队列。</li>
</ol>
<p>如下图：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171127175.jpeg" alt="img"></p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/chenssy/article/details/137480026">https://blog.csdn.net/chenssy/article/details/137480026</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis事务</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/Redis/Redis%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>前几天有读者说自己面试被问到Redis的事务，虽然不常用，但是面试竟然被问到，平时自己没有注意Redis的事务这一块，面试的时候被问到非常不好受。</p>
<p>虽然，这位读者面试最后算是过了，但是薪资方面没有拿到自己理想的薪资。</p>
<p>其实这个也是正常的，一般面试被问到烂大街的，谁还问你啊，专门挑一些不常见的来问你，就是为了压你的薪资。</p>
<p>所以在这里写一篇文章对Redis的事务进行详细的讲解，估计对Redis事务从理解到原理深入这一篇就够了。</p>
<p>以后面试都不用担心了再被问道Redis的事务了，这一篇主要讲解Redis事务原理和实操的演练，理解理论的同时也通过实操来证实理论。</p>
<span id="more"></span>

<h2 id="事务介绍"><a href="#事务介绍" class="headerlink" title="事务介绍"></a><strong>事务介绍</strong></h2><p>Redis事务是一组命令的集合，将多个命令进行打包，然后这些命令会被顺序的添加到队列中，并且按顺序的执行这些命令。</p>
<p><strong>「Redis事务中没有像Mysql关系型数据库事务隔离级别的概念，不能保证原子性操作，也没有像Mysql那样执行事务失败会进行回滚操作」</strong>。</p>
<p>这个与Redis的特点：<strong>「快速、高效」</strong>有着密切的关联，<strong>「因为一些列回滚操作、像事务隔离级别那这样加锁、解锁，是非常消耗性能的」</strong>。所以，Redis中执行事务的流程只需要简单的下面三个步骤：</p>
<ol>
<li>开始事务（MULTI）</li>
<li>命令入队</li>
<li>执行事务（EXEC）、撤销事务（DISCARD ）</li>
</ol>
<p>在Redis中事务的实现主要是通过如下的命令实现的：</p>
<p><strong>命令功能描述</strong>MULTI<strong>「事务开始的命令」</strong>，执行该命令后，后面执行的对Redis数据类型的<strong>「操作命令都会顺序的放进队列中」</strong>，等待执行EXEC命令后队列中的命令才会被执行DISCARD<strong>「放弃执行队列中的命令」</strong>，你可以理解为Mysql的回滚操作，<strong>「并且将当前的状态从事务状态改为非事务状态」</strong>。EXEC执行该命令后<strong>「表示顺序执行队列中的命令」</strong>，执行完后并将结果显示在客户端，<strong>「将当前状态从事务状态改为非事务状态」</strong>。若是执行该命令之前有key被执行WATCH命令并且又被其它客户端修改，那么就会放弃执行队列中的所有命令，在客户端显示报错信息，若是没有修改就会执行队列中的所有命令。WATCH key表示指定监视某个key，<strong>「该命令只能在MULTI命令之前执行」</strong>，如果监视的key被其他客户端修改，<strong>「EXEC将会放弃执行队列中的所有命令」</strong>UNWATCH<strong>「取消监视之前通过WATCH 命令监视的key」</strong>，通过执行EXEC 、DISCARD 两个命令之前监视的key也会被取消监视</p>
<p>以上就是一个Redis事务的执行过程包含的命令，下面就来详细的围绕着这几个命令进行讲解。</p>
<h2 id="开始事务"><a href="#开始事务" class="headerlink" title="开始事务"></a><strong>开始事务</strong></h2><p><code>MULTI</code> 命令表示事务的开始，当看到OK表示已经进入事务的状态：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171116700.png" alt="img"></p>
<p>该命令执行后客户端会将<strong>「当前的状态从非事务状态修改为事务状态」</strong>，这一状态的切换是将客户端的<code>flags</code>属性中打开<code>REDIS_MULTI</code>来完成的，该命令可以理解关系型数据库Mysql的<code>BEGIN TRANCATION</code>语句：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171116387.jpeg" alt="img"></p>
<h2 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a><strong>命令入队</strong></h2><p>执行完MULTI命令后，后面执行的操作Redis五种类型的命令都会按顺序的进入命令队列中，该部分也是真正的业务逻辑的部分。</p>
<p>Redis客户端的命令执行后若是当前状态处于事务状态命令就会进入队列中，并且返回<code>QUEUED</code>字符串，表示该命令已经进入了命令队列中，并且<strong>「事务队列是以先进先出（FIFO）的方式保存入队的命令」</strong>的。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171116233.jpeg" alt="img"></p>
<p>若是当前状态是非事务状态就会立即执行命令，并将结果返回客户端。在事务状态<strong>「执行操作事务的命令就会被立即执行」</strong>，如<code>EXEC、DISCARD、UNWATCH</code>。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171116603.png" alt="img"></p>
<p>结合上面的分析，Redis执行命令的流程如下图所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171116479.jpeg" alt="img"></p>
<p>事务的命令队列中有三个参数分别是：<strong>「要执行的命令」</strong>、<strong>「命令的参数」</strong>、<strong>「参数的个数」</strong>。例如：通过执行如下的命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SET name &quot;黎杜&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET name</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>

<p>那么对应上面的队列中三个参数如下表格所示：</p>
<p><strong>执行的命令命令的参数参数的个数</strong>SET[“name”, “黎杜”]2GET[“name”]1</p>
<h2 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a><strong>执行事务</strong></h2><p>当客户端执行EXEC命令的时候，上面的命令队列就会被按照先进先出的顺序被执行，当然执行的结果有成功有失败，这个后面分析。</p>
<p>上面说到当客户端处于非事务的状态命令发送到服务端会被立即执行，若是客户端处于事务状态命令就会被放进命令队列。</p>
<p>命令入队的时候，会按照顺序进入队列，队列以先进先出的特点来执行队列中的命令。</p>
<p>若是客户端处于事务状态，执行的是<code>EXEC、DISCARD、UNWATCH</code>这些操作事务的命令，也会被立即执行。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171116320.jpeg" alt="img"></p>
<p><strong>「（1）正常执行」</strong></p>
<p>还是上面的例子，执行如下的代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SET name &quot;黎杜&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET name</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>

<p>所有的命令进入了队列，当最后执行EXEC，首先会执行SET命令，然后执行GET命令，并且执行后的结果也会进入一个队列中保存，最后返回给客户端：</p>
<p><strong>回复的类型回复的内容</strong>status code replyOKbulk reply”黎杜”</p>
<p>所以最后你会在客户端看到<strong>「OK、黎杜」</strong>，这样的结果显示，这个也就是一个事务成功执行的过程。</p>
<p>至此一个事务就完整的执行完成，并且此时客户端也从事务状态更改为非事务状态。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171116760.jpeg" alt="img"></p>
<p><strong>「（2）放弃事务」</strong></p>
<p>当然你也可以放弃执行该事务，只要你再次执行DISCARD操作就会放弃执行此次的事务。具体代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SET name &quot;黎杜&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET name</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; DISCARD    // 放弃执行事务</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>DISCARD命令取消一个事务的时候，就会将命令队列清空，并且将客户端的状态从事务状态修改为非事务的状态。</p>
<p><strong>「Redis的事务是不可重复的」</strong>，当客户端处于事务状态的时候，再次向服务端发送MULTI命令时，直接就会向客户端返回错误。</p>
<h2 id="WATCH-命令"><a href="#WATCH-命令" class="headerlink" title="WATCH 命令"></a><strong>WATCH 命令</strong></h2><p><code>WATCH</code>命令是在MULTI命令之前执行的，表示监视任意数量的key，与它对应的命令就是<code>UNWATCH</code>命令，取消监视的key。</p>
<p><code>WATCH</code>命令有点<strong>「类似于乐观锁机制」</strong>，在事务执行的时候，若是被监视的任意一个key被更改，则队列中的命令不会被执行，直接向客户端返回(nil)表示事务执行失败。</p>
<p>下面我们来演示一下WATCH命令的操作流程，具体实现代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">redis&gt; WATCH num</span><br><span class="line">OK</span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; incrby num 10</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; decrby num 1</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC   // 执行成功</span><br></pre></td></tr></table></figure>

<p>这个是<code>WATCH</code>命令的正常的操作流程，若是在其它的客户端，修改了被监视的任意key，就会放弃执行该事务，如下图所示：</p>
<p><strong>客户端一客户端二</strong>WATCH numMULTIincrby num 10get numdecrby num 1EXEC执行失败，返回(nil)</p>
<p>WATCH命令的底层实现中保存了<code>watched_keys</code> 字典，<strong>「字典的键保存的是监视的key，值是一个链表，链表中的每个节点值保存的是监视该key的客户端」</strong>。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171117257.jpeg" alt="img"></p>
<p>若是某个客户端不再监视某个key，该客户端就会从链表中脱离。如client3，通过执行UNWATCH命令，不再监视key1：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171117663.jpeg" alt="img"></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a><strong>错误处理</strong></h2><p>上面说到Redis是没有回滚机制的，那么执行的过程，若是不小心敲错命令，Redis的命令发送到服务端没有被立即执行，所以是暂时发现不到该错误。</p>
<p>那么在Redis中的错误处理主要分为两类：<strong>「语法错误」</strong>、<strong>「运行错误」</strong>。下面主要来讲解一下这两类错误的区别。</p>
<p><strong>「（1）语法错误」</strong></p>
<p>比如执行命令的时候，命令的不存在或者错误的敲错命令、参数的个数不对等都会导致语法错误。</p>
<p>下面来演示一下，执行下面的四个命令，前后的两个命令是正确的，中间的两个命令是错误的，如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set num 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set num</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;set&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; ssset num 3</span><br><span class="line">(error) ERR unknown command &#x27;ssset&#x27;</span><br><span class="line">127.0.0.1:6379&gt; set num 2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>

<p>语法错误是在Redis语法检测的时候就能发现的，所以当你执行错误命令的时候，也会即使的返回错误的提示。</p>
<p>最后，即使命令进入队列，只要存在语法错误，该队列中的命令都不会被执行，会直接向客户端返回事务执行失败的提示。</p>
<p><strong>「（2）运行错误」</strong></p>
<p>执行时使用不同类型的操作命令操作不同数据类型就会出现运行时错误，这种错误时Redis在不执行命令的情况下，是无法发现的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set num 3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; sadd num 4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set num 6</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">&quot;6&quot;</span><br></pre></td></tr></table></figure>

<p>这样就会导致，正确的命令被执行，而错误的命令不会不执行，这也显示出Redis的事务并不能保证数据的一致性，因为中间出现了错误，有些语句还是被执行了。</p>
<p>这样的结果只能程序员自己根据之前执行的命令，自己一步一步正确的回退，所谓自己的烂摊子，自己收拾。</p>
<h2 id="Redis事务与Mysql事务"><a href="#Redis事务与Mysql事务" class="headerlink" title="Redis事务与Mysql事务"></a><strong>Redis事务与Mysql事务</strong></h2><p>我们知道关系性数据库Mysql中具有事务的四大特性：<strong>「原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）」</strong>。</p>
<p>但是Redis的事务为了保证Redis除了客户端的请求高效，去除了传统关系型数据库的<strong>「事务回滚、加锁、解锁」</strong>这些消耗性能的操作，Redis的事务实现简单。</p>
<p>原子性中Redis的事务只能保证单个命令的原子性，多个命令就无法保证，如上面索道的运行时错误，即使中间有运行时错误出现也会正确的执行后面正确的命令，不具有回滚操作。</p>
<p>既然没有了原子性，数据的一致性也就无法保证，这些都需要程序员自己手动去实现。</p>
<p>Reids在进行事务的时候，不会被中断知道事务的运行结束，也具有一定的隔离性，并且Redis也能持久化数据。</p>
<hr>
<p>转载自：<a href="https://zhuanlan.zhihu.com/p/156039932">https://zhuanlan.zhihu.com/p/156039932</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>TCC服务设计和实现注意事项</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/TCC%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="一、TCC简介"><a href="#一、TCC简介" class="headerlink" title="一、TCC简介"></a>一、TCC简介</h1><p>&emsp;&emsp;TCC是一种比较成熟的分布式事务解决方案，可用于解决跨库操作的数据一致性问题；</p>
<p>​      TCC是服务化的两阶段编程模型，其Try、Confirm、Cancel 3个方法均由<strong>业务编码实现</strong>；<br>&emsp;&emsp;其中Try操作作为一阶段，负责资源的检查和预留，Confirm操作作为二阶段提交操作，执行真正的业务，Cancel是预留资源的取消；</p>
<p>&emsp;&emsp;如下图所示，业务实现TCC服务之后，该TCC服务将作为分布式事务的其中一个资源，参与到整个分布式事务中；事务管理器分2阶段协调TCC服务，在第一阶段调用所有TCC服务的Try方法，在第二阶段执行所有TCC服务的Confirm或者Cancel方法；</p>
<p><a href="https://img-blog.csdnimg.cn/img_convert/ffca7453c12adde5080518b45fd730c9.png">https://img-blog.csdnimg.cn/img_convert/ffca7453c12adde5080518b45fd730c9.png</a></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291814296.jpeg"></p>
<span id="more"></span>

<h1 id="二、用户在实现TCC服务时，有以下注意事项"><a href="#二、用户在实现TCC服务时，有以下注意事项" class="headerlink" title="二、用户在实现TCC服务时，有以下注意事项"></a>二、用户在实现TCC服务时，有以下注意事项</h1><h2 id="1、业务操作分两阶段完成："><a href="#1、业务操作分两阶段完成：" class="headerlink" title="1、业务操作分两阶段完成："></a>1、业务操作分两阶段完成：</h2><p>&emsp;&emsp;如下图所示，接入TCC前，业务操作只需要一步就能完成，但是在接入TCC之后，需要考虑如何将其分成2阶段完成，把资源的检查和预留放在一阶段的Try操作中进行，把真正的业务操作的执行放在二阶段的Confirm操作中进行；</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291814775.jpeg"></p>
<p>&emsp;&emsp;TCC服务要保证第一阶段Try操作成功之后，二阶段Confirm操作一定能成功；</p>
<h2 id="2、允许空回滚；"><a href="#2、允许空回滚；" class="headerlink" title="2、允许空回滚；"></a>2、允许空回滚；</h2><p>&emsp;&emsp;如下图所示，事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因为丢包而导致的网络超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291814648.jpeg"></p>
<p>&emsp;&emsp;TCC服务在未收到Try请求的情况下收到Cancel请求，这种场景被称为空回滚；TCC服务在实现时应当允许空回滚的执行；</p>
<h2 id="3、防悬挂控制；"><a href="#3、防悬挂控制；" class="headerlink" title="3、防悬挂控制；"></a>3、防悬挂控制；</h2><p>&emsp;&emsp;如下图所示，事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因网络拥堵而导致的超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；在此之后，拥堵在网络上的一阶段Try数据包被TCC服务收到，出现了二阶段Cancel请求比一阶段Try请求先执行的情况；<br>&emsp;&emsp;用户在实现TCC服务时，应当允许空回滚，但是要拒绝执行空回滚之后到来的一阶段Try请求；</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291814837.jpeg"></p>
<h2 id="4、幂等控制："><a href="#4、幂等控制：" class="headerlink" title="4、幂等控制："></a>4、幂等控制：</h2><p>&emsp;&emsp;无论是网络数据包重传，还是异常事务的补偿执行，都会导致TCC服务的Try、Confirm或者Cancel操作被重复执行；用户在实现TCC服务时，需要考虑幂等控制，即Try、Confirm、Cancel 执行次和执行多次的业务结果是一样的；</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291814164.png"></p>
<h2 id="5、业务数据可见性控制；"><a href="#5、业务数据可见性控制；" class="headerlink" title="5、业务数据可见性控制；"></a>5、业务数据可见性控制；</h2><p>&emsp;&emsp;TCC服务的一阶段Try操作会做资源的预留，在二阶段操作执行之前，如果其他事务需要读取被预留的资源数据，那么处于中间状态的业务数据该如何向用户展示，需要业务在实现时考虑清楚；通常的设计原则是“宁可不展示、少展示，也不多展示、错展示”；</p>
<h2 id="6、业务数据并发访问控制；"><a href="#6、业务数据并发访问控制；" class="headerlink" title="6、业务数据并发访问控制；"></a>6、业务数据并发访问控制；</h2><p>&emsp;&emsp;TCC服务的一阶段Try操作预留资源之后，在二阶段操作执行之前，预留的资源都不会被释放；如果此时其他分布式事务修改这些业务资源，会出现分布式事务的并发问题；<br>&emsp;&emsp;用户在实现TCC服务时，需要考虑业务数据的并发控制，尽量将逻辑锁粒度降到最低，以最大限度的提高分布式事务的并发性；</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>&emsp;&emsp;蚂蚁金服大部分业务系统均采用TCC的方式接入分布式事务，但设计TCC服务时要遵循大量设计规范，这无疑对用户提了非常高的要求；为了简化用户接入分布式事务的门槛，蚂蚁金服的分布式事务框架（SOFA-DTX）推出了FMT（Framework-managed transactions）模式和XA模式，这两种模式均不需要用户实现TCC服务，用户只需要关注自身业务SQL便可；DTX的三种模式：TCC、FMT和XA相互之间是功能互补，相辅相成的，形成了蚂蚁金服完善的分布式事务解决方案。<br>&emsp;&emsp;SOFA-DTX全面覆盖金融场景，金融级容灾保障、提供丰富的接入模式并且使用简洁易于接入；目前已经应用在支付宝、网上银行、蚂蚁财富、芝麻信用、南京银行等项目中。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/bntX2jSQfEHy7/article/details/81058746">https://blog.csdn.net/bntX2jSQfEHy7/article/details/81058746</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
        <category>分布式事务</category>
      </categories>
  </entry>
  <entry>
    <title>分布式事务框架seata</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6%20seata/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="1-什么是seata"><a href="#1-什么是seata" class="headerlink" title="1. 什么是seata"></a>1. 什么是seata</h1><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<h1 id="2-seata发展历程"><a href="#2-seata发展历程" class="headerlink" title="2. seata发展历程"></a>2. seata发展历程</h1><p>阿里巴巴作为国内最早一批进行应用分布式（微服务化）改造的企业，很早就遇到微服务架构下的分布式事务问题。阿里巴巴对于分布式事务问题先后发布了以下解决方案：</p>
<ul>
<li>2014 年，阿里中间件团队发布 TXC（Taobao Transaction Constructor），为集团内应用提供分布式事务服务。</li>
<li>2016 年，TXC 在经过产品化改造后，以 GTS（Global Transaction Service） 的身份登陆阿里云，成为当时业界唯一一款云上分布式事务产品。在阿云里的公有云、专有云解决方案中，开始服务于众多外部客户。</li>
<li>2019 年起，基于 TXC 和 GTS 的技术积累，阿里中间件团队发起了开源项目 Fescar（Fast &amp; EaSy Commit And Rollback, FESCAR），和社区一起建设这个分布式事务解决方案。</li>
<li>2019 年 fescar 被重命名为了seata（simple extensiable autonomous transaction architecture）。</li>
<li>TXC、GTS、Fescar 以及 seata 一脉相承，为解决微服务架构下的分布式事务问题交出了一份与众不同的答卷。</li>
</ul>
<span id="more"></span>

<h1 id="3-seata中相关事务概念"><a href="#3-seata中相关事务概念" class="headerlink" title="3. seata中相关事务概念"></a>3. seata中相关事务概念</h1><ul>
<li><p>全局事务：全局事务指的是一次性操作多个资源管理器完成的事务，由一组分支事务（本地事务）组成。</p>
</li>
<li><p>分支事务（本地事务）：本地事务由本地资源管理器（通常指数据库管理系统 DBMS，例如 MySQL、Oracle 等）管理，严格地支持 ACID 特性，高效可靠。本地事务不具备分布式事务的处理能力，隔离的最小单位受限于资源管理器，即本地事务只能对自己数据库的操作进行控制，对于其他数据库的操作则无能为力。</p>
</li>
</ul>
<h1 id="4-seata的工作流程相关概念"><a href="#4-seata的工作流程相关概念" class="headerlink" title="4. seata的工作流程相关概念"></a>4. seata的工作流程相关概念</h1><p>Seata 对分布式事务的协调和控制，主要是通过 XID 和 3 个核心组件实现的。</p>
<p><strong>XID</strong></p>
<p>XID 是全局事务的唯一标识，它可以在服务的调用链路中传递，绑定到服务的事务上下文中。</p>
<p><strong>核心组件</strong></p>
<p>Seata的核心组件可分为Seata服务端和Seata客户端两类</p>
<p>Seata 定义了 3 个核心组件：</p>
<ul>
<li><p>TC（Transaction Coordinator）：事务协调器，直接调度事务参与者RM。负责将RM的反馈结果响应给TM，并听从TM的最终决议，将具体决议（提交或回滚）发送给RM执行。相当于中间人，主要负责维护全局事务和分支事务的状态。</p>
</li>
<li><p>TM（Transaction Manager）：事务管理器，它是事务的发起者（具体的微服务）。根据RM第一阶段的执行结果，进行决议。并将决议反馈给TC。相当于发号施令的</p>
</li>
<li><p>RM（Resource Manager）：资源管理器，其实就是事务的参与者。获取TC的执行命令具去执行分支事务的第一阶段以及第二阶段，并将执行结果反馈给TC，相当于具体做事的</p>
</li>
</ul>
<p>以上三个组件相互协作，TC 以 Seata 服务器（Server）形式独立部署，TM 和 RM 则是以 Seata Client 的形式集成在微服务中运行。</p>
<h1 id="5-seata的工作流程"><a href="#5-seata的工作流程" class="headerlink" title="5. seata的工作流程"></a>5. seata的工作流程</h1><p>TC 以 Seata 服务器（Server）形式独立部署，TM 和 RM 则是以 Seata Client 的形式集成在微服务中运行，</p>
<p>整体工作流程如图：<img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291812703.png" alt="图片"></p>
<p>Seata 的整体工作流程如下：</p>
<ol>
<li>TM 向 TC 申请开启一个全局事务，全局事务创建成功后，TC 会针对这个全局事务生成一个全局唯一的 XID（此时，由TM发起的全局事务已经开启）</li>
<li>XID 通过服务的调用链传递到其他服务</li>
<li>RM 向 TC 注册一个分支事务，并将其纳入 XID 对应全局事务的管辖（事务参与者执行本地事务，此时分支事务已经执行完成，并反馈给TC执行结果。可以理解为AT模式下的第一个阶段）</li>
<li>TM 根据 TC 收集的各个分支事务的执行结果，向 TC 发起全局事务提交或回滚决议（事务协调者根据事务管理者的决议，发送提交或回滚的调度命令，可以理解为AT模式下的第二阶段）</li>
<li>TC 调度 XID 下管辖的所有分支事务完成提交或回滚操作</li>
</ol>
<h1 id="seata四种模式"><a href="#seata四种模式" class="headerlink" title="seata四种模式"></a>seata四种模式</h1><p>1、AT 模式<br>基于 支持本地 ACID 事务 的 关系型数据库：</p>
<p>一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录。</p>
<p>二阶段 commit 行为：马上成功结束，自动 异步批量清理回滚日志。</p>
<p>二阶段 rollback 行为：通过回滚日志，自动 生成补偿操作，完成数据回滚。</p>
<p>2、TCC 模式<br>不依赖于底层数据资源的事务支持：</p>
<p>一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。</p>
<p>二阶段 commit 行为：调用 自定义 的 commit 逻辑。</p>
<p>二阶段 rollback 行为：调用 自定义 的 rollback 逻辑。</p>
<p>所谓 TCC 模式，是指支持把 自定义 的分支事务纳入到全局事务的管理中。</p>
<p>3、Saga 模式<br>Saga模式是SEATA提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。</p>
<p>4、Seata XA 模式<br>支持XA协议 事务的数据库。Java 应用，通过 JDBC 访问数据库。</p>
<p>执行阶段（E xecute）：XA start&#x2F;XA end&#x2F;XA prepare + SQL + 注册分支</p>
<p>完成阶段（F inish）：XA commit&#x2F;XA rollback</p>
<h1 id="6-seata的AT模式"><a href="#6-seata的AT模式" class="headerlink" title="6. seata的AT模式"></a>6. seata的AT模式</h1><p>seata中提供了了XA、TCC、SAGA、TC四种模式。其中TC模式应用最为广泛，可应对大多数业务场景。也是seata的主要模式</p>
<p>前提</p>
<ul>
<li>基于支持本地 ACID 事务的关系型数据库。例如mysql，oracle</li>
<li>Java 应用，通过 JDBC 访问数据库。（mybaits、mybatisplus、springdatajpa）</li>
</ul>
<p>整体机制</p>
<p>官网描述：</p>
<p>两阶段提交协议的演变：</p>
<ul>
<li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交（提交前需要获取到全局锁），释放本地锁和连接资源。</li>
<li>二阶段：提交异步化，非常快速地完成   或  回滚通过一阶段的回滚日志进行反向补偿。</li>
</ul>
<p>其实AT模式可以理解为XA二阶段提交的一个变种，将二阶段提交的部分在一定阶段就已完成，而二阶段的回滚操作是通过回滚日志完成，并是不依赖于数据库的事务机制。也就是说一阶段数据实际上已经提交了，与此同时原子性提交的还有对应的回滚日志</p>
<p>AT模式，是seata的默认&#x2F;独有模式，也是实际项目中比较常用的一种模式，它采用的也是两阶段提交，不过弥补了XA模式中资源锁定周期过长的缺点，相对于XA来说，性能更好一些，但缺点就是数据不是强一致，因为它的数据会真实的提交到数据库的，而如果后面做分支事务有问题的话，回滚靠的是日志来实现最终一致。</p>
<p><strong>写隔离</strong></p>
<ul>
<li>一阶段本地事务提交前，需要确保先拿到 全局锁 。</li>
<li>拿不到 全局锁 ，不能提交本地事务。</li>
<li>拿 全局锁 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。此时一阶段等于失败</li>
</ul>
<p><strong>读隔离</strong> </p>
<p>在数据库本地事务隔离级别 读已提交（Read Committed） 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 读未提交（Read Uncommitted） 。</p>
<p>如果应用在特定场景下，必需要求全局的 读已提交 ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p>
<h1 id="7-seata的AT模式具体执行流程"><a href="#7-seata的AT模式具体执行流程" class="headerlink" title="7. seata的AT模式具体执行流程"></a>7. seata的AT模式具体执行流程</h1><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291812622.png" alt="img"></p>
<p>假设前置条件</p>
<p> 假设当前存在一个业务表：product</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Key</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>bigint(20)</td>
<td>PRI</td>
</tr>
<tr>
<td>name</td>
<td>varchar(100)</td>
<td></td>
</tr>
<tr>
<td>since</td>
<td>varchar(100)</td>
<td></td>
</tr>
</tbody></table>
<p>分支事务的业务逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update product set name = &#x27;GTS&#x27; where name = &#x27;TXC&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>一阶段</strong></p>
<ul>
<li>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name &#x3D; ‘TXC’）等相关的信息。</li>
<li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。这一步的目的为了后续回滚</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id, name, since from product where name = &#x27;TXC&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行业务 SQL：更新这条记录的 name 为 ‘GTS’。</li>
<li>查询后镜像：根据主键ID进行查询。这一步的目的是为了防止存在其他线程修改数据，后续比对使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id, name, since from product where id = 1;</span><br></pre></td></tr></table></figure>

<ul>
<li>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 UNDO_LOG 表中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     &quot;branchId&quot;: 641789253,</span><br><span class="line">      &quot;undoItems&quot;: [&#123;</span><br><span class="line">           &quot;afterImage&quot;: &#123;</span><br><span class="line">                &quot;rows&quot;: [&#123;</span><br><span class="line">                     &quot;fields&quot;: [&#123;</span><br><span class="line">                          &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">                           &quot;type&quot;: 4,</span><br><span class="line">                           &quot;value&quot;: 1</span><br><span class="line">                      &#125;, &#123;</span><br><span class="line">                           &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">                           &quot;type&quot;: 12,</span><br><span class="line">                           &quot;value&quot;: &quot;GTS&quot;</span><br><span class="line">                     &#125;, &#123;</span><br><span class="line">                           &quot;name&quot;: &quot;since&quot;,</span><br><span class="line">                           &quot;type&quot;: 12,</span><br><span class="line">                          &quot;value&quot;: &quot;2014&quot;</span><br><span class="line">                    &#125;]</span><br><span class="line">               &#125;],</span><br><span class="line">              &quot;tableName&quot;: &quot;product&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">        &quot;beforeImage&quot;: &#123;</span><br><span class="line">                  &quot;rows&quot;: [&#123;</span><br><span class="line">                           &quot;fields&quot;: [&#123;</span><br><span class="line">                           &quot;name&quot;: &quot;id&quot;,</span><br><span class="line">                           &quot;type&quot;: 4,</span><br><span class="line">                           &quot;value&quot;: 1</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                           &quot;name&quot;: &quot;name&quot;,</span><br><span class="line">                           &quot;type&quot;: 12,</span><br><span class="line">                           &quot;value&quot;: &quot;TXC&quot;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                            &quot;name&quot;: &quot;since&quot;,</span><br><span class="line">                            &quot;type&quot;: 12,</span><br><span class="line">                             &quot;value&quot;: &quot;2014&quot;</span><br><span class="line">                    &#125;]</span><br><span class="line">              &#125;],</span><br><span class="line">             &quot;tableName&quot;: &quot;product&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">          &quot;sqlType&quot;: &quot;UPDATE&quot;</span><br><span class="line">     &#125;],</span><br><span class="line">     &quot;xid&quot;: &quot;xid:xxx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>提交前，向 TC 注册分支：申请 product 表中，主键值等于 1 的记录的 全局锁 。</p>
</li>
<li><p>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</p>
</li>
<li><p>将本地事务提交的结果上报给 TC。</p>
</li>
</ul>
<p><strong>二阶段-提交</strong> </p>
<p>相关业务在一阶段已经提交了，二阶段只需要删除已经没有用处的回滚日志即可。同时还是异步删除，效率更高</p>
<ul>
<li>收到 TC 的提交指令，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li>
<li>异步任务阶段将异步和批量地删除相应 UNDO LOG 记录。</li>
</ul>
<p><strong>二阶段-回滚</strong> </p>
<p>相关业务在一阶段已经提交了，所以二阶段的回滚相当于又开启了一个事务。一阶段保存的后镜像来用于对比是否有其他动作修改了这条数据，一阶段保存的前镜像用于回滚语句的生成</p>
<ul>
<li><p>收到 TC 的回滚指令，开启一个本地事务，执行如下操作。</p>
</li>
<li><p>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</p>
</li>
<li><p>数据校验：拿 UNDO LOG 中的后镜像与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理</p>
</li>
<li><p>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句，同时删除已经无用的回滚日志</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update product set name = &#x27;TXC&#x27; where id = 1;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>提交本地事务。并把本地事务的执行结果（即分支事务补偿的结果）上报给 TC。</p>
</li>
<li></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">souce：//www.yuque.com/u27809381/ca4o9w/avy27g</span><br></pre></td></tr></table></figure>





<h3 id="AT模式脏读问题解决方案"><a href="#AT模式脏读问题解决方案" class="headerlink" title="AT模式脏读问题解决方案"></a>AT模式脏读问题解决方案</h3><p>存在这样的一个场景，在并发请求中，当线程A刚完成扣减余额1000-200&#x3D;800，但库存还没扣减，这时候线程B来了，线程B读到的余额为800，它也进行了扣减800-200&#x3D;600，而这时候线程A扣库存出现了异常，线程A回滚了，那这里线程B是不是就脏读了？</p>
<p><strong>我们看看官网开发者指南里AT模式的读隔离描述：</strong></p>
<p>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。</p>
<p>如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p>
<p><strong>SELECT FOR UPDATE 语句的执行会申请 全局锁</strong> ，如果 <strong>全局锁</strong> 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 <strong>全局锁</strong> 拿到，即读取的相关数据是 <strong>已提交</strong> 的，才返回。</p>
<p>出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。</p>
<p>以上是官网的描述。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291812766.jpeg" alt="img"></p>
<p>其实官网的描述已经说的很清楚了，如果你还是不太清楚，我给你解析一下官网提供的这个图，你应该就明白了。</p>
<p>首先它有两个线程tx1和tx2，初始的的业务有一条数据为id&#x3D;1、m&#x3D;1000。</p>
<p>1.tx1线程开始执行，获取本地锁，更新id&#x3D;1的m数据为m-100&#x3D;900。</p>
<p>2.tx1线程获取全局锁，提交本地事务并释放本地锁。</p>
<p>3.这时候线程tx2来了，它去查询m并在查询的时候加上了 for update 也就是尝试申请一个全局锁，但这时候tx1还没有执行完，所以tx2拿不到全局锁。</p>
<p>4.tx2释放本地锁并再次重试执行查询，重请期间tx2一直会处于阻塞状态，直到获取到tx1释放的全局锁并查询到tx1已回滚或已提交的数据m。也就是读已提交。</p>
<p><strong>在分布式事务中实现读已提交的代价是很高的，效率比起读未提交差别很大，所以</strong> <strong>Seata 默认并没有开启，当只有你业务上确实需要数据强一致时才有开启的必要。</strong></p>
<h3 id="2-5-AT模式脏写问题"><a href="#2-5-AT模式脏写问题" class="headerlink" title="2.5.AT模式脏写问题"></a>2.5.AT模式脏写问题</h3><p>seata 有没有脏写的问题? 这个问题我们可以直接明确的回答没有，那 seata 是怎么解决AT模式脏写问题的呢? 这个在官网上也有解答，他使用的是全局锁，我们一起来看一下。</p>
<p><strong>官网开发者指南里AT模式的写隔离描述：</strong></p>
<ul>
<li>一阶段本地事务提交前，需要确保先拿到 <strong>全局锁</strong> 。</li>
<li>拿不到 <strong>全局锁</strong> ，不能提交本地事务。</li>
<li>拿 <strong>全局锁</strong> 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。</li>
</ul>
<p>以一个示例来说明：</p>
<p>两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。</p>
<p>tx1 先开始，开启本地事务，拿到本地锁，更新操作 m &#x3D; 1000 - 100 &#x3D; 900。本地事务提交前，先拿到该记录的 <strong>全局锁</strong> ，本地提交释放本地锁。 tx2 后开始，开启本地事务，拿到本地锁，更新操作 m &#x3D; 900 - 100 &#x3D; 800。本地事务提交前，尝试拿该记录的 <strong>全局锁</strong> ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 <strong>全局锁</strong> 。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291812641.jpeg" alt="img"></p>
<p>tx1 二阶段全局提交，释放 <strong>全局锁</strong> 。tx2 拿到 <strong>全局锁</strong> 提交本地事务。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291812151.jpeg" alt="img"></p>
<p>如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。</p>
<p>此时，如果 tx2 仍在等待该数据的 <strong>全局锁</strong>，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 获取 <strong>全局锁</strong> 等待超时，放弃 <strong>全局锁</strong> 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。</p>
<p>因为整个过程 <strong>全局锁</strong> 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 <strong>脏写</strong> 的问题。</p>
<p><a href="https://blog.csdn.net/weixin_43444652/article/details/124683906">https://blog.csdn.net/weixin_43444652/article/details/124683906</a></p>
<h1 id="seata-saga模式"><a href="#seata-saga模式" class="headerlink" title="seata-saga模式"></a>seata-saga模式</h1><p>概述<br>Saga模式是SEATA提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291812938.png" alt="在这里插入图片描述"></p>
<p>适用场景：</p>
<blockquote>
<p>业务流程长、业务流程多<br>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</p>
<p>优势：<br>一阶段提交本地事务，无锁，高性能<br>事件驱动架构，参与者可异步执行，高吞吐<br>补偿服务易于实现</p>
<p>缺点：<br>不保证隔离性（应对方案见后面文档）</p>
</blockquote>
<p>Saga的实现：<br><strong>基于状态机引擎的 Saga 实现：</strong><br>目前SEATA提供的Saga模式是基于状态机引擎来实现的，机制是：</p>
<blockquote>
<p>1.通过状态图来定义服务调用的流程并生成 json 状态语言定义文件<br>2.状态图中一个节点可以是调用一个服务，节点可以配置它的补偿节点<br>3.状态图 json 由状态机引擎驱动执行，当出现异常时状态引擎反向执行已成功节点对应的补偿节点将事务回滚<br>注意: 异常发生时是否进行补偿也可由用户自定义决定<br>可以实现服务编排需求，支持单项选择、并发、子流程、参数转换、参数映射、服务执行状态判断、异常捕获等功能</p>
</blockquote>
<p>示例状态图:</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291813128.png" alt="在这里插入图片描述"></p>
<p>最佳实践<br>Saga 服务设计的实践经验</p>
<ul>
<li>允许空补偿</li>
</ul>
<p>空补偿：原服务未执行，补偿服务执行了<br>出现原因：</p>
<blockquote>
<p>原服务 超时（丢包）<br>Saga 事务触发 回滚<br>未收到 原服务请求，先收到 补偿请求<br>所以服务设计时需要允许空补偿, 即没有找到要补偿的业务主键时返回补偿成功并将原业务主键记录下来</p>
</blockquote>
<ul>
<li><p>防悬挂控制<br>悬挂：补偿服务 比 原服务 先执行<br>出现原因：</p>
<blockquote>
<p>原服务 超时（拥堵）<br>Saga 事务回滚，触发 回滚<br>拥堵的 原服务 到达<br>所以要检查当前业务主键是否已经在空补偿记录下来的业务主键中存在，如果存在则要拒绝服务的执行</p>
</blockquote>
</li>
<li><p>幂等控制<br>原服务与补偿服务都需要保证幂等性, 由于网络可能超时, 可以设置重试策略，重试发生时要通过幂等控制避免业务数据重复更新</p>
</li>
<li><p>缺乏隔离性的应对<br>由于 Saga 事务不保证隔离性, 在极端情况下可能由于脏写无法完成回滚操作, 比如举一个极端的例子, 分布式事务内先给用户A充值, 然后给用户B扣减余额, 如果在给A用户充值成功, 在事务提交以前, A用户把余额消费掉了, 如果事务发生回滚, 这时则没有办法进行补偿了。这就是缺乏隔离性造成的典型的问题, 实践中一般的应对方法是：<br>1.业务流程设计时遵循“宁可长款, 不可短款”的原则, 长款意思是客户少了钱机构多了钱, 以机构信誉可以给客户退款, 反之则是短款, 少的钱可能追不回来了。所以在业务流程设计上一定是先扣款。<br>2.有些业务场景可以允许让业务最终成功, 在回滚不了的情况下可以继续重试完成后面的流程, 所以状态机引擎除了提供“回滚”能力还需要提供“向前”恢复上下文继续执行的能力, 让业务最终执行成功, 达到最终一致性的目的。</p>
</li>
<li><p>性能优化<br>配置客户端参数client.rm.report.success.enable&#x3D;false，可以在当分支事务执行成功时不上报分支状态到server，从而提升性能。<br>当上一个分支事务的状态还没有上报的时候，下一个分支事务已注册，可以认为上一个实际已成功<br>————————————————</p>
</li>
</ul>
<hr>
<p>转载自：<br><a href="https://mp.weixin.qq.com/s?__biz=MzA4MTk3MjI0Mw==&mid=2247497223&idx=1&sn=913c9afb7e26895162153899f93dca6f&chksm=9f8e6b7ba8f9e26d9b091eed0ee6cc9ff5a259ab55f197afa5b9654234a0894e85464e24648c&scene=27">https://mp.weixin.qq.com/s?__biz=MzA4MTk3MjI0Mw==&amp;mid=2247497223&amp;idx=1&amp;sn=913c9afb7e26895162153899f93dca6f&amp;chksm=9f8e6b7ba8f9e26d9b091eed0ee6cc9ff5a259ab55f197afa5b9654234a0894e85464e24648c&amp;scene=27</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
        <category>分布式事务</category>
      </categories>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="一、普通事务与分布式事务"><a href="#一、普通事务与分布式事务" class="headerlink" title="一、普通事务与分布式事务"></a>一、普通事务与分布式事务</h2><h3 id="1-1-普通事务"><a href="#1-1-普通事务" class="headerlink" title="1.1 普通事务"></a>1.1 普通事务</h3><p>&emsp;&emsp;普通事务就是一般所说的 <strong>数据库事务</strong>。<br>&emsp;&emsp;事务 是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。当事务被提交给了DBMS（数据库管理系统），DBMS需要确保 该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态。</p>
<h4 id="1-1-1-事务的ACID特性"><a href="#1-1-1-事务的ACID特性" class="headerlink" title="1.1.1 事务的ACID特性"></a>1.1.1 事务的ACID特性</h4><p>&emsp;&emsp;<strong>原子性（Atomicity）</strong>：所谓的原子性就是说，在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。事务在执行中发生错误，所有的操作都会被回滚。<br>&emsp;&emsp;<strong>一致性（Consistency）</strong>：事务的执行必须保证系统的一致性，就拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B 50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。<br>&emsp;&emsp;<strong>隔离性（Isolation）</strong>：所谓的隔离性就是说，事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务感知。<br>&emsp;&emsp;<strong>持久性（Durability）</strong>：所谓的持久性，就是说一旦事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电、系统宕机也是如此。</p>
<span id="more"></span>
<h3 id="1-2-分布式事务（Distributed-Transaction-DT）"><a href="#1-2-分布式事务（Distributed-Transaction-DT）" class="headerlink" title="1.2 分布式事务（Distributed Transaction DT）"></a>1.2 分布式事务（Distributed Transaction DT）</h3><p>&emsp;&emsp;分布式事务 顾名思义就是在 <strong>分布式环境下运行的事务</strong>，对于分布式事务来说，事务的每个操作步骤是运行在不同机器上的服务的。分布式事务处理的关键是 必须可以知道事务在任何地方所做的所有动作，提交或回滚事务的动作必须产生统一的结果（全部提交或全部回滚）。<br>&emsp;&emsp;在现如今的大型互联网平台中，基本上都是采用分布式架构，所以分布式事务是非常常见的。比如一个电商平台的下单场景，一般对于用户下单会有两个步骤，一是订单业务下订单操作，二是库存业务减库存操作，但这两个业务一般会运行在不同的机器上，这就是一个典型的分布式事务场景。还有一个常见的场景就是支付宝向余额宝转账，而支付宝和余额宝不是一个系统，怎么保证这两个系统之间的一致性就是分布式事务所关注的问题。</p>
<h4 id="1-2-1-分布式系统中的CAP定律"><a href="#1-2-1-分布式系统中的CAP定律" class="headerlink" title="1.2.1 分布式系统中的CAP定律"></a>1.2.1 分布式系统中的CAP定律</h4><p>&emsp;&emsp;为了更方便的理解分布式事务，介绍一下一个分布式系统的CAP定律。在分布式系统里面有一个CAP定律，这个定理的内容是指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p>
<ul>
<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否是同样的值。</li>
<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。或者换个说法，系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</li>
<li>分区容错性（P）：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。以实际效果而言，分区相当于对通信的时限要求，系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>
<p>&emsp;&emsp;需要明确的一点是，对于一个分布式系统而言，分区容错性是一个最基本的要求。因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。</p>
<h4 id="1-2-2-一致性理论"><a href="#1-2-2-一致性理论" class="headerlink" title="1.2.2 一致性理论"></a>1.2.2 一致性理论</h4><p>&emsp;&emsp;为了下一步讨论分布式事务特性，先简单介绍下数据一致性的基础理论。</p>
<ul>
<li><p>   强一致：当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。</p>
</li>
<li><p>   弱一致性：系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。</p>
<ul>
<li>最终一致性：弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。</li>
</ul>
</li>
</ul>
<h4 id="1-2-3-分布式事务特性—最终一致性（BASE）"><a href="#1-2-3-分布式事务特性—最终一致性（BASE）" class="headerlink" title="1.2.3 分布式事务特性—最终一致性（BASE）"></a>1.2.3 分布式事务特性—最终一致性（BASE）</h4><p>&emsp;&emsp;在互联网大型分布式平台场景中，为了保障系统的可用性，一般会把强一致性的需求转换成最终一致性的需求。所以，对于大部分分布式事务场景，仅需要保证最终一致性即可。这种思路，即经典的BASE (Basically Available, Soft state, Eventually consistent)方案。</p>
<blockquote>
<ul>
<li>BA: Basic Availability 基本业务可用性，分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。</li>
<li>S: Soft state 软状态，允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。</li>
<li>E: Eventual consistency 最终一致性，指经过一段时间后，所有节点上的数据都将会达到一致。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="二、分布式事务解决方案"><a href="#二、分布式事务解决方案" class="headerlink" title="二、分布式事务解决方案"></a>二、分布式事务解决方案</h2><h3 id="2-1-二阶段提交协议-2PC"><a href="#2-1-二阶段提交协议-2PC" class="headerlink" title="2.1 二阶段提交协议(2PC)"></a>2.1 二阶段提交协议(2PC)</h3><p>&emsp;&emsp;在分布式系统中，每个节点虽然可以知晓自己的操作是成功或者失败，却无法知道其他节点的操作是成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为 协调者 的组件来统一掌控所有节点(称作参与者)的操作结果，并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。<br>&emsp;&emsp;因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈决定各个参与者是否要提交操作还是中止操作。<br>&emsp;&emsp;<br>&emsp;&emsp;二阶段提交算法的成立基于以下假设：</p>
<ul>
<li>   该分布式系统中，存在一个节点作为协调者，其他节点作为参与者。且节点之间可以进行网络通信。</li>
<li>   所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li>
<li>   所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li>
</ul>
<p>&emsp;&emsp;两阶段提交协议把分布式事务分成两个过程，一个是准备阶段，一个是提交阶段：<br>&emsp;&emsp;1.准备阶段：协调者向所有参与者发起指令，参与者评估自己的状态，如果参与者评估指令可以完成，参与者会写redo或者undo日志（Write-Ahead Log的一种），然后锁定资源，执行操作，但是并不提交，并反馈给协调者；</p>
<p>&emsp;&emsp;2.提交阶段：如果每个参与者明确返回准备成功，也就是预留资源和执行操作成功，协调者向参与者发起提交指令，参与者提交资源变更的事务，释放锁定的资源；如果任何一个参与者明确返回准备失败，也就是预留资源或者执行操作失败，协调者向参与者发起中止指令，参与者取消已经变更的事务，执行undo日志，释放锁定的资源。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408112008613.jpeg" alt="d32da35a66599d2785d4d34cfd515e28.jpg">&emsp;&emsp;<br>&emsp;&emsp;两阶段提交协议在准备阶段锁定资源，是一个重量级的操作，并能保证强一致性，但是实现起来复杂、成本较高，不够灵活，更重要的是它有如下致命的问题：</p>
<ol>
<li><p>同步阻塞（性能问题）：从上面的描述来看，对于任何一次指令必须收到明确的响应，才会继续做下一步，否则处于阻塞状态，参与者占用的资源被一直锁定，不会被释放；</p>
</li>
<li><p>单点故障（可靠性问题）：如果协调者宕机，参与者没有了协调者指挥，会一直阻塞。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。尽管可以通过选举方式选出新的协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题；</p>
</li>
<li><p>   数据不一致：当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，导致只有一部分参与者接受到了commit请求。而这部分参与者接到commit请求之后就会执行commit操作，但是其它未接到commit请求的机器则无法执行事务提交，于是整个分布式系统便出现了数据不一致性的现象。</p>
</li>
</ol>
<p>&emsp;&emsp;上面所有的这些问题，都是需要人工干预处理，没有自动化的解决方案，因此两阶段提交协议在正常情况下能保证系统的强一致性，但是在出现异常情况下，当前处理的操作处于错误状态，需要管理员人工干预解决，因此可用性不够好，这也符合CAP协议的一致性和可用性不能兼得的原理。</p>
<p>&emsp;&emsp;</p>
<h3 id="2-2-三阶段提交协议-3PC"><a href="#2-2-三阶段提交协议-3PC" class="headerlink" title="2.2 三阶段提交协议(3PC)"></a>2.2 三阶段提交协议(3PC)</h3><p>&emsp;&emsp;<strong>二阶段协议存在的问题:主要是同步阻塞问题。</strong>在二阶段协议中的第一阶段，所有参与者接受到事务协调器的事务准备请求后，会在本地开启并执行事务，但是没有提交事务。之后所有参与者等待第二阶段事务协调器发出事务提交或者回滚后才会提交或者回滚事务。而在这期间所有参与者开启的本地事务一直存在，也就是一直把相应的资源锁定了（比如本地事务要更新一行数据，则在开启事务后，事务提交或者回滚之前都一直通过行锁锁定了这行数据），导致其他需要访问这行数据的事务阻塞等待。<br>&emsp;&emsp;假如在第一阶段事务协调器给10个参与者发送准备请求，其中9个参与者正确接受了，并开启了本地事务锁定了具体的资源，而剩下一个参与者 或者由于网络问题没有收到准备请求，或者接受到了但是本事事务执行失败，或者执行正常但是给事务协调器的回执由于网络原因没有被协调器收到等，则事务协调器发现其中一个参与者返回准备失败或者等待超时后还没收到那一个参与者的回执则会通知所有的参与者执行回滚操作。也就是在具体回滚前，其他9个参与者白白的锁定了本地资源，这显然很浪费。</p>
<p>&emsp;&emsp;三阶段协议把二阶段的第一阶段在细分为2阶段，具体内容如下：</p>
<ul>
<li><p>第一阶段 canCommit<br>事务发起方发起事务后，事务协调器会给所有的事务参与者发起 canCommit 的请求，参与者收到后根据自己的情况判断是否可以执行提交，如果可以则返回ok，否者返回fail，但不开启本地事务并执行。具体参与者是如何判断本地是否可以执行提交协议并没有具体规定，需要协议实现者自己规定，比如可能判断参与者是否存在（网络是否OK）或者本地数据库连接是否可用来判断。<br>如果协调器发现有些参与者返回fail或者等待超时后参与者还没返回，则给所有事务参与者发起中断操作，具体中断操作做什么协议也没有具体规定。如果协调器发现所有参与者返回可以提交，则进入第二阶段。</p>
</li>
<li><p>第二阶段 preCommit<br> 事务协调器向所有参与者发起准备事务请求，参与者接受到后，开启本地事务并执行，但是不提交。剩下的与二阶段协议的第一阶段一致。</p>
</li>
<li><p>第三阶段doCommit<br> 与二阶段协议中的第二阶段一致。</p>
<p> <img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408112010148.jpeg" alt="89cd7f395e530a61da32a3bfa6669e15.jpg"></p>
</li>
</ul>
<p>&emsp;&emsp;三阶段协议与二阶段协议最大不同在于三阶段协议把二阶段协议的第一阶段拆分为了两个阶段，其中第一阶段并不锁定资源，而是询问参与者是否可以提交，等所有参与者回复OK后在具体执行第二阶段锁定资源，询问阶段可以确保尽可能早的发现无法执行操作而需要中止的行为，但是它并不能发现所有的这种行为，只会减少这种情况的发生。理论上如果第一阶段返回都OK，则第二阶段和三阶段执行成功的概率就很大，另外如果第一阶段有些参与者返回了fail，由于这时候其他参与者还没有锁定资源，所以不会造成资源的阻塞。</p>
<p>​	与2PC相比，3PC降低了阻塞范围，并且在等待超时后，协调者或参与者会中断事务，避免了协调者单点问题，阶段三中协调者出现问题时，参与者会继续提交事务。</p>
<p>​	数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 doCommit 指令时，此时如果协调者请求中断事务，而协调者因为网络问题无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</p>
<p>​	2PC和3PC都无法保证数据绝对的一致性，一般为了预防这种问题，可以添加一个报警，比如监控到事务异常的时候，通过脚本自动补偿差异的信息。</p>
<p>&emsp;&emsp;</p>
<h3 id="2-3-TCC编程模式"><a href="#2-3-TCC编程模式" class="headerlink" title="2.3 TCC编程模式"></a>2.3 TCC编程模式</h3><p>&emsp;&emsp;TCC是通过补偿机制实现最终一致性，TCC编程模式本质上也是一种二阶段协议，不同在于TCC编程模式需要与具体业务耦合，下面首先看下TCC编程模式步骤:</p>
<ul>
<li>所有事务参与方都需要实现try,confirm,cancle接口。</li>
<li>事务发起方 向 事务协调器 发起事务请求，事务协调器调用所有事务参与者的try方法完成资源的预留，这时候并没有真正执行业务，而是为后面具体要执行的业务预留资源，这里完成了一阶段。</li>
<li>如果事务协调器发现有参与者的try方法预留资源时候发现资源不够，则调用参与方的cancle方法回滚预留的资源，注意<strong>cancle方法需要实现业务幂等</strong>，因为有可能调用失败（比如网络原因参与者接受到了请求，但是由于网络原因事务协调器没有接受到回执）会重试。</li>
<li>如果事务协调器发现所有参与者的try方法返回都OK，则事务协调器调用所有参与者的confirm方法，不做资源检查，直接进行具体的业务操作。</li>
<li>如果协调器发现所有参与者的confirm方法都OK了，则分布式事务结束。</li>
<li>如果协调器发现有些参与者的confirm方法失败了，或者由于网络原因没有收到回执，则协调器会进行重试。这里如果重试一定次数后还是失败，会怎么样那？常见的是做事务补偿。</li>
</ul>
<p>TCC的执行流程可以分为两个阶段，分别如下：</p>
<p>（1）第一阶段：Try，业务系统做检测并预留资源 (加锁，锁住资源)，比如常见的下单，在try阶段，我们不是真正的减库存，而是把下单的库存给锁定住。</p>
<p>（2）第二阶段：根据第一阶段的结果决定是执行confirm还是cancel</p>
<ul>
<li>Confirm：执行真正的业务（执行业务，释放锁）</li>
<li>Cancle：是对Try阶段预留资源的释放（出问题，释放锁）</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408112013160.jpeg" alt="3ea72d3d3c669ceb5b2cd026d777cb7e.jpg"></p>
<p>&emsp;&emsp;</p>
<h3 id="2-4-本地消息-事务-表"><a href="#2-4-本地消息-事务-表" class="headerlink" title="2.4 本地消息(事务)表"></a>2.4 本地消息(事务)表</h3><p>&emsp;&emsp;此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理，达到最终的一致。</p>
<p>&emsp;&emsp;举个例子。假设系统中有两个表<code>user(id, name, amt_sold, amt_bought)</code>及<code>transaction(xid, seller_id, buyer_id, amount)</code>。其中user表记录用户交易汇总信息，transaction表记录每个交易的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">    INSERT INTO transaction VALUES(xid, $seller_id, $buyer_id, $amount);</span><br><span class="line">    UPDATE user SET amt_sold = amt_sold + $amount WHERE id = $seller_id;</span><br><span class="line">    UPDATE user SET amt_bought = amt_bought + $amount WHERE id = $buyer_id;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;即在transaction表中记录交易信息，然后更新卖家和买家的状态。</p>
<p>&emsp;&emsp;假设transaction表和user表存储在不同的节点上，那么上述事务就是一个分布式事务。对于一个分布式事务，需要考虑将其拆分两个独立的子事务，每个子事务都有一张本地消息表。<br>&emsp;&emsp;对于transaction表插入的业务，先启动一个事务，插入transaction表后，并不直接去更新user表，而是将更新业务以消息的形式插入到本地消息表message。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">    INSERT INTO transaction VALUES(xid, $seller_id, $buyer_id, $amount);</span><br><span class="line">    put_to_queue &#x27;update user(“seller”, $seller_id, amount)&#x27;;</span><br><span class="line">    put_to_queue &#x27;update user(“buyer”, $buyer_id, amount)&#x27;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于user表更新业务，也需要新建一个<code>message_applied(msg_id)</code>表来记录被成功应用的消息，然后发起一个异步任务轮询队列内容进行处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for each message in queue</span><br><span class="line">    begin;</span><br><span class="line">    //先检查此消息是否已处理</span><br><span class="line">    SELECT count(*) as cnt FROM message_applied WHERE msg_id = message.id;</span><br><span class="line">    if cnt = 0 then</span><br><span class="line">    //若没有处理，对user表做更新操作</span><br><span class="line">    if message.type = “seller” then</span><br><span class="line">        UPDATE user SET amt_sold = amt_sold + message.amount WHERE id = message.user_id;</span><br><span class="line">    else</span><br><span class="line">        UPDATE user SET amt_bought = amt_bought + message.amount WHERE id = message.user_id;</span><br><span class="line">    end</span><br><span class="line">    //插入应用的消息，标记此消息已处理</span><br><span class="line">    INSERT INTO message_applied VALUES(message.id);</span><br><span class="line">    end</span><br><span class="line">    commit;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;来仔细分析一下上面代码：<br>&emsp;&emsp;1. 消息队列与transaction使用同一实例，因此第一个事务不涉及分布式操作；<br>&emsp;&emsp;2. message_applied与user表在同一个实例中，也能保证一致性；<br>&emsp;&emsp;3. 第二个事务结束后，系统可能出故障，出故障后系统会重新从消息队列中取出这一消息，但通过message_applied表可以检查出来这一消息已经被应用过，跳过这一消息实现正确的行为。</p>
<hr>
<p><strong>本地消息表的执行流程：</strong></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408112019172.jpeg" alt="1d5b0548ba00d569f9bf3cd85840262e.jpg"></p>
<ul>
<li>① 事务主动方在同一个本地事务中处理业务和写消息表操作</li>
<li>② 事务主动方通过消息中间件，通知事务被动方处理事务消息。消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。</li>
<li>③ 事务被动方通过消息中间件，通知事务主动方事务已处理的消息。</li>
<li>④ 事务主动方接收中间件的消息，更新消息表的状态为已处理。</li>
</ul>
<p>一些必要的容错处理如下：</p>
<ul>
<li>当①处理出错，由于还在事务主动方的本地事务中，直接回滚即可</li>
<li>当②、③处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，通知事务被动方重新读取消息处理业务即可。</li>
<li>如果是业务上处理失败，事务被动方可以发消息给事务主动方回滚事务</li>
<li>如果事务被动方已经消费了消息，事务主动方需要回滚事务的话，需要发消息通知事务主动方进行回滚事务。</li>
</ul>
<p><strong>本地消息表的优缺点</strong>：</p>
<p>（1）优点：</p>
<ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<p>2）缺点：</p>
<ul>
<li>与具体的业务场景绑定，耦合性强，不可公用</li>
<li>消息数据与业务数据同库，占用业务系统资源</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限</li>
</ul>
<p>&emsp;&emsp;</p>
<h3 id="2-5-采用MQ事务消息"><a href="#2-5-采用MQ事务消息" class="headerlink" title="2.5 采用MQ事务消息"></a>2.5 采用MQ事务消息</h3><p>​	基于MQ的分布式事务方案本质上是对本地消息表的封装，整体流程与本地消息表一致，唯一不同的就是将本地消息表存在了MQ内部，而不是业务数据库中，如下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408112021699.png" alt="6501a3de25d9618797c6fdbc1eb9306b.png"><br>&emsp;&emsp;实质上，基于消息中间件的两阶段提交是将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息)+ B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。</p>
<p>​	由于将本地消息表存在了MQ内部，那么MQ内部的处理尤为重要，下面主要基于 RocketMQ4.3 之后的版本介绍 MQ 的分布式事务方案。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408112024512.png" alt="7752a69202d9c41af10e8991e26b08c3.png"></p>
<p>​	在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，而 RocketMQ 的事务消息相对于普通 MQ提供了 2PC 的提交接口，方案如下：</p>
<p><strong>（1）正常情况：</strong></p>
<p>在事务主动方服务正常，没有发生故障的情况下，发消息流程如下：</p>
<ul>
<li>步骤①：发送方向 MQ Server(MQ服务方)发送 half 消息</li>
<li>步骤②：MQ Server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功</li>
<li>步骤③：发送方开始执行本地事务逻辑</li>
<li>步骤④：发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</li>
<li>最终步骤：MQ Server 如果收到的是 commit 操作，则将半消息标记为可投递，MQ订阅方最终将收到该消息；若收到的是 rollback 操作则删除 half 半消息，订阅方将不会接受该消息</li>
</ul>
<p><strong>（2）异常情况：</strong></p>
<p>​	在断网或者应用重启等异常情况下，图中的步骤④提交的二次确认超时未到达 MQ Server，此时的处理逻辑如下：</p>
<ul>
<li>步骤⑤：MQ Server 对该消息发起消息回查</li>
<li>步骤⑥：发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果</li>
<li>步骤⑦：发送方根据检查得到的本地事务的最终状态再次提交二次确认。</li>
<li>最终步骤：MQ Server基于 commit&#x2F;rollback 对消息进行投递或者删除。</li>
</ul>
<p><strong>MQ事务消息的优缺点：</strong></p>
<p>（1）优点：相比本地消息表方案，MQ 事务方案优点是：</p>
<ul>
<li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合</li>
<li>吞吐量大于使用本地消息表方案</li>
</ul>
<p>（2）缺点：</p>
<ul>
<li>一次消息发送需要两次网络请求(half 消息 + commit&#x2F;rollback 消息) 。</li>
<li>业务处理服务需要实现消息状态回查接口。</li>
</ul>
<h3 id="2-6-最大努力通知"><a href="#2-6-最大努力通知" class="headerlink" title="2.6 最大努力通知"></a>2.6 最大努力通知</h3><p>​	最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到主动方发送的消息，此时可以调用事务主动方提供的消息校对的接口主动获取。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408112026928.png" alt="7d1f86d1f8b86ad0448a38ce8fb0be51.png"></p>
<p>​	在可靠消息事务中，事务主动方需要将消息发送出去，并且让接收方成功接收消息，这种可靠性发送是由事务主动方保证的；但是最大努力通知，事务主动方仅仅是尽最大努力（重试，轮询…）将事务发送给事务接收方，所以存在事务被动方接收不到消息的情况，此时需要事务被动方主动调用事务主动方的消息校对接口查询业务消息并消费，这种通知的可靠性是由事务被动方保证的。</p>
<p>​	所以最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。</p>
<hr>
<p>转载自：<br><a href="http://ifeve.com/distribute-transaction-2pc/">http://ifeve.com/distribute-transaction-2pc/</a><br><a href="http://coolshell.cn/articles/10910.html">http://coolshell.cn/articles/10910.html</a><br><a href="http://www.jianshu.com/p/1156151e20c8">http://www.jianshu.com/p/1156151e20c8</a><br><a href="https://blog.csdn.net/suifeng3051/article/details/52691210">https://blog.csdn.net/suifeng3051/article/details/52691210</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
        <category>分布式事务</category>
      </categories>
  </entry>
  <entry>
    <title>Redis过期策略实现原理</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/Redis/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>我们在使用redis时，一般会设置一个过期时间，当然也有不设置过期时间的，也就是永久不过期。<br>当我们设置了过期时间，redis是如何判断是否过期，以及根据什么策略来进行删除的。</p>
<p>1.redis设置过期时间：expire 只针对顶级key有效，即哈希结构不支持过期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expire key time(以秒为单位)--这是最常用的方式</span><br><span class="line"></span><br><span class="line">setex(String key, int seconds, String value)--字符串独有的方式</span><br></pre></td></tr></table></figure>
<p>注：<br>除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间;<br>如果没有设置时间，那缓存就是永不过期;<br>如果设置了过期时间，之后又想让缓存永不过期，使用persist key;</p>
<span id="more"></span>

<p>2.三种过期策略：</p>
<ul>
<li><p>a.定时删除<br>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</p>
<p>优点：保证内存被尽快释放</p>
<p>缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key; 定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重。</p>
</li>
<li><p>b.懒汉式删除<br>含义：key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null。</p>
<p>优点：删除操作只发生在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</p>
<p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p>
</li>
<li><p>c.定期删除<br>含义：每隔一段时间执行一次删除过期key操作</p>
<p>优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点；定期删除过期key–处理”懒汉式删除”的缺点</p>
<p>缺点：在内存友好方面，不如”定时删除”（会造成一定的内存占用，但是没有懒汉式那么占用内存）；在CPU时间友好方面，不如”懒汉式删除”（会定期的去进行比较和删除操作，cpu方面不如懒汉式，但是比定时好）</p>
<p>难点：合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了），每次执行时间太长，或者执行频率太高对cpu都是一种压力。每次进行定期删除操作执行之后，需要记录遍历循环到了哪个标志位，以便下一次定期时间来时，从上次位置开始进行循环遍历</p>
</li>
</ul>
<blockquote>
<p>memcached只是用了惰性删除，而redis同时使用了惰性删除与定期删除，这也是二者的一个不同点（可以看做是redis优于memcached的一点）；<br>对于懒汉式删除而言，并不是只有获取key的时候才会检查key是否过期，在某些设置key的方法上也会检查（eg.setnx key2 value2：该方法类似于memcached的add方法，如果设置的key2已经存在，那么该方法返回false，什么都不做；如果设置的key2不存在，那么该方法设置缓存key2-value2。假设调用此方法的时候，发现redis中已经存在了key2，但是该key2已经过期了，如果此时不执行删除操作的话，setnx方法将会直接返回false，也就是说此时并没有重新设置key2-value2成功，所以对于一定要在setnx执行之前，对key2进行过期检查）。</p>
</blockquote>
<p>3.Redis采用的过期策略<br>  懒汉式删除+定期删除</p>
<ul>
<li><p>懒汉式删除流程：</p>
<blockquote>
<p>在进行get或setnx等操作时，先检查key是否过期；<br>若过期，删除key，然后执行相应操作；<br>若没过期，直接执行相应操作；</p>
</blockquote>
</li>
<li><p>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）：</p>
<blockquote>
<p>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）<br>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体是下边的描述）<br>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历<br>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key<br>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</p>
</blockquote>
</li>
</ul>
<p>对于定期删除，在程序中有一个全局变量current_db来记录下一个将要遍历的库，假设有16个库，我们这一次定期删除遍历了10个，那此时的current_db就是11，下一次定期删除就从第11个库开始遍历，假设current_db等于15了，那么之后遍历就再从0号库开始（此时current_db&#x3D;&#x3D;0）</p>
<p>在实际中，如果我们要自己设计过期策略，在使用<strong>懒汉式删除+定期删除</strong>时，控制<strong>时长和频率</strong>这个尤为关键，需要结合服务器性能，已经并发量等情况进行调整，以致最佳。</p>
<hr>
<hr>
<p><strong>定期删除+惰性删除是如何工作</strong></p>
<p>定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。</p>
<p>需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。</p>
<p>因此，如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。</p>
<p>也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。</p>
<p>采用定期删除+惰性删除就没其他问题了么?</p>
<p>不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。</p>
<p><strong>在 redis.conf 中有一行配置：</strong></p>
<p># maxmemory-policy volatile-lru</p>
<p><strong>该配置就是配内存淘汰策略：</strong></p>
<p>◆noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。</p>
<p>◆allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。</p>
<p>◆allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。</p>
<p>◆volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。</p>
<p>◆volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。</p>
<p>◆volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。</p>
<p>PS：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)；那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/zhousenshan/article/details/78569234">https://blog.csdn.net/zhousenshan/article/details/78569234</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>从Opentracing、OpenCensus 到 OpenTelemetry，看可观测数据标准演进史</title>
    <url>/2024/06/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%8F%AF%E8%A7%82%E6%B5%8B/%E4%BB%8EOpentracing%E3%80%81OpenCensus%20%E5%88%B0%20OpenTelemetry%EF%BC%8C%E7%9C%8B%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E6%BC%94%E8%BF%9B%E5%8F%B2/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;伴随着分布式应用、Serverless 应用被越来越多开发者及企业所接受，但其背后所隐藏的运维问题也逐渐凸显出来–微服务架构中请求链路过长从而导致问题定位时间长，运维想要日常监控也非常困难。以一个具体问题举例，在分布式应用中完成一个单一用户请求可能会需要多个不同的微服务处理，这其中任何一个服务失败或性能拉垮，都会对用户请求响应造成极大影响。随着业务不断扩张，这个调用链也越来越复杂。仅凭借打印日志或 APM 性能监控很难做到全景浏览或者一竿到底。对于问题排查或性能分析时，这无异于盲人摸象。</p>
<p>&emsp;&emsp;面对这样的问题，Google 发表了论文《“Dapper - a Large-Scale Distributed Systems Tracing Infrastructure”》介绍他们的分布式跟踪技术，并认为分布式跟踪系统应该满足以下业务需求：</p>
<ul>
<li>性能低损耗： 分布式跟踪系统对服务的性能损耗应尽可能做到忽略不计，尤其是那些对性能敏感的应用。</li>
<li>低侵入： 尽可能做到业务代码的低侵入或无侵入。</li>
<li>快速扩展：能够随着业务或微服务规模快速扩大。</li>
<li>实时展现：低延时采集数据，实时监控系统，对系统的异常状况作出快速的反应。</li>
</ul>
<span id="more"></span>

<p>&emsp;&emsp;除了以上要求，该论文也针对分布式追踪的数据采集、数据持久化、数据展示三个核心环节进行了完整阐述。这其中，数据采集指在代码中埋点，设置请求中需要上报的内容。数据持久化指将上报的数据落盘存储。数据展示则是根据 TraceID 查询与之关联的请求在界面上呈现。</p>
<p>&emsp;&emsp;也是随着这篇论文的诞生，分布式追踪（Distributed Tracing)被越来越多人接受，技术概念逐渐兴起。相关产品如雨后春笋般涌现，Uber 的 Jaeger、Twitter 的 Zipkin 等分布式追踪产品声名大噪。但在这过程中也带来了一个问题：虽然每个产品都有自己一套数据采集标准和 SDK，但大多都是基于谷歌 Dapper 协议，只是实现不尽相同。为了解决这个问题，OpenTracing 和 OpenCensus 诞生。</p>
<h1 id="OpenTracing"><a href="#OpenTracing" class="headerlink" title="OpenTracing"></a>OpenTracing</h1><p>&emsp;&emsp;对于很多开发人员而言，想让应用支持分布式追踪太难了。这不仅需要在进程内进行追踪数据的传递，还要在进程之间传递。更难的是还需要其他组件对分布式跟踪的支持，比如 NGINX, Cassandra, Redis 等开源服务，或者在服务内引入的 gRPC, ORMs 等开源库。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240606161441.png" alt="在这里插入图片描述"></p>
<p>&emsp;&emsp;在 OepnTracing 之前，一方面，很多分布式追踪系统通过使用不兼容 API 的应用程序级检测进行实现，这使得开发人员对应用与任何特定的分布式跟踪紧密耦合，都会感到不安。另一方面，这些应用程序级检测 API 具有非常相似的语义。为了解决不同的分布式追踪系统 API 不兼容问题，或者说追踪数据从一个库到另一个库和一个进程到下一个进程传递过程中的标准化问题，诞生了 OpenTracing 规范。位于应用程序&#x2F;类库和追踪或日志分析程序之间的轻量级标准化层。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>&emsp;&emsp;OpenTracing 的优势在于制定了一套无关厂商、无关平台的协议标准，使开发人员只需要修改 Tracer 就可以更迅捷的添加或更换底层监控的实现。也是基于这一点，2016 年云原生计算基金会 CNCF 正式接纳 OpenTracing，顺利成为 CNCF 第三个项目。而前两个项目都已成为云原生及开源领域的事实标准—Kubernetes 和 Prometheus。由此也可以看到行业对于可观测及统一标准的重视程度。</p>
<p>&emsp;&emsp;OpenTracing 由 API 规范、实现该规范的框架和库，以及项目文档组成，并进行以下努力：</p>
<ul>
<li>后台无关的 API 接口标准化：被追踪的服务只需要调用相关 API 接口，就可被任何实现这套接口的追踪后台支持。</li>
<li>对跟踪最小单位 Span 管理标准化：定义开始 Span，结束 Span 和记录 Span 耗时的 API。</li>
<li>进程间跟踪数据传递方式标准化：定义 API 方便追踪数据的传递。</li>
<li>对多语言应用支持的标准化：全面覆盖 GO、Python、Javascript、Java、C#、Objective-C、C++ 、Ruby、PHP 等开发语言。它支持 Zipkin、LightStep、Appdash 跟踪器，并可以轻松集成到 GRPC、Flask、DropWizard、Django和Go Kit 等框架中。</li>
</ul>
<h2 id="核心术语介绍"><a href="#核心术语介绍" class="headerlink" title="核心术语介绍"></a>核心术语介绍</h2><ul>
<li><p>Trace<br>一个完整请求链路。</p>
</li>
<li><p>Span - 一次调用过程<br>  系统中具有开始时间和执行时长的逻辑单元，并包含多个状态。<br>  每个 Span 封装以下状态：</p>
</li>
</ul>
<blockquote>
<p>An operation name - 操作名称<br>A start timestamp - 起始时间<br>A finish timestamp - 结束时间<br>Span Tag - 一组键值对构成的 Span 标签集合。键值对的键必须为 String，值可以是字符串、布尔或数字类型。<br>Span Log - 一组 Span 的日志集合。每次 Log 操作包含一个键值对以及时间戳。键值对的键必须为 String，值可以是任意类型。</p>
</blockquote>
<ul>
<li><p>References - Span 间关系<br>              相关的零个或者多个 Span。Span 间通过 SpanContext 建立 References 关系。</p>
</li>
<li><p>SpanContext - 通过 SpanContext，引用其他因果相关的 Span。</p>
</li>
</ul>
<p>&emsp;&emsp;OpenTracing 目前定义了两种类型的引用：ChildOf 和 FollowsFrom. 这两种引用类型都专门模拟了子 Span 和父 Span 之间的直接因果关系。</p>
<p>&emsp;&emsp;ChildOf 关系中的父级 Span 要等待子 Span 返回，子 Span 执行时间影响了其所在父 Span 执行时间，父 Span 依赖子 Span 执行结果。除了串行的任务之外，我们的逻辑中还有很多并行的任务，它们对应的 Span 也是并行的，这种情况下一个父 Span 可以合并所有子 Span 执行结果并等待所有并行子 Span 结束。在分布式应用中某些上游系统不以任何方式依赖下游系统执行结果，例如，上游系统通过消息队列向下游系统发送消息。这种情况下，下游系统对应的子 Span 和上游系统对应的父级 Span 之间是 FollowsFrom 关系。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>&emsp;&emsp;在了解相关术语之后，我们可以发现 OpenTracing 规范中具备三个关键且互连的类型：Tracer、Span 和 SpanContext。</p>
<p>&emsp;&emsp;OpenTracing 的技术模型，也就清晰起来：Trace 调用链通过归属于此调用链的 Span 来隐性定义，每次调用就称为一个 Span，每个 Span 都要带上全局的 TraceId 。Trace 调用链可以被认为是一个由多个 Span 组成的有向无环图（DAG 图），一条 Trace 中 Span 是首尾连接的。TraceID 及相关内容以 SpanContext 为载体，通过传输协议，遵循着 Span“路径”按序进行。以上可以看作分布式应用中一次客户端请求全过程，除了从业务视角的 DAG 图之外，为了更好的展示组件调用时间、先后关系等信息，我们也尝试基于时间轴的时序图去更好地展现 Trace 调用链。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240606161456.png" alt="在这里插入图片描述"></p>
<h2 id="相关产品"><a href="#相关产品" class="headerlink" title="相关产品"></a>相关产品</h2><p>&emsp;&emsp;遵循 OpenTracing 协议的产品有 Jaeger、Zipkin、 LightStep 和 AppDash 等追踪组件，并可以轻松集成到 gRPC、Flask、Django 和 Go-kit 等开源框架中。</p>
<h1 id="OpenCensus"><a href="#OpenCensus" class="headerlink" title="OpenCensus"></a>OpenCensus</h1><p>&emsp;&emsp;在整个可观测领域，为了更好的实现 DevOps，除了分布式追踪 Trace，运维人员开始关注 Log 和 Metrics。Metrics 指标监控作为可观测的重要组成部分，包括 CPU、内存、硬盘、网络等机器指标，gRPC 请求延迟、错误率等网络协议指标，用户数、访问数等业务指标。</p>
<p>&emsp;&emsp;OpenCensus 提供了统一的测量工具：跨服务捕获跟踪跨度 Span、应用级别指标 Metrics。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240606161508.png" alt="在这里插入图片描述"></p>
<h2 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h2><ul>
<li>相较于 OpenTracing 只支持 Traces，OpenCensus 支持 Traces 和 Metrics。</li>
<li>相较于 OpenTracing 制定规范，OpenCensus 不仅制定规范，还包含了 Agent 和 Collector。</li>
<li>家属团阵容相较 OpenTracing 更加庞大，获得 Google、微软支持。</li>
</ul>
<h2 id="OpenCensus做了什么"><a href="#OpenCensus做了什么" class="headerlink" title="OpenCensus做了什么"></a>OpenCensus做了什么</h2><ul>
<li>标准通信协议和一致的 API ：用于处理 Metrics 和 Trace。</li>
<li>多语言库支持：Java、C++、Go、.Net、Python、PHP、Node.js、Erlang 、Ruby。</li>
<li>与 RPC 框架的集成。</li>
<li>集成存储和分析工具。</li>
<li>完全开源并支持三方集成和输出的插件化。</li>
<li>不需要额外服务器或 Agent 来支持 OpenCensus。</li>
</ul>
<h2 id="核心术语介绍-1"><a href="#核心术语介绍-1" class="headerlink" title="核心术语介绍"></a>核心术语介绍</h2><p>除了沿用 OpenTracing 的相关术语之外，OpenCensus 也定义了一些新术语。</p>
<ul>
<li>Tags<br>OpenCensus 允许在记录时将指标与维度相关联。从而能够从不同角度分析测量结果。</li>
<li>Stats<br>收集库和应用记录的可观测结果，汇总、导出统计数据，并包括 Recording（记录）、Views（聚合度量查询）两部分。</li>
<li>Trace<br>除了 Opentracing 所提供的 Span 属性之外，OpenCensus 还支持 Parent SpanId、Remote Parent、Attributes、Annotations、Message Events、Links 等属性。</li>
<li>Agent<br>OpenCensus Agent 是一个守护进程，允许 OpenCensus 的多语言部署使用Exporter。与传统上为每个语言库和每个应用程序删除和配置 OpenCensus Exporter不同，使用 OpenCensus Agent，只需为其目标语言单独启用 OpenCensus Agent Exporter。对于运维团队而言，实现单个 exporte 管理并从多语言应用程序中获取数据，将数据发送到所选择的后端。与此同时，尽可能的减少反复启动或部署对于应用的影响。最后，Agent 还附带了“Receivers”。“Receivers”使 Agent 直通后端，去接收可观测数据并将其路由到所选择的 Exporter。比如 Zipkin、Jaeger 或 Prometheus。</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240606161534.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>Collector<br>Collector 作为 OpenCensus 的重要组成部分，由 Go 语言便编写，可以从任何可用 Receivers 的应用中接受流量，而不用关注编程语言以及部署方式，而这个好处显而易见。对于提供 Metrics 和 Trace 的服务或应用而言，只需要一个 Exporters 导出组件，就能从多语言应用中获取数据。</p>
</li>
<li><p>Exporters<br>OpenCensus 可以通过各种 Exporter 实现将相关数据上传到各种后端，比如：Prometheus for stats、OpenZipkin for traces、Stackdriver Monitoring for stats and Trace for traces、Jaeger for traces、Graphite for stats。</p>
<p>对于开发者而言，只需要管理维护单个 Exporter，所有应用都使用 OpenCensus Exporter 发送数据。与此同时，开发人员自由选择将数据发送到业务所需的后端，并随时进行更好。为了解决通过网络发送大量数据可能需要处理发送失败的问题，Collector 具有缓冲和重试功能，可确保数据完整性与可用性。</p>
</li>
</ul>
<h2 id="相关产品-1"><a href="#相关产品-1" class="headerlink" title="相关产品"></a>相关产品</h2><p>&emsp;&emsp;遵循 OpenCensus 协议的产品有 Prometheus、SignalFX、Stackdriver 和 Zipkin。</p>
<p>&emsp;&emsp;看到这里，我们可以看到从功能、特性等维度来评估上述两者。OpenTracing 和 OpenCensus 各有明显优缺点：OpenTracing 支持语言更多、对其他系统耦合性更低；OpenCensus 支持 Metrics、分布式跟踪，同时从 API 层一直到基础设施层都进行支持。对很多开发人员而言，选择困难症发作的同时，一个新的想法不断被讨论：是否能有一个能够将 OpenTracing 和 OpenCensus，并且能够支持 Log 日志相关可观测数据的项目呢？</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240606161544.png" alt="在这里插入图片描述"></p>
<h1 id="OpenTelemetry"><a href="#OpenTelemetry" class="headerlink" title="OpenTelemetry"></a>OpenTelemetry</h1><p>在回答上一个问题时，我们先看看一个典型服务问题排查过程是怎样的：</p>
<ol>
<li>通过各式各样预设报警发现异常（Metrics&#x2F;Logs）</li>
<li>打开监控大盘查找异常现象，并通过查询找到异常模块（Metrics）</li>
<li>对异常模块以及关联日志进行查询分析，找到核心的报错信息（Logs）</li>
<li>通过详细的调用链数据定位到引起问题的代码（Tracing）</li>
</ol>
<p>为了能够获得更好的可观测性或快速解决上述问题，Tracing、Metrics、Logs缺一不可。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240606161550.png" alt="在这里插入图片描述"></p>
<p>与此同时，行业中已经有了丰富的开源及商业方案，其中包括：</p>
<ul>
<li>Metric：Zabbix、Nagios、Prometheus、InfluxDB、OpenFalcon、OpenCensus</li>
<li>Tracing：Jaeger、Zipkin、SkyWalking、OpenTracing、OpenCensus</li>
<li>Logs：ELK、Splunk、SumoLogic、Loki、Loggly。</li>
</ul>
<p>有着五花八门的方案同时，各个方案也有着五花八门的协议格式&#x2F;数据类型。不同的方案之间很难兼容&#x2F;互通。与此同时，实际的业务场景中也会将各种方案混用，开发人员只能自己开发各类 Adapter 去兼容。</p>
<h2 id="什么是-OpenTelemetry"><a href="#什么是-OpenTelemetry" class="headerlink" title="什么是 OpenTelemetry"></a>什么是 OpenTelemetry</h2><p>为了更好的将 Traces、Metrics 和 Logs 融合在一起，OpenTelemetry 诞生了。作为 CNCF 的孵化项目，OpenTelemetry 由 OpenTracing 和 OpenCensus 项目合并而成，是一组规范、API 接口、SDK、工具和集成。为众多开发人员带来 Metrics、Tracing、Logs 的统一标准，三者都有相同的元数据结构，可以轻松实现互相关联。</p>
<p>OpenTelemetry 与厂商、平台无关，不提供与可观测性相关的后端服务。可根据用户需求将可观测类数据导出到存储、查询、可视化等不同后端，如 Prometheus、Jaeger 、云厂商服务中。</p>
<h2 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h2><p>OpenTelemetry 核心优势集中在以下部分：</p>
<ul>
<li>完全打破各个厂商的 Lock-on 隐患</li>
</ul>
<p>​	作为运维人员而言，发现工具不够用，但评估实现成本太高而无法切换时，一定会跳起来大骂厂商“狗贼又要谋害朕”。而 OpenTelemetry 的出现，旨在通过提供标准化 instrumentation 框架打破这种宿命，作为一个可插拔的服务，可以轻松添加常见的技术协议与格式，让服务选择更加自由。</p>
<ul>
<li>规范的制定和协议的统一</li>
</ul>
<p>​	OpenTelemetry 采用基于标准的实现方法。对标准的关注对于 OpenTelemetry 来说尤其重要，因为需要追踪跨语言的互操作性。许多语言都带有类型定义，可以在实现中使用，例如用于创建可重用组件的接口。包括可观测客户端内部实现所需要的规范，以及可观测客户端与外部通信所需实现的协议规范。具体包括：</p>
<blockquote>
<ul>
<li>API：定义 Metrics、Tracing、Logs 数据的类型和操作。</li>
<li>SDK：定义 API 特定语言实现需求，定义配置、数据处理和导出概念。</li>
<li>数据：定义 OpenTelemetry Line Protocol （OTLP）。虽然在 Opentelemetry中组件支持了 Zipkin v2 或 Jaeger Thrift 协议格式的实现，但都以第三方贡献库形式提供。只有 OTLP 是 Opentelemetry 官方原生支持的格式。</li>
</ul>
</blockquote>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240606161556.png" alt="在这里插入图片描述"></p>
<p>&emsp;&emsp;每种语言都通过其 API 实现规范。API 包含特定于语言的类型和接口定义，它们是抽象类、类型和接口，由具体的语言实现使用。它们还包含无操作（no-op）实现，以支持本地测试并为单元测试提供工具。API 的定义位于每种语言的实现中。正如 OpenTelemetry Python 客户端所述：“opentelemetry-api 包包括抽象类和无操作实现，它们组成了遵循规范的 OpenTelemetry API。”可以在 Javascript 客户端中看到类似定义：“这个包提供了与 OpenTelemetry API 交互所需的所有东西，包括所有 TypeScript 接口、枚举和 no-op 实现。它既可以在服务器上使用，也可以在浏览器中使用。”</p>
<ul>
<li>多语言 SDK 的实现和集成</li>
</ul>
<p>&emsp;&emsp;OpenTelemetry 为每个常见语言都实现了对应 SDK，将导出器与 API 结合在一起。SDK 是具体的、可执行的 API 实现。包含 C++、.NET、Erlang&#x2F;Elixir、Go、Java、JavaScript、PHP、Python、Ruby、Rust、Swift。</p>
<p>&emsp;&emsp;OpenTelemetry SDK 通过使用 OpenTelemetry API 使用选择的语言生成可观测数据，并将该数据导出到后端。并允许为公共库或框架增强。用户可以使用 SDK 进行代码自动注入和手动埋点，同时对其他三方库（Log4j、LogBack 等）集成支持；这些包一般都是根据 opentelemetry-specification 里面的规范与定义，结合语言自身的特点去实现在客户端采集可观测数据的基本能力。如元数据在服务间、进程间的传递，Trace 添加监测与数据导出，Metrics 指标的创建、使用及数据导出等。</p>
<ul>
<li>数据收集系统的实现</li>
</ul>
<p>&emsp;&emsp;在 Tracing 实践中有个基本原则，可观测数据收集过程需要与业务逻辑处理正交。尽量减少可观测客户端对原有业务逻辑的影响，Collector 是基于这个原则。</p>
<p>&emsp;&emsp;OpenTelemetry 基于 OpenCensus Service 的收集系统，包括 Agent 和 Collector。Collector 涵盖采集（Collect）、转换（Transform）和导出（Export）可观测数据的功能，支持以多种格式（例如 OTLP、Jaeger、Prometheus 等）接收可观测数据，并将数据发送到一个或多个后端。它还支持在输出可观测数据之前，对其进行处理和过滤。Collector contrib 软件包支持更多数据格式和后端。</p>
<p>&emsp;&emsp;从架构层面来说，Collector 有两种模式。一种是把 Collector 部署在应用相同的主机内（如Kubernetes 的 DaemonSet），或者部署在应用相同的 Pod 里面（如Kubernetes 中的 Sidecar），应用采集到的遥测数据，直接通过回环网络传递给 Collector。这种模式统称为 Agent 模式。另一种模式是把 Collector 当作一个独立的中间件，应用把采集到的遥测数据往这个中间件里面传递。这种模式称之为 Gateway 模式。两种模式既可以单独使用，也可以组合使用，只需要数据出口的数据协议格式跟数据入口的数据协议格式保持一致。</p>
<ul>
<li><p>自动代码注入技术<br>OpenTelemetry 也开始提供可以自动代码注入的实现，目前已经支持Java各类主流框架的自动注入。</p>
</li>
<li><p>云原生架构<br>OpenTelemetry 设计之初就已经考虑了云原生的特性，并且还提供了 Kubernetes Operator 用于快速部署使用。</p>
</li>
</ul>
<h2 id="OpenTelemetry-支持的数据类型"><a href="#OpenTelemetry-支持的数据类型" class="headerlink" title="OpenTelemetry 支持的数据类型"></a>OpenTelemetry 支持的数据类型</h2><ul>
<li><p>Metrics<br>Metric 是关于一个服务的度量，在运行时捕获。从逻辑上讲，捕获其中一个量度的时刻称为 Metric event，它不仅包含量度本身，还包括获取它的时间和相关元数据。应用和请求指标是可用性和性能的重要指标。自定义指标可以深入了解可用性如何影响用户体验和业务。自定义 Metrics 可以深入理解可用性 Metrics 是如何影响用户体验或业务的。</p>
<p> OpenTelemetry 目前定义了三个 Metric 工具：</p>
<blockquote>
<p>• counter: 一个随时间求和的值，可以理解成汽车的里程表，它只会上升。<br>• measure: 随时间聚合的值。它表示某个定义范围内的值。<br>• observer: 捕捉特定时间点的一组当前值，如车辆中的燃油表。</p>
</blockquote>
</li>
<li><p>Logs</p>
<p>日志是带有时间戳的文本记录，可以是带有元数据结构化的，也可以是非结构化的。虽然每个日志都是独立数据源，但可以附加到 Trace 的 Span 中。日常使用调用时，在进行节点分析时出伴随着也可看到日志。<br>在 OpenTelemetry 中，任何不属于分布式 Trace 或 Metrics 的数据都是日志。日志通常用于确定问题根因，通常包含有关谁更改了内容以及更改结果的信息。</p>
</li>
<li><p>Traces</p>
<p>Trace 指单个请求的追踪，请求可以由应用程序发起，也可以由用户发起。分布式 Tracing 是跨网络，跨应用的追踪形式。每个工作单元在 Trace 中被称为 Span，一个 Trace 由一个树形的 Span 组成。Span 表示经过应用程序所设计的服务或组件所做工作的对象，Span 还提供了可用于调试可用性和性能问题的请求、错误和持续时间的 Metrics。Span 包含了一个 Span 上下文，它是一组全局唯一标识符，表示每个 Span 所属的唯一请求。通常我们称之为 TraceID。</p>
</li>
<li><p>Baggage</p>
<p>除了 Trace 的传播，OpenTelemetry 还提供了 Baggage 来传播键值对。Baggage 用于索引一个服务中的可观察事件，该服务包含同一事务中先前的服务提供的属性，有助于在事件之间建立因果关系。虽然 Baggage 可以用作其他横切关注点的原型，但这种机制主要是为了传递 OpenTelemetry 可观测性系统的值。这些值可以从 Baggage 中消费，并作为度量的附加维度，或日志和跟踪的附加上下文使用。</p>
</li>
</ul>
<h2 id="仅仅是第一步，还是一站式？"><a href="#仅仅是第一步，还是一站式？" class="headerlink" title="仅仅是第一步，还是一站式？"></a>仅仅是第一步，还是一站式？</h2><p>&emsp;&emsp;结合上面的内容，我们可以看到 OpenTelemetry 覆盖了各类可观测数据类型的规范定义、API 定义、规范实现以及数据的获取与传输。应用只需要一种 SDK 就可以实现所有类型数据的统一产生；集群只需要部署一个 OpenTelemetry Collector 便可以实现所有类型数据的采集。而且 Metrics、Tracing、Logging 的具有相同的 Meta 信息，可以做无缝关联。</p>
<p>&emsp;&emsp;OpenTelemetry 要解决的是可观测性数据统一的第一步，通过 API 和 SDK 来标准化可观测数据的采集和传输，OpenTelemetry 并不想对所有组件都进行重写，而是最大程度复用业界在各大领域常用工具，通过提供一个安全、无关平台、无关厂商的协议、组件、标准。其自身定位很明确：数据采集和标准规范的统一，对于数据如何去使用、存储、展示、告警，官方是不涉及的。但就可观测整体方案而言，OpenTelemetry 只完成了数据统一生产部分，后续如何存储、利用这些数据进行分析、告警等并没有明确提供相关方案，但这些问题又非常突出。</p>
<ul>
<li><p>各类数据的存储方式</p>
<p>Metrics 可以存在 Prometheus、InfluxDB 或者各类时序数据库；Tracing 可以对接Jaeger、OpenCensus、Zipkin。但如何进行选型以及后续进行运维这些后端服务是个很难抉择的问题。</p>
</li>
<li><p>数据分析（可视化与关联）</p>
<p>对于所采集的数据如何进行统一分析？不同数据需要不同的数据平台进行处理，想要在统一平台显示 Metrics、Logging、Tracing 并实现三者关联跳转，需要很多定制开发工作。这对于运维而言是个很大的工作量。</p>
</li>
<li><p>异常检测与诊断</p>
<p>除了日常可视化监控之外，对应用异常检测和根因诊断是运维的重要业务需求，这时就需要把 OpenTelemetry 的数据融入到 AIOps 中。但对很多开发及运维团队而言，基础的 DevOps 都尚未完全落地，更何况更进一步的 AIOps。</p>
</li>
</ul>
<hr>
<p>转载自：</p>
<p><a href="https://blog.csdn.net/alisystemsoftware/article/details/124164685">https://blog.csdn.net/alisystemsoftware/article/details/124164685</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
        <category>可观测</category>
      </categories>
  </entry>
  <entry>
    <title>分布式系统为什么需要 Tracing</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%8F%AF%E8%A7%82%E6%B5%8B/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Tracing/</url>
    <content><![CDATA[<p>  <strong>Tracer是一个用于分布式系统调用跟踪的组件，通过统一的 ID，将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等等。</strong></p>
<p>   电商平台由数以百计的分布式服务构成，每一个请求路由过来后，会经过多个业务系统并留下足迹，并产生对各种Cache或DB的访问，但是这些分散的数据对于问题排查，或是流程优化都帮助有限。对于这么一个跨进程&#x2F;跨线程的场景，汇总收集并分析海量日志就显得尤为重要。<strong>要能做到追踪每个请求的完整调用链路，收集调用链路上每个服务的性能数据，计算性能数据和比对性能指标（SLA），甚至在更远的未来能够再反馈到服务治理中，那么这就是分布式跟踪的目标了</strong>。</p>
<span id="more"></span>  

<p>  分布式系统的跟踪系统的目标要求有如下几点：</p>
<p>  <strong>1、探针的性能消耗</strong></p>
<p>  APM组件服务的影响应该做到足够小。<strong>服务调用埋点本身会带来性能损耗，这就需要调用跟踪的低损耗，实际中还会通过配置采样率的方式，选择一部分请求去分析请求路径</strong>。在一些高度优化过的服务，即使一点点损耗也会很容易察觉到，而且有可能迫使在线服务的部署团队不得不将跟踪系统关停。</p>
<p>  <strong>2、代码的侵入性</strong></p>
<p>  <strong>即也作为业务组件，应当尽可能少入侵或者无入侵其他业务系统，对于使用方透明，减少开发人员的负担</strong>。</p>
<p>  对于应用的程序员来说，是不需要知道有跟踪系统这回事的。如果一个跟踪系统想生效，就必须需要依赖应用的开发者主动配合，那么这个跟踪系统也太脆弱了，往往由于跟踪系统在应用中植入代码的bug或疏忽导致应用出问题，这样才是无法满足对跟踪系统“无所不在的部署”这个需求。</p>
<p>  <strong>3、可扩展性</strong></p>
<p>  <strong>一个优秀的调用跟踪系统必须支持分布式部署，具备良好的可扩展性。能够支持的组件越多当然越好</strong>。或者提供便捷的插件开发API，对于一些没有监控到的组件，应用开发者也可以自行扩展。</p>
<p>  <strong>4、数据的分析</strong></p>
<p>  <strong>数据的分析要快</strong> <strong>，分析的维度尽可能多</strong>。跟踪系统能提供足够快的信息反馈，就可以对生产环境下的异常状况做出快速反应。<strong>分析的全面，能够避免二次开发</strong>。</p>
<hr>
<hr>
<p>  一个请求完整的调用链可能如下图，经过多个系统服务，调用关系复杂。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291804898.jpg"></p>
<p>   在前端请求到达服务器时，应用容器在执行实际业务处理之前，会先执行埋点逻辑（类似 Filter 的机制），埋点逻辑为这个前端请求分配一个全局唯一的调用链ID，即TraceId。埋点逻辑把TraceId放在一个调用上下文对象里面，而调用上下文对象会存储在 ThreadLocal里面。</p>
<p>  调用上下文对象里还有一个ID非常重要，在淘宝的EagleEye里面被称作RpcId。RpcId用于区分同一个调用链下的多个网络调用的发生顺序和嵌套层次关系。对于前端收到请求，生成的RpcId固定都是0。</p>
<p>   当这个前端执行业务处理需要发起RPC调用时，会首先从当前线程ThreadLocal上面获取之前EagleEye设置的调用上下文。然后，把RpcId递增一个序号。在 EagleEye里使用多级序号来表示RpcId，比如应用A收到请求的RpcId是0，那么它第一次调用RPC服务B时，会把RpcId改成 0.1。之后，调用上下文会作为附件随这次请求一起发送到远程服务器。</p>
<p>   服务端收到这个请求之后，会从请求附件里取出调用上下文，并放到当前线程ThreadLocal上面。如果服务B在处理时，需要调用另一个服务，这个时候它会重复之前提到的操作，唯一的差别就是RpcId会先改成0.1.1 再传过去。服务A的逻辑全部处理完毕之后，在返回响应对象之前，会把这次调用情况以及TraceId、RpcId都打印到它的访问日志之中，同时，会从ThreadLocal 清理掉调用上下文。</p>
<hr>
<p>TraceId 生成规则参考</p>
<p>Tracer 通过 TraceId 来将一个请求在各个服务器上的调用日志串联起来，TraceId一般由接收请求经过的第一个服务器产生，产生规则是：服务器IP + 进程的ID + 产生ID时候的时间 + 自增序列。产生TracerId的机器的IP可以用一个十六进制的数字，每两位代表 IP 中的一段。时间可以用毫秒数表示，自增的序列可以是四位的数字表示。</p>
<p>RPC ID 生成规则参考</p>
<p>  Tracer中的 RPC ID代表本次调用在整个调用链路中的位置，假设一个 Web系统A接收了一次用户请求，那么在这个系统的Tracer日志中，记录下的 RPC ID是0，代表是整个调用的根节点，如果A系统处理这次请求，需要通过 RPC依次调用B，C，D三个系统，那么在 B，C，D三个系统的Tracer服务端日志中，RPC ID也分别是0.1，0.2和0.3；如果C系统在处理请求的时候又调用了E，F两个系统，那么E，F两个系统对应的Tracer服务端日志是0.2.1 和0.2.2。</p>
<hr>
<p><a href="http://www.cnblogs.com/zhengyun_ustc/p/55solution2.html">http://www.cnblogs.com/zhengyun_ustc/p/55solution2.html</a><br><a href="https://blog.csdn.net/u014229282/article/details/81097188">https://blog.csdn.net/u014229282/article/details/81097188</a><br><a href="http://www.aboutyun.com/thread-20646-1-1.html">http://www.aboutyun.com/thread-20646-1-1.html</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
        <category>可观测</category>
      </categories>
  </entry>
  <entry>
    <title>如何选择分布式事务</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>分布式事务有多种主流形态，包括：</p>
<ul>
<li>基于消息实现的分布式事务</li>
<li>基于补偿实现的分布式事务</li>
<li>基于TCC实现的分布式事务</li>
<li>基于SAGA实现的分布式事务</li>
<li>基于2PC实现的分布式事务</li>
<li>…</li>
</ul>
<h3 id="何时选择单机事务？"><a href="#何时选择单机事务？" class="headerlink" title="何时选择单机事务？"></a>何时选择单机事务？</h3><p>&emsp;&emsp;在条件允许的情况下，应该尽可能地使用单机事务，因为单机事务里，无需额外协调其他数据源，减少了网络交互时间消耗以及协调时所需的存储IO消耗，在修改等量业务数据的情况下，单机事务将会有更高的性能。<br>&emsp;&emsp;但单机数据库由于 业务逻辑解耦等因素进行了数据库垂直拆分、或者由于单机数据库性能压力等因素进行了数据库水平拆分之后，数据分布于多个数据库，这时若需要对多个数据库的数据进行协调变更，则需要引入分布式事务。<br>&emsp;&emsp;分布式事务的模式有很多种，那究竟要怎么选择适合业务的模式呢？以下我们将从使用场景、性能、开发成本这几个方面进行分析。</p>
<h3 id="何时选择基于消息实现的事务？"><a href="#何时选择基于消息实现的事务？" class="headerlink" title="何时选择基于消息实现的事务？"></a>何时选择基于消息实现的事务？</h3><p>&emsp;&emsp;基于消息实现的事务适用于 <strong>分布式事务的提交或回滚只取决于事务发起方的业务需求</strong>，其他数据源的数据变更跟随发起方进行的业务场景。</p>
<p>&emsp;&emsp;举个例子，假设存在业务规则：某笔订单成功后，为用户加一定的积分。在这条规则里，管理订单数据源的服务为事务发起方，管理积分数据源的服务为事务跟随者。从这个过程可以看到，基于消息队列实现的事务存在以下操作：</p>
<ul>
<li>订单服务创建订单，提交本地事务</li>
<li>订单服务发布一条消息</li>
<li>积分服务收到消息后加积分</li>
</ul>
<p>&emsp;&emsp;可以看到它的整体流程是比较简单的，同时业务开发工作量也不大：</p>
<ul>
<li>编写订单服务里订单创建的逻辑</li>
<li>编写积分服务里增加积分的逻辑</li>
</ul>
<p>&emsp;&emsp;可以看到该事务形态过程简单，性能消耗小，发起方与跟随方之间的流量峰谷可以使用队列填平，同时业务开发工作量也基本与单机事务没有差别，都不需要编写反向的业务逻辑过程。因此基于消息队列实现的事务是除了单机事务外最优先考虑使用的形态。</p>
<span id="more"></span>

<h3 id="何时选择利用补偿实现的事务？"><a href="#何时选择利用补偿实现的事务？" class="headerlink" title="何时选择利用补偿实现的事务？"></a>何时选择利用补偿实现的事务？</h3><p>&emsp;&emsp;但是基于消息实现的事务并不能解决所有的业务场景，例如以下场景：某笔订单完成时，同时扣掉用户的现金。<br>&emsp;&emsp;这里事务发起方是管理订单库的服务，但对整个事务是否提交并不能只由订单服务决定，因为还要确保用户有足够的钱，才能完成这笔交易，而这个信息在管理现金的服务里。这里可以引入基于补偿实现的事务，其流程如下：</p>
<ul>
<li>创建订单数据，但暂不提交本地事务</li>
<li>订单服务发送远程调用到现金服务，以扣除对应的金额</li>
</ul>
<p>&emsp;&emsp;上述步骤成功后提交订单库的事务。以上这个是正常成功的流程，异常流程需要回滚的话，将额外发送远程调用到现金服务以加上之前扣掉的金额。</p>
<p>&emsp;&emsp;开发的工作量：</p>
<ul>
<li>编写订单服务里创建订单的逻辑</li>
<li>编写现金服务里扣钱的逻辑</li>
<li>编写现金服务里补偿返还的逻辑</li>
</ul>
<p>&emsp;&emsp;可以看到，该事务流程相对于基于消息实现的分布式事务更为复杂，需要额外开发相关的业务回滚方法，也失去了服务间流量削峰填谷的功能。但其仅仅只比基于消息的事务复杂多一点，若不能使用基于消息队列的最终一致性事务，那么可以优先考虑使用基于补偿的事务形态。</p>
<h3 id="何时选择利用TCC实现的事务"><a href="#何时选择利用TCC实现的事务" class="headerlink" title="何时选择利用TCC实现的事务"></a>何时选择利用TCC实现的事务</h3><p>&emsp;&emsp;然而基于补偿的事务形态也并非能实现所有的需求，如以下场景：某笔订单完成时，同时扣掉用户的现金，但交易未完成，也未被取消时，不能让客户看到钱变少了。这时可以引入TCC，其流程如下：</p>
<ul>
<li>订单服务创建订单</li>
<li>订单服务发送远程调用到现金服务，冻结客户的现金</li>
<li>提交订单服务数据</li>
<li>订单服务发送远程调用到现金服务，扣除客户冻结的现金</li>
</ul>
<p>&emsp;&emsp;以上是正常完成的流程，若为异常流程，则需要发送远程调用请求到现金服务，撤销冻结的金额。</p>
<p>开发的工作量：</p>
<ul>
<li>订单服务编写创建订单的逻辑</li>
<li>现金服务编写冻结现金的逻辑</li>
<li>现金服务编写扣除现金的逻辑</li>
<li>现金服务编写解冻现金的逻辑</li>
</ul>
<p>&emsp;&emsp;TCC实际上是最为复杂的一种情况，其能处理所有的业务场景，但无论出于性能上的考虑，还是开发复杂度上的考虑，都应该尽量避免该类事务。</p>
<h3 id="何时选择利用SAGA实现的事务？"><a href="#何时选择利用SAGA实现的事务？" class="headerlink" title="何时选择利用SAGA实现的事务？"></a>何时选择利用SAGA实现的事务？</h3><p>&emsp;&emsp;SAGA可以看做一个异步的、利用队列实现的补偿事务。其适用于无需马上返回业务发起方最终状态的场景，例如：请求已提交，请稍后查询或留意通知 之类。将上述补偿事务的场景用SAGA改写，其流程如下：</p>
<ul>
<li>订单服务创建最终状态未知的订单记录，并提交事务</li>
<li>现金服务扣除所需的金额，并提交事务</li>
<li>订单服务更新订单状态为成功，并提交事务</li>
</ul>
<p>&emsp;&emsp;以上为成功的流程，若现金服务扣除金额失败，那么，最后一步订单服务将会更新订单状态为失败。其业务编码工作量比补偿事务多一点，包括以下内容：</p>
<ul>
<li>订单服务创建初始订单的逻辑</li>
<li>订单服务确认订单成功的逻辑</li>
<li>订单服务确认订单失败的逻辑</li>
<li>现金服务扣除现金的逻辑</li>
<li>现金服务补偿返回现金的逻辑</li>
</ul>
<p>&emsp;&emsp;但其相对于补偿事务形态有性能上的优势，所有的本地子事务执行过程中，都无需等待其调用的子事务执行，减少了加锁的时间，这在事务流程较多较长的业务中性能优势更为明显。同时，其利用队列进行进行通讯，具有削峰填谷的作用。<br>&emsp;&emsp;因此该形式适用于不需要同步返回发起方执行最终结果、可以进行补偿、对性能要求较高、不介意额外编码的业务场景。<br>&emsp;&emsp;但当然SAGA也可以进行稍微改造，变成与TCC类似、可以进行资源预留的形态。</p>
<h3 id="2PC事务"><a href="#2PC事务" class="headerlink" title="2PC事务"></a>2PC事务</h3><p>&emsp;&emsp;其适用于参与者较少，单个本地事务执行时间较少，并且参与者自身可用性很高的场景，否则，其很可能导致性能下降严重。</p>
<p>&emsp;&emsp;通过分析可以发现，并不存在一种事务形态能解决所有的问题，需要根据特定的业务场景选择合适的事务形态。甚至于有时需要混合多种事务形态才能更好的完成目标，如 上面提到的 订单、积分、钱包混合的场景：订单的成功与否需要依赖于钱包的余额，但不依赖于积分的多少，因此可以混合基于消息的事务形态以加积分 及 基于补偿的事务形态以确保扣钱成功，从而得到一个性能更好，编码量更少的形态。</p>
<hr>
<p>转载自：<a href="https://blog.csdn.net/xiaolang85/article/details/85759536">https://blog.csdn.net/xiaolang85/article/details/85759536</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
        <category>分布式事务</category>
      </categories>
  </entry>
  <entry>
    <title>sun.misc.Contended避免伪共享(false sharing)</title>
    <url>/2024/03/12/Java/Java%E8%BF%9B%E9%98%B6/%E4%BC%AA%E5%85%B1%E4%BA%AB&amp;%E9%9B%B6%E6%8B%B7%E8%B4%9D/sun.misc.Contended%E9%81%BF%E5%85%8D%E4%BC%AA%E5%85%B1%E4%BA%AB(false%20sharing)/</url>
    <content><![CDATA[<p>Java8中使用<code>@sun.misc.Contended</code>注解来避免伪共享(false sharing)。关于伪共享这个概念，可以先参照<a href="http://ifeve.com/falsesharing/">http://ifeve.com/falsesharing/</a></p>
<p>伪共享的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileLong</span> &#123;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有两个VolatileLong对象，会被load到同一个缓存行里面，如果一个线程要修改对象1，另一个线程同时要修改对象2，此时就要面对伪共享问题（core1对缓存行中对象1的修改，导致core2中同一缓存行失效，即缓存的对象2需要重新load）。</p>
 <span id="more"></span>

<p>jdk6中的解决办法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileLong</span> &#123;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">long</span> p0, p1, p2, p3, p4, p5, p6;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">long</span> q0, q1, q2, q3, q4, q5, q6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方式也就是long padding来避免伪共享，使用无关数据来填充缓存行，使得两个VolatileLong对象不会load到同一个缓存行里面。无锁并发框架Disruptor正是采用的这种方式。</p>
<p>long padding的解决办法不怎么优雅，并且在jdk7某个版本以后能会优化掉long padding，详细参考<a href="http://ifeve.com/false-sharing-java-7/%E3%80%82%E4%BD%86%E6%98%AFjava8%E5%B7%B2%E7%BB%8F%E7%BB%99%E5%87%BA%E4%BA%86%E5%AE%98%E6%96%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%8C%E5%B0%B1%E6%98%AFsun.misc.Contended%E6%B3%A8%E8%A7%A3%E3%80%82">http://ifeve.com/false-sharing-java-7/。但是java8已经给出了官方的解决办法，就是sun.misc.Contended注解。</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk8新特性，Contended注解避免false sharing</span></span><br><span class="line"><span class="comment">// Restricted on user classpath</span></span><br><span class="line"><span class="comment">// Unlock: -XX:-RestrictContended</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileLong</span> &#123;</span><br><span class="line">		<span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，JVM就不会将被Contended注解的两个VolatileLong对象load到同一个缓存行里面。要注意的是user classpath使用此注解默认是无效的，需要在jvm启动时设置<code>-XX:-RestrictContended</code>。（不太理解。。。经测试自己应用程序的<code>sun.misc.Contended</code>注解的类需要<code>-XX:-RestrictContended</code>才能生效，是不是对jdk源码中的<code>sun.misc.Contended</code>不需要上述注解就可以生效了？）</p>
<p>jdk8中有很多地方已经使用了<code>sun.misc.Contended</code>：</p>
<p><code>java/util/concurrent/ConcurrentHashMap.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CounterCell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    CounterCell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>java/util/concurrent/Exchanger.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes hold partially exchanged data, plus other per-thread</span></span><br><span class="line"><span class="comment"> * bookkeeping. Padded via <span class="doctag">@sun</span>.misc.Contended to reduce memory</span></span><br><span class="line"><span class="comment"> * contention.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> index;              <span class="comment">// Arena index</span></span><br><span class="line">    <span class="type">int</span> bound;              <span class="comment">// Last recorded value of Exchanger.bound</span></span><br><span class="line">    <span class="type">int</span> collides;           <span class="comment">// Number of CAS failures at current bound</span></span><br><span class="line">    <span class="type">int</span> hash;               <span class="comment">// Pseudo-random for spins</span></span><br><span class="line">    Object item;            <span class="comment">// This thread&#x27;s current item</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match;  <span class="comment">// Item provided by releasing thread</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked; <span class="comment">// Set to this thread when parked, else null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<hr>
<p>参考:<br><a href="http://www.myexception.cn/program/1630142.html">http://www.myexception.cn/program/1630142.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>伪共享&amp;零拷贝</category>
      </categories>
  </entry>
  <entry>
    <title>从Java视角理解CPU缓存和伪共享</title>
    <url>/2024/03/12/Java/Java%E8%BF%9B%E9%98%B6/%E4%BC%AA%E5%85%B1%E4%BA%AB&amp;%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BB%8EJava%E8%A7%86%E8%A7%92%E7%90%86%E8%A7%A3CPU%E7%BC%93%E5%AD%98%E5%92%8C%E4%BC%AA%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<p>​	CPU是计算机的大脑，它负责执行程序的指令；内存负责存数据，包括程序自身数据。内存比CPU慢很多，现在获取内存中的一条数据大概需要200多个CPU周期(CPU cycles)，而CPU寄存器一般情况下1个CPU周期就够了。</p>
<p>​	网页浏览器为了加快速度，会在本机存缓存以前浏览过的数据；传统数据库或NoSQL数据库为了加速查询,常在内存设置一个缓存，减少对磁盘(慢)的IO。同样内存与CPU的速度相差太远，于是CPU设计者们就给CPU加上了缓存(CPU Cache)。如果需要对同一批数据操作很多次，那么把数据放至离CPU更近的缓存，会给程序带来很大的速度提升。例如，做一个循环计数，把计数变量放到缓存里，就不用每次循环都往内存存取数据了。下面是CPU Cache的简单示意图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291540498.png" alt="image-20240228163008629"></p>
<span id="more"></span>

<p>​	随着多核的发展，CPU Cache分成了三个级别：L1、 L2、L3。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。L1是最接近CPU的，它容量最小，例如32K，速度最快，每个核上都有一个L1 Cache(准确地说每个核上有两个L1 Cache，一个存数据 L1d Cache，一个存指令 L1i Cache)。L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache；L3 Cache是三级缓存中最大的一级，例如12MB，同时也是最慢的一级，在同一个CPU插槽之间的核共享一个L3 Cache。</p>
<p>​	就像数据库cache一样，获取数据时首先会在最快的cache中找数据，如果没有命中(Cache miss)则往下一级找，直到三层Cache都找不到，那只有向内存要数据了。一次次地未命中，代表取数据消耗的时间越长。</p>
<p>​	为了高效地存取缓存，不是简单随意地将单条数据写入缓存的。缓存是由缓存行组成的，典型的一行是64字节。CPU存取缓存都是按行为最小单位操作的。一个Java long型占8字节，所以从一条缓存行上可以获取到8个long型变量。所以如果访问一个long型数组，当有一个long被加载到cache中，将会无消耗地加载了另外7个，所以可以非常快地遍历数组。</p>
<p>​	既然典型的CPU微架构有3级缓存，每个核都有自己私有的L1、 L2缓存，那么多线程编程时，另外一个核的线程想要访问当前核内L1、L2缓存行的数据时，该怎么办呢？</p>
<p>​	有一种办法可以通过第2个核直接访问第1个核的缓存行。这是可行的，但这种方法不够快。跨核访问需要通过Memory Controller，典型的情况是第2个核经常访问第1个核的这条数据，那么每次都有跨核的消耗。更糟的情况是，有可能第2个核与第1个核不在一个插槽内，况且Memory Controller的总线带宽是有限的，扛不住这么多数据传输。所以CPU设计者们更偏向于另一种办法：如果第2个核需要这份数据，由第1个核直接把数据内容发过去，数据只需要传一次。</p>
<p>​	那么什么时候会发生缓存行的传输呢？答案很简单：当一个核需要读取另外一个核的脏缓存行时发生。但是前者怎么判断后者的缓存行已经被弄脏(写)了呢？</p>
<p>​	下面将详细地解答以上问题. 首先需要谈到一个协议—MESI协议。现在主流的处理器都是用它来保证缓存的相干性和内存的相干性。M、E、S和I代表使用MESI协议时缓存行所处的四个状态:</p>
<ul>
<li><p>**M(修改，Modified): **本地处理器已经修改缓存行, 即是脏行, 它的内容与内存中的内容不一样. 并且此cache只有本地一个拷贝(专有).</p>
</li>
<li><p><strong>E(专有，Exclusive)：</strong>缓存行内容和内存中的一样, 而且其它处理器都没有这行数据.</p>
</li>
<li><p><strong>S(共享，Shared)：</strong>缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝.</p>
</li>
<li><p><strong>I(无效，Invalid)：</strong>缓存行失效, 不能使用.</p>
</li>
</ul>
<p>​    下面简单地说明下缓存行的四种状态怎么转换的：</p>
<ul>
<li><p><em>初始：</em>一开始时，缓存行没有加载任何数据，所以它处于I状态。</p>
</li>
<li><p><em>本地写</em>*(Local Write)*<em>：</em>如果本地处理器写数据至处于I状态的缓存行，则缓存行的状态变成M。</p>
</li>
<li><p><em>本地读</em>*(Local Read)*<em>：</em>如果本地处理器读取处于I状态的缓存行, 很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成E状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为S状态。P.S.如果处于M状态的缓存行，再由本地处理器写入&#x2F;读出，状态是不会改变的。</p>
</li>
<li><p><em>远程读</em>*(Remote Read)*<em>：</em>假设有两个处理器c1和c2。如果c2需要读另外一个处理器c1的缓存行内容，c1需要把它缓存行的内容通过内存控制器(Memory Controller)发送给c2，c2接到后将相应的缓存行状态设为S。在设置之前，内存也得从总线上得到这份数据并保存。</p>
</li>
<li><p><em>远程写</em>*(Remote Write)*<em>：</em>其实确切地说不是远程写，而是c2得到c1的数据后，不是为了读，而是为了写，也算是本地写，只是c1也拥有这份数据的拷贝，这该怎么办呢？c2将发出一个RFO(Request For Owner)请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理RFO请求以及设置I的过程将给写操作带来很大的性能消耗。</p>
</li>
</ul>
<p>上述内容知道，写操作的代价很高，特别当需要发送RFO消息时。那编写程序时，什么时候会发生RFO请求呢？有以下两种：</p>
<ol>
<li>线程的工作从一个处理器移到另一个处理器，它操作的所有缓存行都需要移到新的处理器上。此后如果再写缓存行，则此缓存行在不同核上有多个拷贝，需要发送RFO请求了。</li>
<li>两个不同的处理器确实都需要操作相同的缓存行。</li>
</ol>
<p>在Java程序中，数组的成员在缓存中也是连续的。其实从Java对象的相邻成员变量也会加载到同一缓存行中。如果多个线程操作不同的成员变量，但是相同的缓存行，伪共享(False Sharing)问题就发生了。</p>
<p>​    举个例子：一个运行在处理器core 1上的线程想要更新变量X的值，同时另外一个运行在处理器core 2上的线程想要更新变量Y的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送RFO消息，占得此缓存行的拥有权。当core 1取得了拥有权开始更新X，则core 2对应的缓存行需要设为I状态。当core 2取得了拥有权开始更新Y，则core 1对应的缓存行需要设为I状态(失效态)。轮番夺取拥有权不但带来大量的RFO消息，而且如果某个线程需要读此行数据时，L1和L2缓存上都是失效数据，只有L3缓存上是同步好的数据。读L3的数据非常影响性能，更坏的情况是跨槽读取，L3都要miss，只能从内存上加载。</p>
<p>表面上X和Y都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。</p>
<p>那么怎么避免伪共享呢？一条缓存行有64字节，而Java程序的对象头固定占8字节(32位系统)或12字节(64位系统默认开启压缩, 不开压缩为16字节)。只需要填6个无用的长整型补上6*8&#x3D;48字节，让不同的变量处于不同的缓存行，就可以避免伪共享了(64位系统超过缓存行的64字节也无所谓,只要保证不同线程不要操作同一缓存行就可以)，这个办法叫做补齐(Padding)。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VolatileLong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> p1, p2, p3, p4, p5, p6; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>伪共享在多核编程中很容易发生，而且比较隐蔽。例如在JDK的LinkedBlockingQueue中，存在指向队列头的引用head和指向队列尾的引用last。而这种队列经常在异步编程中使有，这两个引用的值经常的被不同的线程修改，但它们却很可能在同一个缓存行，于是就产生了伪共享。线程越多，核越多，对性能产生的负面效果就越大。</p>
<p>某些Java编译器会将没有使用到的补齐数据，即使示例代码中的6个长整型在编译时优化掉，可以在程序中加入一些代码防止被编译优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">preventFromOptimization</span><span class="params">(VolatileLong v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v.p1 + v.p2 + v.p3 + v.p4 + v.p5 + v.p6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，由于Java的GC问题。数据在内存和对应的CPU缓存行的位置有可能发生变化，所以在使用pad的时候应该注意GC的影响。</p>
<hr>
<p>转载自：<br><a href="http://ifeve.com/from-javaeye-cpu-cache/">http://ifeve.com/from-javaeye-cpu-cache/</a><br><a href="http://ifeve.com/from-javaeye-false-sharing/">http://ifeve.com/from-javaeye-false-sharing/</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>伪共享&amp;零拷贝</category>
      </categories>
  </entry>
  <entry>
    <title>简述OpenTracing与OpenTelemetry的分别</title>
    <url>/2024/06/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%8F%AF%E8%A7%82%E6%B5%8B/%E7%AE%80%E8%BF%B0OpenTracing%E4%B8%8EOpenTelemetry%E7%9A%84%E5%88%86%E5%88%AB/</url>
    <content><![CDATA[<p>[toc]</p>
<p>OpenTracing作为调用链规范标准，在实际使用的过程，也有了一些使用上的痛点，例如：</p>
<ul>
<li>光依据调用链无法很好的定位问题；</li>
<li>调用链与日志系统关联性差，定位具体问题耗时较长；</li>
<li>切换数据后端成本较高；</li>
<li>内部团队有些使用的规范不同，需要适配多套规范；</li>
</ul>
<p>业界也开始寻找是否有更优的解决方案，OpenTelemetry逐渐突显出来。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>&emsp;&emsp;随着软件应用从单片机结构向分布式微服务体系转变，应用监控(<strong>Monitoring</strong>)和应用观测(<strong>Observability</strong>)也的需求也随之提升。应用观测与应用监控虽然存在着一些相同的定义，但是还是存在着一些差别。</p>
<p>&emsp;&emsp;应用监控和应用观测的目的都是为了发现应用程序中的问题。但是，应用监控的目的是为了捕获已知的问题，并将其显示在仪表盘上，用以了解其发生问题的原因和其发生的具体时间。</p>
<p>&emsp;&emsp;而应用观测则采用更底层的方式，即开发人员通过调试代码的方式从而了解程序的内部状态。因此，应用观测是为了帮助监控应用程序的未知问题的最新发展。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240606163758.png" alt="img"></p>
<p>而其中帮助进行应用观测的三大支柱，他们分别是日志(logs)、指标(metrics)、调用链(traces)。</p>
<ul>
<li>指标(<strong>Metrics</strong>)指出了是否存在问题，通常是通过<strong>告警</strong>「<strong>发现</strong>」</li>
<li>调用链(<strong>Traces</strong>)能标明问题点在哪里 「<strong>定位</strong>」</li>
<li>日志(<strong>Logs</strong>)帮助你定位到产生问题的根本原因 「<strong>分析</strong>」</li>
</ul>
<p>应用观测提供了以下几个好处：</p>
<ul>
<li>能够找出本来或许难以发现的隐患。通常来说，解决生产问题是一场灾难；</li>
<li>降低告警疲劳；</li>
<li>更快的发布产品；</li>
<li>提高自动化程度；</li>
<li>提高开发人员的生产力；</li>
</ul>
<h2 id="什么是OpenTracing？"><a href="#什么是OpenTracing？" class="headerlink" title="什么是OpenTracing？"></a>什么是OpenTracing？</h2><p>&emsp;&emsp;在调用链概念出现之前，日志是用来帮助我们理解应用程序中发生情况的唯一途径。大多数的应用程序在他们运行的服务器上创建日志。然而，对于分布式系统来说，光靠日志是不够的，因为光靠日志定位问题的具体位置是一项巨大的挑战。但是调用链则可以非常方便的处理这种场景，因为其可以完整的追踪一个请求的开始到结束所经过的所有节点。</p>
<p>&emsp;&emsp;但哪怕调用链提供的对分布式系统链路的可见性，插桩调用链仍是一项单调乏味的工作。每种可能被追踪的工具都以自己的标准进行工作，并且它们自身也在不停迭代。因此，开发人员很难在整个软件过程中只使用其中一种工具，而其不同的对接和适用标准常常会对使用人员造成困扰。这就是OpenTracing大放异彩的地方。</p>
<p>&emsp;&emsp;OpenTracing是一套与供应商无关的开源API，允许开发人员将调用链打点能力添加到它们的代码中。它是一个用于插桩的标准框架，而不是一个特定的，可安装的程序。其目的是为所有可用的追踪工具提供标准的规范。其提供的API提供了九种不同的语言，包括Java、JavaScript和Python等。</p>
<h3 id="OpenTracing的功能介绍"><a href="#OpenTracing的功能介绍" class="headerlink" title="OpenTracing的功能介绍"></a>OpenTracing的功能介绍</h3><p>OpenTracing由以下四个主要的组成部分组成，他们分别是：</p>
<ul>
<li><p>Tracer</p>
<p>Tracer是调用链API的入口。Tracer用于创建Spans，Spans允许我们从外部来源提取和注入追踪信息。</p>
</li>
<li><p>Span</p>
<p>Span是调用链中的主要构成勾结或工作单元。例如你如果发起了一个Web请求则会创建一个新的Span，而其被称为根Span「root span」，如果该请求在其工作流中发起了另一个请求，则第二个请求则会创建出一个子Span，如此循环直至完成整个请求过程。期间产生的所有Span通过一个相同的Trace Id进行关联，这一系列具有链式关系的Spans就被称为调用链。Span可以支持很多复杂的工作流，甚至包括异步消息的传递。</p>
</li>
<li><p>SpanContext</p>
<p>SpanContext是Span的一种可序列化内容，通过它可以跨进城边界的来传输Span信息。其内容通常包含Trace Id，Span Id还有一些行李项(baggae item，用于向后续的span传递一些信息)。</p>
</li>
<li><p>References</p>
<p>References是Spans之间建立连接的描述，目前有两种类型，ChildOf 和 FollowsFrom。</p>
</li>
</ul>
<h2 id="什么是OpenTelemetry"><a href="#什么是OpenTelemetry" class="headerlink" title="什么是OpenTelemetry?"></a>什么是OpenTelemetry?</h2><p>&emsp;&emsp;遥测数据(Telemetry data)是跨科学领域的通用术语。它描述一种从远程位置收集数据集用于测量系统健康状况的行为。而在DevOps中，系统指的的就是软件应用，而我们收集的数据就是日志、调用链和指标了。</p>
<p>&emsp;&emsp;OpenTelemetry一个开源框架，其包含用于收集遥测数据的工具、API和SDK。然后被收集到的数据会被发送到后端平台进行分析用以了解应用程序的状态。OpenTelemetry是一个<strong>CNCF</strong>(Cloud Native Computing Foundation，云原生计算基金会)的孵化项目，并于2019年5月合并了OpenTracing和OpenCensus。</p>
<p>&emsp;&emsp;OpenTelemetry旨在创建一个收集可观测性数据的标准格式。在OpenTelemetry规范被提出前，跨不同应用程序收集遥测数据的规范是不一致的。这对于开发人员来说是一个相当大的负担。OpenTelemetry提供了一个与供应商无关的API以及库为可观测监控提供了一个标准。它能为公司节省下本来用于建立收集遥测数据机制而花费的大量宝贵时间。</p>
<p>&emsp;&emsp;OpenTelemetry相关的安装和使用方法可以参考官方的<a href="https://opentelemetry.io/docs/instrumentation/net/getting-started/">引导</a></p>
<h3 id="OpenTelemetry的功能介绍"><a href="#OpenTelemetry的功能介绍" class="headerlink" title="OpenTelemetry的功能介绍"></a>OpenTelemetry的功能介绍</h3><p>上文提到，OpenTelemetry是一整套完整的软件框架，那我们必须了解其中几个关键组成部分，才能理解其是如何工作的，它们如下：</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>API通过插桩你的应用来创建调用链、指标和日志。这些API是基于特定语言的，目前已经支持大部分主流语言，例如: Java、.Net、Python和JavaScript。</p>
<h4 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h4><p>SDK是另一个基于语言的组件，其作为API与数据导出的中介。SDK定义了类似配置、数据处理和数据导出等概念。SDK也很能好的处理事务采样以及请求过滤。</p>
<h4 id="收集器-Collector"><a href="#收集器-Collector" class="headerlink" title="收集器(Collector)"></a>收集器(Collector)</h4><p>收集器用于收集、处理和导出遥测数据。它主要充当一个与供应商无关的代理。虽然它不是一个必不可少的组件，但由于它对于接收和发送应用遥测数据到后端具有很大的灵活性，所以其还是很有帮助的。举个例子，如果必须，你可以处理来此OTLP(opentelemetry本身提供的数据格式)、Jaeger及Prometheus的多种数据格式，并将其发送到各种后端应用。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240606163812.png" alt="img"></p>
<h4 id="导出器-Exporter"><a href="#导出器-Exporter" class="headerlink" title="导出器(Exporter)"></a>导出器(Exporter)</h4><p>可以通过配置导出器来选择你希望将遥测数据发送至那个后端。导出器将后端配置从应用插桩中分离出来。因此，你可以很轻松的更换希望处理数据的后端而无需更换插桩。</p>
<h2 id="OpenTracing和OpenTelemetry的区别"><a href="#OpenTracing和OpenTelemetry的区别" class="headerlink" title="OpenTracing和OpenTelemetry的区别"></a>OpenTracing和OpenTelemetry的区别</h2><p>&emsp;&emsp;OpenTracing和OpenTelemetry都是开源项目，旨在提供与供应商无关的解决方案。然而，OpenTelemetry是最新的解决方案，并且它是集OpenTracing与OpenCensus两者之大成者。因此，它比OpenTracing更为<strong>健壮</strong>。</p>
<p>&emsp;&emsp;OpenTracing仅仅在分布式应用中记录调用链数据，而OpenTelemetry收集所有类型的遥测数据例如日志、指标和调用链。此外，OpenTelemtry是一个开箱即用的API、SDK和库的合集。还有一个关键的优势就是OpenTelemetry能够快速改变处理遥测数据的后端。</p>
<p>&emsp;&emsp;综上所述，OpenTelemetry比OpenTracing具备更多的优势，从而成为了当前事实上的业界标准。</p>
<hr>
<p>转载自：</p>
<p><a href="https://developers.weixin.qq.com/community/develop/article/doc/00040a73f2440837740fab41b5b413">https://developers.weixin.qq.com/community/develop/article/doc/00040a73f2440837740fab41b5b413</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
        <category>可观测</category>
      </categories>
  </entry>
  <entry>
    <title>Zero Copy（零拷贝）</title>
    <url>/2024/03/12/Java/Java%E8%BF%9B%E9%98%B6/%E4%BC%AA%E5%85%B1%E4%BA%AB&amp;%E9%9B%B6%E6%8B%B7%E8%B4%9D/Zero%20Copy%EF%BC%88%E9%9B%B6%E6%8B%B7%E8%B4%9D%EF%BC%89/</url>
    <content><![CDATA[<p>&emsp;&emsp;缓冲区是所有I&#x2F;O的基础，I&#x2F;O无非就是把数据移进或移出缓冲区。下面看一个java进程发起read请求加载数据大致的流程图：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291543228.jpeg"><br>&emsp;&emsp;进程发起read请求之后，内核接收到read请求之后，会先检查内核空间中是否已经存在进程所需要的数据，如果已经存在，则直接把数据copy给进程的缓冲区；如果没有，内核随即向磁盘控制器发出命令，要求从磁盘读取数据，磁盘控制器把数据直接写入内核read缓冲区，这一步通过DMA完成；接下来就是内核将数据copy到进程的缓冲区；<br>&emsp;&emsp;如果进程发起 write网络请求，同样需要把用户缓冲区里面的数据copy到内核的socket缓冲区里面，然后再通过DMA把数据copy到网卡中，发送出去；<br>&emsp;&emsp;这样每次都需要把内核空间的数据拷贝到用户空间中，零拷贝的出现就是为了解决这种问题。<br>&emsp;&emsp;关于零拷贝提供了两种方式分别是：<code>mmap+write</code>方式，<code>sendfile</code>方式。</p>
<span id="more"></span>

<p>&emsp;&emsp;先介绍一下虚拟内存，所有现代操作系统都使用虚拟内存，使用虚拟的地址取代物理地址，这样做的好处是：</p>
<blockquote>
<ul>
<li>一个以上的虚拟地址可以指向同一个物理内存地址，</li>
<li>虚拟内存空间可大于实际可用的物理地址；</li>
</ul>
</blockquote>
<p>&emsp;&emsp;利用第一个特性可以把内核空间地址和用户空间的虚拟地址映射到同一个物理地址，这样DMA就可以填充对内核和用户空间进程同时可见的缓冲区了，大致如下图所示：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291543929.jpeg"><br>&emsp;&emsp;这样就省去了内核与用户空间的往来拷贝，java也利用操作系统的此特性来提升性能。</p>
<p>&emsp;&emsp;<br><strong>mmap+write方式</strong><br>&emsp;&emsp;使用 mmap+write 方式代替原来的 read+write 方式，mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系；这样就可以省掉原来内核read缓冲区copy数据到用户缓冲区，但是还是需要内核read缓冲区将数据copy到内核socket缓冲区，大致如下图所示：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291544515.jpeg"></p>
<p>&emsp;&emsp;<br><strong>sendfile方式</strong><br>&emsp;&emsp;sendfile系统调用在内核版本2.1中被引入，目的是简化通过网络在两个通道之间进行的数据传输过程。sendfile系统调用的引入，不仅减少了数据复制，还减少了上下文切换的次数，大致如下图所示：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291544594.jpeg"></p>
<p>&emsp;&emsp;数据传送只发生在内核空间，所以减少了一次上下文切换；但是还是存在一次copy，能不能把这一次copy也省略掉，Linux2.4内核中做了改进，将Kernel buffer中对应的数据描述信息（内存地址，偏移量）记录到相应的socket缓冲区当中，这样连内核空间中的一次cpu copy也省掉了。</p>
<p>&emsp;&emsp;</p>
<h3 id="Java零拷贝"><a href="#Java零拷贝" class="headerlink" title="Java零拷贝"></a>Java零拷贝</h3><h4 id="1-MappedByteBuffer"><a href="#1-MappedByteBuffer" class="headerlink" title="1. MappedByteBuffer"></a>1. MappedByteBuffer</h4><p>&emsp;&emsp;java nio提供的FileChannel提供了map()方法，该方法可以在一个打开的文件和MappedByteBuffer之间建立一个虚拟内存映射，MappedByteBuffer继承于ByteBuffer，类似于一个基于内存的缓冲区，只不过该对象的数据元素存储在磁盘的一个文件中；调用get()方法会从磁盘中获取数据，此数据反映该文件当前的内容，调用put()方法会更新磁盘上的文件，并且对文件做的修改对其他线程也是可见的。</p>
<h4 id="2-Channel-to-Channel传输"><a href="#2-Channel-to-Channel传输" class="headerlink" title="2. Channel-to-Channel传输"></a>2. Channel-to-Channel传输</h4><p>&emsp;&emsp;经常需要从一个位置将文件传输到另外一个位置，Java类库通过java.nio.channels.FileChannel提供的transferTo()方法用来提高传输的效率，可以通过这个方法把一个channel中读取到的字节传输到另一个channel，不再需要数据流经应用程序。</p>
<p>&emsp;&emsp;下图展示了通过transferTo实现数据传输的路径：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291544090.gif"></p>
<p>&emsp;&emsp;Java中使用zero copy的数据传输的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void transferTo(long position,long count,WritableByteChannel target);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;</p>
<hr>
<p>DMA（Direct Memory Access，直接存储器访问）<br>DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。DMA负责将数据从一个地址空间复制到另外一个地址空间。</p>
<hr>
<p>很多Web应用程序都会提供大量的静态内容，其数量多到相当于读完整个磁盘的数据再将同样的数据写回响应套接字（socket）。此动作看似只需较少的 CPU 活动，但它的效率非常低：内核首先从磁盘文件读取数据，然后从内核空间将数据传到用户空间，应用程序又将数据从用户空间返回到内核空间然后传输给socket。实际上，应用程序就相当于是个低效的中间者，从磁盘拿数据放到socket。</p>
<p>下图展示了数据从文件到socket的内部流程：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291544479.gif"></p>
<p>每次数据在内核空间和用户空间传输就一次拷贝过程，这是需要占用一定的CPU周期和内存资源的。幸运的是可以通过一个叫zero copy的技术来消除这些拷贝过程。使用了zero copy技术的应用程序的数据传输过程就是内核从磁盘文件读取数据直接传输到socket中，不再经过应用程序这个中间者。zero copy大大改善了应用程序的性能并且减少了用户态和内核态之间的切换次数。</p>
<p>在linux或者unix系统上，Java类库通过<code>java.nio.channels.FileChannel</code>的<code>transferTo()</code>方法来应用zero copy。可以通过这个方法把一个channel中读取到的字节传输到另一个channel，不再需要数据流经应用程序。</p>
<p>下图展示了通过transferTo实现数据传输的路径：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291544414.gif"></p>
<p><strong>Java中使用zero copy的数据传输的方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferTo</span><span class="params">(<span class="type">long</span> position,<span class="type">long</span> count,WritableByteChannel target)</span>;</span><br></pre></td></tr></table></figure>

<p><code>transferTo()</code>方法将数据从一个channel传输到另一个可写的channel上，其内部实现依赖于操作系统对zero copy技术的支持。在unix操作系统和各种linux的发型版本中，这种功能最终是通过sendfile()系统调用实现。</p>
<p>使用transferTo()方式所经历的步骤：</p>
<blockquote>
<p>1、transferTo调用会引起DMA将文件内容复制到读缓冲区(内核空间的缓冲区)，然后数据从这个缓冲区复制到另一个与socket输出相关的内核缓冲区中。</p>
<p>2、第三次数据复制就是DMA把socket关联的缓冲区中的数据复制到协议引擎上发送到网络上。</p>
</blockquote>
<p>这次改善，将数据的复制次数从四次减少到三次(只有一次用到cpu资源)。但这并没有达到零复制的目标。如果底层网络适配器支持收集操作的话，可以进一步减少内核对数据的复制次数。在内核为2.4或者以上版本的linux系统上，socket缓冲区描述符将被用来满足这个需求。这个方式不仅减少了内核用户态间的切换，而且也省去了那次需要cpu参与的复制过程。从用户角度来看依旧是调用<code>transferTo()</code>方法，但是其本质发生了变化：</p>
<blockquote>
<p>1、调用transferTo方法后数据被DMA从文件复制到了内核的一个缓冲区中。</p>
<p>2、数据不再被复制到socket关联的缓冲区中了，仅仅是将一个描述符（包含了数据的位置和长度等信息）追加到socket关联的缓冲区中。DMA直接将内核中的缓冲区中的数据传输给协议引擎，消除了仅剩的一次需要cpu周期的数据复制。</p>
</blockquote>
<p>如下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291545987.gif"></p>
<p>Java nio中提供的<strong>FileChannel</strong>和<strong>SocketChannel</strong>实现零拷贝传输数据示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">copy</span><span class="params">(String srcFilename,String destFilename)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">    <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcFilename);  </span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> srcFile.length();  </span><br><span class="line">    </span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile).getChannel();  </span><br><span class="line">   </span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(destFilename)).getChannel();  </span><br><span class="line">    fileChannel.transferTo(<span class="number">0</span>, size, outChannel);  </span><br><span class="line">    </span><br><span class="line">    fileChannel.close();  </span><br><span class="line">    outChannel.close();  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> size;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<p>转载自：<br><a href="http://blog.csdn.net/fyxxq/article/details/20000045">http://blog.csdn.net/fyxxq/article/details/20000045</a><br><a href="http://www.cnblogs.com/metoy/p/4033366.html">http://www.cnblogs.com/metoy/p/4033366.html</a><br><a href="https://maimai.cn/article/detail?fid=1236304197&efid=u4GUhDloTNP1da_BcFd-4Q">https://maimai.cn/article/detail?fid=1236304197&amp;efid=u4GUhDloTNP1da_BcFd-4Q</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>伪共享&amp;零拷贝</category>
      </categories>
  </entry>
  <entry>
    <title>Netty关于ThreadLocal的优化</title>
    <url>/2024/03/10/Java/Java%E8%BF%9B%E9%98%B6/ThreadLocal/Netty%E5%85%B3%E4%BA%8EThreadLocal%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>在<a href="http://blog.csdn.net/zero__007/article/details/78288448">http://blog.csdn.net/zero__007/article/details/78288448</a> 中简单介绍了一下ThreadLocal，每个ThreadLocal实例都有一个唯一的threadLocalHashCode初始值，在ThreadLocalMap中设置或获取Entry时，会根据<code>threadLocalHashCode&amp;（len-1）</code>的值去对应的槽中操作。</p>
<p>而ThreadLocal解决Hash 冲突使用线性探测的方法，当一个线程对应多个ThreadLocal实例的场景中，在命中的情况下基本上一次hash就可以找到位置，如果发生没有命中的情况，则会引发性能会急剧下降，本身是O(1)，结果变成了O(n)当在读写操作频繁的场景，这点导致性能的后滞。</p>
 <span id="more"></span>  

<p>作为一个高并发框架，Netty对ThreadLocal作了一些优化，并提供一个性能更好的FastThreadLocal。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastThreadLocalThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InternalThreadLocalMap threadLocalMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastThreadLocalThread</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastThreadLocalThread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastThreadLocalThread</span><span class="params">(ThreadGroup group, Runnable target)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(group, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastThreadLocalThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastThreadLocalThread</span><span class="params">(ThreadGroup group, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(group, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastThreadLocalThread</span><span class="params">(Runnable target, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(target, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastThreadLocalThread</span><span class="params">(ThreadGroup group, Runnable target, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(group, target, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastThreadLocalThread</span><span class="params">(ThreadGroup group, Runnable target, String name, <span class="type">long</span> stackSize)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(group, target, name, stackSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the internal data structure that keeps the thread-local variables bound to this thread.</span></span><br><span class="line"><span class="comment">     * Note that this method is for internal use only, and thus is subject to change at any time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> InternalThreadLocalMap <span class="title function_">threadLocalMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocalMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the internal data structure that keeps the thread-local variables bound to this thread.</span></span><br><span class="line"><span class="comment">     * Note that this method is for internal use only, and thus is subject to change at any time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setThreadLocalMap</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadLocalMap = threadLocalMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Netty专门提供一个FastThreadLocalThread，继承了JDK的Thread，内部也有个InternalThreadLocalMap实例变量，并暴露了这个变量的getter&#x2F;setter方法。</p>
<p>JDK中的ThreadLocalMap中的数组存放的是Entrty，key为ThreadLocal，value为真正保存的变量，而InternalThreadLocalMap中的数组里面的数据就是真正保存的变量值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastThreadLocal</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">variablesToRemoveIndex</span> <span class="operator">=</span> InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">        index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        JDK的ThreadLocal中将threadLocalHashCode放在了ThreadLocal类中，然后再拿这个值通过计算去定位ThreadLocalMap中的槽，而Netty的FastThreadLocal直接直接保存index，该index是通过InternalThreadLocalMap的静态方法获取的，该值是一个递增的值，也就是说不同的线程，在同一个FastThreadLocal中保存的变量值，在其实例变量InternalThreadLocalMap中的槽都是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">static</span> InternalThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">InternalThreadLocal</span>&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;zero&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InternalThread</span> <span class="variable">thread0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InternalThread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">InternalThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InternalThread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  上面的例子，线程私有的String变量，在其实例变量threadLocalMap里的数组，存放的位置下标都是1。由于InternalThreadLocal的index会递增，因此InternalThreadLocal实例再多的话也只会扩容，而不会发生Hash冲突。</p>
<p>  在提一下FastThreadLocal中variablesToRemoveIndex，该变量是static final修饰的，会占用一个下标，即在InternalThreadLocalMap中会占一个槽。实际上该下标的元素是一个包装了IndentityHashMap的Set，每次FastThreadLocal中设置值的时候将自己加到该Set，移除值的时候将自己从该Set移除。也就是说初始值、设置值、删除值这几个功能的耗时比有值时的get更多。</p>
<p><strong>性能比较看<a href="http://www.bubuko.com/infodetail-1932175.html">http://www.bubuko.com/infodetail-1932175.html</a></strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>ThreadLocal</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadLocal和线程同步机制的比较</title>
    <url>/2024/03/10/Java/Java%E8%BF%9B%E9%98%B6/ThreadLocal/ThreadLocal%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>​	早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p>
<p>​	ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。</p>
 <span id="more"></span> 

<p>​	ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
<p>​        在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
<p>​        而ThreadLocal则从另一个角度来解决多线程的并发访问。 ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<p>​        ThreadLocal中可以持有任何类型的对象。对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<p><strong>Spring使用ThreadLocal解决线程安全问题</strong></p>
<p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、 LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</p>
<p>下面的实例能够体现Spring对有状态Bean的改造思路：</p>
<p>代码清单3 TopicDao：非线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Connection conn; <span class="comment">//①一个非线程安全的变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTopic</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stat</span> <span class="operator">=</span> conn.createStatement(); <span class="comment">//②引用非线程安全变量</span></span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于①处的conn是成员变量，因为addTopic()方法是非线程安全的，必须在使用时创建一个新TopicDao实例（非singleton）。下面使用ThreadLocal对conn这个非线程安全的“状态”进行改造：</p>
<p>代码清单4 TopicDao：线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicDao</span> &#123;</span><br><span class="line">    <span class="comment">//①使用ThreadLocal保存Connection变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//②如果connThreadLocal没有本线程对应的Connection创建一个新的Connection，并将其保存到线程本地变量中。</span></span><br><span class="line">        <span class="keyword">if</span> (connThreadLocal.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ConnectionManager.getConnection();</span><br><span class="line">            connThreadLocal.set(conn);</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> connThreadLocal.get(); <span class="comment">//③直接返回线程本地变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTopic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//④从ThreadLocal中获取线程对应的Connection</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stat</span> <span class="operator">=</span> getConnection().createStatement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​         不同的线程在使用TopicDao时，先判断connThreadLocal.get()是否是null，如果是null，则说明当前线程还没有对应的 Connection对象，这时创建一个Connection对象并添加到本地线程变量中；如果不为null，则说明当前的线程已经拥有了 Connection对象，直接使用就可以了。这样，就保证了不同的线程使用线程相关的Connection，而不会使用其它线程的 Connection。因此，这个TopicDao就可以做到singleton共享了。</p>
<p>​        当然，这个例子本身很粗糙，将Connection的ThreadLocal直接放在DAO只能做到本DAO的多个方法共享Connection时不发生 线程安全问题，但无法和其它DAO共用同一个Connection，要做到同一事务多DAO共享同一Connection，必须在一个共同的外部类使用 ThreadLocal保存Connection。</p>
<hr>
<p>转载自：<br><a href="http://blog.csdn.net/feihong247/article/details/7791049">http://blog.csdn.net/feihong247/article/details/7791049</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>ThreadLocal</category>
      </categories>
  </entry>
  <entry>
    <title>Future.get()在配置RejectedExecutionHandler为ThreadPoolExecutor.DiscardPolicy策略时一直阻塞</title>
    <url>/2024/03/11/Java/Java%E8%BF%9B%E9%98%B6/Future/Future.get()%E5%9C%A8%E9%85%8D%E7%BD%AERejectedExecutionHandler%E4%B8%BAThreadPoolExecutor.DiscardPolicy%E7%AD%96%E7%95%A5%E6%97%B6%E4%B8%80%E7%9B%B4%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<p><strong>1、先复现这种情况：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sdcuike.java11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.ThreadFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;rpc-pool-%d&quot;</span>).setDaemon(<span class="literal">true</span>).build();</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.HOURS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), threadFactory, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;rejectedExecution&quot;</span>);</span><br><span class="line">     </span><br><span class="line">                <span class="built_in">super</span>.rejectedExecution(r, executor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">     </span><br><span class="line">        threadPoolExecutor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">     </span><br><span class="line">        Future&lt;String&gt; future = threadPoolExecutor.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;done&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">     </span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        System.out.println(<span class="string">&quot;done....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <span id="more"></span> 

<p>线程池中线程的配置为daemon线程（后台运行），当我们的main线程退出时，后台线程也会退出。会输出</p>
<p>done…. 而现实的结果是main线程一直阻塞在future.get()调用：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291556277.png" alt="img"></p>
<p><strong>2、why？</strong></p>
<p>我们看下源码：java.util.concurrent.FutureTask#get()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &lt;= COMPLETING)</span><br><span class="line">            s = awaitDone(false, 0L);</span><br><span class="line">        return report(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>FutureTask 内部有几种状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final int NEW          = 0;</span><br><span class="line">    private static final int COMPLETING   = 1;</span><br><span class="line">    private static final int NORMAL       = 2;</span><br><span class="line">    private static final int EXCEPTIONAL  = 3;</span><br><span class="line">    private static final int CANCELLED    = 4;</span><br><span class="line">    private static final int INTERRUPTING = 5;</span><br><span class="line">    private static final int INTERRUPTED  = 6;</span><br></pre></td></tr></table></figure>
<p>当状态state&lt;&#x3D;COMPLETING 即COMPLETING和NEW两种状态时，会一直阻塞：awaitDone(false, 0L)。</p>
<p>FutureTask的状态设置是在线程池ThreadPoolExecutor执行过程中所设置的，一般情况下线程池队列不满，即不会执行RejectedExecutionHandler处理不能处理的任务时，状态都会设置为state &gt; COMPLETING的某个状态 ，但线程池执行RejectedExecutionHandler的时候，java内置的拒绝策略有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CallerRunsPolicy</span><br><span class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Creates a &#123;@code CallerRunsPolicy&#125;.</span><br><span class="line">         */</span><br><span class="line">        public CallerRunsPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Executes task r in the caller&#x27;s thread, unless the executor</span><br><span class="line">         * has been shut down, in which case the task is discarded.</span><br><span class="line">         *</span><br><span class="line">         * @param r the runnable task requested to be executed</span><br><span class="line">         * @param e the executor attempting to execute this task</span><br><span class="line">         */</span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">            if (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这种策略会使用调用线程池执行任务的当前线程执行，java.util.concurrent.FutureTask#run() 执行肯定会设置新的完成状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbortPolicy</span><br><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Creates an &#123;@code AbortPolicy&#125;.</span><br><span class="line">         */</span><br><span class="line">        public AbortPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Always throws RejectedExecutionException.</span><br><span class="line">         *</span><br><span class="line">         * @param r the runnable task requested to be executed</span><br><span class="line">         * @param e the executor attempting to execute this task</span><br><span class="line">         * @throws RejectedExecutionException always</span><br><span class="line">         */</span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">            throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line">                                                 &quot; rejected from &quot; +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这种策略是线程池没配置的情况下使用的 默认策略，直接抛出异常，线程池根本就不会执行任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DiscardOldestPolicy</span><br><span class="line">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Creates a &#123;@code DiscardOldestPolicy&#125; for the given executor.</span><br><span class="line">         */</span><br><span class="line">        public DiscardOldestPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Obtains and ignores the next task that the executor</span><br><span class="line">         * would otherwise execute, if one is immediately available,</span><br><span class="line">         * and then retries execution of task r, unless the executor</span><br><span class="line">         * is shut down, in which case task r is instead discarded.</span><br><span class="line">         *</span><br><span class="line">         * @param r the runnable task requested to be executed</span><br><span class="line">         * @param e the executor attempting to execute this task</span><br><span class="line">         */</span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">            if (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>丢弃任务队列队头的任务，任何重试执行提交的新任务。状态肯定会设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DiscardPolicy</span><br><span class="line">public static class DiscardPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Creates a &#123;@code DiscardPolicy&#125;.</span><br><span class="line">         */</span><br><span class="line">        public DiscardPolicy() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Does nothing, which has the effect of discarding task r.</span><br><span class="line">         *</span><br><span class="line">         * @param r the runnable task requested to be executed</span><br><span class="line">         * @param e the executor attempting to execute this task</span><br><span class="line">         */</span><br><span class="line">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这种策略什么都不做，任务的状态自然是初始状态，永远不会更新任务的状态，导致java.util.concurrent.FutureTask#get() 一直阻塞。</p>
<p>所以，最好的情况下是不使用这种策略，或者使用java.util.concurrent.FutureTask#get(long, java.util.concurrent.TimeUnit) 带有超时的方法获取结果，或者重写策略，取消任务： ((FutureTask) r).cancel(true);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">           public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123;</span><br><span class="line">               System.out.println(&quot;rejectedExecution&quot;);</span><br><span class="line">               ((FutureTask) r).cancel(true)</span><br><span class="line">               super.rejectedExecution(r, executor);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>3、解决一直阻塞的问题总结</strong><br>1、重写DiscardPolicy，取消任务：  ((FutureTask) r).cancel(true)。<br>2、不使用DiscardPolicy，建议还是用线程池默认的AbortPolicy，可以重写，打印日志，再调用super.rejectedExecution(r, executor)，抛出默认异常行为。<br>3、使用java.util.concurrent.FutureTask#get(long, java.util.concurrent.TimeUnit) 带有超时的方法获取结果</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>Future</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadLocal与InheritableThreadLocal的使用</title>
    <url>/2024/03/10/Java/Java%E8%BF%9B%E9%98%B6/ThreadLocal/ThreadLocal%E4%B8%8EInheritableThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>​	ThreadLocal，线程本地存储,为变量在每个线程中都创建了一个副本，那么每个线程可以独立地改变和访问自己的副本变量，而不会影响其它线程所对应的副本变量。从线程的角度看，目标变量就像是线程的本地变量，这也是类名中“Local”所要表达的意思。</p>
<p>​        ThreadLocal不是用来解决对象共享访问问题的，而是提供了保持对象的方法和避免参数传递的对象访问方式。每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象。</p>
<p>​        在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个 threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对 Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为 value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
 <span id="more"></span> 

<p>在Thread类中会发现有threadLocals与inheritableThreadLocals两个成员变量，都是ThreadLocal.ThreadLocalMap类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap这个类是ThreadLocal类的一个内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p>
<p>总的来说，实际上是通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中，threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，这样每个线程中可有多个threadLocal变量。</p>
<p>简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    ThreadLocal&lt;StringBuilder&gt; a = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    ThreadLocal&lt;String&gt; b = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;---zero&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadLocalTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalTest</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.a.get());</span><br><span class="line">        System.out.println(test.b.get());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                test.a.set(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">                System.out.println(test.a.get());</span><br><span class="line">                System.out.println(test.b.get());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.a.get());</span><br><span class="line">        System.out.println(test.b.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span></span><br><span class="line">main---zero</span><br><span class="line">hello</span><br><span class="line">Thread-<span class="number">0</span>---zero</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">main---zero</span><br></pre></td></tr></table></figure>



<p>​        InheritableThreadLocal类继承于ThreadLocal类，所以它具有ThreadLocal类的特性，但又是一种特殊的 ThreadLocal，其特殊性在于InheritableThreadLocal变量值会自动传递给所有子线程，即在创建子线程时，子线程会接收所有可继承的线程局部变量的初始值，以获得父线程所具有的值。而普通ThreadLocal变量不行。</p>
<p>​        如果一个子线程调用InheritableThreadLocal的get()，那么它将与它的父线程看到同一个对象。为保护线程安全性，应该只对不可变对象（一旦创建，其状态就永远不会被改变的对象）使用InheritableThreadLocal，因为对象被多个线程共享。</p>
<p>​        简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalTest</span> &#123;</span><br><span class="line">    InheritableThreadLocal&lt;StringBuilder&gt; a = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">    InheritableThreadLocal&lt;String&gt; b = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InheritableThreadLocalTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritableThreadLocalTest</span>();</span><br><span class="line"></span><br><span class="line">        test.a.set(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;main---hello&quot;</span>));</span><br><span class="line">        test.b.set(<span class="string">&quot;main---zero&quot;</span>);</span><br><span class="line">        System.out.println(test.a.get());</span><br><span class="line">        System.out.println(test.b.get());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(test.a.get());</span><br><span class="line">                System.out.println(test.b.get());</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">a</span> <span class="operator">=</span> test.a.get().append(<span class="string">&quot;---subThread&quot;</span>);</span><br><span class="line">                test.a.set(a);</span><br><span class="line">                test.b.set(<span class="string">&quot;subThread--zero&quot;</span>);</span><br><span class="line">                System.out.println(test.a.get());</span><br><span class="line">                System.out.println(test.b.get());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.a.get());</span><br><span class="line">        System.out.println(test.b.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main---hello</span><br><span class="line">main---zero</span><br><span class="line">main---hello</span><br><span class="line">main---zero</span><br><span class="line">main---hello---subThread</span><br><span class="line">subThread--zero</span><br><span class="line">main---hello---subThread</span><br><span class="line">main---zero</span><br></pre></td></tr></table></figure>

<p>可以看出，如果InheritableThreadLocal存储的是可变性（mutable）的对象，如StringBuilder，对于主线程设置的值，子线程可以通过get函数获取，但子线程调用set函数设置新值后，对主线程没有影响，对其它子线程也没有影响，只对自己可见，但如果子线程先get获取再修改对象的属性，那么这个修改对主线程和其它子线程是可见的，因为共享的是同一个引用。为了保护线程的安全性，一般建议只传递不可变（Immuable）对象，即没有状态的对象。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>ThreadLocal</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadLocal注意事项</title>
    <url>/2024/03/10/Java/Java%E8%BF%9B%E9%98%B6/ThreadLocal/ThreadLocal%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>​	在使用了线程池(如Executor)的情况下，那么即使父线程已经结束，子线程依然存在并被池化。这样，线程池中的线程在下一次请求被执行的时候，ThreadLocal对象的get()方法返回的将不是当前线程中设定的变量，因为池中的“子线程”根本不是当前线程创建的，当前线程设定的 ThreadLocal变量也就无法传递给线程池中的线程。因此，必须将外部线程中的ThreadLocal变量显式地传递给线程池中的线程。</p>
 <span id="more"></span> 


<p>关于ThreadLocal的内存泄露问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadLocal</span> <span class="variable">tl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadLocal</span>();</span><br><span class="line">        tl.set(<span class="keyword">new</span> <span class="title class_">My50MB</span>());</span><br><span class="line"></span><br><span class="line">        tl = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Full GC&quot;</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThreadLocal</span> <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] a = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;My threadlocal 1 MB finalized.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">My50MB</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] a = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;My 50 MB finalized.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Full GC  </span><br><span class="line">My threadlocal <span class="number">1</span> MB finalized.  </span><br></pre></td></tr></table></figure>

<p><code>TimeUnit.SECONDS.sleep(1)</code>是为了给GC一个反应的时间. GC优先级低,即使调用了system.gc也不能立刻执行.所以sleep 1秒.</p>
<p>于是有了如下分析：threadlocal里面使用了一个存在弱引用的map,当释放掉threadlocal的强引用以后,map里面的value却没有被回收.而这块 value永远不会被访问到了. 所以存在着内存泄露. 最好的做法是将调用threadlocal的remove方法. 说的也比较正确,当value不再使用的时候,调用remove的确是很好的做法.但内存泄露一说却不正确。</p>
<p>在threadlocal的生命周期中,存在的引用如下图: 实线代表强引用,虚线代表弱引用：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291536806.png" alt="image-20240318153607258"></p>
<p>​        每个thread中都存在一个map, map的类型是<code>ThreadLocal.ThreadLocalMap</code>. Map中的key为一个threadlocal实例. 这个Map的确使用了弱引用,不过弱引用只是针对key. 每个key都弱引用指向threadlocal.当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以 threadlocal将会被gc回收. 但是,value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收.</p>
<p>​        <strong>弱引用只存在于key上,所以key会被回收. 而value还存在着强引用.只有thead退出以后,value的强引用链条才会断掉. 改进如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zero.threadlocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">ThreadLocal</span> <span class="variable">tl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadLocal</span>();</span><br><span class="line">                tl.set(<span class="keyword">new</span> <span class="title class_">My50MB</span>());</span><br><span class="line">                tl = <span class="literal">null</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;Full GC&quot;</span>);</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThreadLocal</span> <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] a = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;My threadlocal 1 MB finalized.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">My50MB</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] a = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;My 50 MB finalized.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Full GC</span><br><span class="line">My threadlocal <span class="number">1</span> MB finalized.</span><br><span class="line">My <span class="number">50</span> MB finalized.</span><br></pre></td></tr></table></figure>

<p>可以看到,所有的都回收了.为什么要多次调用system.gc()? 这和finalize方法的策略有关系. finalize是一个特别低优先级的线程,当执行gc时,如果一个对象需要被回收,先执行它的finalize方法.这意味着,本次gc可能无法真正回收这个具有finalize方法的对象.留待下次回收. 这里多次调用system.gc正是为了给finalize留些时间. </p>
<p>从上面的例子可以看出,当线程退出以后,我们的value被回收了. 这是正确的.这说明内存并没有泄露.栈中还存在着对value的强引用路线。 然而在使用线程池时，线程一般是不会被销毁的。</p>
<p>参考：<a href="http://my.oschina.net/xpbug/blog/113444">http://my.oschina.net/xpbug/blog/113444</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>ThreadLocal</category>
      </categories>
  </entry>
  <entry>
    <title>AbstractQueuedSynchronizer（二）</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/AbstractQueuedSynchronizer%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>AQS，AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架，如ReentrantLock、ReentrantReadWriteLock、Semaphore等，它是JUC并发包中的核心基础组件。</p>
<p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。AQS使用一个int类型的成员变量state来代表共享资源和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。当state&gt;0时表示已经获取了锁，当state &#x3D; 0时表示释放了锁。它提供了三个方法（getState()、setState(int newState)、compareAndSetState(int expect,int update)）来对state进行操作，当然AQS可以确保对state的操作是安全的。</p>
<p>AQS通过内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。AbstractQueuedSynchronizer类的数据结构如下：</p>
<span id="more"></span>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291617148.png"></p>
<p>AbstractQueuedSynchronizer类底层的数据结构是使用双向链表，是队列的一种实现，故也可看成是队列，其中Sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。而Condition queue不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue。</p>
<p>​    AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。  </li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 </li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。  </li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state&#x3D;0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p>类定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractQueuedSynchronizer</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;    </span><br><span class="line">    <span class="comment">// 尾结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;    </span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;    </span><br><span class="line">    <span class="comment">// 自旋时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">spinForTimeoutThreshold</span> <span class="operator">=</span> <span class="number">1000L</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内部类Node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 模式，分为共享与独占</span></span><br><span class="line">        <span class="comment">// 共享模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">// 独占模式</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;        </span><br><span class="line">        <span class="comment">// 结点状态</span></span><br><span class="line">        <span class="comment">// CANCELLED，值为1，表示当前的线程被取消</span></span><br><span class="line">        <span class="comment">// SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark</span></span><br><span class="line">        <span class="comment">// CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中</span></span><br><span class="line">        <span class="comment">// PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行</span></span><br><span class="line">        <span class="comment">// 值为0，表示当前节点在sync队列中，等待着获取锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结点状态</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;        </span><br><span class="line">        <span class="comment">// 前驱结点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;    </span><br><span class="line">        <span class="comment">// 后继结点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;        </span><br><span class="line">        <span class="comment">// 结点所对应的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;        </span><br><span class="line">        <span class="comment">// 下一个等待者</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结点是否在共享模式下等待</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取前驱结点，若前驱结点为空，抛出异常</span></span><br><span class="line">        <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">            <span class="comment">// 保存前驱结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev; </span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="comment">// 前驱结点为空，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 前驱结点不为空，返回</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 无参构造函数</span></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">         Node(Thread thread, Node mode) &#123;    <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    每个被阻塞的线程都会被封装成一个Node结点，放入队列。每个节点包含了一个Thread类型的引用，并且每个节点都存在一个状态，具体状态如下。CANCELLED表示当前的线程被取消；SIGNAL表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作；CONDITION表示当前节点在等待condition，也就是在condition queue中；PROPAGATE表示当前场景下后续的acquireShared能够得以执行；值0表示当前节点在sync queue中，等待着获取锁。</p>
<p>acquire函数</p>
<p>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用tryAcquire函数，调用此方法的线程会试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它并则直接返回。在AbstractQueuedSynchronizer源码中默认会抛出一个异常，即需要子类去重写此函数完成自己的逻辑。</p>
<p>若tryAcquire失败，则调用addWaiter函数，addWaiter函数完成的功能是将调用此方法的线程封装成为一个结点并放入Sync queue。</p>
<p>调用acquireQueued函数，此函数完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。</p>
<p>首先分析addWaiter(Node.EXCLUSIVE):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加等待者</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 新生成一个结点，默认为独占模式</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 保存尾结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123; <span class="comment">// 尾结点不为空，即已经被初始化</span></span><br><span class="line">        <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">        node.prev = pred; </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 比较pred是否为尾结点，是则将尾结点设置为node </span></span><br><span class="line">            <span class="comment">// 设置尾结点的next域为node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">// 返回新生成的结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上一步失败则通过enq入队</span></span><br><span class="line">    enq(node); <span class="comment">// 尾结点为空(即还没有被初始化过)，或者是compareAndSetTail操作失败，则入队列</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。那么该线程下一步即进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源。即acquireQueued 函数的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sync队列中的结点在独占且忽略中断的模式下获取(资源)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 标志</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 中断标志</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// 自旋</span></span><br><span class="line">                <span class="comment">// 获取node节点的前驱结点</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); </span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 前驱为头结点并且成功获得锁</span></span><br><span class="line">                    setHead(node); <span class="comment">// 设置自己为头结点</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">//方便GC回收以前的head结点。</span></span><br><span class="line">                    failed = <span class="literal">false</span>; <span class="comment">// 设置标志</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted; </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    首先获取当前节点的前驱节点，如果前驱节点是头结点并且能够获取资源，代表该当前节点能够占有锁，设置头结点为当前节点，返回。否则，调用shouldParkAfterFailedAcquire和parkAndCheckInterrupt函数，shouldParkAfterFailedAcquire函数如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当获取(资源)失败后，检查并且更新结点状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取前驱结点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 状态为SIGNAL，为-1</span></span><br><span class="line">        <span class="comment">// 可以进行park操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// 表示状态为CANCELLED，为1</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>); <span class="comment">// 找到pred结点前面最近的一个状态不为CANCELLED的结点，即使pred结点为正常等待状态的结点</span></span><br><span class="line">        <span class="comment">// 赋值pred结点的next域</span></span><br><span class="line">        pred.next = node; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) </span></span><br><span class="line">        <span class="comment">// 如果前驱正常，那就把前驱的状态设置成SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能进行park操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    只有当该节点的前驱结点的状态为SIGNAL时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作。再看parkAndCheckInterrupt函数，源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行park操作并且返回该线程是否被中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>); <span class="comment">//调用park()使线程进入waiting状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 当前线程是否已被中断，并清除中断标记位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>parkAndCheckInterrupt函数里的逻辑是首先执行park操作，然后返回该线程是否已经被中断。park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：被unpark()或被interrupt()。</p>
<p>再看final块中的cancelAcquire函数，其源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消继续获取(资源)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 设置node结点的thread为空</span></span><br><span class="line">        node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存node的前驱结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>) <span class="comment">// 找到node前驱结点中第一个状态小于0的结点，即不为CANCELLED状态的结点</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取pred结点的下一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置node结点的状态为CANCELLED</span></span><br><span class="line">        node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; <span class="comment">// node结点为尾结点，则设置尾结点为pred结点</span></span><br><span class="line">            <span class="comment">// 比较并设置pred结点的next节点为null</span></span><br><span class="line">            compareAndSetNext(pred, predNext, <span class="literal">null</span>); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// node结点不为尾结点，或者比较设置不成功</span></span><br><span class="line">            <span class="type">int</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                 (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread != <span class="literal">null</span>) &#123; <span class="comment">// （pred结点不为头结点，并且pred结点的状态为SIGNAL）或者 </span></span><br><span class="line">                                    <span class="comment">// pred结点状态小于等于0，并且比较并设置等待状态为SIGNAL成功，并且pred结点所封装的线程不为空</span></span><br><span class="line">                <span class="comment">// 保存结点的后继</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 后继不为空并且后继的状态小于等于0</span></span><br><span class="line">                    compareAndSetNext(pred, predNext, next); <span class="comment">// 比较并设置pred.next = next;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                unparkSuccessor(node); <span class="comment">// 释放node的前一个结点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.next = node; <span class="comment">// help GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数完成的功能就是取消当前线程对资源的获取，即设置该结点的状态为CANCELLED，接着再看unparkSuccessor函数，此方法用于唤醒等待队列中下一个线程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放后继结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取node结点的等待状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3</span></span><br><span class="line">        <span class="comment">// 比较并且设置结点等待状态，设置为0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取node节点的下一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED</span></span><br><span class="line">        <span class="comment">// s赋值为空</span></span><br><span class="line">        s = <span class="literal">null</span>; </span><br><span class="line">        <span class="comment">// 从尾结点开始从后往前开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点</span></span><br><span class="line">                <span class="comment">// 保存结点</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) <span class="comment">// 该结点不为为空，唤醒</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    acquire()的过程即先调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</p>
<p>release函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 释放成功</span></span><br><span class="line">            <span class="comment">// 保存头结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; </span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 头结点不为空并且头结点状态不为0</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">//释放头结点的后继结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tryRelease的默认实现是抛出异常，需要具体的子类实现，如果tryRelease成功，那么如果头结点不为空并且头结点的状态不为0，则释放头结点的后继结点，unparkSuccessor函数已经分析过，不再累赘。</p>
<p>　　对于其他函数我们也可以分析，与前面分析的函数大同小异，所以，不再累赘。</p>
<p>acquireShared函数</p>
<p>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。</p>
<p>所以这里acquireShared()的流程就是：tryAcquireShared()尝试获取资源，成功则直接返回；失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</p>
<p>releaseShared函数</p>
<p>此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是releaseShared()的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放资源</span></span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state&#x3D;0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。</p>
<p>​    AbstractQueuedSynchronizer中还有内部类ConditionObject，表示Condition Queue的数据结构，由于篇幅原因暂不展开了。</p>
<hr>
<p>参考阅读：<br><a href="http://blog.csdn.net/zero__007/article/details/51570276">http://blog.csdn.net/zero__007/article/details/51570276</a><br><a href="http://www.cnblogs.com/leesf456/p/5350186.html">http://www.cnblogs.com/leesf456/p/5350186.html</a><br><a href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadLocal源码分析</title>
    <url>/2024/03/10/Java/Java%E8%BF%9B%E9%98%B6/ThreadLocal/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>​	ThreadLocal这个类给线程提供了一个本地变量，这个变量是该线程自己拥有的。在该线程存活和ThreadLocal实例能访问的时候,保存了对这个变量副本的引用.当线程消失的时候，所有的本地实例都会被GC。建议ThreadLocal最好是 private static 修饰的成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	ThreadLocals 解决Hash 冲突使用线性探测的方法。其中key为ThreadLocal对象，因为Thread类中的threadLocals是个map对象，意味一个Thread中可以存放多个ThreadLocal对象。因此用threadLocalHashCode来区分是哪个ThreadLocal类型。</p>
<span id="more"></span> 

<p>get方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    返回当前线程的threadLocal变量，如果这个变量对当前线程没有值，则它调用前面介绍的initialValue方法获取初始值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​    Thread中threadLocals定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>



<p>​    ThreadLocalMap结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">        threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    内部是Entry数组，Entry是继承WeakReference。ThreadLocalMap的getEntry方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    先结合threadLocalHashCode与table.length – 1的值确定该ThreadLocal在ThreadLocalMap的Entry数组下标位置。然后根据下标如果能在table找到直接返回，否则调用getEntryAfterMiss：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    解释下<code>e.get() == null</code>表示这个key引用被垃圾回收了，因此需要调用expungeStaleEntry方法从数组里删除该Entry；如果其它情况需要向后找下一个Entry，因为采用的是线性探测法解决冲突的。</p>
<p>set方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    ThreadLocalMap的set方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    for循环中是根据计算得出的下标在table中找Entry，当Entry不为空时，如果是同一个对象，k &#x3D;&#x3D; key，直接替换Entry里面的value值；如果k为null，说明k被回收了，重新放入该位置；否则向后继续找Entry，直到Entry为空。</p>
<p>​    如果计算后的坐标获取到的entry为null，就new一个Entry对象并保存进去，然后调用cleanSomeSlots()对table进行清理，如果没有任何Entry被清理，并且数组的size超过了阈值，就会调用rehash()方法。</p>
<p>​    cleanSomeSlots()中会调用expungeStaleEntry清理不用的Entry。rehash则会调用expungeStaleEntries()方法清理所有不用的Entry：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>ThreadLocal</category>
      </categories>
  </entry>
  <entry>
    <title>AbstractQueuedSynchronizer</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/AbstractQueuedSynchronizer/</url>
    <content><![CDATA[<p>Java提供了一个基于FIFO队列—<strong>AbstractQueuedSynchronizer</strong>，可以用于构建锁或者其他相关同步装置的基础框架。该同步器（AQS）利用了一个int来表示状态，期望它能够成为实现大部分同步需求的基础。子类通过继承AQS并需要实现它的方法来管理其状态，管理的方式就是通过类似acquire和 release的方式来操纵状态。然而多线程环境中对状态的操纵必须确保原子性，因此子类对于状态的把握，需要使用这个同步器提供的以下三个方法对状态进行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS的功能可以分为两类：独占功能和共享功能，它的所有子类中，要么实现并使用了它独占功能的API，要么使用了共享锁的功能，而不会同时使用两套 API，即便是它最有名的子类ReentrantReadWriteLock，也是通过两个内部类：读锁和写锁，分别实现的两套API来实现的，为什么这 么做，后面我们再分析，到目前为止，我们只需要明白AQS在功能上有独占控制和共享控制两种功能即可。</p>
<span id="more"></span> 

<p>同步器是实现锁的关键，利用同步器将锁的语义实现，然后在锁的实现中聚合同步器。可以这样理解：锁的API是面向使用者的，它定义了与锁交互的公共行为，而每个锁需要完成特定的操作也是透过这些行为来完成的，但是实现是依托给同步器来完成；同步器面向的是线程访问和资源控制，它定义了线程对资源是否能够获取以及线程的排队等操作。锁和同步器很好的隔离了二者所需要关注的领域，严格意义上讲，同步器可以适用于除了锁以外的其他同步设施上（包括锁）。</p>
<p>同步器的开始提到了其实现依赖于一个FIFO队列，那么队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。Node的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>waitStatus：表示节点的状态，存在有五种状态。</p>
<blockquote>
<p>CANCELLED(1)表示线程已经被取消；</p>
<p>SIGNAL表示当前节点的后继节点包含的线程需要运行，也就是unpark；</p>
<p>CONDITION表示当前节点在等待condition，也就是在condition队列中；</p>
<p>PROPAGATE表示当前场景下后续的acquireShared能够得以执行；</p>
<p>当值为0时，表示当前节点在sync队列中，等待着获取锁。</p>
</blockquote>
</li>
<li><p>prev：前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。</p>
</li>
<li><p>next：后继节点。</p>
</li>
<li><p>thread：入队列时的当前线程。</p>
</li>
<li><p>nextWaiter：存储condition队列中的后继节点。</p>
</li>
</ul>
<p>AbstractQueuedSynchronizer定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">    。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面通过一个排它锁的例子来深入理解一下同步器的工作原理，而只有掌握同步器的工作原理才能够更加深入了解其他的并发组件。排他锁的实现，一次只能一个线程获取到锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 内部类，自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否处于占用状态</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">        Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出Mutex将Lock接口均代理给了同步器的实现。使用方将Mutex构造出来之后，调用lock获取锁，调用unlock进行解锁。下面以Mutex为例子，详细分析以下同步器的实现逻辑。</p>
<p>源码分析</p>
<p>获取锁过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尝试获取锁，在tryAcquire方法中使用了同步器提供的对state操作的方法，利用compareAndSet保证只有一个线程能够对状态进行成功修改，如果获取不到，将当前线程构造成节点Node并加入sync队列。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode); <span class="comment">//构造Node</span></span><br><span class="line">    <span class="comment">//快速尝试在尾部添加</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123; <span class="comment">//存在尾节点</span></span><br><span class="line">        node.prev = pred; <span class="comment">//新节点前驱节点指向尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">//使自己成为tail</span></span><br><span class="line">            pred.next = node; <span class="comment">//原有的尾节点的后继节点指向自己</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);<span class="comment">//if块操作失败则使用该方式在尾部添加</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">//获取前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; </span><br><span class="line"><span class="comment">//前驱节点是head，并尝试获取到了锁</span></span><br><span class="line">                setHead(node); <span class="comment">//设置头结点head为当前节点</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line"><span class="comment">//检查前一个节点的状态，看当前获取锁失败的线程是否需要挂起(Node.SIGNAL时返回true；</span></span><br><span class="line"><span class="comment">////如果需要，借助JUC包下的LockSopport类的静态方法Park挂起当前线程。)。</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node); <span class="comment">//取消请求，对应到队列操作，就是将当前节点从队列中移除。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>释放锁过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">//尝试释放状态</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">//唤醒当前节点的后继节点所包含的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next; <span class="comment">//获取当前节点的后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//注意是从队列尾部开始往前去找的最前面的一个waitStatus小于0的节点。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) </span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">// 唤醒线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<p>参看：<br><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/">http://ifeve.com/introduce-abstractqueuedsynchronizer/</a><br><a href="http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/">http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>Java内存模型之happens-before</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8Bhappens-before/</url>
    <content><![CDATA[<p>从JDK 5 开始，JMM就使用happens-before的概念来阐述多线程之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</p>
<p>happens-before原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。下面我们就一个简单的例子稍微了解下happens-before：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span>;    <span class="comment">//线程A执行  </span></span><br><span class="line">j = i ;   <span class="comment">//线程B执行  </span></span><br></pre></td></tr></table></figure>

<p>j 是否等于1呢？假定线程A的操作（i &#x3D; 1）happens-before线程B的操作（j &#x3D; i）,那么可以确定线程B执行后j &#x3D; 1 一定成立，如果他们不存在happens-before原则，那么j &#x3D; 1 不一定成立。这就是happens-before原则的威力。</p>
<span id="more"></span>

<p>happens-before原则定义如下：</p>
<p><strong>1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</strong></p>
<p><strong>2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</strong></p>
<p>下面是happens-before原则规则：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；  </li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；  </li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；  </li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；  </li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作； </li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；  </li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；  </li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>
</ul>
<p>来详细看看上面每条规则（摘自《深入理解Java虚拟机第12章》）：</p>
<p>程序次序规则：一段代码在单线程中执行的结果是有序的。注意是执行结果，因为虚拟机、处理器会对指令进行重排序（重排序后面会详细介绍）。虽然重排序了，但是并不会影响程序的执行结果，所以程序最终执行的结果与顺序执行的结果是一致的。故而这个规则只对单线程有效，在多线程环境下无法保证正确性。</p>
<ul>
<li><p>锁定规则：这个规则比较好理解，无论是在单线程环境还是多线程环境，一个锁处于被锁定状态，那么必须先执行unlock操作后面才能进行lock操作。</p>
</li>
<li><p>volatile变量规则：这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。</p>
</li>
<li><p>传递规则：提现了happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C</p>
</li>
<li><p>线程启动规则：假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。</p>
</li>
<li><p>线程终结规则：假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。</p>
</li>
</ul>
<p>上面八条是原生Java满足Happens-before关系的规则，但是我们可以对他们进行推导出其他满足happens-before的规则： </p>
<p>1.将一个元素放入一个线程安全的队列的操作Happens-Before从队列中取出这个元素的操作</p>
<p>2.将一个元素放入一个线程安全容器的操作Happens-Before从容器中取出这个元素的操作</p>
<p>3.在CountDownLatch上的倒数操作Happens-Before CountDownLatch#await()操作</p>
<p>4.释放Semaphore许可的操作Happens-Before获得许可操作</p>
<p>5.Future表示的任务的所有操作Happens-Before Future#get()操作</p>
<p>6.向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作</p>
<p>这里再说一遍happens-before的概念：如果两个操作不存在上述（前面8条 + 后面6条）任一一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序。如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的。即happens-before是原则，满足这些原则操作才有happens-before的关系。</p>
<p>下面就用一个简单的例子来描述下happens-before原则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> j )</span>&#123;      </span><br><span class="line">  i = j;  </span><br><span class="line">&#125;     </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>&#123;      </span><br><span class="line">  <span class="keyword">return</span> i;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们约定线程A执行write()，线程B执行read()，且线程A优先于线程B执行，那么线程B获得结果是什么？；我们就这段简单的代码一次分析happens-before的规则（规则5、6、7、8以及推导出的6条可以忽略，因为他们和这段代码毫无关系）：</p>
<p>1.由于两个方法是由不同的线程调用，所以肯定不满足程序次序规则；</p>
<p>2.两个方法都没有使用锁，所以不满足锁定规则；</p>
<p>3.变量i不是用volatile修饰的，所以volatile变量规则不满足；</p>
<p>4.传递规则肯定不满足；</p>
<p>所以我们无法通过happens-before原则推导出线程A happens-before线程B，虽然可以确认在时间上线程A优先于线程B指定，但是就是无法确认线程B获得的结果是什么，所以这段代码不是线程安全的。那么怎么修复这段代码呢？满足规则2、3任一即可。</p>
<hr>
<p><a href="http://blog.csdn.net/chenssy/article/details/55046860">http://blog.csdn.net/chenssy/article/details/55046860</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>Java虚拟机对内部锁的四种优化方式</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E5%86%85%E9%83%A8%E9%94%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>&emsp;&emsp;锁消除是JIT编译器对内部锁的具体实现所做的一种优化。<br>&emsp;&emsp;在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问。如果同步块所使用的锁对象只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候并不生成synchronized所表示的锁的申请与释放对应的机器码，而仅生成原临界区代码对应的机器码，即消除了锁的使用。这种编译器优化就被称为锁消除，它使得特定情况下我们可以完全消除锁的开销。</p>
<p>&emsp;&emsp;例如，StringBuffer虽然是线程安全的，但是在实际使用中往往不在多个线程间共享这些类的实例。而这些类在实现线程安全的时候往往借助于内部锁。因此，这些类是锁消除优化的常见目标。<br>&emsp;&emsp;锁消除优化还可能需要以JIT编译器的内联优化为前提。而一个方法是否会被JIT编译器内联取决于该方法的热度以及该方法对应的字节码的尺寸（Bytecode Size)。因此，锁消除优化能否被实施还取决于被调用的同步方法（或者带同步块的方法）是否能够被内联。</p>
<span id="more"></span>&emsp;&emsp;

<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>&emsp;&emsp;锁粗化是JIT编译器对内部锁的具体实现所做的一种优化。<br>&emsp;&emsp;对于相邻的几个同步块，如果这些同步块使用的是同一个锁实例，那么JIT编译器会将这些同步块合并为一个大同步块，从而避免了一个线程反复申请、释放同一个锁所导致的开销。然而，锁粗化可能导致一个线程持续持有一个锁的时间变长，从而使得同步在该锁之上的其他线程在申请锁时的等待时间变长。因此，锁粗化不会被应用到循环体内的相邻同步块。</p>
<p>&emsp;&emsp;</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>&emsp;&emsp;偏向锁是Java虚拟机对锁的实现所做的一种优化。这种优化基于 大多数锁并没有被争用，并且这些锁在其整个生命周期内至多只会被一个线程持有。然而，Java虚拟机在实现monitorenter字节码（申请锁）和monitorexit字节码（释放锁）时需要借助一个原子操作（CAS操作），这个操作代价相对来说比较昂贵。因此，Java虚拟机会为每个对象维护一个偏好，即一个对象对应的内部锁第1次被一个线程获得，那么这个线程就会被记录为该对象的偏好线程（Biased Thread）。这个线程后续无论是再次申请该锁还是释放该锁，都无须借助原先（指未实施偏向锁优化前）昂贵的原子操作，从而减少了锁的申请与释放的开销。</p>
<p>&emsp;&emsp;</p>
<h3 id="适应性锁"><a href="#适应性锁" class="headerlink" title="适应性锁"></a>适应性锁</h3><p>&emsp;&emsp;适应性锁是JIT编译器对内部锁实现所做的一种优化。<br>&emsp;&emsp;存在锁争用的情况下，一个线程申请一个锁的时候如果这个锁恰好被其他线程持有，那么这个线程就需要等待该锁被其持有线程释放。实现这种等待的一种保守方法——将这个线程暂停（线程的生命周期状态变为非Runnable状态）。由于暂停线程会导致上下文切换，因此对于一个具体锁实例来说，这种实现策略比较适合于系统中绝大多数线程对该锁的持有时间较长的场景，这样才能够抵消上下文切换的开销。另外一种实现方法就是采用忙等，所谓忙等相当于一个循环体为空的循环语句。<br>&emsp;&emsp;可见，忙等是通过反复执行空操作（什么也不做）直到所需的条件成立为止而实现等待的。这种策略的好处是不会导致上下文切换，缺点是比较耗费处理器资源——如果所需的条件在相当长时间内未能成立，那么忙等的循环就会一直被执行。因此，对于一个具体的锁实例来说，忙等策略比较适合于绝大多数线程对该锁的持有时间较短的场景，这样能够避免过多的处理器时间开销。</p>
<p>&emsp;&emsp;事实上，Java虚拟机也不是非要在上述两种实现策略之中择其一 ——它可以综合使用上述两种策略。对于一个具体的锁实例，Java虚拟机会根据其运行过程中收集到的信息来判断这个锁是属于被线程持有时间“较长”的还是“较短”的。对于被线程持有时间“较长”的锁，Java虚拟机会选用暂停等待策略；而对于被线程持有时间“较短”的锁，Java虚拟机会选用忙等等待策略。Java虚拟机也可能先采用忙等等待策略，在忙等失败的情况下再采用暂停等待策略。Java虚拟机的这种优化就被称为适应性锁，这种优化同样也需要JIT编译器介入。<br>&emsp;&emsp;适应性锁优化可以是以具体的一个锁实例为基础的。也就是说，Java虚拟机可能对一个锁实例采用忙等等待策略，而对另外一个锁实例采用暂停等待策略。<br>&emsp;&emsp;从适应性锁优化可以看出，内部锁的使用并不一定会导致上下文切换，这就是说锁“可能”导致上下文切换的原因。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/broadview2006/article/details/78132983">https://blog.csdn.net/broadview2006/article/details/78132983</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的Atomic包</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/Java%E4%B8%AD%E7%9A%84Atomic%E5%8C%85/</url>
    <content><![CDATA[<p><strong>Atomic包介绍</strong></p>
<p>在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<p><strong>原子更新基本类型类</strong></p>
<p>用于通过原子的方式更新基本类型，Atomic包提供了以下三个类：</p>
<p>AtomicBoolean：原子更新布尔类型。</p>
<p>AtomicInteger：原子更新整型。</p>
<p>AtomicLong：原子更新长整型。</p>
<p><strong>原子更新数组类</strong></p>
<p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下三个类：</p>
<p>·    AtomicIntegerArray：原子更新整型数组里的元素。</p>
<p>·    AtomicLongArray：原子更新长整型数组里的元素。</p>
<p>·    AtomicReferenceArray：原子更新引用类型数组里的元素。</p>
<span id="more"></span> 

<p><strong>原子更新引用类型</strong></p>
<p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子的更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下三个类：</p>
<p>·    AtomicReference：原子更新引用类型。</p>
<p>·    AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</p>
<p>·    AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子的更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference(V initialRef, boolean initialMark)</p>
<p><strong>原子更新字段类</strong></p>
<p>如果只需要某个类里的某个字段，那么就需要使用原子更新字段类，Atomic包提供了以下三个类：</p>
<p>·    AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p>
<p>·    AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p>
<p>·    AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更数据和数据的版本号，可以解决使用CAS进行原子更新时，可能出现的ABA问题。</p>
<p>原子更新字段类都是抽象类，每次使用都时候必须使用静态方法newUpdater创建一个更新器。原子更新类的字段的必须使用public volatile修饰符。AtomicIntegerFieldUpdater的例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater</span><br><span class="line">			.newUpdater(User.class, <span class="string">&quot;old&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">User</span> <span class="variable">conan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;conan&quot;</span>, <span class="number">10</span>);</span><br><span class="line">		System.out.println(a.getAndIncrement(conan));</span><br><span class="line">		System.out.println(a.get(conan));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> old;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> old)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.name = name;</span><br><span class="line">			<span class="built_in">this</span>.old = old;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOld</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> old;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>java的几把锁</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/java%E7%9A%84%E5%87%A0%E6%8A%8A%E9%94%81/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h2><p>synchronized 关键字是一把经典的锁，也是我们平时用得最多的。在 JDK1.6 之前， syncronized 是一把重量级的锁，不过随着 JDK 的升级，也在对它进行不断的优化，如今它变得不那么重了，甚至在某些场景下，它的性能反而优于轻量级锁。在加了 syncronized 关键字的方法、代码块中，一次只允许一个线程进入特定代码段，从而避免多线程同时修改同一数据。</p>
<p>synchronized 锁有如下几个特点：</p>
<h3 id="有锁升级过程"><a href="#有锁升级过程" class="headerlink" title="有锁升级过程"></a><strong>有锁升级过程</strong></h3><p>在 JDK1.5 (含)之前， synchronized 的底层实现是重量级的，所以之前一致称呼它为”重量级锁”，在 JDK1.5 之后，对 synchronized 进行了各种优化，它变得不那么重了，实现原理就是锁升级的过程。我们先聊聊 1.5 之后的 synchronized 实现原理是怎样的。说到 synchronized 加锁原理，就不得不先说 Java 对象在内存中的布局， Java 对象内存布局如下:</p>
<span id="more"></span>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291619519.png" alt="img"></p>
<p>如上图所示，在创建一个对象后，在 JVM 虚拟机( HotSpot )中，对象在 Java 内存中的存储布局 可分为三块:</p>
<p><strong>对象头区域此处存储的信息包括两部分：</strong></p>
<p>1、对象自身的运行时数据( MarkWord )</p>
<p>存储 hashCode、GC 分代年龄、锁类型标记、偏向锁线程 ID 、 CAS 锁指向线程 LockRecord 的指针等， synconized 锁的机制与这个部分( markwork )密切相关，用 markword 中最低的三位代表锁的状态，其中一位是偏向锁位，另外两位是普通锁位。</p>
<p>2、对象类型指针( Class Pointer )</p>
<p>对象指向它的类元数据的指针、 JVM 就是通过它来确定是哪个 Class 的实例。</p>
<p><strong>实例数据区域</strong> </p>
<p> 此处存储的是对象真正有效的信息，比如对象中所有字段的内容</p>
<p><strong>对齐填充区域</strong></p>
<p> JVM 的实现 HostSpot 规定对象的起始地址必须是 8 字节的整数倍，换句话来说，现在 64 位的 OS 往外读取数据的时候一次性读取 64bit 整数倍的数据，也就是 8 个字节，所以 HotSpot 为了高效读取对象，就做了”对齐”，如果一个对象实际占的内存大小不是 8byte 的整数倍时，就”补位”到 8byte 的整数倍。所以对齐填充区域的大小不是固定的。</p>
<p>当线程进入到 synchronized 处尝试获取该锁时， synchronized 锁升级流程如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291619140.png" alt="img"></p>
<p>如上图所示， synchronized 锁升级的顺序为：偏向锁-&gt;轻量级锁-&gt;重量级锁，每一步触发锁升级的情况如下：</p>
<p><strong>偏向锁</strong></p>
<p>在 JDK1.8 中，其实默认是轻量级锁，但如果设定了 -XX:BiasedLockingStartupDelay &#x3D; 0 ，那在对一个 Object 做 syncronized 的时候，会立即上一把偏向锁。当处于偏向锁状态时， markwork 会记录当前线程 ID 。</p>
<p><strong>升级到轻量级锁</strong></p>
<p>当下一个线程参与到偏向锁竞争时，会先判断 markword 中保存的线程 ID 是否与这个线程 ID 相等，如果不相等，会立即撤销偏向锁，升级为轻量级锁。每个线程在自己的线程栈中生成一个 LockRecord ( LR )，然后每个线程通过 CAS (自旋)的操作将锁对象头中的 markwork 设置为指向自己的 LR 的指针，哪个线程设置成功，就意味着获得锁。关于 synchronized 中此时执行的 CAS 操作是通过 native 的调用 HotSpot 中 bytecodeInterpreter.cpp 文件 C++ 代码实现的，有兴趣的可以继续深挖。</p>
<p><strong>升级到重量级锁</strong></p>
<p>如果锁竞争加剧(如线程自旋次数或者自旋的线程数超过某阈值， JDK1.6 之后，由 JVM 自己控制该规则)，就会升级为重量级锁。此时就会向操作系统申请资源，线程挂起，进入到操作系统内核态的等待队列中，等待操作系统调度，然后映射回用户态。在重量级锁中，由于需要做内核态到用户态的转换，而这个过程中需要消耗较多时间，也就是”重”的原因之一。</p>
<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a><strong>可重入</strong></h3><p>synchronized 拥有强制原子性的内部锁机制，是一把可重入锁。因此，在一个线程使用 synchronized 方法时调用该对象另一个 synchronized 方法，即一个线程得到一个对象锁后再次请求该对象锁，是永远可以拿到锁的。<br>在 Java 中线程获得对象锁的操作是以线程为单位的，而不是以调用为单位的。<br>synchronized 锁的对象头的 markwork 中会记录该锁的线程持有者和计数器，当一个线程请求成功后， JVM 会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个 synchronized 方法&#x2F;块时，计数器会递减，如果计数器为 0 则释放该锁锁。</p>
<h3 id="悲观锁-互斥锁、排他锁"><a href="#悲观锁-互斥锁、排他锁" class="headerlink" title="悲观锁(互斥锁、排他锁)"></a><strong>悲观锁(互斥锁、排他锁)</strong></h3><p> synchronized 是一把悲观锁(独占锁)，当前线程如果获取到锁，会导致其它所有需要锁该的线程等待，一直等待持有锁的线程释放锁才继续进行锁的争抢。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h2><p>ReentrantLock 从字面可以看出是一把可重入锁，这点和 synchronized 一样，但实现原理也与 syncronized 有很大差别，它是基于经典的 AQS(AbstractQueueSyncronized) 实现的, AQS 是基于 volitale 和 CAS 实现的，其中 AQS 中维护一个 valitale 类型的变量 state 来做一个可重入锁的重入次数，加锁和释放锁也是围绕这个变量来进行的。 ReentrantLock 也提供了一些 synchronized 没有的特点，因此比 synchronized 好用。</p>
<p><strong>AQS模型如下图：</strong></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291619721.png" alt="img"></p>
<p>ReentrantLock 有如下特点：</p>
<h3 id="1、可重入"><a href="#1、可重入" class="headerlink" title="1、可重入"></a><strong>1、可重入</strong></h3><p>ReentrantLock 和 syncronized 关键字一样，都是可重入锁，不过两者实现原理稍有差别， RetrantLock 利用 AQS 的的 state 状态来判断资源是否已锁，同一线程重入加锁， state 的状态 +1 ; 同一线程重入解锁, state 状态 -1 (解锁必须为当前独占线程，否则异常); 当 state 为 0 时解锁成功。</p>
<h3 id="2、需要手动加锁、解锁"><a href="#2、需要手动加锁、解锁" class="headerlink" title="2、需要手动加锁、解锁"></a><strong>2、需要手动加锁、解锁</strong></h3><p>synchronized 关键字是自动进行加锁、解锁的，而 ReentrantLock 需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成，来手动加锁、解锁。</p>
<h3 id="3、支持设置锁的超时时间"><a href="#3、支持设置锁的超时时间" class="headerlink" title="3、支持设置锁的超时时间"></a><strong>3、支持设置锁的超时时间</strong></h3><p>synchronized 关键字无法设置锁的超时时间，如果一个获得锁的线程内部发生死锁，那么其他线程就会一直进入阻塞状态，而 ReentrantLock 提供 tryLock 方法，允许设置线程获取锁的超时时间，如果超时，则跳过，不进行任何操作，避免死锁的发生。</p>
<h3 id="4、支持公平-非公平锁"><a href="#4、支持公平-非公平锁" class="headerlink" title="4、支持公平&#x2F;非公平锁"></a><strong>4、支持公平&#x2F;非公平锁</strong></h3><p>synchronized 关键字是一种非公平锁，先抢到锁的线程先执行。而 ReentrantLock 的构造方法中允许设置 true&#x2F;false 来实现公平、非公平锁，如果设置为 true ，则线程获取锁要遵循”先来后到”的规则，每次都会构造一个线程 Node ，然后到双向链表的”尾巴”后面排队，等待前面的 Node 释放锁资源。</p>
<h3 id="5、可中断锁"><a href="#5、可中断锁" class="headerlink" title="5、可中断锁"></a><strong>5、可中断锁</strong></h3><p>ReentrantLock 中的 lockInterruptibly() 方法使得线程可以在被阻塞时响应中断，比如一个线程 t1 通过 lockInterruptibly() 方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过 interrupt() 方法就可以立刻打断 t1 线程的执行，来获取t1持有的那个可重入锁。而通过 ReentrantLock 的 lock() 方法或者 Synchronized 持有锁的线程是不会响应其他线程的 interrupt() 方法的，直到该方法主动释放锁之后才会响应 interrupt() 方法。</p>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a><strong>ReentrantReadWriteLock</strong></h2><p>ReentrantReadWriteLock (读写锁)其实是两把锁，一把是 WriteLock (写锁)，一把是读锁， ReadLock 。<br>读写锁的规则是：读读不互斥、读写互斥、写写互斥。<br>在一些实际的场景中，读操作的频率远远高于写操作，如果直接用一般的锁进行并发控制的话，就会读读互斥、读写互斥、写写互斥，效率低下，读写锁的产生就是为了优化这种场景的操作效率。一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高，因此需要根据实际情况选择使用。 </p>
<p>ReentrantReadWriteLock 的原理也是基于 AQS 进行实现的，与 ReentrantLock 的差别在于 ReentrantReadWriteLock 锁拥有共享锁、排他锁属性。<br>读写锁中的加锁、释放锁也是基于 Sync (继承于 AQS )，并且主要使用 AQS 中的 state 和 node 中的 waitState 变量进行实现的。实现读写锁与实现普通互斥锁的主要区别在于需要分别记录读锁状态及写锁状态，并且等待队列中需要区别处理两种加锁操作。<br>ReentrantReadWriteLock 中将 AQS 中的 int 类型的 state 分为高 16 位与第 16 位分别记录读锁和写锁的状态，如下图所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291619457.png" alt="img"></p>
<p><strong>WriteLock(写锁)是悲观锁(排他锁、互斥锁)</strong><br>通过计算 state&amp;((1&lt;&lt;16)-1) ，将 state 的高 16 位全部抹去，因此 state 的低位记录着写锁的重入计数。</p>
<p><strong>ReadLock(读锁)是共享锁(乐观锁)</strong><br>通过计算 state&gt;&gt;&gt;16 进行无符号补 0 ，右移 16 位，因此 state 的高位记录着写锁的重入计数.</p>
<p>读锁获取锁的过程比写锁稍微复杂些，首先判断写锁是否为 0 并且当前线程不占有独占锁，直接返回；否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功，若当前没有读锁，则设置第一个读线程 firstReader 和 firstReaderHoldCount ；若当前线程线程为第一个读线程，则增加 firstReaderHoldCount ；否则，将设置当前线程对应的 HoldCounter 对象的值，更新成功后会在 firstReaderHoldCount 中 readHolds ( ThreadLocal 类型的)的本线程副本中记录当前线程重入数，这是为了实现 JDK1.6 中加入的 getReadHoldCount ()方法的，这个方法能获取当前线程重入共享锁的次数( state 中记录的是多个线程的总重入次数)，加入了这个方法让代码复杂了不少，但是其原理还是很简单的：如果当前只有一个线程的话，还不需要动用 ThreadLocal ，直接往 firstReaderHoldCount 这个成员变量里存重入数，当有第二个线程来的时候，就要动用 ThreadLocal 变量 readHolds 了，每个线程拥有自己的副本，用来保存自己的重入数。</p>
<p>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p>
<p>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p>
<h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a><strong>LongAdder</strong></h2><p>在高并发的情况下，我们对一个 Integer 类型的整数直接进行 i++ 的时候，无法保证操作的原子性，会出现线程安全的问题。为此我们会用 juc 下的 AtomicInteger ，它是一个提供原子操作的 Interger 类，内部也是通过 CAS 实现线程安全的。但当大量线程同时去访问时，就会因为大量线程执行 CAS 操作失败而进行空旋转，导致 CPU 资源消耗过多，而且执行效率也不高。Doug Lea 大神应该也不满意，于是在 JDK1.8 中对 CAS 进行了优化，提供了 LongAdder ，它是基于了 CAS 分段锁的思想实现的。</p>
<p>线程去读写一个 LongAdder 类型的变量时，流程如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291619451.png" alt="img"></p>
<p>LongAdder 也是基于 Unsafe 提供的 CAS 操作 +valitale 去实现的。在 LongAdder 的父类 Striped64 中维护着一个 base 变量和一个 cell 数组，当多个线程操作一个变量的时候，先会在这个 base 变量上进行 cas 操作，当它发现线程增多的时候，就会使用 cell 数组。比如当 base 将要更新的时候发现线程增多（也就是调用 casBase 方法更新 base 值失败），那么它会自动使用 cell 数组，每一个线程对应于一个 cell ，在每一个线程中对该 cell 进行 cas 操作，这样就可以将单一 value 的更新压力分担到多个 value 中去，降低单个 value 的 “热度”，同时也减少了大量线程的空转，提高并发效率，分散并发压力。这种分段锁需要额外维护一个内存空间 cells ，不过在高并发场景下，这点成本几乎可以忽略。分段锁是一种优秀的优化思想， juc 中提供的的 ConcurrentHashMap 也是基于分段锁保证读写操作的线程安全。</p>
<hr>
<p>转载自：<a href="https://blog.csdn.net/u013256816/article/details/104912386">https://blog.csdn.net/u013256816/article/details/104912386</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>synchronized和Lock</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/synchronized%E5%92%8CLock/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>在Java中，最基本的互斥同步手段就是synchronized关键字。synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ol>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的class字节码对象 </li>
<li>同步方法块，锁是括号里面的对象</li>
</ol>
<p>synchronized的实现中，针对同步代码块是使用monitorenter和monitorexit指令实现的，而同步方法依靠的是方法修饰符上的ACC_SYNCHRONIZED实现（JVM底层实现）。</p>
<ul>
<li><p><strong>同步代码块</strong>：monitorenter指令会插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁； </p>
</li>
<li><p><strong>同步方法</strong>：synchronized方法则会被翻译成普通的方法调用和返回指令，如:invokevirtual、areturn指令，在JVM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。</p>
</li>
</ul>
<span id="more"></span> 

<p>根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p>
<p>在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的。首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</p>
<p> Java对象头（Mark Word）和Monitor Record是实现synchronized的基础。</p>
<ul>
<li><p>关于对象头，可以参看下：<a href="http://blog.csdn.net/zero__007/article/details/52430869%EF%BC%8C">http://blog.csdn.net/zero__007/article/details/52430869，</a> Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。</p>
</li>
<li><p>Monitor Record是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor record关联（对象头的MarkWord中的LockWord指向monitor record的起始地址），同时monitor record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。Owner初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL。</p>
</li>
</ul>
<p> <img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291623592.png" alt="img"></p>
<ul>
<li>Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li>
<li>EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。</li>
<li>RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。</li>
<li>Nest:用来实现重入锁的计数。</li>
<li>HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li>
<li>Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。<br>摘自：<a href="https://blog.csdn.net/u012465296/article/details/53022317%EF%BC%89">https://blog.csdn.net/u012465296/article/details/53022317）</a></li>
</ul>
<p><strong>锁优化</strong></p>
<p>JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 </p>
<p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p>自旋锁：所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p>
<p>适应自旋锁：JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<p>锁消除：为了保证数据的完整性，在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。</p>
<p>锁粗化：在使用同步锁的时候，需要让同步块的作用范围尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念。锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p>
<p>偏向锁、轻量级锁：参看<a href="http://blog.csdn.net/zero__007/article/details/49587319%E3%80%82">http://blog.csdn.net/zero__007/article/details/49587319。</a></p>
<p>重量级锁：重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>除了synchronized实现同步，还可以使用java.util.concurrent（下文称J.U.C）包中的重入锁（ReentrantLock）来实现，在基本用法上，ReentrantLock与synchronized很相似，都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁（lock（）和unlock（）方法配合try&#x2F;finally语句块来完成），另一个表现为原生语法层面的互斥锁。不过，相比synchronized,ReentrantLock增加了一些高级功能，主要有以下3项：</p>
<p>等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p>
<ul>
<li><p>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</p>
</li>
<li><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</p>
</li>
<li><p>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait（）和notify（）或notifyAll（）方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition（）方法即可。</p>
</li>
</ul>
<hr>
<p>　　总结来说，Lock和synchronized有以下几点不同：</p>
<p>　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p>
<p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p>
<p>　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p>
<p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p>
<p>　　5）Lock可以提高多个线程进行读操作的效率。</p>
<p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<p>补充锁的相关概念介绍</p>
<p>　　1.可重入锁</p>
<p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。</p>
<p>　　2.可中断锁</p>
<p>　　可中断锁：顾名思义，就是可以相应中断的锁。</p>
<p>　　在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p>
<p>　　如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p>
<p>在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</p>
<p>　　3.公平锁</p>
<p>　　公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p>
<p>　　非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p>
<p>　　在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p>
<p>　　而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p>
<hr>
<p>转载自：<br><a href="http://blog.csdn.net/zhibuguonicuo/article/details/69389771">http://blog.csdn.net/zhibuguonicuo/article/details/69389771</a><br><a href="http://blog.csdn.net/chenssy/article/details/54883355">http://blog.csdn.net/chenssy/article/details/54883355</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>ObjectMonitor对象</title>
    <url>/2024/07/02/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/ObjectMonitor%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><strong>内置锁ObjectMonitor类</strong><br>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>通常所说的对象的内置锁，是对象头Mark Word中的重量级锁指针指向的monitor对象，每个对象都存在着一个 Monitor对象与之关联。执行 monitorenter 指令就是线程试图去获取 Monitor 的所有权，抢到了就是成功获取锁了；执行 monitorexit 指令则是释放了Monitor的所有权。</p>
<p>该对象是在HotSpot底层C++语言编写的(openjdk里面看)，简单看一下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体如下</span></span><br><span class="line">ObjectMonitor::<span class="built_in">ObjectMonitor</span>() &#123;  </span><br><span class="line">  _header       = <span class="literal">NULL</span>;  </span><br><span class="line">  _count       = <span class="number">0</span>;  </span><br><span class="line">  _waiters      = <span class="number">0</span>,  </span><br><span class="line">  _recursions   = <span class="number">0</span>;       <span class="comment">//线程的重入次数</span></span><br><span class="line">  _object       = <span class="literal">NULL</span>;  </span><br><span class="line">  _owner        = <span class="literal">NULL</span>;    <span class="comment">//标识拥有该monitor的线程</span></span><br><span class="line">  _WaitSet      = <span class="literal">NULL</span>;    <span class="comment">//等待线程组成的双向循环链表，_WaitSet是第一个节点</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;  </span><br><span class="line">  _Responsible  = <span class="literal">NULL</span> ;  </span><br><span class="line">  _succ         = <span class="literal">NULL</span> ;  </span><br><span class="line">  _cxq          = <span class="literal">NULL</span> ;    <span class="comment">//多线程竞争锁进入时的单向链表</span></span><br><span class="line">  FreeNext      = <span class="literal">NULL</span> ;  </span><br><span class="line">  _EntryList    = <span class="literal">NULL</span> ;    <span class="comment">//_owner从该双向循环链表中唤醒线程结点，_EntryList是第一个节点</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;  </span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;  </span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
 <span id="more"></span>
<img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291455690.png" alt="img"  />
- _owner：指向持有ObjectMonitor对象的线程
- _WaitSet：存放处于wait状态的线程队列，即已经获取得一次锁了，对象调用了wait方法，将当前线程挂起了就进入了等待队列。等待时间到期的时候唤醒，或者其他线程唤醒。
- _EntryList：队列，用来获取锁的缓冲区，用来将cxq和waitSet中的数据 移动到entryList进行排队。这个统一获取锁的入口。一般是cxq 或者waitSet数据复制过来进行统一排队。
- _count：约为_WaitSet 和 _EntryList 的节点数之和
- _cxq：竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。`_cxq`是一个临界资源，JVM通过CAS原子指令来修改`_cxq`队列。修改前`_cxq`的旧值填入了node的next字段，`_cxq`指向新值（新线程）。因此`_cxq`是一个后进先出的stack（栈）。
- _recursions：记录重入次数
<img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291455071.png" alt="img" style="zoom: 50%;" />

<p><strong>ObjectMonitor的基本工作机制</strong><br>上图简略展示了ObjectMonitor的基本工作机制：</p>
<p>（1）所有期待获得锁的线程，在锁已经被其它线程拥有的时候，这些期待获得锁的线程就进入了对象锁的<code>entry set</code>区域。即进入 _EntryList 队列中。</p>
<p>（2）当某个线程获取到对象的Monitor后进入临界区域，并把Monitor中的 _owner 变量设置为当前线程，同时Monitor中的计数器 _count 加1。即获得对象锁。</p>
<p>（3）若持有Monitor的线程调用 wait() 方法，将释放当前持有的Monitor，_owner变量恢复为null，_count自减1，同时该线程进入 _WaitSet 集合中等待被唤醒。</p>
<p>（4）在<code>wait set</code>区域的线程获得<code>Notify/notifyAll</code>通知的时候，随机的一个<code>Thread（Notify）</code>或者是全部的<code>Thread（NotifyALL）</code>从对象锁的<code>wait set</code>区域进入了<code>entry set</code>中。</p>
<p>（5）若当前线程执行完毕也将释放Monitor并复位变量的值，以便其他线程进入获取锁。</p>
<p>线程争抢锁的过程要比上面展示得更加复杂。除了_EntryList 这个双向链表用来保存竞争的线程，ObjectMonitor中还有另外一个单向链表 _cxq，由两个队列来共同管理并发的线程。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291456825.webp" alt="img"  /></p>
<p>ObjectMonitor的并发管理逻辑</p>
<p>ObjectMonitor::enter() 和 ObjectMonitor::exit() 分别是ObjectMonitor获取锁和释放锁的方法。线程解锁后还会唤醒之前等待的线程，根据策略选择直接唤醒_cxq队列中的头部线程去竞争，或者将_cxq队列中的线程加入_EntryList，然后再唤醒_EntryList队列中的线程去竞争。</p>
<p><strong>ObjectMonitor::enter()</strong><br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291456721.webp" alt="img"  /></p>
<p>ObjectMonitor::enter()竞争锁的流程</p>
<p>下面我们看一下ObjectMonitor::enter()方法竞争锁的流程<strong>：</strong></p>
<p>首先尝试通过 CAS 把 ObjectMonitor 中的 _owner 设置为当前线程，<strong>设置成功就表示获取锁成功</strong>。通过 _recursions 的自增来表示重入。</p>
<p>如果没有CAS成功，那么就开始启动自适应自旋，自旋还不行的话，就包装成 ObjectWaiter 对象加入到 _cxq 单向链表之中。关于自旋锁和自适应自旋，可以参考前文《<a href="https://link.zhihu.com/?target=https://www.toutiao.com/i6934327407897854475/?group_id=6934327407897854475">Java面试必考问题：什么是自旋锁</a> 》。</p>
<p>加入_cxq链表后，再次尝试是否可以CAS拿到锁，再次失败就要阻塞(block)，底层调用了pthread_mutex_lock。</p>
<p><strong>ObjectMonitor::exit()方法</strong></p>
<p>线程执行 Object.wait()方法时，会将当前线程加入到 _waitSet 这个双向链表中，然后再运行ObjectMonitor::exit() 方法来释放锁。</p>
<p>可重入锁就是根据 _recursions 来判断的，重入一次就执行 _recursions++，解锁一次就执行 _recursions–，如果 _recursions 减到 0 ，就说明需要释放锁了。</p>
<p>线程解锁后还会唤醒之前等待的线程。当线程执行 Object.notify()方法时，从 _waitSet 头部拿线程节点，然后根据策略（QMode指定）决定将线程节点放在哪里，包括_cxq 或 _EntryList 的头部或者尾部，然后唤醒队列中的线程。</p>
<p>线程执行同步方法或代码块结束之后，会调用exit方法将当前线程从锁对象中移除，并尝试唤醒启动的线程来获取锁的过程。核心要点有两个，一个是将当前线程释放，这个很好理解就把_owner字段中线程值设为空就好了。另一个是唤醒其他线程，这个就涉及到相关的策略，因为前面他有一个排队队列_cxq，还有一个_EntryList，到底从哪里优先去取。提供了四种策略：</p>
<ul>
<li>QMode&#x3D;2 的时候，优先从<code>_cxq</code>唤醒；</li>
<li>QMode&#x3D;3 的时候，<code>_cxq</code>中的数据加入到<code>_EntryList</code>尾部中来 然后从<code>_EntryList</code>开始获取；</li>
<li>QMode&#x3D;4的时候，<code>_cxq</code>中的数据加入到<code>_EntryList</code>前面来 然后从<code>_EntryList</code>开始获取；</li>
<li>QMode&#x3D;1 的时候，这个是默认策略 优先从<code>_EntryList </code>中获取，如果<code>_EntryList</code>为空的情况，把<code>_cxq</code>进行队列反转然后从<code>_cxq</code>获取。整个策略本质上是考虑公平性与吞吐效率的考量。</li>
</ul>
<hr>
<p>转载自：<br><a href="https://zhuanlan.zhihu.com/p/356010805">https://zhuanlan.zhihu.com/p/356010805</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>volatile类型变量操作</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/volatile%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>volatile类型的实例变量的修改，JDK提供了J.U.C下的atomic包下类来支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、AtomicInteger/AtomicLong/AtomicBoolean/AtomicReference是关于对变量的原子更新，</span><br><span class="line"><span class="number">2</span>、AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray是关于对数组的原子更新</span><br><span class="line"><span class="number">3</span>、AtomicIntegerFieldUpdater&lt;T&gt;/AtomicLongFieldUpdater&lt;T&gt;/AtomicReferenceFieldUpdater&lt;T,V&gt;是基于反射的原子更新字段的值。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>  这里也有一些约束，只能是非final的实例变量，并且被volatile修饰。</p>
<p>  简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String[] name = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicIntegerFieldUpdater</span> <span class="variable">indexUpdater</span> <span class="operator">=</span></span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(Mock.class, <span class="string">&quot;index&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;Mock, String[]&gt; nameUpdater =</span><br><span class="line">            AtomicReferenceFieldUpdater.newUpdater(Mock.class, String[].class, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAndIncrementIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexUpdater.getAndIncrement(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getName() &#123;</span><br><span class="line">        nameUpdater.set(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;zero&quot;</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> nameUpdater.get(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  AtomicXxxFieldUpdater本质上通过sun.misc.Unsafe来完成操作，在java.util.concurrent.locks包中可以发现很多Unsafe的使用痕迹，例如AbstractQueuedSynchronizer。</p>
<p>Unsafe提供了static方法来获取Unsafe的类变量theUnsafe，即一个Unsafe对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  但是，可以发现，只有调用类的ClassLoader是Bootstrp ClassLoader能返回这个theUnsafe，否则会抛出SecurityException异常。因为这个类如其名，unsafe，该类设计初衷也不想被应用程序使用，只能被rt.jar中的类使用。但是实际上是可以通过反射机制拿到这个值的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Unsafe unsafe;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sun.misc.Unsafe.theUnsafe: unavailable, &#123;&#125;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            unsafe = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UNSAFE = unsafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">UnsafeFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cann&#x27;t Access UnsafeFactory Constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  然后就可以用Unsafe来完成对volatile变量的修改:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> UnsafeFactory.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> indexOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            indexOffset = unsafe.objectFieldOffset(Mock.class.getDeclaredField(<span class="string">&quot;index&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAndAddIndex</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, indexOffset, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>双重检查锁定及单例模式</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E5%8F%8A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例创建"><a href="#单例创建" class="headerlink" title="单例创建"></a>单例创建</h2><p>要理解双重检查锁定是从哪里起源的，就必须理解通用单例创建，如清单 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="keyword">private</span> Vector v;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> inUse;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    v = <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    v.addElement(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    inUse = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) <span class="comment">//1</span></span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> instance; <span class="comment">//3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span> 

<p>此类的设计确保只创建一个 Singleton 对象。构造函数被声明为 private，getInstance()方法只创建一个对象。这个实现适合于单线程程序。然而，当引入多线程时，就必须通过同步来保护getInstance()方法。如果不保护getInstance() 方法，则可能返回 Singleton对象的两个不同的实例。假设两个线程并发调用 getInstance()方法并且按以下顺序执行调用：</p>
<ol>
<li>线程1调用getInstance()方法并判断出instance在&#x2F;&#x2F;1处为 null。</li>
<li>线程1进入if代码块，但在执行&#x2F;&#x2F;2处的代码行时被线程2预占。 </li>
<li>线程2调用getInstance()方法并在&#x2F;&#x2F;1处判断出instance为 null。</li>
<li>线程2进入if代码块并创建一个新的Singleton对象并在&#x2F;&#x2F;2处将变量instance分配给这个新对象。</li>
<li>线程2 在&#x2F;&#x2F;3处返回Singleton对象引用。</li>
<li>线程2被线程1预占。 </li>
<li>线程1在它停止的地方启动，并执行&#x2F;&#x2F;2代码行，这导致创建另一个Singleton对象。 </li>
<li>线程1在&#x2F;&#x2F;3处返回这个对象。</li>
</ol>
<p>结果是getInstance()方法创建了两个Singleton对象，而它本该只创建一个对象。通过同步getInstance()方法从而在同一时间只允许一个线程执行代码，这个问题得以改正，如清单2 所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="literal">null</span>) <span class="comment">//1</span></span><br><span class="line">    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">//2</span></span><br><span class="line">  <span class="keyword">return</span> instance; <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清单2中的代码针对多线程访问getInstance()方法运行得很好。然而，其实只有在第一次调用方法时才需要同步。由于只有第一次调用执行了&#x2F;&#x2F;2处的代码，而只有此行代码需要同步，因此就无需对后续调用使用同步。所有其它调用用于判断instance是否为null，并将其返回。多线程能够安全并发地执行除第一次调用外的所有调用。尽管如此，由于该方法是synchronized的，需要为该方法的每一次调用付出同步的代价，即使只有第一次调用需要同步。</p>
<p>为使此方法更为有效，一个被称为双重检查锁定的习语就应运而生了。这个想法是为了避免对除第一次调用外的所有调用都实行同步的昂贵代价。同步的代价在不同的 JVM 间是不同的。在早期，代价相当高。随着更高级的JVM的出现，同步的代价降低了，但出入synchronized方法或块仍然有性能损失。</p>
<p>因为只有清单2中的&#x2F;&#x2F;2行需要同步，可以只将其包装到一个同步块中，如清单3所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清单3中的代码展示了用多线程加以说明的和清单1相同的问题。当<code>instance</code>为<code>null</code>时，两个线程可以并发地进入<code>if</code>语句内部。然后，一个线程进入<code>synchronized</code>块来初始化<code>instance</code>，而另一个线程则被阻断。当第一个线程退出<code>synchronized</code>块时，等待着的线程进入并创建另一个<code>Singleton</code>对象。注意：当第二个线程进入<code>synchronized</code>块时，它并没有检查<code>instance</code>是否为<code>null</code>。</p>
<h2 id="双重检查锁定"><a href="#双重检查锁定" class="headerlink" title="双重检查锁定"></a>双重检查锁定</h2><p>为处理清单3中的问题，需要对<code>instance</code>进行第二次检查。这就是“双重检查锁定”名称的由来。将双重检查锁定习语应用到清单3的结果就是清单4。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;  <span class="comment">//1</span></span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">null</span>)          <span class="comment">//2</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重检查锁定背后的理论是：在&#x2F;&#x2F;2处的第二次检查使（如清单3中那样）创建两个不同的Singleton对象成为不可能。假设有下列事件序列：</p>
<ol>
<li>线程1进入getInstance()方法。 </li>
<li>由于instance为null，线程1在&#x2F;&#x2F;1处进入synchronized块。 </li>
<li>线程1被线程2预占。</li>
<li>线程2进入getInstance()方法。</li>
<li>由于instance仍旧为null，线程2试图获取&#x2F;&#x2F;1处的锁。然而，由于线程1持有该锁，线程2在&#x2F;&#x2F;1处阻塞。</li>
<li>线程2被线程1预占。</li>
<li>线程1执行，由于在&#x2F;&#x2F;2处实例仍旧为null，线程1还创建一个 Singleton对象并将其引用赋值给instance。</li>
<li>线程1退出synchronized块并从getInstance()方法返回实例。     </li>
<li>线程1被线程2预占。</li>
<li>线程2获取&#x2F;&#x2F;1处的锁并检查instance是否为null。 </li>
<li>由于instance是非null的，并没有创建第二个Singleton 对象，由线程1创建的对象被返回。</li>
</ol>
<p>双重检查锁定背后的理论是完美的。但仍存在问题，双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。</p>
<p>上述清单 4 中的&#x2F;&#x2F;3 行。此行代码创建了一个Singleton对象并初始化变量instance 来引用此对象。这行代码的问题是：在 Singleton构造函数体执行之前，变量instance可能成为非null的。instance &#x3D; new Singleton(); 这一行代码可以分解为如下的三行伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();   <span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory);  <span class="comment">//2：初始化对象</span></span><br><span class="line">instance = memory;     <span class="comment">//3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure>

<p>上面三行伪代码中的2和3之间，可能会被重排序（在一些JIT编译器上，这种重排序是真实发生的）。2和3之间重排序之后的执行时序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();   <span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">instance = memory;     <span class="comment">//3：设置instance指向刚分配的内存地址</span></span><br><span class="line">                       <span class="comment">//注意，此时对象还没有被初始化！</span></span><br><span class="line">ctorInstance(memory);  <span class="comment">//2：初始化对象 </span></span><br></pre></td></tr></table></figure>

<p>回到之前的DoubleCheckedLocking示例代码的第7行（instance &#x3D; new Singleton();）如果发生重排序，另一个并发执行的线程B就有可能判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化！</p>
<p>在知晓了问题发生的根源之后，我们可以想出两个办法来实现线程安全的延迟初始化：1. 不允许2和3重排序；2.允许2和3重排序，但不允许其他线程“看到”这个重排序。</p>
<p>考虑到当前的双重检查锁定不起作用，加入了另一个版本的代码，如清单 7 所示，从而防止刚才看到的无序写入问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">//1</span></span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">inst</span> <span class="operator">=</span> instance; <span class="comment">//2</span></span><br><span class="line">      <span class="keyword">if</span> (inst == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">//3</span></span><br><span class="line">          inst = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">        instance = inst; <span class="comment">//5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看着清单7中的代码，此代码试图避免无序写入问题。它试图通过引入局部变量inst和第二个synchronized 块来解决这一问题。由于当前内存模型的定义，清单7中的代码无效。Java语言规范（Java Language Specification，JLS）要求不能将synchronized块中的代码移出来。但是，并没有说不能将 synchronized 块外面的代码移<em>入</em> synchronized 块中。</p>
<p>JIT 编译器会在这里看到一个优化的机会。此优化会删除&#x2F;&#x2F;4和&#x2F;&#x2F;5处的代码，组合并且生成清单8中所示的代码。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">//1</span></span><br><span class="line">      <span class="type">Singleton</span> <span class="variable">inst</span> <span class="operator">=</span> instance; <span class="comment">//2</span></span><br><span class="line">      <span class="keyword">if</span> (inst == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">//3</span></span><br><span class="line">        <span class="comment">//inst = new Singleton(); //4</span></span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//instance = inst; //5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果进行此项优化，将同样遇到我们之前讨论过的无序写入问题。</p>
<p><strong>基于volatile的双重检查锁定的解决方案</strong></p>
<p>对于前面的基于双重检查锁定来实现延迟初始化的方案（指DoubleCheckedLocking示例代码），只需要做一点小的修改（把instance声明为volatile型），就可以实现线程安全的延迟初始化。请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckedLocking</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Instance</span>();<span class="comment">//instance为volatile，现在没问题了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>基于类初始化的解决方案</strong></p>
<p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。</p>
<p>基于这个特性，可以实现另一种线程安全的延迟初始化方案（这个方案被称之为Initialization On Demand Holder idiom）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InstanceHolder</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance ;  <span class="comment">//这里将导致InstanceHolder类被初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">monitorenter</span></span><br><span class="line"><span class="comment">getstatic #2 &lt;Singleton.instance&gt;</span></span><br><span class="line"><span class="comment">ifnonull </span></span><br><span class="line"><span class="comment">new #3 </span></span><br><span class="line"><span class="comment">dup</span></span><br><span class="line"><span class="comment">invokespecial #4 &lt;Singleton.&lt;init&gt;&gt;</span></span><br><span class="line"><span class="comment">putstatic #2 &lt;Singleton.instance&gt;</span></span><br><span class="line"><span class="comment">aload_0</span></span><br><span class="line"><span class="comment">monitorexist</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>更多参考：<br><a href="http://blog.csdn.net/zero__007/article/details/45644257">http://blog.csdn.net/zero__007/article/details/45644257</a><br><a href="http://blog.csdn.net/turkeyzhou/article/details/6179951">http://blog.csdn.net/turkeyzhou/article/details/6179951</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>偏向锁与轻量级锁</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/%E5%81%8F%E5%90%91%E9%94%81%E4%B8%8E%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/</url>
    <content><![CDATA[<p>[toc]<br>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<span id="more"></span>

<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p><strong>获取锁：</strong></p>
<blockquote>
<p>1.检测Mark Word是否为可偏向状态，即是否为偏向锁，锁标识位为01； </p>
<p>2.若为可偏向状态，则检查线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）； </p>
<p>3.如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行步骤（4）； </p>
<p>4.通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块； </p>
<p>5.执行同步代码块</p>
</blockquote>
<p><strong>释放锁:</strong> </p>
<p>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。</p>
<p>它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<p>下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p>
<p> <img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291604283.png"></p>
<p>关闭偏向锁：</p>
<p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟<code>-XX： BiasedLockingStartupDelay = 0</code>。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过 JVM 参数关闭偏向锁<code>-XX:-UseBiasedLocking=false</code>，那么默认会进入轻量级锁状态。</p>
<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>引入背景：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒。</p>
<p><strong>获取锁：</strong></p>
<blockquote>
<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）； </li>
<li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）； </li>
<li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
</blockquote>
<p><strong>释放锁：</strong></p>
<p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下： </p>
<blockquote>
<ol>
<li>取出在获取轻量级锁保存在Displaced Mark Word中的数据； </li>
<li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）； </li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
</blockquote>
<p>下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291604007.png"></p>
<p>因为自旋会消耗 CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</p>
<h1 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h1><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
<hr>
<p>转载自：<br><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized">http://www.infoq.com/cn/articles/java-se-16-synchronized</a><br><a href="http://blog.csdn.net/chenssy/article/details/54883355">http://blog.csdn.net/chenssy/article/details/54883355</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解StampedLock及其实现原理</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3StampedLock%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>StampedLock是java8在java.util.concurrent.locks新增的一个API。</p>
<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取。然而，如果读取很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿问题，也就是写入线程无法竞争到锁定而一直处于等待状态。</p>
<p>StampedLock（印戳锁）是对ReentrantReadWriteLock读写锁的一种改进，主要的改进为：在没有写只有读的场景下，StampedLock支持不用加读锁而是直接进行读操作，最大程度提升读的效率，只有在发生过写操作之后，再加读锁才能进行读操作</p>
<p>StampedLock有三种模式的锁，用于控制读取&#x2F;写入访问。StampedLock的状态由版本和模式组成。锁获取操作返回一个用于展示和访问锁状态的票据（stamp）变量，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。锁释放以及其他相关方法需要使用邮编（stamps）变量作为参数，如果他们和当前锁状态不符则失败，这三种模式为：</p>
<ul>
<li>写入：方法writeLock可能为了获取独占访问而阻塞当前线程，返回一个stamp变量，能够在unlockWrite方法中使用从而释放锁。也提供了tryWriteLock。当锁被写模式所占有，没有读或者乐观的读操作能够成功。</li>
<li>读取：方法readLock可能为了获取非独占访问而阻塞当前线程，返回一个stamp变量，能够在unlockRead方法中用于释放锁。也提供了tryReadLock。</li>
<li>乐观读取：方法tryOptimisticRead返回一个非0邮编变量，仅在当前锁没有以写入模式被持有。如果在获得stamp变量之后没有被写模式持有，方法validate将返回true。这种模式可以被看做一种弱版本的读锁，可以被一个写入者在任何时间打断。乐观读取模式仅用于短时间读取操作时经常能够降低竞争和提高吞吐量。</li>
</ul>
<p>StampedLock 的读写锁都是不可重入锁，所以在获取锁后释放锁前不应该再调用会获取锁的操作，以避免造成调用线程被阻塞</p>
<span id="more"></span>

<p>下面是java doc提供的StampedLock一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">//一个点的x，y坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x, y;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stamped类似一个时间戳的作用，每次写的时候对其+1来改变被操作对象的Stamped值</span></span><br><span class="line"><span class="comment">     * 这样其它线程读的时候发现目标对象的Stamped改变，则执行重读</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an exclusively locked method</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(doubledeltaX, doubledeltaY)</span> &#123;</span><br><span class="line">        <span class="comment">/**stampedLock调用writeLock和unlockWrite时候都会导致stampedLock的stamp值的变化</span></span><br><span class="line"><span class="comment">         * 即每次+1，直到加到最大值，然后从0重新开始 */</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock(); <span class="comment">//写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);<span class="comment">//释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;    <span class="comment">// A read-only method</span></span><br><span class="line">        <span class="comment">/**tryOptimisticRead是一个乐观的读，使用这种锁的读不阻塞写</span></span><br><span class="line"><span class="comment">         * 每次读的时候得到一个当前的stamp值（类似时间戳的作用）*/</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里就是读操作，读取x和y，因为读取x时，y可能被写了新的值，所以下面需要判断</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x, currentY = y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**如果读取的时候发生了写，则stampedLock的stamp属性值会变化，此时需要重读，</span></span><br><span class="line"><span class="comment">         * 再重读的时候需要加读锁（并且重读时使用的应当是悲观的读锁，即阻塞写的读锁）</span></span><br><span class="line"><span class="comment">         * 当然重读的时候还可以使用tryOptimisticRead，此时需要结合循环了，即类似CAS方式</span></span><br><span class="line"><span class="comment">         * 读锁又重新返回一个stampe值*/</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123;</span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">//读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp);<span class="comment">//释放读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读锁验证成功后才执行计算，即读的时候没有发生写</span></span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<p> StampedLock源码分析</p>
<p>StampedLock也是通过一个int变量state、一个队列来实现的<br><strong>state</strong><br>state的默认值是256 1 0000 0000<br>state是一个int变量，总共有32位<br>前24位表示版本号、低8位表示锁。<br>低8位的第1位表示是否为写锁，1表示写锁、0表示没有写锁<br>剩下7位表示悲观读锁的个数</p>
<p> StampedLock引入乐观读，读时不加读锁，写锁也可进行写，避免写线程被饿死，读数据时读出来发现数据被修改了，再升级为悲观读，再读一次  </p>
<p>  StampedLock是一个读写锁，因此也会像读写锁那样，把一个state变量分成两半，分别表示读锁和写锁的状态，同时，还需要一个数据的version，但是，一次CAS没有办法操作两个变量，所以这个state变量本身同时也表示了数据的version。下面先分析state变量 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLock</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RUNIT</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span> <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS; <span class="comment">// 第8位表示写锁</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RBITS</span> <span class="operator">=</span> WBIT - <span class="number">1L</span>; <span class="comment">// 最低的7位表示读锁</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RFULL</span> <span class="operator">=</span> RBITS - <span class="number">1L</span>; <span class="comment">// 读锁的数目</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ABITS</span> <span class="operator">=</span> RBITS | WBIT; <span class="comment">// 读锁和写锁状态合二为一</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SBITS</span> <span class="operator">=</span> ~RBITS;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>; <span class="comment">// state的初始值</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>用最低的8位表示读和写的状态，其中第8位表示写锁的状态，最低的7位表示读锁的状态。因为写锁只有一个bit位，所以写锁是不可重入的</p>
<p>初始值不为0，而是把WBIT 向左移动了一位，也就是上面的ORIGIN 常量，构造方法如下所示</p>
<p>为什么state的初始值不设为0呢？看乐观锁的实现：</p>
<p>上面两个方法必须结合起来看：当state&amp;WBIT !&#x3D; 0的时候，说明有线程持有写锁，上面的tryOptimisticRead会永远返回0。这样，再调用validate（stamp），也就是validate（0）也会永远返回false。这正是我们想要的逻辑：当有线程持有写锁的时候，validate永远返回false，无论写线程是否释放了写锁。因为无论是否释放了（state回到初始值）写锁，state值都不为0，所以validate（0）永远为false<br>为什么上面的validate(…)方法不直接比较stamp&#x3D;state，而要比较state&amp;SBITS&#x3D;state&amp;SBITS 呢？<br>因为读锁和读锁是不互斥的！<br>所以，即使在“乐观读”的时候，state 值被修改了，但如果它改的是第7位，validate(…)还是会返回true。<br>另外要说明的一点是，上面使用了内存屏障VarHandle.acquireFence();，是因为在这行代码的下一行里面的stamp、SBITS变量不是volatile的，由此可以禁止其和前面的currentX&#x3D;X，currentY&#x3D;Y进行重排序<br>通过上面的分析，可以发现state的设计非常巧妙。只通过一个变量，既实现了读锁、写锁的状态记录，还实现了数据的版本号的记录</p>
<hr>
<p>转载自：<br><a href="https://www.cnblogs.com/zmhjay1999/p/15183390.html">https://www.cnblogs.com/zmhjay1999/p/15183390.html</a><br><a href="http://www.importnew.com/14941.html">http://www.importnew.com/14941.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>深入解析 volatile 、CAS 的实现原理</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20volatile%20%E3%80%81CAS%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h1><h2 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h2><p>&emsp;&emsp;现代处理器为了提高访问数据的效率，在每个CPU核心上都会有多级 容量小、速度快 的缓存（分别称之为L1 cache，L2 cache，多核心共享L3 cache等），用于缓存数据。<br>&emsp;&emsp;缓存系统中是以缓存行(cache line)为单位存储的。缓存行是 2 的整数幂个连续字节，一般为 32-256 个字节。最常见的缓存行大小是 64个字节。<br>&emsp;&emsp;因此当CPU在执行一条读内存指令时，它是会将内存地址所在的内容加载进缓存中的，加载的大小取决于是缓存行大小的。也就是说，一次加载一整个缓存行。</p>
<p>&emsp;</p>
<h2 id="2-缓存一致性协议"><a href="#2-缓存一致性协议" class="headerlink" title="2. 缓存一致性协议"></a>2. 缓存一致性协议</h2><p>&emsp;&emsp;在多核处理器系统中，每个处理器核心都有它们自己的一级缓存、二级缓存等。这样一来当多个处理器核心在对共享的数据进行写操作时，就需要保证该共享数据在所有处理器核心中的可见性&#x2F;一致性。<br>&emsp;&emsp;【窥探技术 + MESI协议 】的出现，就是为了解决多核处理器时代，缓存不一致的问题的。</p>
<h3 id="2-1-窥探技术-总线窥探-总线嗅探"><a href="#2-1-窥探技术-总线窥探-总线嗅探" class="headerlink" title="2.1 窥探技术(总线窥探&#x2F;总线嗅探)"></a>2.1 窥探技术(总线窥探&#x2F;总线嗅探)</h3><p>&emsp;&emsp;“窥探”背后的基本思想是，所有内存传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线：缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁：同一个指令周期中，只有一个缓存可以读写内存。<br>&emsp;&emsp;窥探技术的思想是，缓存不仅仅在做内存传输的时候才和总线打交道，而是不停地在窥探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去读写内存时，其他处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其他处理器马上就知道这块内存在它们自己的缓存中对应的缓存行已经失效。</p>
<span id="more"></span>

<h3 id="2-2-MESI协议"><a href="#2-2-MESI协议" class="headerlink" title="2.2 MESI协议"></a>2.2 MESI协议</h3><p>&emsp;&emsp;缓存系统 操作的最小单位就是缓存行，而MESI是缓存行四种状态的首字母缩写，任何多核系统中的缓存行都处于这四种状态之一。<br>&emsp;&emsp;① 失效（Invalid）缓存行：该处理器缓存中无该缓存行，或缓存中的缓存行已经失效了。<br>&emsp;&emsp;② 共享（Shared）缓存行：缓存行的内容是同主内存内容保持一致的一份拷贝，在这种状态下的缓存行只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存行。<br>&emsp;&emsp;③ 独占（Exclusive）缓存行：和S状态一样，也是和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了E状态的缓存行，那其他处理器就不能同时持该内容的缓存行，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存行，那么它会马上变成“失效”状态（I状态）。<br>&emsp;&emsp;④ 已修改（Modified）缓存行：该缓存行已经被所属的处理器修改了。如果一个缓存行处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存行如果被丢弃或标记为失效（即从M状态 ——&gt; I状态），那么先要把它的内容回写到内存中。</p>
<p>&emsp;&emsp;只有当缓存行处于E或M状态时，处理器才能去写它，也就是说只有这两种状态下，处理器是独占这个缓存行的。当处理器想写某个缓存段时，如果它没有独占权，它必须先发送一条“我要独占权”的请求给总线，这会通知其他处理器，把它们拥有的同一缓存行的拷贝失效（I状态），如果它们有的话。只有在获得独占权后，处理器才能开始修改数据。并且此时，这个处理器知道，这个缓存行只有一份拷贝，在我自己的缓存里，所以不会有任何冲突。反之，如果有其他处理器想读取这个缓存行（能知道，因为一直在窥探总线），独占或已修改的缓存行必须先回到“共享”状态。如果是已修改的缓存段，那么还要先把内容回写到内存中。</p>
<p>&emsp;&emsp;</p>
<h1 id="二、volatile的内存语义"><a href="#二、volatile的内存语义" class="headerlink" title="二、volatile的内存语义"></a>二、volatile的内存语义</h1><p>&emsp;&emsp;volatile变量自身具有下列特性：<br>&emsp;&emsp;① 可见性：当一个变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>&emsp;&emsp;② 禁止指令重排序：通过增加内存屏障的方式禁止指令重排。happens-before规则中有这么一条，volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</p>
<p>&emsp;&emsp;happens-before的这个规则会保证volatile写-读具有如下的内存语义：</p>
<blockquote>
<p>volatile写的内存语义：当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。<br>volatile读的内存语义：当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>
</blockquote>
<p>&emsp;&emsp;volatile内存语义的实现原理：为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入 <strong>内存屏障</strong> 来禁止特定类型的处理器重排序。因为内存屏障是一组处理器指令，它并不由JVM直接暴露，因此JVM会根据不同的操作系统插入不同的指令以达成所要内存屏障效果。<br>&emsp;&emsp;为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p>
<blockquote>
<p>在每个volatile写操作的前面插入一个StoreStore屏障<br>在每个volatile写操作的后面插入一个StoreLoad屏障<br>在每个volatile读操作的后面插入一个LoadLoad屏障<br>在每个volatile读操作的后面插入一个LoadStore屏障</p>
</blockquote>
<p>&emsp;&emsp;内存屏障是一组处理器指令，而上面的四种内存屏障（StoreStore、StoreLoad、LoadLoad、LoadStore）是JMM内存屏障的分类，<strong>volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现</strong>，但在不同的处理器中，会转换成相应处理器对应的该内存屏障类型的指令。在X86处理器上执行volatile写操作时会插入一个带有lock前缀的指令（汇编指令）来实现volatile的内存语义的。如<code>0x01a3de24: lock addl $0x0,(%esp);</code><br>&emsp;&emsp;至于lock前缀是如何保证volatile的内存语义，lock 前缀的指令在多核处理器下会引发两件事情:</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li>
</ul>
<hr>
<p>&emsp;&emsp;</p>
<h1 id="三、CAS-CompareAndSet"><a href="#三、CAS-CompareAndSet" class="headerlink" title="三、CAS(CompareAndSet)"></a>三、CAS(CompareAndSet)</h1><p>&emsp;&emsp;以原子的方式更新这个更新器所管理的对象(obj)的成员变量，如果当前值等于期望值(expect)时，将这个成员变量更新为给定的值(update)。该操作具有volatile 读和写的内存语义。<br>&emsp;&emsp;前面已经介绍了原子操作的概念，所以这里CAS涉及的两步：只有field的值为expect时；将field的值修改为update的值；这视为一个原子操作。</p>
<h2 id="1-处理器如何实现原子操作"><a href="#1-处理器如何实现原子操作" class="headerlink" title="1. 处理器如何实现原子操作"></a>1. 处理器如何实现原子操作</h2><p>&emsp;&emsp;首先处理器会自动保证基本的内存操作的原子性。同时，处理器提供 <strong>总线锁定</strong> 和 <strong>缓存锁定</strong> 两个机制来保证复杂内存操作的原子性。<br>&emsp;&emsp;① 使用 总线锁 保证原子性<br>&emsp;&emsp;所谓总线锁就是使用处理器提供的一个<code>LOCK＃</code>信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。<br>&emsp;&emsp;② 使用 缓存锁 保证原子性<br>&emsp;&emsp;在同一时刻只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p>
<p>&emsp;&emsp;所谓“缓存锁定”就是 如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效。<br>&emsp;&emsp;在JDK 8，Linux操作系统，X86处理器环境下，CAS的源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_IF_MP(mp) <span class="string">&quot;cmp $0, &quot;</span> #mp <span class="string">&quot;; je 1f; lock; 1: &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> jint     <span class="title function_">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mp = os::is_MP();</span><br><span class="line">  __asm__ <span class="title function_">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgq %1,(%3)&quot;</span></span></span><br><span class="line"><span class="params">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span><br><span class="line"><span class="params">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span><br><span class="line"><span class="params">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。CAS在底层是使用cmpxchg指令完成的，还是compareAndSet的过程。<br>&emsp;&emsp;<br>&emsp;&emsp;应用层面其实体现的很明显, volatile是通过线程屏障, 也就是编译器插入指令,然后在真正运行时会自动转成lock前缀的指令, 而cas则在java中是native方法,那么必然有其对应的c++代码,这样很明显volatile的性能要好点.</p>
<p>&emsp;&emsp;cas调用了汇编指令cmpxchg，lock_if_mp在CPU指令上也会加锁，但是这个锁和java的锁不太一样，不用切换到内核态所以更轻量级。</p>
<h2 id="2-lock前缀"><a href="#2-lock前缀" class="headerlink" title="2. lock前缀"></a>2. lock前缀</h2><p>&emsp;&emsp;lock前缀的指令的说明：<br>&emsp;&emsp;① 保证指令的执行的原子性<br>&emsp;&emsp;带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或已修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读&#x2F;写该指令要访问的内存区域，因此能保证指令执行的原子性。(将当前处理器对应缓存的内容刷新到内存，并使其它处理器对应的缓存失效)。</p>
<p>&emsp;&emsp;② 禁止该指令与之前和之后的读和写指令重排序<br>&emsp;&emsp;LOCK前缀会禁止指令与之前和之后的读和写指令重排序。这相当于JMM中定义的StoreLoad内存屏障的效果。也正是因为这个内存屏障的效果，会使得线程把其写缓冲区中的所有数据刷新到内存中。注意，这里不是单单被修改的数据会被回写到主内存，而是写缓存中所有的数据都回写到主内存。<br>&emsp;&emsp;而将写缓冲区的数据回写到内存时，就会通过缓存一致性协议（如，MESI协议）和窥探技术来保证写入的数据被其他处理器的缓存可见。<br>&emsp;&emsp;而这就相当于实现了volatile的内存语义。<br>&emsp;&emsp;所以，CAS的指令的原子性，以及内存语义就是通过lock前缀指令来完成的。</p>
<h1 id="四、synchronized与volatile"><a href="#四、synchronized与volatile" class="headerlink" title="四、synchronized与volatile"></a>四、synchronized与volatile</h1><p>&emsp;&emsp;synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：<br>&emsp;&emsp;1）对变量的写操作不依赖于当前值<br>&emsp;&emsp;2）该变量没有包含在具有其他变量的不变式中</p>
<p>&emsp;&emsp;实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>&emsp;&emsp;下面列举几个Java中使用volatile的几个场景。<br>&emsp;&emsp;1. 状态标记量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">     doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">()</span> &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">inited</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="literal">true</span>;            </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">    sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2.double check</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                 <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">                     instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;volatile让变量每次在使用的时候，都从主存中取。而不是从各个线程的“工作内存”。volatile具有synchronized关键字的“可见性”，但是没有synchronized关键字的“并发正确性”，也就是说不保证线程执行的有序性。也就是说，volatile变量对于每次使用，线程都能得到当前volatile变量的最新值。但是volatile变量并不保证并发的正确性。</p>
<hr>
<p>转载自：<br><a href="https://www.jianshu.com/p/bd68ddf91240">https://www.jianshu.com/p/bd68ddf91240</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2024/03/11/Java/Java%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%E6%B1%A0/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-为什么需要使用线程池"><a href="#1-为什么需要使用线程池" class="headerlink" title="1.为什么需要使用线程池"></a>1.为什么需要使用线程池</h2><p>&emsp;&emsp;合理利用线程池能够带来三个好处。<br>&emsp;&emsp;第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>&emsp;&emsp;第二：提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即行。<br>&emsp;&emsp;第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<span id="more"></span>
<h2 id="2-线程池的创建"><a href="#2-线程池的创建" class="headerlink" title="2.线程池的创建"></a>2.线程池的创建</h2><p>&emsp;&emsp;可以通过 ThreadPoolExecutor 来创建一个线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>corePoolSize</strong>表示线程池的基本大小：当提交一个任务到线程池时，如果线程池中的线程数小于corePoolSize，就会创建一个新线程来执行任务， 即使有空闲的线程，直到线程池中的线程数量等到corePoolSize。如果调用了线程池的 prestartAllCoreThreads 方法，线程池会提前创建并启动所有基本线程。<br>&emsp;&emsp;<strong>maximumPoolSize</strong>是线程池最大大小，线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。<br>&emsp;&emsp;<strong>keepAliveTime</strong>：线程池中的空闲线程所能持续的最长时间。<br>&emsp;&emsp;<strong>workQueue</strong>任务队列，用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列:</p>
<blockquote>
<ol>
<li>ArrayBlockingQueue： 是一个基于数组结构的有界阻塞队列， 此队列按 FIFO（先进先出）原则对元素进行排序。</li>
<li>LinkedBlockingQueue： 一个基于链表结构的阻塞队列， 此队列按 FIFO （先进先出） 排序元素， 吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue： 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态， 吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。</li>
<li>PriorityBlockingQueue： 一个具有优先级得无限阻塞队列。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;<strong>threadFactory</strong>：线程工厂，主要用来创建线程；<br>&emsp;&emsp;<strong>handler</strong>：表示当拒绝处理任务时的策略，（也就是中断策略，由于线程池中的线程容器已经放不的任务了，饱和了，必须要有一个相应的策略来处理）有以下四种取值：</p>
<blockquote>
<p>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常，（中止）它是默认的策略。<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常，（遗弃）策略，它默认会放弃这个任务。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）（遗弃最旧的）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务，(调用者运行), 它既不会丢弃任务，也不会抛出任何异常，它会把任务推回到调用者那里去,以此缓解任务流</p>
</blockquote>
<p>&emsp;&emsp;</p>
<h2 id="3-向线程池提交任务"><a href="#3-向线程池提交任务" class="headerlink" title="3.向线程池提交任务"></a>3.向线程池提交任务</h2><p>&emsp;&emsp;可以使用 execute 提交的任务，但是 execute 方法没有返回值，所以无法判断任务知否被线程池执行成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">threadPoolExecutor.execute(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;也可以使用 submit 方法来提交任务，它会返回一个 future, 通过这个 future 来判断任务是否执行成功，通过 future 的 get 方法来获取返回值， get 方法会阻塞住直到任务完成，而使用<code>get(long timeout, TimeUnit unit)</code>方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line">try &#123;</span><br><span class="line">    Object s = future.get();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    // 处理中断异常</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line">    // 处理无法执行任务异常</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 关闭线程池</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h2 id="4-线程池的关闭"><a href="#4-线程池的关闭" class="headerlink" title="4.线程池的关闭"></a>4.线程池的关闭</h2><p>&emsp;&emsp;通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。 但是它们存在一定的的区别， shutdownNow 首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而 shutdown 只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。<br>&emsp;&emsp;只要调用了这两个关闭方法的其中一个， isShutdown 方法就会返回 true。当所有的任务都已关闭后, 才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。</p>
<p>&emsp;&emsp;</p>
<h2 id="5-线程池的分析"><a href="#5-线程池的分析" class="headerlink" title="5.线程池的分析"></a>5.线程池的分析</h2><p>&emsp;&emsp;线程池的主要工作流程如图：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291447686.png"><br>&emsp;&emsp;从上图可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：<br>&emsp;&emsp;1) 首先线程池判断基本线程池是否已满？没满， 创建一个工作线程来执行任务。 满了，则进入下个流程。<br>&emsp;&emsp;2) 其次线程池判断工作队列 是否已满？没满，则将新提交的任务存储在工作队列里。 满了，则进入下个流程。<br>&emsp;&emsp;3) 最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        /*</span><br><span class="line">         * Proceed in 3 steps:</span><br><span class="line">         *</span><br><span class="line">         * 1. If fewer than corePoolSize threads are running, try to start a new thread with the given command as its first task.  The call to addWorker atomically checks runState and workerCount, and so prevents false alarms that would add  threads when it shouldn&#x27;t, by returning false.</span><br><span class="line">         * 2. If a task can be successfully queued, then we still need to double-check whether we should have added a thread (because existing ones died since last checking) or that the pool shut down since entry into this method. So we  recheck state and if necessary roll back the enqueuing if  stopped, or start a new thread if there are none.</span><br><span class="line">         * 3. If we cannot queue task, then we try to add a new  thread.  If it fails, we know we are shut down or saturated and so reject the task.</span><br><span class="line">         */</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            else if (workerCountOf(recheck) == 0)</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;</p>
<h2 id="6-Executors"><a href="#6-Executors" class="headerlink" title="6.Executors"></a>6.Executors</h2><p>&emsp;&emsp;一般而言，创建线程池都是使用Executors提供的一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。<br>&emsp;&emsp;ExecutorService接口继承自Executor接口，它提供了更丰富的实现多线程的方法，比如，ExecutorService提供了关闭自己的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。可以调用ExecutorService的shutdown（）方法来关闭 ExecutorService，调用该方法后，将导致ExecutorService停止接受任何新的任务且等待已经提交的任务执行完成(已经提交的任务会分两类：一类是已经在执行的，另一类是还没有开始执行的)，当所有已经提交的任务执行完毕后将会关闭ExecutorService。因此一般用该接口来实现和管理多线程。<br>&emsp;&emsp;ExecutorService的生命周期包括三种状态：运行、关闭、终止。创建后便进入运行状态，当调用了shutdown（）方法时，便进入关闭状态，此时意味着ExecutorService不再接受新的任务，但它还在执行已经提交了的任务，当已经提交了的任务执行完后，便到达终止状态。如果不调用shutdown（）方法，ExecutorService会一直处在运行状态，不断接收新的任务，执行新的任务，服务器端一般不需要关闭它，保持一直运行即可。</p>
<p>&emsp;&emsp;Executors的工厂方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads)</span><br><span class="line">创建固定数目线程的线程池。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool()</span><br><span class="line">创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。</span><br><span class="line">如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor()</span><br><span class="line">创建一个单线程化的Executor。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</span><br><span class="line">创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这四种方法都是用的Executors中的ThreadFactory建立的线程，下面就以上四个方法做个比较<br>&emsp;&emsp;<code>newCachedThreadPool()</code>: -缓存型池子，先查看池中有没有空闲的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。<br>&emsp;&emsp;<code>newFixedThreadPool(int)</code>: -newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。fixed池线程数固定，并且是0秒IDLE（无IDLE），cache池线程数支持0-Integer.MAX_VALUE，60秒IDLE。<br>&emsp;&emsp;<code>newScheduledThreadPool(int)</code>: -调度型线程池，这个池子里的线程可以按schedule依次delay执行，或周期执行。<br>&emsp;&emsp;<code>newSingleThreadExecutor()</code>:-单例线程，任意时间池中只能有一个线程。用的是和cache池和fixed池相同的底层池，但线程数目是1,0秒IDLE（无IDLE）</p>
<p>&emsp;&emsp;</p>
<h2 id="7-线程池的监控"><a href="#7-线程池的监控" class="headerlink" title="7.线程池的监控"></a>7.线程池的监控</h2><p>&emsp;&emsp;ThreadPoolExecutor提供接口获取内部运行情况，用于监控线程池：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 线程池需要执行的任务数</span><br><span class="line">*/</span><br><span class="line">long taskCount = threadPoolExecutor.getTaskCount();</span><br><span class="line">/**</span><br><span class="line">* 线程池在运行过程中已完成的任务数</span><br><span class="line">*/</span><br><span class="line">long completedTaskCount = threadPoolExecutor.getCompletedTaskCount();</span><br><span class="line">/**</span><br><span class="line">* 曾经创建过的最大线程数</span><br><span class="line">*/</span><br><span class="line">long largestPoolSize = threadPoolExecutor.getLargestPoolSize();</span><br><span class="line">/**</span><br><span class="line">* 线程池里的线程数量</span><br><span class="line">*/</span><br><span class="line">long poolSize = threadPoolExecutor.getPoolSize();</span><br><span class="line">/**</span><br><span class="line">* 线程池里活跃的线程数量</span><br><span class="line">*/</span><br><span class="line">long activeCount = threadPoolExecutor.getActiveCount();</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意 getLargestPoolSize 返回在这个线程池里曾经同时存在过的最大线程数。largestPoolSize是历史最大值，只增不减。</p>
<h2 id="8-如何设置线程数"><a href="#8-如何设置线程数" class="headerlink" title="8.如何设置线程数"></a>8.如何设置线程数</h2><p>1、CPU密集型：一般线程数设置为：CPU核数 + 1。<br>2、IO密集型：（（线程等待时间+线程CPU时间）&#x2F;线程CPU时间 ）* CPU数目，比如CPU核数为4核，一个任务线程cpu耗时为20ms，IO耗时80ms，那最佳线程数目：( 80 + 20 )&#x2F;20 * 4 &#x3D; 20。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>线程&amp;线程池</category>
      </categories>
  </entry>
  <entry>
    <title>由CopyOnWriteArrayList类的set方法引发对volatile深入理解</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/%E7%94%B1CopyOnWriteArrayList%E7%B1%BB%E7%9A%84set%E6%96%B9%E6%B3%95%E5%BC%95%E5%8F%91%E5%AF%B9volatile%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>在CopyOnWriteArrayList类的set方法中有一段setArray(elements)代码（else块），实际上这段代码并未对elements做任何改动，注意这里的，实现的volatile语意并不对CopyOnWriteArrayList实例产生任何影响，为什么还是要保留这行语句？</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);  <span class="comment">// -----这里？？？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里首先理解下volatile，我们知道volatile变量自身具有下列特性：</p>
<p>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</p>
<p>原子性：对任意单个volatile变量的读&#x2F;写具有原子性，但类似于volatile++这种复合操作不具有原子性。</p>
 <span id="more"></span>

<p>从JSR-133开始，volatile变量的写-读可以实现线程之间的通信。从内存语义的角度来说，volatile与锁有相同的效果。</p>
<p>下面使用volatile变量的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="literal">true</span>;               <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  a;           <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens before规则，这个过程建立的happens before关系可以分为两类：</p>
<ol>
<li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li>
<li>根据volatile规则，2 happens     before 3。</li>
<li>根据happens before 的传递性规则，1     happens before 4。</li>
</ol>
<p>volatile写-读的内存语义：</p>
<p>volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。上面示例程序VolatileExample为例，假设线程A首先执行writer()方法，随后线程B执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行volatile写后，共享变量的状态示意图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291613847.png" alt="image-20240222115228141"></p>
<p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p>
<p>volatile读的内存语义</p>
<p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>
<p>下面是线程B读同一个volatile变量后，共享变量的状态示意图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291613318.png" alt="image-20240222115425416"></p>
<p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p>
<p>如果把volatile写和volatile读这两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p>
<p>下面对volatile写和volatile读的内存语义做个总结：</p>
<p>  线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所在修改的）消息。</p>
<p>  线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。</p>
<p>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<p>那么JMM如何实现volatile写&#x2F;读的内存语义？</p>
<p>前文提到过重排序分为编译器重排序和处理器重排序，为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下面是JMM针对编译器制定的volatile重排序规则表：</p>
<table>
<thead>
<tr>
<th>是否能重排序</th>
<th>第二个操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>第一个操作</td>
<td>普通读&#x2F;写</td>
<td>volatile读</td>
<td>volatile写</td>
</tr>
<tr>
<td>普通读&#x2F;写</td>
<td></td>
<td></td>
<td>NO</td>
</tr>
<tr>
<td>volatile读</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>volatile写</td>
<td></td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<p>举例来说，在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p>
<p>从上表可以看出：</p>
<ul>
<li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
</ul>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p>
<p>内存屏障可以被分为以下几种类型：</p>
<p>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>
<p>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</p>
<p>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p>
<p>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p>
<p>JSR-133的规定，Java编译器会这样使用内存屏障。下面是JMM内存屏障插入策略：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
<li>为了保证final字段的特殊语义，也会在下面的语句加入内存屏障。x.finalField &#x3D; v; StoreStore; sharedRef &#x3D; x;</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。关于JMM主内存与工作内存交互，可以参考：<a href="http://blog.csdn.net/zero__007/article/details/53025425%E3%80%82">http://blog.csdn.net/zero__007/article/details/53025425。</a></p>
<p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图：</p>
<p> <img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291613967.png" alt="image-20240222115535644"></p>
<p>上图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。volatile写后面的StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面，是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。</p>
<p>为了保证能正确实现volatile的内存语义，JMM在这里采取了保守策略：在每个volatile写的后面或在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile 变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。</p>
<p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291613191.png" alt="image-20240222115633452"> </p>
<p>上图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p>
<p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面通过具体的示例代码来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileBarrierExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">readAndWrite</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v1;           <span class="comment">//第一个volatile读</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2;           <span class="comment">// 第二个volatile读</span></span><br><span class="line">        a = i + j;            <span class="comment">//普通写</span></span><br><span class="line">        v1 = i + <span class="number">1</span>;          <span class="comment">// 第一个volatile写</span></span><br><span class="line">        v2 = j * <span class="number">2</span>;          <span class="comment">//第二个 volatile写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …                    <span class="comment">//其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291613494.png" alt="image-20240222115706580"> </p>
<p>注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器常常会在这里插入一个StoreLoad屏障。</p>
<p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量之间重排序。在旧的内存模型中，VolatileExample示例程序可能被重排序成下列时序来执行：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291613284.png" alt="image-20240222115733557"></p>
<p>在旧的内存模型中，当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。其结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。</p>
<p>因此在旧的内存模型中 ，volatile的写-读没有锁的释放-获所具有的内存语义。为了提供一种比锁更轻量级的线程之间通信的机制，JSR-133增强 volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取一样，具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要volatile变量与普通变量之间的重排序可能会破坏volatile的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<p>那么回到之前的问题，未对elements做任何改动为什还要在else块中调用setArray(elements);是否是多余呢？</p>
<p>如下例子：a为非volatile的某基本类型变量,coal为CopyOnWriteArrayList对象，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread1:</span><br><span class="line">x:a = calValue;</span><br><span class="line">y:coal.set….</span><br><span class="line">———————</span><br><span class="line">thread2:</span><br><span class="line">m:coal.get…</span><br><span class="line">n:<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设存在以上场景，如果能保证只会存在这样的轨迹：x,y,m,n.根据约定有happen-before(y,m),根据线程内的操作相关规定有happen-before(x,y), happen-before(m,n)，根据happen-before的传递性读写a变量就有happen-before(x,n)，所以thread1对a的写操作对thread2中a的读操作可见。如果CopyOnWriteArrayList的set的else里没有setArray(elements) 的话，before(y,m)就不再有了，上述的可见性也就无法保证。</p>
<p>所以实际上else中的setArray(elements)不是为了保证CopyOnWriteArrayList本身的可见性，而是保证外部的非volatile变量的happen-before。可以参考<a href="http://stackoverflow.com/questions/28772539/why-setarray-method-call-required-in-copyonwritearraylist%E3%80%82">http://stackoverflow.com/questions/28772539/why-setarray-method-call-required-in-copyonwritearraylist。</a></p>
<hr>
<p>相关阅读：<br><a href="http://blog.csdn.net/zero__007/article/details/44080975">http://blog.csdn.net/zero__007/article/details/44080975</a><br><a href="http://ifeve.com/copyonwritearraylist-set/">http://ifeve.com/copyonwritearraylist-set/</a><br><a href="http://ifeve.com/java-memory-model-4/">http://ifeve.com/java-memory-model-4/</a><br><a href="http://tech.meituan.com/java-memory-reordering.html">http://tech.meituan.com/java-memory-reordering.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>Java线程的6种状态及切换</title>
    <url>/2024/03/11/Java/Java%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%E6%B1%A0/Java%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="一、线程六种状态"><a href="#一、线程六种状态" class="headerlink" title="一、线程六种状态"></a>一、线程六种状态</h2><p>线程的状态在java中有明确的定义，在java.lang.Thread.State中有6种。</p>
<ul>
<li>① New：线程被创建，未执行和运行的时候</li>
<li>② Runnable：不代表线程在跑，两种：被cpu执行的线程，随时可以被cpu执行的状态。</li>
<li>③ Blocked：线程阻塞，处于synchronized同步代码块或方法中被阻塞。</li>
<li>④ Waiting：等待先生的线程状态。线程当前不执行，如果被其他唤醒后会继续执行的状态。依赖另一个线程的通知的。这个等待是一直等，没人叫你，你起不来。</li>
<li>⑤ Time Waiting：指定等待时间的等待线程的线程状态。带超时的方式：Thread.sleep，Object.wait，Thread.join，LockSupport.parkNanos，LockSupport.parkUntil</li>
<li>⑥ Terminated：正常执行完毕或者出现异常终止的线程状态。</li>
</ul>
<span id="more"></span>

<h2 id="二、线程状态流程解析"><a href="#二、线程状态流程解析" class="headerlink" title="二、线程状态流程解析"></a>二、线程状态流程解析</h2><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240607202433.png" alt="Java线程的6种状态及切换，透彻讲解"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>线程&amp;线程池</category>
      </categories>
  </entry>
  <entry>
    <title>重排序</title>
    <url>/2024/03/13/Java/Java%E8%BF%9B%E9%98%B6/%E5%90%8C%E6%AD%A5&amp;%E9%94%81&amp;volatile/%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>　　在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序会遵守数据的依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。重排序分为如下三种类型。</p>
<p>　　1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
<p>　　2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
<p>　　3. 内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操 作看上去可能是在乱序执行。</p>
<p>　　而我们编写的Java源程序中的语句顺序并不对应指令中的相应顺序，如（int a &#x3D; 0; int b &#x3D; 0；翻译成机器指令后并不能保证a &#x3D; 0操作在b &#x3D; 0操作之前）。因为编译器、处理器会对指令进行重排序，通常而言，Java源程序变成最后的机器执行指令会经过如下的重排序。</p>
 <span id="more"></span> ]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>同步&amp;锁&amp;volatile</category>
      </categories>
  </entry>
  <entry>
    <title>Tomcat的StandardThreadExecutor</title>
    <url>/2024/03/11/Java/Java%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%E6%B1%A0/Tomcat%E7%9A%84StandardThreadExecutor/</url>
    <content><![CDATA[<p>JDK中的ThreadExecutor中的execute方法的处理逻辑应该都知道：</p>
<blockquote>
<p>1.小于等于Coresize：创建线程执行；<br>2.大于CoreSize：加入队列；<br>3.队列满且小于maxSize：有空闲线程使用空闲线程执行，没有的话，创建线程执行；如果大于maxSize则拒绝策略执行。</p>
</blockquote>
<p>这样会造成一个现象，如果设置的不恰当，队列使用LinkedBlockingQueue，那么线程数量是很不可能达到maximumPoolSize，因为线程数量到了corePoolSize之后，之后新的任务是添加到队列里面去了。</p>
<p>Tomcat中有一个StandardThreadExecutor线程池，该线程池execute执行策略是优先扩充线程到maximumPoolSize，再offer到queue，如果满了就reject。来看看StandardThreadExecutor是怎么实现的。</p>
<span id="more"></span>

<p>首先Tomcat的StandardThreadExecutor类实现了<code>org.apache.catalina.Executor</code>接口,该接口继承了<code>java.util.concurrent.Executor</code>。StandardThreadExecutor内部组合了一个<code>org.apache.tomcat.util.threads.ThreadPoolExecutor</code>,该类继承了<code>java.util.concurrent.ThreadPoolExecutor</code>。</p>
<p>先来关注一下<code>java.util.concurrent.ThreadPoolExecutor</code>的execute方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>addWorker是创建线程执行任务，该方法中会判断当前的线程数量是否达到maximumPoolSize；workQueue.offer是将任务添加到队列里面。</p>
<p><code>org.apache.tomcat.util.threads.ThreadPoolExecutor</code>就是对workQueue作了一些改动。StandardThreadExecutor使用的是<code>org.apache.tomcat.util.threads.TaskQueue</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskQueue</span> <span class="keyword">extends</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">force</span><span class="params">(Runnable o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( parent==<span class="literal">null</span> || parent.isShutdown() ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o); <span class="comment">//forces the item onto the queue, to be used if the task is rejected</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">force</span><span class="params">(Runnable o, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> ( parent==<span class="literal">null</span> || parent.isShutdown() ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o,timeout,unit); <span class="comment">//forces the item onto the queue, to be used if the task is rejected</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Runnable o)</span> &#123;</span><br><span class="line">      <span class="comment">//we can&#x27;t do any checks</span></span><br><span class="line">        <span class="keyword">if</span> (parent==<span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">        <span class="comment">//we are maxed out on threads, simply queue the object</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getPoolSize() == parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">        <span class="comment">//we have idle threads, just add it to the queue</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getSubmittedCount()&lt;(parent.getPoolSize())) <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">        <span class="comment">//if we have less threads than maximum force creation of a new thread</span></span><br><span class="line">        <span class="keyword">if</span> (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//if we reached here, we need to add it to the queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看一下TaskQueue的offer方法，是不是明白了？当parent.getPoolSize()还没达到parent.getMaximumPoolSize()大小时，返回false，这样会走addWorker分支。再来看<code>org.apache.tomcat.util.threads.ThreadPoolExecutor</code>的execute:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">    submittedCount.incrementAndGet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.execute(command);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> (TaskQueue)<span class="built_in">super</span>.getQueue();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Queue capacity is full.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            submittedCount.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> rx;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  当抛出RejectedExecutionException时，会等待timeout后重试一次加到queue中，如果失败才最终抛出异常。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>线程&amp;线程池</category>
      </categories>
  </entry>
  <entry>
    <title>Thread.interrupt与LockSupport</title>
    <url>/2024/03/11/Java/Java%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%E6%B1%A0/Thread.interrupt%E4%B8%8ELockSupport/</url>
    <content><![CDATA[<p>首先抛几个问题：</p>
<ul>
<li>Thread.interrupt()方法和InterruptedException异常的关系？是由interrupt触发产生了InterruptedException异常？</li>
<li>Thread.interrupt()会中断线程什么状态的工作？ RUNNING or BLOCKING？</li>
<li>LockSupport.park()和unpark()，与object.wait()和notify()的区别？</li>
<li>LockSupport.park(Object blocker)传递的blocker对象做什么用？</li>
<li>LockSupport能响应Thread.interrupt()事件不？会抛出InterruptedException异常？</li>
</ul>
 <span id="more"></span>

<h1 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h1><p>​    每个线程都有一个interrupt status标志位，用于表明当前线程是否处于中断状态。调用interrupt()仅仅是置线程的中断状态位，不会停止线程。 在Core Java中有这样一句话：”没有任何语言方面的需求要求一个被中断的程序应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断 “。</p>
<p>Thread的interrupt相关方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//置线程的中断状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回线程的中断状态，并清除中断状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程是否中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure>

<p>注意，<code>public static boolean interrupted()</code>会check当前线程是否处于interrupt，并重置interrupt信息。</p>
<p><code>public void interrupt()</code>不会中断正在执行的线程，只是将线程的标志位设置成true。但是当线程被<code>Object.wait</code>, <code>Thread.join</code>和<code>Thread.sleep</code>等方法阻塞时，调用线程的<code>interrput()</code>方法，可想而知，没有占用CPU运行的线程是不可能给自己的中断状态置位的，因此会抛出InterruptedException，同时会清除线程的中断状态，因此在catch块中捕获到这个异常时，isInterrupted()始终都为false。</p>
<p>为什么有InterruptedException？如果线程被阻塞，它便不能核查共享变量，也就不能停止。例如调用<code>Object.wait()</code>、<code>ServerSocket.accept()</code>和<code>DatagramSocket.receive()</code>时，都可能永久的阻塞线程。即使发生超时，在超时期满之前持续等待也是不可行和不适当的。<code>Thread.interrupt()</code>方法不会中断一个正在运行的线程，但是该方法可以在线程受到阻塞时抛出一个中断异常（InterruptedException），这样线程就得以提早地终结被阻塞状态。</p>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><p>​	LockSupport是JDK中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞原语。java锁和同步器框架的核心AQS: AbstractQueuedSynchronizer，就是通过调用 <code>LockSupport.park()</code>和 <code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的。</p>
<p>​	LockSupport 很类似于二元信号量(只有1个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继续执行；如果许可已经被占用，当前线程阻塞，等待获取许可。这个“许可”是不能叠加的，“许可”是一次性的。比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态。</p>
<p>​	注意，unpark函数可以先于park调用。比如线程B调用unpark函数，给线程A发了一个“许可”，那么当线程A调用park时，它发现已经有“许可”了，那么它会马上再继续运行。</p>
<p>​	实际上，park函数即使没有“许可”，有时也会无理由地返回，这点等下再解析。</p>
<p>​	在Java5里是用wait&#x2F;notify&#x2F;notifyAll来同步的。wait&#x2F;notify机制有个很蛋疼的地方是，比如线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。另外，是调用notify，还是notifyAll？notify只会唤醒一个线程，如果错误地有两个线程在同一个对象上wait等待，那么又悲剧了。为了安全起见，貌似只能调用notifyAll了。</p>
<p>​	park&#x2F;unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     LockSupport.park();</span><br><span class="line">     System.out.println(<span class="string">&quot;block.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该代码，可以发现主线程一直处于阻塞状态。因为<strong>许可默认是被占用的</strong>，调用<code>park()</code>时获取不到许可，所以进入阻塞状态。 </p>
<p>如下代码：先释放许可，再获取许可，主线程能够正常终止。LockSupport许可的获取和释放，一般来说是对应的，如果多次unpark，只有一次park也不会出现什么问题，结果是许可处于可用状态，而且LockSupport是不可重入的，如果一次unpark，多次park，当前线程也会阻塞（可以理解对某一线程许可证有且仅有一个）。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    LockSupport.unpark(thread);<span class="comment">//释放许可</span></span><br><span class="line">    LockSupport.park();<span class="comment">// 获取许可</span></span><br><span class="line">    System.out.println(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">    LockSupport.unpark(thread);<span class="comment">//释放许可</span></span><br><span class="line">    LockSupport.unpark(thread);<span class="comment">//释放许可</span></span><br><span class="line">    LockSupport.park();<span class="comment">// 获取许可</span></span><br><span class="line">    System.out.println(<span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">    LockSupport.unpark(thread);<span class="comment">//释放许可</span></span><br><span class="line">    LockSupport.park();<span class="comment">// 获取许可</span></span><br><span class="line">    LockSupport.park();<span class="comment">// 获取许可</span></span><br><span class="line">    System.out.println(<span class="number">333</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码打印出111和222，不会打印333，因为第二次调用park的时候，线程无法获取许可出现阻塞。</p>
<p>线程如果因为调用park而阻塞的话，能够响应中断请求(中断状态被设置成true)，但是不会抛出InterruptedException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="number">111</span>);</span><br><span class="line">    <span class="comment">//等待或许许可</span></span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;thread over.&quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中断线程</span></span><br><span class="line">t.interrupt();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码打印出111和thread over.true。</p>
<hr>
<p>最后解答之前的问题：</p>
<p>问题1： <code>Thread.interrupt()</code>方法和<code>InterruptedException</code>异常的关系？是由interrupt触发产生了InterruptedException异常？ </p>
<p>答： <code>Thread.interrupt()</code>只是在<code>Object.wait() </code>、<code>Object.join()</code>、<code>Object.sleep()</code>几个方法会主动抛出InterruptedException异常。而在其他的的block常见，只是设置了Thread的一个标志位信息，需要程序自我进行处理。</p>
<p>问题2：<code>Thread.interrupt()</code>会中断线程什么状态的工作？ RUNNING or BLOCKING？</p>
<p>答：<code>Thread.interrupt</code>设计的目的主要是用于处理线程处于block状态，比如<code>wait()</code>,<code>sleep()</code>状态就是个例子。但可以在程序设计时为支持task cancel，同样可以支持RUNNING状态。比如<code>Object.join()</code>和一些支持interrupt的一些nio channel设计。</p>
<p>问题3： <code>LockSupport.park()</code>和<code>unpark()</code>，与<code>object.wait()</code>和<code>notify()</code>的区别？</p>
<p>答：</p>
<ol>
<li>面向的主体不一样。LockSuport主要是针对Thread进行阻塞处理，可以指定阻塞队列的目标对象，每次可以指定具体的线程唤醒。<code>Object.wait()</code>是以对象为纬度，阻塞当前的线程和唤醒单个(随机)或者所有线程。</li>
<li>实现机制不同。虽然LockSuport可以指定monitor的object对象，但和<code>object.wait()</code>，两者的阻塞队列并不交叉。</li>
</ol>
<p>问题4： <code>LockSupport.park(Object blocker)</code>传递的blocker对象做什么用？</p>
<p>答: 对应的blcoker会记录在Thread的一个parkBlocker属性中,通过jstack命令可以非常方便的监控具体的阻塞对象.</p>
<p>问题5： <code>LockSupport</code>能响应<code>Thread.interrupt()</code>事件不？会抛出InterruptedException异常？</p>
<p>答：能响应interrupt事件，但不会抛出InterruptedException异常</p>
<hr>
<p>转载自：<br><a href="http://agapple.iteye.com/blog/970055">http://agapple.iteye.com/blog/970055</a><br><a href="http://www.tuicool.com/articles/MveUNzF">http://www.tuicool.com/articles/MveUNzF</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>线程&amp;线程池</category>
      </categories>
  </entry>
  <entry>
    <title>再聊线程池</title>
    <url>/2024/03/11/Java/Java%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%86%8D%E8%81%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>关于线程池的介绍在<a href="http://blog.csdn.net/zero__007/article/details/43795287">http://blog.csdn.net/zero__007&#x2F;article&#x2F;details&#x2F;43795287</a> ，<a href="http://blog.csdn.net/zero__007/article/details/44102239">http://blog.csdn.net/zero__007&#x2F;article&#x2F;details&#x2F;44102239</a> 已经介绍了，这里只是稍微补充补充。</p>
<p><strong>RejectedExecutionHandler</strong></p>
<p>ThreadPoolExecutor的构造函数中会有该参数，表示拒绝策略。当队列满且线程池大小&gt;&#x3D;maximumPoolSize时会触发驳回，因为这时线程池已经不能响应新提交的任务，驳回时就会回调这个接口rejectedExecution方法，JDK默认提供了4种驳回策略，可以根据业务场景来选择，线程池的默认策略是AbortPolicy。</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy：直接抛出运行时异常。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy： 转成同步调用。</li>
<li>ThreadPoolExecutor.DiscardPolicy：  直接丢弃。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy： 取出队列的头并丢弃，重新提交该任务。</li>
</ul>
<p>ThreadPoolExecutor预留了以下三个方法，我们可以通过继承该类来做一些扩展，比如监控、日志等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t,  Runnable r)</span> &#123; &#125;  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Thread t,  Runnable r)</span> &#123; &#125; </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123; &#125;  </span><br></pre></td></tr></table></figure>

 <span id="more"></span>

<p><strong>ThreadPoolExecutor状态</strong></p>
<p>RUNNING：初始状态，接受新任务并且处理已经在队列中的任务。</p>
<p>SHUTDOWN：不接受新任务，但处理队列中的任务。</p>
<p>STOP：不接受新任务，不处理排队的任务，并中断正在进行的任务。</p>
<p>TIDYING：所有任务已终止，workerCount为零，线程转换到状态TIDYING，这时回调terminate()方法。</p>
<p>TERMINATED：终态，terminated()执行完成。</p>
<p><strong>Worker</strong></p>
<p>​    ThreadPoolExecutor中重要的类是Worker:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">     <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">     <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">// worker 所对应的线程</span></span><br><span class="line">     <span class="keyword">final</span> Thread thread;</span><br><span class="line">     <span class="comment">// worker所对应的第一个任务</span></span><br><span class="line">     Runnable firstTask;</span><br><span class="line">     <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">     <span class="comment">// 已完成任务数量</span></span><br><span class="line">     <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​    该类继承了AQS与Runnable，其重载的run中会不断从queue中获取任务并执行。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>线程&amp;线程池</category>
      </categories>
  </entry>
  <entry>
    <title>线程池的异常处理机制</title>
    <url>/2024/03/11/Java/Java%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>先上两段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">threadPool.execute(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    System.out.println(obj.toString());</span><br><span class="line">&#125;);</span><br><span class="line">threadPool.shutdown();</span><br><span class="line">System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">threadPool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;submit&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    System.out.println(obj.toString());</span><br><span class="line">&#125;);</span><br><span class="line">threadPool.shutdown();</span><br><span class="line">System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果发现，execute执行的时候抛出了预期的NullPointerException异常，而submit执行时什么都没有！</p>
 <span id="more"></span>

<p>三个字：跟源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    使用submit提交任务时，会先把task包装成FutureTask对象，然后才去调用execute来执行任务。继续看execute：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 如果线程个数消息核心线程数则新增处理线程处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前线程个数已经达到核心线程数则任务放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试新增处理线程进行处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">            reject(command);<span class="comment">// 新增失败则调用拒绝策略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​    这里是一个典型的生产者，通过addWorker()方法将任务包装成Worker提交到workQueue中。来看Worker代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​    忽略一些细节的地方，Worker就是一个Runnable，run()方法调用的是runWorker()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);  <span class="comment">//可重写此方法，ThreadPoolExecutor类中</span></span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();  <span class="comment">//关键</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);  <span class="comment">//可重写此方法，ThreadPoolExecutor类中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<p>​    execute的方式提交时，这里的task就是Runnable（上面代码有），因此就会直接抛出，最终JVM会去调用Thread#dispatchUncaughtException方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch an uncaught exception to the handler. This method is</span></span><br><span class="line"><span class="comment"> * intended to be called only by the JVM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchUncaughtException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="built_in">this</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title function_">getUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uncaughtExceptionHandler != <span class="literal">null</span> ?</span><br><span class="line">        uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 一般没有去设置uncaughtExceptionHandler 时，getUncaughtExceptionHandler()返回的是group，即ThreadGroup实例，来看ThreadGroup#uncaughtException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">ueh</span> <span class="operator">=</span></span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="literal">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span></span><br><span class="line">                             + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以看到，先看有没有parent，没有则通过Thread.getDefaultUncaughtExceptionHandler()获取UncaughtExceptionHandler来处理，没有的话才将异常打印到System.err里面。</p>
<p>​    那么submit的方式提交时，是怎么的情况呢？runWorker()中task是FutureTask，它的run()方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="type">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，对于异常并没有抛出，而是把异常给了outcome，这样在调用get()方法的时候，才会拿到这个异常。</p>
<p>​    OK，到此为止已经解释了最开始的两段代码运行结果不同的原因了。</p>
<p>在写代码时对于线程池、包括线程的异常处理最好是直接try&#x2F;catch。 除此之外还有其它的方式，但是不推荐：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">            t.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;uncaughtException&quot;</span>);</span><br><span class="line">                    System.out.println(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadPool.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(obj.toString());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>线程&amp;线程池</category>
      </categories>
  </entry>
  <entry>
    <title>线程池使用拒绝策略时需要注意的坑</title>
    <url>/2024/03/11/Java/Java%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>线程池使用FutureTask的时候如果拒绝策略设置为了DiscardPolicy和DiscardOldestPolicy并且在被拒绝的任务的Future对象上调用无参get方法那么调用线程会一直被阻塞。</p>
<p><strong>问题复现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1)线程池单个线程，线程池队列元素个数为1</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">1L</span>, TimeUnit.MINUTES,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2)添加任务one</span></span><br><span class="line">    <span class="type">Future</span> <span class="variable">futureOne</span> <span class="operator">=</span> executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start runable one&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(3)添加任务two</span></span><br><span class="line">    <span class="type">Future</span> <span class="variable">futureTwo</span> <span class="operator">=</span> executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start runable two&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(4)添加任务three</span></span><br><span class="line">    <span class="type">Future</span> <span class="variable">futureThree</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        futureThree = executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;start runable three&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(e.getLocalizedMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;task one finish &quot;</span> + futureOne.get());<span class="comment">//(5)等待任务one执行完毕</span></span><br><span class="line">    System.out.println(<span class="string">&quot;task two finish &quot;</span> + futureTwo.get());<span class="comment">//(6)等待任务two执行完毕</span></span><br><span class="line">    System.out.println(<span class="string">&quot;task three finish &quot;</span> + (futureThree == <span class="literal">null</span> ? <span class="literal">null</span> : futureThree.get()));<span class="comment">// (7)等待任务three执行完毕</span></span><br><span class="line"></span><br><span class="line">    executorService.shutdown();<span class="comment">//(8)关闭线程池，阻塞直到所有任务执行完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start runable one</span><br><span class="line">task one finish null</span><br><span class="line">start runable two</span><br><span class="line">task two finish null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建了一个单线程并且队列元素个数为1的线程池，并且拒绝策略设置为了DiscardPolicy；先提交任务one，这个任务会使用唯一的一个线程进行执行，任务在打印 start runable one后会阻塞该线程5s；再向线程池提交了一个任务two，这时候会把任务two放入到阻塞队列；提交任务three时，由于队列已经满了则会触发拒绝策略丢弃任务three。</p>
<p>从运行结果看在任务one阻塞的5s内，主线程执行到了代码(5)等待任务one执行完毕，当任务one执行完毕后代码（5）返回，主线程打印出<code>task one finish null</code>。之后线程池的唯一线程会去队列里面取出任务two并执行所以输出<code>start runable two</code>，然后代码（6）会返回，这时候主线程输出<code>task two finish null</code>，然后执行代码（7）等待任务three执行完毕，从执行结果看代码（7）会一直阻塞不会返回。</p>
<p>至此问题产生，如果把拒绝策略修改为DiscardOldestPolicy也会存在有一个任务的get方法一直阻塞只是现在是任务two被阻塞：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start runable one</span><br><span class="line">task one finish null</span><br><span class="line">start runable three</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是如果拒绝策略设置为默认的AbortPolicy则会抛出RejectedExecutionException并正常返回。</p>
<p><strong>问题分析</strong></p>
<p>​    要分析这个问题需要看下线程池的submit方法里面做了什么，submit方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    newTaskFor()把Runnable转为FutureTask对象，FutureTask实现RunnableFuture接口，继续跟execute：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果线程个数消息核心线程数则新增处理线程处理</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前线程个数已经达到核心线程数则任务放入队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试新增处理线程进行处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);<span class="comment">// 新增失败则调用拒绝策略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再来看下拒绝策略DiscardPolicy的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DiscardPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里rejectedExecution方法里面什么都没做，所以代码（4）调用submit后会返回一个future对象，即FutureTask：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Possible state transitions:</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>state标识FutureTask的状态，初始状态是New。因此使用DiscardPolicy策略提交后返回了一个状态为NEW的FutureTask对象。</p>
<p>那么下面就需要看下当调用future的无参get方法时候当future变为什么状态时候才会返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)  <span class="comment">// 状态值为NORMAL正常返回</span></span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED) <span class="comment">// 状态值大于等于CANCELLED则抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    也就是说当future的状态 <code>&gt;COMPLETING</code> 时候调用get方法才会返回，而明显DiscardPolicy策略在拒绝元素的时候并没有设置该future的状态，后面也没有其他机会可以设置该future的状态，所以future的状态一直是NEW，所以一直不会返回，同理DiscardOldestPolicy策略也是这样的问题，最老的任务被淘汰时候没有设置被淘汰任务对于future的状态，也会导致一直不会返回。</p>
<p>那么默认的AbortPolicy策略为啥没问题那？来看AbortPolicy策略代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbortPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                             <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    看代码就应该明白了吧。</p>
<p>所以当使用Future的时候，尽量使用带超时时间的get方法，这样即使使用了DiscardPolicy拒绝策略也不至于一直等待，等待超时时间到了会自动返回的，如果非要使用不带参数的get方法则可以重写DiscardPolicy的拒绝策略。在执行策略时候设置该Future的状态大于COMPLETING即可，但是查看FutureTask提供的方法发现只有cancel方法是public的，并且可以设置FutureTask的状态大于COMPLETING，重写拒绝策略具体代码可以如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//(1)线程池单个线程，线程池队列元素个数为1</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">1L</span>, TimeUnit.MINUTES,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r != <span class="literal">null</span> &amp;&amp; r <span class="keyword">instanceof</span> FutureTask) &#123;</span><br><span class="line">                            ((FutureTask) r).cancel(<span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2)添加任务one</span></span><br><span class="line">    <span class="type">Future</span> <span class="variable">futureOne</span> <span class="operator">=</span> executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start runable one&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(3)添加任务two</span></span><br><span class="line">    <span class="type">Future</span> <span class="variable">futureTwo</span> <span class="operator">=</span> executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start runable two&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(4)添加任务three</span></span><br><span class="line">    <span class="type">Future</span> <span class="variable">futureThree</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        futureThree = executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;start runable three&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(e.getLocalizedMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task one finish &quot;</span> + futureOne.get());<span class="comment">//(5)等待任务one执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;task two finish &quot;</span> + futureTwo.get());<span class="comment">//(6)等待任务two执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;task three finish &quot;</span> + (futureThree == <span class="literal">null</span> ? <span class="literal">null</span> : futureThree.get()));<span class="comment">// (7)等待任务three执行完毕</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();<span class="comment">//(8)关闭线程池，阻塞直到所有任务执行完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>​    使用这个策略时候，由于report方法中对cancel的任务上会抛出CancellationException异常，所以在get()时使用try-catch捕获异常。运行后发现程序能正常退出。</p>
<hr>
<p>转载自：<br><a href="http://ifeve.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8futuretask%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E7%82%B9%E4%BA%8B/">http://ifeve.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8futuretask%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E7%82%B9%E4%BA%8B/</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>线程&amp;线程池</category>
      </categories>
  </entry>
  <entry>
    <title>Java引用</title>
    <url>/2024/03/01/Java/JVM/Reference/Java%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="1-强可及对象（strongly-reachable）："><a href="#1-强可及对象（strongly-reachable）：" class="headerlink" title="1)强可及对象（strongly reachable）："></a>1)强可及对象（strongly reachable）：</h1><p>　　可以通过强引用访问的对象，一般来说，平时写代码的方式都是使用的强引用对象，比如下边的代码段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　StringBuilder builder= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>()；</span><br></pre></td></tr></table></figure>

<p>上边代码builder这个引用将引用内存堆中的一个对象，这种情况下，只要引用存在，垃圾回收器就永远不会释放该对象的存储空间。</p>
<p>这种对象又成为强引用（Strong references），这种强引用方式就是Java语言的原生的Java引用。上边代码JVM存储了一个StringBuilder类型的对象的强引用在变量builder。强引用和GC的交互是这样的，如果一个对象通过强引用可达或者通过强引用链可达的话这种对象就成为强可及对象，这种情况下的对象垃圾回收器不予理睬。</p>
 <span id="more"></span>

<h1 id="2-软可及对象（softly-reachable）："><a href="#2-软可及对象（softly-reachable）：" class="headerlink" title="2)软可及对象（softly reachable）："></a>2)软可及对象（softly reachable）：</h1><p>　　不通过强引用访问的对象，即不是强可及对象，但是可以通过软引用访问的对象就成为软可及对象，软可及对象就需要使用类SoftReference（java.lang.ref.SoftReference）。       </p>
<p>​        此种类型的引用主要用于内存比较敏感的高速缓存，而且此种引用还是具有较强的引用功能，当内存不够的时候GC会回收这类内存，因此如果内存充足的时候，这种引用通常不会被回收的。不仅仅如此，这种引用对象在JVM里面保证在抛出OutOfMemory异常之前，设置成为null。通俗地讲，这种类型的引用保证在JVM内存不足的时候全部被清除，但是有个关键在于：垃圾收集器在运行时是否释放软可及对象是不确定的，而且使用垃圾回收算法并不能保证一次性寻找到所有的软可及对象。当垃圾回收器每次运行的时候都可以随意释放不是强可及对象占用的内存，如果垃圾回收器找到了软可及对象过后，可能会进行以下操作：</p>
<ul>
<li>将SoftReference对象的referent域设置成为null，从而使该对象不再引用heap对象。 </li>
<li>SoftReference引用过的内存堆上的对象一律被生命为finalizable。 </li>
<li>当内存堆上的对象finalize()方法被运行而且该对象占用的内存被释放，SoftReference对象就会被添加到它的ReferenceQueue，前提条件是ReferenceQueue本身是存在的。</li>
</ul>
<p>　　既然Java里面存在这样的对象，那么在编写代码的时候如何创建这样的对象呢？创建步骤如下：</p>
<p>​        先创建一个对象，并使用普通引用方式强引用，然后再创建一个SoftReference来引用该对象，最后将普通引用设置为null， 通过这样的方式，这个对象就仅仅保留了一个SoftReference引用，同时这种情况所创建的对象就是SoftReference对象。一般情况 下，可以使用该引用来完成Cache功能，就是前边说的用于高速缓存，保证最大限度使用内存而不会引起内存泄漏的情况。</p>
<p>​        软引用技术使得Java系统可以更好地管理内存，保持系统稳定，防止内存泄漏，避免系统崩溃，因此在处理一些内存占用大而且生命周期长使用不频繁的对象可以使用该技术。</p>
<h1 id="3-弱可及对象（weakly-reachable）："><a href="#3-弱可及对象（weakly-reachable）：" class="headerlink" title="3)弱可及对象（weakly reachable）："></a>3)弱可及对象（weakly reachable）：</h1><p>　　不是强可及对象同样也不是软可及对象，仅仅通过弱引用WeakReference（java.lang.ref.WeakReference）访问的对象，这种对象的用途在于规范化映射，对于生存周期相对比较长而且重新创建的时候开销少的对象，弱引用也比较有用，和软引用对象不同的是，垃圾回收器如果碰到了弱可及对象，将释放WeakReference对象的内存，但是垃圾回收器需要运行很多次才能够找到弱可及对象。弱引用对象在使用的时候，可以配合ReferenceQueue类使用，如果弱引用被回收，JVM就会把这个弱引用加入到相关的引用队列中去。最简单的弱引用方法如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　<span class="type">WeakReference</span> <span class="variable">weakWidget</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(classA);</span><br></pre></td></tr></table></figure>

<p>　　在上面代码里面，当我们使用weakWidget.get()来获取classA的时候，由于弱引用本身是无法阻止垃圾回收的，所以也许会拿到一个null为返回。【小技巧，如果希望取得某个对象的信息，但是又不影响该对象的垃圾回收过程，就可以使用WeakReference来记住该对象，一般在开发调试器和优化器的时候使用这个是很好的一个手段。】</p>
<p>​        如果上边的代码部分，通过<code>weakWidget.get()</code>返回的是null就证明该对象已经被垃圾回收器回收了，而这种情况下弱引用对象就失去了使用价值，GC就会定义为需要进行清除工作。这种情况下弱引用无法引用任何对象，所以在JVM里面就成为了一个死引用，这就是为什么有时候需要通过ReferenceQueue类来配合使用的原因，使用了ReferenceQueue过后，就使得我们更加容易监视该引用的对象，如果通过ReferenceQueue类来构造一个弱引用，当弱引用的对象已经被回收的时候，系统将自动使用对象引用队列来代替对象引用，而且我们可以通过ReferenceQueue类的运行来决定是否真正要从垃圾回收器里面将该死引用（Dead Reference）清除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">弱引用代码段：</span><br><span class="line">　　<span class="comment">//创建普通引用对象</span></span><br><span class="line">　　<span class="type">MyObject</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">　　<span class="comment">//创建一个引用队列</span></span><br><span class="line">　　<span class="type">ReferenceQueue</span> <span class="variable">rq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">　　<span class="comment">//使用引用队列创建MyObject的弱引用</span></span><br><span class="line">　　<span class="type">WeakReference</span> <span class="variable">wr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(object,rq);</span><br></pre></td></tr></table></figure>



<p>　　当Java回收器遇到了弱引用的时候有可能会执行以下操作：</p>
<ul>
<li>将WeakReference对象的referent域设置成为null，从而使该对象不再引用heap对象。 </li>
<li>WeakReference引用过的内存堆上的对象一律被生命为finalizable。 </li>
<li>当内存堆上的对象finalize()方法被运行而且该对象占用的内存被释放，WeakReference对象就会被添加到它的ReferenceQueue，前提条件是ReferenceQueue本身是存在的。</li>
</ul>
<h1 id="4-虚可及对象（phantomly-reachable）："><a href="#4-虚可及对象（phantomly-reachable）：" class="headerlink" title="4)虚可及对象（phantomly reachable）："></a>4)虚可及对象（phantomly reachable）：</h1><p>　　不是强可及对象，也不是软可及对象，同样不是弱可及对象，之所以把虚可及对象放到最后来讲，主要也是因为它的特殊性，有时候又称之为“幽灵对象”，已经结束的，可以通过虚引用来访问该对象。使用类PhantomReference（java.lang.ref.PhantomReference）来访问，这个类只能用于跟踪被引用对象进行的收集，同样的，可以用于执行per-mortern清除操作。</p>
<p>​        PhantomReference必须与 ReferenceQueue类一起使用。需要使用ReferenceQueue是因为它能够充当通知机制，当垃圾收集器确定了某个对象是虚可及对象的时 候，PhantomReference对象就被放在了它的ReferenceQueue上，这就是一个通知，表明PhantomReference引用的对象已经结束，可以收集了，一般情况下我们刚好在对象内存在回收之前采取该行为。这种引用不同于弱引用和软引用，这种方式通过get()获取到的对象总是 返回null，仅仅当这些对象在ReferenceQueue队列里面的时候，我们可以知道它所引用的哪些对对象是死引用（Dead Reference）。而这种引用和弱引用的区别在于：</p>
<p>　　弱引用（WeakReference）是在对象不可达的时候尽快进入ReferenceQueue队列的，在finalization方法执行和垃圾回收之前是确实会发生的，理论上这类对象是不正确的对象，但是WeakReference对象可以继续保持Dead状态，</p>
<p>　　虚引用（PhantomReference）是在对象确实已经从物理内存中移除过后才进入的ReferenceQueue队列，而且get()方法会一直返回null</p>
<p>　　当垃圾回收器遇到了虚引用的时候将有可能执行以下操作：</p>
<ul>
<li>PhantomReference引用过的heap对象声明为finalizable； </li>
<li>虚引用在堆对象释放之前就添加到了它的ReferenceQueue里面，这种情况使得我们可以在堆对象被回收之前采取操作【*：再次提醒，PhantomReference对象必须经过关联的ReferenceQueue来创建，就是说必须和ReferenceQueue类配合操作】</li>
</ul>
<p>　　看似没有用处的虚引用，有什么用途呢？</p>
<ul>
<li>首先，我们可以通过虚引用知道对象究竟什么时候真正从内存里面移除的，而且这也是唯一的途径。 </li>
<li>虚引用避过了finalize()方法，因为对于此方法的执行而言，虚引用真正引用到的对象是异常对象，若在该方法内要使用对象只能重建。一般情况垃圾回收器会轮询两次，一次标记为finalization，第二次进行真实的回收，而往往标记工作不能实时进行，或者垃圾回收其会等待一个对象去标记finalization。这种情况很有可能引起MemoryOut，而使用虚引用这种情况就会完全避免。因为虚引用在引用对象的过程不会去使得这个对象由Dead复活，而且这种对象是可以在回收周期进行回收的。</li>
</ul>
<p>　 　在JVM内部，虚引用比起使用finalize()方法更加安全一点而且更加有效。而finaliaze()方法回收在虚拟机里面实现起来相对简单，而 且也可以处理大部分工作，所以我们仍然使用这种方式来进行对象回收的扫尾操作，但是有了虚引用过后我们可以选择是否手动操作该对象使得程序更加高效完美。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>Reference</category>
      </categories>
  </entry>
  <entry>
    <title>FinalReference完全解读</title>
    <url>/2024/03/01/Java/JVM/Reference/FinalReference%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>[toc]<br>JAVA对象引用体系除了强引用之外，出于对性能、可扩展性等方面考虑还特地实现了四种其他引用：SoftReference、WeakReference、PhantomReference、FinalReference，本文主要想讲的是FinalReference，因为在使用内存分析工具比如zprofiler、mat等在分析一些oom的heap的时候，经常能看到 java.lang.ref.Finalizer占用的内存大小远远排在前面，而这个类占用的内存大小又和FinalReference有着密不可分的关系。</p>
<p>对于FinalReference及关联的内容，可能有如下印象：自己代码里从没有使用过，线程dump之后，能看到一个叫做Finalizer的java线程，偶尔能注意到java.lang.ref.Finalizer的存在、我们在类里可能会写finalize方法。</p>
<p>那FinalReference到底存在的意义是什么，以怎样的形式和我们的代码相关联呢？</p>
 <span id="more"></span>

<h2 id="FinalReference"><a href="#FinalReference" class="headerlink" title="FinalReference"></a>FinalReference</h2><p>首先我们看看FinalReference在JDK里的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类访问权限是package的，这也就意味着不能直接去对其进行扩展，但是JDK里对此类进行了扩展实现java.lang.ref.Finalizer，这个类也是我们在概述里提到的，而此类的访问权限也是package的，并且是final的，意味着真的不能被扩展了，接下来的重点围绕java.lang.ref.Finalizer展开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.ref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> sun.misc.JavaLangAccess;</span><br><span class="line"><span class="keyword">import</span> sun.misc.SharedSecrets;</span><br><span class="line"><span class="keyword">import</span> sun.misc.VM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Finalizer</span> <span class="keyword">extends</span> <span class="title class_">FinalReference</span>&lt;Object&gt; &#123; <span class="comment">/* Package-private; must be in</span></span><br><span class="line"><span class="comment">                                                          same package as the Reference</span></span><br><span class="line"><span class="comment">                                                          class */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Finalizer</span> <span class="variable">unfinalized</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Finalizer</span></span><br><span class="line">        <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>,</span><br><span class="line">        prev = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasBeenFinalized</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (next == <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unfinalized != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.next = unfinalized;</span><br><span class="line">                unfinalized.prev = <span class="built_in">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unfinalized = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unfinalized == <span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    unfinalized = <span class="built_in">this</span>.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unfinalized = <span class="built_in">this</span>.prev;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.next.prev = <span class="built_in">this</span>.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.prev != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.prev.next = <span class="built_in">this</span>.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="built_in">this</span>;   <span class="comment">/* Indicates that this has been finalized */</span></span><br><span class="line">            <span class="built_in">this</span>.prev = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Finalizer</span><span class="params">(Object finalizee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(finalizee, queue);</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invoked by VM */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object finalizee)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Finalizer</span>(finalizee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runFinalizer</span><span class="params">(JavaLangAccess jla)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasBeenFinalized()) <span class="keyword">return</span>;</span><br><span class="line">            remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">finalizee</span> <span class="operator">=</span> <span class="built_in">this</span>.get();</span><br><span class="line">            <span class="keyword">if</span> (finalizee != <span class="literal">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span><br><span class="line">                jla.invokeFinalize(finalizee);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Clear stack slot containing this variable, to decrease</span></span><br><span class="line"><span class="comment">                   the chances of false retention with a conservative GC */</span></span><br><span class="line">                finalizee = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span><br><span class="line">        <span class="built_in">super</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a privileged secondary finalizer thread in the system thread</span></span><br><span class="line"><span class="comment">       group for the given Runnable, and wait for it to complete.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       This method is used by both runFinalization and runFinalizersOnExit.</span></span><br><span class="line"><span class="comment">       The former method invokes all pending finalizers, while the latter</span></span><br><span class="line"><span class="comment">       invokes all uninvoked finalizers if on-exit finalization has been</span></span><br><span class="line"><span class="comment">       enabled.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       These two methods could have been implemented by offloading their work</span></span><br><span class="line"><span class="comment">       to the regular finalizer thread and waiting for that thread to finish.</span></span><br><span class="line"><span class="comment">       The advantage of creating a fresh thread, however, is that it insulates</span></span><br><span class="line"><span class="comment">       invokers of these methods from a stalled or deadlocked finalizer thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forkSecondaryFinalizer</span><span class="params">(<span class="keyword">final</span> Runnable proc)</span> &#123;</span><br><span class="line">        AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">                     tgn != <span class="literal">null</span>;</span><br><span class="line">                     tg = tgn, tgn = tg.getParent());</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">sft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tg, proc, <span class="string">&quot;Secondary finalizer&quot;</span>);</span><br><span class="line">                sft.start();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sft.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    <span class="comment">/* Ignore */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Called by Runtime.runFinalization() */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runFinalization</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!VM.isBooted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        forkSecondaryFinalizer(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> running;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (running)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">JavaLangAccess</span> <span class="variable">jla</span> <span class="operator">=</span> SharedSecrets.getJavaLangAccess();</span><br><span class="line">                running = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="type">Finalizer</span> <span class="variable">f</span> <span class="operator">=</span> (Finalizer)queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                    f.runFinalizer(jla);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invoked by java.lang.Shutdown */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runAllFinalizers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!VM.isBooted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        forkSecondaryFinalizer(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> running;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (running)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">JavaLangAccess</span> <span class="variable">jla</span> <span class="operator">=</span> SharedSecrets.getJavaLangAccess();</span><br><span class="line">                running = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    Finalizer f;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        f = unfinalized;</span><br><span class="line">                        <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                        unfinalized = f.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    f.runFinalizer(jla);</span><br><span class="line">                &#125;&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FinalizerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> running;</span><br><span class="line">        FinalizerThread(ThreadGroup g) &#123;</span><br><span class="line">            <span class="built_in">super</span>(g, <span class="string">&quot;Finalizer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (running)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finalizer thread starts before System.initializeSystemClass</span></span><br><span class="line">            <span class="comment">// is called.  Wait until JavaLangAccess is available</span></span><br><span class="line">            <span class="keyword">while</span> (!VM.isBooted()) &#123;</span><br><span class="line">                <span class="comment">// delay until VM completes initialization</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    VM.awaitBooted();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    <span class="comment">// ignore and continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">JavaLangAccess</span> <span class="variable">jla</span> <span class="operator">=</span> SharedSecrets.getJavaLangAccess();</span><br><span class="line">            running = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Finalizer</span> <span class="variable">f</span> <span class="operator">=</span> (Finalizer)queue.remove();</span><br><span class="line">                    f.runFinalizer(jla);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    <span class="comment">// ignore and continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">             tgn != <span class="literal">null</span>;</span><br><span class="line">             tg = tgn, tgn = tg.getParent());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">finalizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalizerThread</span>(tg);</span><br><span class="line">        finalizer.setPriority(Thread.MAX_PRIORITY - <span class="number">2</span>);</span><br><span class="line">        finalizer.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        finalizer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Finalizer类"><a href="#Finalizer类" class="headerlink" title="Finalizer类"></a>Finalizer类</h2><p>从Finalizer类的构造函数可以获得下面的几个关键信息：private意味着在外面无法自己构建这类对象，finalizee参数表示FinalReference指向的对象引用，调用add方法是将当前对象插入到Finalizer对象链里，链里的对象和Finalizer类静态相关联，言外之意是在这个链里的对象都无法被gc掉，除非将这种引用关系剥离掉（因为Finalizer类无法被unload）。</p>
<p>虽然外面无法创建Finalizer对象，但是注意到有一个register的静态方法，在方法里会创建这种对象，同时将这个对象加入到Finalizer对象链里，这个方法是被vm调用的，那么问题来了，vm在什么情况下会调用这个方法呢？</p>
<p>GC在处理finalizer类的对象的时候要做一些特殊的处理，如在这个对象被回收之前会调用一下它的finalize方法。在java.lang.Object里有这样一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>这意味着所有类都会继承这个方法，甚至可以覆写该方法。而<strong>判断当前类是否是一个finalizer类的标准并不仅仅是当前类是否含有一个参数为空，返回值为void的名为finalize的方法，而另外一个要求是finalize方法必须非空</strong>，因此我们的Object类虽然含有一个finalize方法，但是并不是一个finalizer类，Object的对象在被gc回收的时候其实并不会去调用它的finalize方法。</p>
<p>需要注意的是我们的类在被加载过程中其实就已经被标记为是否为finalizer类了（遍历所有方法，包括父类的方法，只要有一个非空的 参数为空返回void的finalize方法 就认为是一个finalizer类）。</p>
<p>finalizer类的对象何时传到Finalizer.register方法呢？对象的创建其实是被拆分成多个步骤的，先执行new分配好对象空间，然后再执行invokespecial调用构造函数，jvm里其实可以让用户选择在这两个时机中的任意一个将当前对象传递给Finalizer.register方法来注册到Finalizer对象链里。另外需要提一点的是当通过clone的方式复制一个对象的时候，如果当前类是一个finalizer类，那么在clone完成的时候将调用Finalizer.register方法进行注册。</p>
<p>一个构造函数执行的时候，会去调用父类的构造函数，主要是为了能对继承自父类的属性也能做初始化，那么任何一个对象的初始化最终都会调用到Object的空构造函数里，任何空的构造函数其实并不空，会含有三条字节码指令，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line"><span class="number">1</span>: invokespecial #<span class="number">21</span>                 <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="number">4</span>: <span class="keyword">return</span>      </span><br></pre></td></tr></table></figure>

<p>为了不对所有的类的构造函数都做埋点调用Finalizer.register方法，hotspot的实现是在Object这个类在做初始化的时候将构造函数里的return指令替换为_return_register_finalizer指令，该指令并不是标准的字节码指令，是hotspot扩展的指令，这样在处理该指令的时候调用Finalizer.register方法，这样就在侵入性很小的情况下完美地在构造函数执行完毕后调用Finalizer.register。</p>
<h2 id="finalizer类对象的GC回收"><a href="#finalizer类对象的GC回收" class="headerlink" title="finalizer类对象的GC回收"></a>finalizer类对象的GC回收</h2><p>在Finalizer类的clinit方法（静态块）里会创建了一个FinalizerThread的守护线程，这个线程的优先级并不是最高的，意味着在cpu很紧张的情况下其被调度的优先级可能会受到影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FinalizerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> running;</span><br><span class="line">      FinalizerThread(ThreadGroup g) &#123;</span><br><span class="line">          <span class="built_in">super</span>(g, <span class="string">&quot;Finalizer&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (running)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          running = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="type">Finalizer</span> <span class="variable">f</span> <span class="operator">=</span> (Finalizer)queue.remove();</span><br><span class="line">                  f.runFinalizer();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">           tgn != <span class="literal">null</span>;</span><br><span class="line">           tg = tgn, tgn = tg.getParent());</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">finalizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalizerThread</span>(tg);</span><br><span class="line">      finalizer.setPriority(Thread.MAX_PRIORITY - <span class="number">2</span>);</span><br><span class="line">      finalizer.setDaemon(<span class="literal">true</span>);</span><br><span class="line">      finalizer.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个线程主要就是从queue里取Finalizer对象，然后执行该对象的runFinalizer方法，这个方法主要是将Finalizer对象从Finalizer对象链里剥离出来，这样意味着下次gc发生的时候就可能将其关联的finalizer对象gc掉了，最后将这个Finalizer对象关联的finalizer对象传给了一个native方法invokeFinalizeMethod。invokeFinalizeMethod方法其实就是调了这个finalizer对象的finalize方法。</p>
<p>如果在finalizer对象的finalize方法里重新将当前对象赋值出去，变成可达对象，当这个finalizer对象再次变成不可达的时候还会被执行finalize方法吗？答案是否定的，因为在执行完第一次finalize方法之后，这个finalizer对象已经和之前的Finalizer对象关系剥离了，也就是下次gc的时候不会再发现Finalizer对象指向该finalizer对象了，自然也就不会调用这个finalizer对象的finalize方法了。</p>
<p>当gc发生的时候，gc算法会判断finalizer类对象是不是只被Finalizer类引用（finalizer类对象被Finalizer对象引用，然后放到Finalizer对象链里），如果这个类仅仅被Finalizer对象引用的时候，说明这个对象在不久的将来会被回收了现在可以执行它的finalize方法了，于是会将这个Finalizer对象放到Finalizer类的ReferenceQueue里，但是这个finalizer类对象其实并没有被回收，因为Finalizer这个类还对他们持有引用，在gc完成之前，jvm会调用ReferenceQueue里的lock对象的notify方法（当ReferenceQueue为空的时候，FinalizerThread线程会调用ReferenceQueue的lock对象的wait方法直到被jvm唤醒），此时就会执行上面FinalizeThread线程里看到的其它逻辑了。</p>
<h2 id="Finalizer导致的内存泄露"><a href="#Finalizer导致的内存泄露" class="headerlink" title="Finalizer导致的内存泄露"></a>Finalizer导致的内存泄露</h2><p>这里举一个简单的例子，使用挺广的socket通信，SocksSocketImpl的父类其实就实现了finalize方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cleans up if the user forgets to close it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这么做的主要目的是万一用户忘记关闭socket了，那么在这个对象被回收的时候能主动关闭socket来释放一些系统资源，但是如果真的是用户忘记关闭了，那这些socket对象可能因为FinalizeThread迟迟没有执行到这些socket对象的finalize方法，而导致内存泄露，这种问题碰到过多次，需要特别注意的是对于已经没有地方引用的这些finalizer对象，并不会在最近的那一次gc里马上回收掉，而是会延迟到下一个或者下几个gc时才被回收，因为执行finalize方法的动作无法在gc过程中执行，万一finalize方法执行很长呢，所以只能在这个gc周期里将这个垃圾对象重新标活，直到执行完finalize方法从queue里删除，这样下次gc的时候就真的是漂浮垃圾了会被回收，因此建议是千万不要在运行期不断创建finalizer对象，不然会很悲剧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>finalizer对象因为Finalizer的引用而变成了一个临时的强引用，即使没有其他的强引用了，还是无法立即被回收；</p>
<p>finalizer对象至少经历两次GC才能被回收，因为只有在FinalizerThread执行完了finalizer对象的finalize方法的情况下才有可能被下次gc回收，而有可能期间已经经历过多次gc了，但是一直还没执行finalizer对象的finalize方法；</p>
<p>cpu资源比较稀缺的情况下FinalizerThread线程有可能因为优先级比较低而延迟执行finalizer对象的finalize方法；</p>
<p>因为finalizer对象的finalize方法迟迟没有执行，有可能会导致大部分finalizer对象进入到old分代，此时容易引发old分代的gc，甚至fullgc，gc暂停时间明显变长；</p>
<p>finalizer对象的finalize方法被调用了，但是这个对象其实还并没有被回收，虽然可能在不久的将来会被回收。</p>
<hr>
<p>转载自：<br><a href="http://lovestblog.cn/blog/2015/07/09/final-reference/">http://lovestblog.cn/blog/2015/07/09/final-reference/</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>Reference</category>
      </categories>
  </entry>
  <entry>
    <title>线程泄漏</title>
    <url>/2024/03/11/Java/Java%E8%BF%9B%E9%98%B6/%E7%BA%BF%E7%A8%8B&amp;%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<p>当单线程应用程序中的主线程抛出一个未捕获的异常时，因为控制台中会打印堆栈跟踪（也因为程序停止），所以很可能注意到。但在多线程应用程序中，尤其是在作为服务器运行并且不与控制台相连的应用程序中，线程死亡可能成为不太引人注目的事件，这会导致局部系统失败，从而产生混乱的应用程序行为。</p>
<p>编写得不正确的线程池会“泄漏”线程，直到最终丢失所有线程。大多数线程池实现通过捕获抛出的异常或重新启动死亡的线程来防止这一点，但线程泄漏的问题并不仅限于线程池，使用线程来为工作队列提供服务的服务器应用程序也可能具有这种问题。当服务器应用程序丢失了一个工作线程（worker thread）时，在较长时间内应用程序仍可能显得一切正常，这使得该问题的真实原因难以确定。 </p>
<p>许多应用程序用线程来提供后台服务：处理来自事件队列的任务、从套接字读取命令或执行UI线程以外的长期任务。当由于抛出未捕获的 RuntimeException 或 Error ，或者只是停下来，等待阻塞的 I&#x2F;O 操作（原本未预计到阻塞），从而引起这些线程之一死亡时，会发生什么呢？</p>
<p>有时，譬如当线程执行由用户启动的长期任务（如拼写检查）时，用户会注意到任务没有进展，他们可能会异常终止操作或程序。但其它时间，后台线程执行“清理维护”任务 ，它们可能消失很长时间而不被察觉。</p>
  <span id="more"></span>

<p>服务器应用程序中的线程泄漏问题在于不是总是容易从外部检测它。因为大多数线程只处理服务器的部分工作负载，或可能仅处理特定类型的后台任务，所以当程序实际上遭遇严重故障时，在用户看来它仍在正常工作。这一点，再加上引起线程泄漏的因素并不总是留下明显痕迹，就会引起令人惊讶甚或使人迷惑的应用程序行为。</p>
<p>当线程抛出未捕获的异常或错误时它们可能消失；而当线程等待的 I&#x2F;O 操作永远不会完成，或没人为它们等待的监视器调用 <code>notify() </code>时，它们只是停止工作。意外线程死亡的最常见根源是 <code>RuntimeException</code>（如<code>NullPointerException</code>、 <code>ArrayIndexOutOfBoundsException</code> 等）。在多线程应用程序中，由于未查出的异常，线程会无声无息地死亡，使得用户和开发人员对于发生的问题和为什么发生这些问题毫无头绪。</p>
<p>所以，对于服务方法，我们应该怀疑，它是不是真好到可以假设它从不抛出未查出异常的程度。如果服务例程抛出 RuntimeException ，则调用线程应该捕获这个异常。</p>
<p>示例一中的代码是典型的从工作队列处理 Runnable 任务的线程，<code>handleMessage()</code>方法可能抛出 RuntimeException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrustingPoolWorker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        IncomingResponse ir;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">            ir = (IncomingResponse) queue.getNext(); </span><br><span class="line">            <span class="type">PlugIn</span> <span class="variable">plugIn</span> <span class="operator">=</span> findPlugIn(ir.getResponseId()); </span><br><span class="line">            <span class="keyword">if</span> (plugIn != <span class="literal">null</span>) </span><br><span class="line">                plugIn.handleMessage(ir.getResponse()); </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                log(<span class="string">&quot;Unknown plug-in for response &quot;</span> + ir.getResponseId());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>只要通过捕获RuntimeException ，然后进行纠正操作，就可以防止破坏整个服务器。</p>
<p>示例二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SaferPoolWorker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        IncomingResponse ir;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">            ir = (IncomingResponse) queue.getNext(); </span><br><span class="line">            <span class="type">PlugIn</span> <span class="variable">plugIn</span> <span class="operator">=</span> findPlugIn(ir.getResponseId()); </span><br><span class="line">            <span class="keyword">if</span> (plugIn != <span class="literal">null</span>) &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123; </span><br><span class="line">                    plugIn.handleMessage(ir.getResponse()); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; </span><br><span class="line">                    <span class="comment">// Take some sort of action; </span></span><br><span class="line">                    <span class="comment">// - log the exception and move on </span></span><br><span class="line">                    <span class="comment">// - log the exception and restart the worker thread </span></span><br><span class="line">                    <span class="comment">// - log the exception and unload the offending plug-in </span></span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> </span><br><span class="line">                log(<span class="string">&quot;Unknown plug-in for response &quot;</span> + ir.getResponseId());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>除了将外来代码视作较可能抛出 RuntimeException 的方法之外，使用 ThreadGroup 类的uncaughtException 函数也是明智的。如果线程组中的一个线程因抛出一个未捕获的异常而死亡，则调用该线程组的 uncaughtException() 方法，该方法可以向日志写入一条记录、重新启动线程，然后重新启动系统，或采取它认为必要的任何纠正或诊断操作。至少，如果在线程死亡时所有线程都写一条日志消息，将有一个何时、何处出错的记录，而不是只能奇怪处理线程到哪里去了。</p>
<p>对于使用线程池时，可以使用下面方法来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ThreadFactoryBuilder <span class="title function_">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler uncaughtExceptionHandler)</span></span><br></pre></td></tr></table></figure>



<p>当线程从应用程序中消失时会引起混乱，并且在很多情况下，线程消失时没有（堆栈）跟踪。象对付许多风险一样，防止线程泄漏的最佳方法是预防和检测相结合；注意有可能抛出RuntimeException的地方（如调用外来代码时），并使用ThreadGroup提供的 uncaughtException 处理程序来在线程异常终止时进行检测。</p>
<hr>
<p>转载自：<br><a href="http://blog.csdn.net/huoyunshen88/article/details/8618642">http://blog.csdn.net/huoyunshen88/article/details/8618642</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
        <category>线程&amp;线程池</category>
      </categories>
  </entry>
  <entry>
    <title>CMS垃圾收集器</title>
    <url>/2024/04/01/Java/JVM/GC%E7%9B%B8%E5%85%B3/CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<ul>
<li><p>初始标记（CMS initial mark）只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p>
</li>
<li><p>并发标记（CMS concurrent mark）进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p>
</li>
<li><p>重新标记（CMS remark）为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</p>
</li>
<li><p>并发清除（CMS concurrent sweep）清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。</p>
</li>
<li><p>重置(CMS concurrent reset) 清理数据结构,为下一个并发收集做准备.</p>
</li>
</ul>
 <span id="more"></span>

<p>​      由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</p>
<p><strong>CMS收集器有以下三个不足：</strong></p>
<p>a.   CMS收集器对CPU资源非常敏感。在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源而导致应用程序变慢），总吞吐量会降低。CMS默认启动的回收线程数&#x3D;(CPU数量+3)&#x2F;4，在用户程序本来CPU负荷已经比较高的情况下，如果还要分出CPU资源用来运行垃圾收集器线程，会使得CPU负载加重。</p>
<p>b.   CMS无法处理浮动垃圾(Floating Garbage)，可能会导致“Concurrent Mode Failure“而导致另一次Full GC的产生。在与用户线程并发运行的过程中，不断会有新的垃圾产生，这部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只能留待下一次GC时再清理，这部分垃圾就称为“浮动垃圾”。 CMS垃圾收集器不能像其它垃圾收集器那样等待年老代几乎完全被填满之后再进行收集，需要预留一部分空间供并发收集时的使用，可以通过参数<code>-XX:CMSInitiatingOccupancyFraction</code>来设置年老代空间达到多少的百分比时触发CMS进行垃圾收集。如果在CMS运行期间，预留的内存无法满足程序需要，就会出现一次“ConcurrentMode Failure“，此时虚拟机将启动预备方案，临时使用Serial Old收集器重新进行年老代垃圾回收。</p>
<p>c.   CMS收集器是基于标记-清除算法，因此不可避免会产生大量不连续的内存碎片，空间碎片过多时，将会给大对象分配带来很大麻烦。如果无法找到足够大的连续内存来分配对象时，将会触发因此Full GC。CMS提供一个开关参数<code>-XX:+UseCMSCompactAtFullCollection</code>，用于指定在Full GC之后进行内存整理，这个过程无法并发，会导致垃圾收集停顿时间变长，CMS提供了另外一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>，用于设置在执行多少次不压缩的Full GC之后，跟着来一次带压缩的Full GC。</p>
<p>相关的参数配置可以参考<a href="http://blog.csdn.net/zero__007/article/details/49278849%E4%B8%AD%E5%85%B3%E4%BA%8ECMS%E7%9A%84%E4%BB%8B%E7%BB%8D%E3%80%82">http://blog.csdn.net/zero__007/article/details/49278849中关于CMS的介绍。</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>GC相关</category>
      </categories>
  </entry>
  <entry>
    <title>ReferenceQueue、Reference详解</title>
    <url>/2024/03/01/Java/JVM/Reference/ReferenceQueue%E3%80%81Reference%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h3><p>引用队列，在检测到适当的可到达性更改后，垃圾回收器将已注册的引用对象添加到该队列中，ReferenceQueue实现了入队（enqueue）和出队（poll），还有remove)操作，内部元素head就是泛型的Reference：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Reference&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; head = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>ReferenceQueue的实现是由Reference自身的链表结构（单向循环链表）所实现的。所以说ReferenceQueue名义上是一个队列，但实际内部并非有实际的存储结构，它的存储是依赖于内部节点之间的关系来表达。来看下它的入队方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> &#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// Check that since getting the lock this reference hasn&#x27;t already been</span></span><br><span class="line">        <span class="comment">// enqueued (and even then removed)</span></span><br><span class="line">        ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">        <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> queue == <span class="built_in">this</span>;</span><br><span class="line">        r.queue = ENQUEUED;</span><br><span class="line">        r.next = (head == <span class="literal">null</span>) ? r : head;</span><br><span class="line">        head = r;</span><br><span class="line">        queueLength++;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">            sun.misc.VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    从enqueue()代码可以看出来，queue仅存储当前的head节点，而后面的节点由每个reference节点通过自己的next来保持的。而且queue是一个后进先出的队列。当新的节点进入时成为了head，然后出队时也是先出的head。</p>
 <span id="more"></span> 

<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>​    java.lang.ref.Reference是SoftReference、WeakReference、PhantomReference的基类。Reference对象是和垃圾回收密切配合实现，Reference的直接子类都是由JVM定制化处理的，因此在代码中直接继承于Reference类型没有任何作用。但可以继承JVM定制的Reference的子类。例如：Cleaner就继承了PhantomReference。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>Reference内部提供2个构造函数，一个带queue，一个不带queue。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="built_in">this</span>(referent, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="built_in">this</span>.referent = referent;</span><br><span class="line">    <span class="built_in">this</span>.queue = (queue == <span class="literal">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        其中queue的意义在于可以在外部对这个queue进行监控。如果有对象即将被回收，那么相应的reference对象就会被放到这个queue里，我们就拿到reference再作一些事情。而如果不带的话，就只有不断地轮询reference对象，通过判断里面的get是否返回null，来判断是否被回收。phantomReference对象不能这样作，其get始终返回null，因此它只有带queue的构造函数。queue的默认值是ReferenceQueue.NULL。</p>
<p>​        以上这两种构造方法均有相应的使用场景，取决于实际的应用。如WeakHashMap中就选择去查询queue的数据，来判定是否有对象将被回收。而ThreadLocalMap则采用判断get()是否为null来作处理。</p>
<p>​        如果在创建一个引用对象时，指定了ReferenceQueue，那么当引用对象指向的对象达到合适的状态（根据引用类型不同而不同）时，GC会把引用对象本身添加到这个队列中，方便我们处理它，因为“引用对象指向的对象GC会自动清理，但是引用对象本身也是对象（是对象就占用一定资源），所以需要我们自己清理。”</p>
<h4 id="Reference内部主要的成员"><a href="#Reference内部主要的成员" class="headerlink" title="Reference内部主要的成员"></a>Reference内部主要的成员</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br><span class="line"><span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When active:   NULL</span></span><br><span class="line"><span class="comment">     *     pending:   this</span></span><br><span class="line"><span class="comment">     *    Enqueued:   next reference in queue (or this if last)</span></span><br><span class="line"><span class="comment">     *    Inactive:   this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Reference next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When active:   next element in a discovered reference list maintained by GC (or this if last)</span></span><br><span class="line"><span class="comment">     *     pending:   next element in the pending list (or null if last)</span></span><br><span class="line"><span class="comment">     *   otherwise:   NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of References waiting to be enqueued.  The collector adds</span></span><br><span class="line"><span class="comment">     * References to this list, while the Reference-handler thread removes</span></span><br><span class="line"><span class="comment">     * them.  This list is protected by the above lock object. The</span></span><br><span class="line"><span class="comment">     * list uses the discovered field to link its elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Reference&lt;Object&gt; pending = <span class="literal">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        referent表示其引用的对象，即在构造的时候需要被包装在其中的对象。</p>
<p>​        queue是对象即将被回收时所要通知的队列。当对象即将被回收时，整个reference对象，而不仅仅是被回收的对象，会被放到queue里面，然后外部程序即可通过监控这个queue拿到相应的数据了。</p>
<p>​        next即当前引用节点所存储的下一个即将被处理的节点。但next仅在放到queue中才会有意义，因为只有在enqueue的时候，会将next设置为下一个要处理的Reference对象。为了描述相应的状态值，在放到队列当中后，其queue就不会再引用这个队列了。而是引用一个特殊的ENQUEUED（内部定义的一个空队列）。因为已经放到队列当中，并且不会再次放到队列当中。</p>
<p>​        discovered表示要处理的对象的下一个对象。即可以理解要处理的对象也是一个链表，通过discovered进行排队，这边只需要不停地拿到pending，然后再通过discovered不断地拿到下一个对象赋值给pending即可，直到取到了最有一个。它是被JVM使用的。</p>
<p>​        pending是等待被入队的引用列表。JVM收集器会添加引用到这个列表，直到Reference-handler线程移除了它们。这个列表使用discovered字段来连接它下一个元素（即pending的下一个元素就是discovered对象。<code>r = pending; pending = r.discovered</code>）。</p>
<h4 id="Reference状态值"><a href="#Reference状态值" class="headerlink" title="Reference状态值"></a>Reference状态值</h4><p>​        每个引用对象都有相应的状态描述，即描述自己以及其包装的对象当前处于一个什么样的状态，以方便进行查询，定位或处理。Reference有4种状态。四种状态用Reference的成员变量queue与next来标示。</p>
<p>​        Active：活动状态，新创建的引用对象都是这个状态，即相应的对象为强引用状态。在这个状态下next &#x3D;&#x3D; null，queue为构造Reference对象时传入的ReferenceQueue对象，默认是ReferenceQueue.NULL。在GC检测到引用对象的可达性发生变化之后，它的状态将变化为Pending或Inactive（如果引用对象在构造时指定了ReferenceQueue，那么转移到Pending；如果没指定，转移到Inactive）。</p>
<p>​        Pending：准备放入queue当中的引用对象，在这个状态的对象将挨个地排队放到queue当中。在这个时间窗口期，相应的对象为Pending状态，都在pending列表中。此状态的下，next &#x3D;&#x3D; this（由JVM设置），queue为定义时所引用的queue。这里需要注意的是，queue如果指定了，那么引用对象能转移到Pending，如果没指定，直接转移到Inactive，因为此时next &#x3D;&#x3D; this，queue &#x3D;&#x3D; ReferenceQueue.NULL。</p>
<p>​        Enqueued：引用对象已经放到queue当中了。准备由外部线程来询循queue获取相应的数据。调用ReferenceQueue.enqueued()后的reference就会处于这个状态中。此状态中next 为该queue中的下一个引用，如果是该队列中的最后一个，那么为this，queue &#x3D; ReferenceQueue.ENQUEUED。当reference实例从它的ReferenceQueue移除后，它将成为Inactive。没有注册queue的实例不会进入这个状态。</p>
<p>​        Inactive：即此对象已经由外部从queue中获取到，并且已经处理掉了，此时next &#x3D;&#x3D; this，queue &#x3D;&#x3D; ReferenceQueue.NULL。即意味着此引用对象可以被回收，并且对内部封装的对象也可以被回收掉了。但实际的回收运行取决于clear()方法是否被调用（clear()方法会设置this.referent &#x3D; null）。</p>
<p>Reference类加载后，就会启动Reference Handler线程:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">ThreadGroup</span> <span class="variable">tgn</span> <span class="operator">=</span> tg;</span><br><span class="line">         tgn != <span class="literal">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceHandler</span>(tg, <span class="string">&quot;Reference Handler&quot;</span>);</span><br><span class="line">    <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">     * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    handler.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    handler.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，这个线程在Reference类的static构造块中启动，并且被设置为最高优先级MAX_PRIORITY和daemon状态，并随即启动该线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="built_in">super</span>(g, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Reference&lt;Object&gt; r;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pending != <span class="literal">null</span>) &#123;</span><br><span class="line">                    r = pending;</span><br><span class="line">                    pending = r.discovered;</span><br><span class="line">                    r.discovered = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123; &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123; &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Fast path for cleaners</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">                ((Cleaner)r).clean();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReferenceQueue&lt;Object&gt; q = r.queue;</span><br><span class="line">            <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此线程要做的事情就是不断的检查pending是否为null，如果pending不为null，则将pending进行enqueue，否则线程进入wait状态。</p>
<p>当Reference内部的referent对象的可达状态改变时，JVM会将该Reference对象放入pending链表，注意这时JVM会设置referent对象的next &#x3D; this。并且这里enqueue的队列是在初始化Reference对象时传进来的queue，如果传入了null（实际使用的是ReferenceQueue.NULL），则ReferenceHandler则不进行enqueue操作，这时referent对象的状态已经是Inactive了。只有非RefernceQueue.NULL的queue才会将Reference进行enqueue。</p>
<p>​    在enqueue()中，当reference实例的<code>queue!=null &amp;&amp; queue != ENQUEUED</code>时；设置queue为ENQUEUED，next为下一个要处理的reference对象，或者若为最后一个则next&#x3D;&#x3D;this。这时referent对象是Enqueue。</p>
<p>​    当调用queue的remove或者poll方法时，就会将要处理的reference实例的queue设置为<code>ReferenceQueue.NULL，next = this</code>，此时reference实例就进入了Inactive状态，等待JVM回收。</p>
<p>具体执行过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个引用队列</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建虚引用，此时状态为Active，并且Reference.pending为空，当前Reference.queue = 上面创建的queue，并且next=null</span></span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(<span class="keyword">new</span> <span class="title class_">Object</span>(), queue);</span><br><span class="line">System.out.println(reference);</span><br><span class="line"><span class="comment">// 当GC执行后，由于是虚引用，所以回收该object对象，并且置于pending上，此时reference的状态为PENDING</span></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ReferenceHandler从pending中取下该元素，并且将该元素放入到queue中，此时Reference状态为ENQUEUED，Reference.queue = ReferenceENQUEUED */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当从queue里面取出该元素，则变为INACTIVE，Reference.queue = Reference.NULL */</span></span><br><span class="line"><span class="type">Reference</span> <span class="variable">reference1</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">System.out.println(reference1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<hr>
<p>转载自：<br><a href="http://www.jianshu.com/p/f86d3a43eec5">http://www.jianshu.com/p/f86d3a43eec5</a><br><a href="http://www.cnblogs.com/jabnih/p/6580665.html">http://www.cnblogs.com/jabnih/p/6580665.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>Reference</category>
      </categories>
  </entry>
  <entry>
    <title>9种常见的CMS GC问题分析与解决</title>
    <url>/2024/04/01/Java/JVM/GC%E7%9B%B8%E5%85%B3/9%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84CMS%20GC%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="GC-Cause"><a href="#GC-Cause" class="headerlink" title="GC Cause"></a>GC Cause</h1><p>JVM 什么样的条件下选择进行 GC 操作，具体 Cause 的分类可以看一下 Hotspot 源码：src&#x2F;share&#x2F;vm&#x2F;gc&#x2F;shared&#x2F;gcCause.hpp 和 src&#x2F;share&#x2F;vm&#x2F;gc&#x2F;shared&#x2F;gcCause.cpp 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char* GCCause::to_string(GCCause::Cause cause) &#123;</span><br><span class="line">  switch (cause) &#123;</span><br><span class="line">    case _java_lang_system_gc:</span><br><span class="line">      return &quot;System.gc()&quot;;</span><br><span class="line"></span><br><span class="line">    case _full_gc_alot:</span><br><span class="line">      return &quot;FullGCAlot&quot;;</span><br><span class="line">     </span><br><span class="line">    case _scavenge_alot:</span><br><span class="line">      return &quot;ScavengeAlot&quot;;</span><br><span class="line">     </span><br><span class="line">    case _allocation_profiler:</span><br><span class="line">      return &quot;Allocation Profiler&quot;;</span><br><span class="line">     </span><br><span class="line">    case _jvmti_force_gc:</span><br><span class="line">      return &quot;JvmtiEnv ForceGarbageCollection&quot;;</span><br><span class="line">     </span><br><span class="line">    case _gc_locker:</span><br><span class="line">      return &quot;GCLocker Initiated GC&quot;;</span><br><span class="line">     </span><br><span class="line">    case _heap_inspection:</span><br><span class="line">      return &quot;Heap Inspection Initiated GC&quot;;</span><br><span class="line">     </span><br><span class="line">    case _heap_dump:</span><br><span class="line">      return &quot;Heap Dump Initiated GC&quot;;</span><br><span class="line">     </span><br><span class="line">    case _wb_young_gc:</span><br><span class="line">      return &quot;WhiteBox Initiated Young GC&quot;;</span><br><span class="line">     </span><br><span class="line">    case _wb_conc_mark:</span><br><span class="line">      return &quot;WhiteBox Initiated Concurrent Mark&quot;;</span><br><span class="line">     </span><br><span class="line">    case _wb_full_gc:</span><br><span class="line">      return &quot;WhiteBox Initiated Full GC&quot;;</span><br><span class="line">     </span><br><span class="line">    case _no_gc:</span><br><span class="line">      return &quot;No GC&quot;;</span><br><span class="line">     </span><br><span class="line">    case _allocation_failure:</span><br><span class="line">      return &quot;Allocation Failure&quot;;</span><br><span class="line">     </span><br><span class="line">    case _tenured_generation_full:</span><br><span class="line">      return &quot;Tenured Generation Full&quot;;</span><br><span class="line">     </span><br><span class="line">    case _metadata_GC_threshold:</span><br><span class="line">      return &quot;Metadata GC Threshold&quot;;</span><br><span class="line">     </span><br><span class="line">    case _metadata_GC_clear_soft_refs:</span><br><span class="line">      return &quot;Metadata GC Clear Soft References&quot;;</span><br><span class="line">     </span><br><span class="line">    case _cms_generation_full:</span><br><span class="line">      return &quot;CMS Generation Full&quot;;</span><br><span class="line">     </span><br><span class="line">    case _cms_initial_mark:</span><br><span class="line">      return &quot;CMS Initial Mark&quot;;</span><br><span class="line">     </span><br><span class="line">    case _cms_final_remark:</span><br><span class="line">      return &quot;CMS Final Remark&quot;;</span><br><span class="line">     </span><br><span class="line">    case _cms_concurrent_mark:</span><br><span class="line">      return &quot;CMS Concurrent Mark&quot;;</span><br><span class="line">     </span><br><span class="line">    case _old_generation_expanded_on_last_scavenge:</span><br><span class="line">      return &quot;Old Generation Expanded On Last Scavenge&quot;;</span><br><span class="line">     </span><br><span class="line">    case _old_generation_too_full_to_scavenge:</span><br><span class="line">      return &quot;Old Generation Too Full To Scavenge&quot;;</span><br><span class="line">     </span><br><span class="line">    case _adaptive_size_policy:</span><br><span class="line">      return &quot;Ergonomics&quot;;</span><br><span class="line">     </span><br><span class="line">    case _g1_inc_collection_pause:</span><br><span class="line">      return &quot;G1 Evacuation Pause&quot;;</span><br><span class="line">     </span><br><span class="line">    case _g1_humongous_allocation:</span><br><span class="line">      return &quot;G1 Humongous Allocation&quot;;</span><br><span class="line">     </span><br><span class="line">    case _dcmd_gc_run:</span><br><span class="line">      return &quot;Diagnostic Command&quot;;</span><br><span class="line">     </span><br><span class="line">    case _last_gc_cause:</span><br><span class="line">      return &quot;ILLEGAL VALUE - last gc cause - ILLEGAL VALUE&quot;;</span><br><span class="line">     </span><br><span class="line">    default:</span><br><span class="line">      return &quot;unknown GCCause&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  ShouldNotReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点需要关注的几个GC Cause：</p>
<ul>
<li><p>System.gc()：手动触发GC操作。</p>
</li>
<li><p>CMS：CMS GC 在执行过程中的一些动作，重点关注 CMS Initial Mark 和 CMS Final Remark 两个 STW 阶段。</p>
</li>
<li><p>Promotion Failure：Old 区没有足够的空间分配给 Young 区晋升的对象（即使总可用内存足够大）。</p>
</li>
<li><p>Concurrent Mode Failure：CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化，严重影响 GC 性能，下面的一个案例即为这种场景。</p>
</li>
<li><p>GCLocker Initiated GC：如果线程执行在 JNI 临界区时，刚好需要进行 GC，此时 GC Locker 将会阻止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="GC-问题分类"><a href="#GC-问题分类" class="headerlink" title="GC 问题分类"></a>GC 问题分类</h1><p>笔者选取了九种不同类型的 GC 问题，覆盖了大部分场景，如果有更好的场景，欢迎在评论区给出。</p>
<ul>
<li><p>Unexpected GC：意外发生的 GC，实际上不需要发生，我们可以通过一些手段去避免。</p>
<ul>
<li>Space Shock：空间震荡问题，参见“场景一：动态扩容引起的空间震荡”。</li>
<li>Explicit GC：显示执行 GC 问题，参见“场景二：显式 GC 的去与留”。</li>
</ul>
</li>
<li><p>Partial GC：部分收集操作的 GC，只对某些分代&#x2F;分区进行回收。</p>
<ul>
<li><p>Young GC：分代收集里面的 Young 区收集动作，也可以叫做 Minor GC。</p>
<ul>
<li>ParNew：Young GC 频繁，参见“场景四：过早晋升”。</li>
</ul>
</li>
<li><p>Old GC：分代收集里面的 Old 区收集动作，也可以叫做 Major GC，有些也会叫做 Full GC，但其实这种叫法是不规范的，在 CMS 发生 Foreground GC 时才是 Full GC，CMSScavengeBeforeRemark 参数也只是在 Remark 前触发一次Young GC。</p>
<ul>
<li>CMS：Old GC 频繁，参见“场景五：CMS Old GC 频繁”。</li>
<li>CMS：Old GC 不频繁但单次耗时大，参见“场景六：单次 CMS Old GC 耗时长”。</li>
</ul>
</li>
</ul>
</li>
<li><p>Full GC：全量收集的 GC，对整个堆进行回收，STW 时间会比较长，一旦发生，影响较大，也可以叫做 Major GC，参见“场景七：内存碎片&amp;收集器退化”。</p>
</li>
<li><p>MetaSpace：元空间回收引发问题，参见“场景三：MetaSpace 区 OOM”。</p>
</li>
<li><p>Direct Memory：直接内存（也可以称作为堆外内存）回收引发问题，参见“场景八：堆外内存 OOM”。</p>
</li>
<li><p>JNI：本地 Native 方法引发问题，参见“场景九：JNI 引发的 GC 问题”。</p>
</li>
</ul>
<h2 id="场景一：动态扩容引起的空间震荡"><a href="#场景一：动态扩容引起的空间震荡" class="headerlink" title="场景一：动态扩容引起的空间震荡"></a>场景一：动态扩容引起的空间震荡</h2><p><strong>1.1 现象</strong></p>
<p>服务刚刚启动时 GC 次数较多，最大空间剩余很多但是依然发生 GC，这种情况我们可以通过观察 GC 日志或者通过监控工具来观察堆的空间变化情况即可。GC Cause 一般为 Allocation Failure，且在 GC 日志中会观察到经历一次 GC ，堆内各个空间的大小会被调整，如下图所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291400583.png" alt="img"></p>
<p><strong>1.2 原因</strong></p>
<p>在 JVM 的参数中 -Xms 和 -Xmx 设置的不一致，在初始化时只会初始 -Xms 大小的空间存储信息，每当空间不够用时再向操作系统申请，这样的话必然要进行一次 GC。另外，如果空间剩余很多时也会进行缩容操作，JVM 通过 -XX:MinHeapFreeRatio 和 -XX:MaxHeapFreeRatio 来控制扩容和缩容的比例。</p>
<p><strong>1.3 策略</strong></p>
<p>定位：观察 CMS GC 触发时间点 Old&#x2F;MetaSpace 区的 committed 占比是不是一个固定的值，或者像上文提到的观察总的内存使用率也可以。</p>
<p>解决：尽量将成对出现的空间大小配置参数设置成固定的，如 -Xms 和 -Xmx，-XX:MaxNewSize 和 -XX:NewSize，-XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 等。</p>
<p><strong>1.4 小结</strong></p>
<p>一般来说，我们需要保证 Java 虚拟机的堆是稳定的，确保 -Xms 和 -Xmx 设置的是一个值（即初始值和最大值一致），获得一个稳定的堆，同理在 MetaSpace 区也有类似的问题。不过在不追求停顿时间的情况下震荡的空间也是有利的，可以动态地伸缩以节省空间，例如作为富客户端的 Java 应用。这个问题虽然初级，但是发生的概率还真不小，尤其是在一些规范不太健全的情况下。</p>
<h2 id="场景二：显式-GC-的去与留"><a href="#场景二：显式-GC-的去与留" class="headerlink" title="场景二：显式 GC 的去与留"></a>场景二：显式 GC 的去与留</h2><p><strong>2.1 现象</strong></p>
<p>除了扩容缩容会触发 CMS GC 之外，还有 Old 区达到回收阈值、MetaSpace 空间不足、Young 区晋升失败、大对象担保失败等几种触发条件，如果这些情况都没有发生却触发了 GC ？这种情况有可能是代码中手动调用了 System.gc 方法，此时可以找到 GC 日志中的 GC Cause 确认下。那么这种 GC 到底有没有问题，翻看网上的一些资料，有人说可以添加 -XX:+DisableExplicitGC 参数来避免这种 GC，也有人说不能加这个参数，加了就会影响 Native Memory 的回收。先说结论，笔者这里建议保留 System.gc，那为什么要保留？我们一起来分析下。</p>
<p><strong>2.2 原因</strong></p>
<p>找到 System.gc 在 Hotspot 中的源码，可以发现增加 -XX:+DisableExplicitGC 参数后，这个方法变成了一个空方法，如果没有加的话便会调用 Universe::heap()::collect 方法，继续跟进到这个方法中，发现 System.gc 会引发一次 STW 的 Full GC，对整个堆做收集。</p>
<p><strong>2.3 策略</strong></p>
<p>通过上面的分析看到，无论是保留还是去掉都会有一定的风险点，不过目前互联网中的 RPC 通信会大量使用 NIO，所以笔者在这里建议保留。此外 JVM 还提供了 -XX:+ExplicitGCInvokesConcurrent  和 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses ，这样的话就能大幅降低了 STW 开销，同时也不会发生 NIO Direct Memory OOM。</p>
<p><strong>2.4 小结</strong></p>
<p>不止 CMS，在 G1 或 ZGC中开启 ExplicitGCInvokesConcurrent 模式，都会采用高性能的并发收集方式进行收集，不过还是建议在代码规范方面也要做好约束，规范好 System.gc 的使用。</p>
<h2 id="场景三：MetaSpace-区-OOM"><a href="#场景三：MetaSpace-区-OOM" class="headerlink" title="场景三：MetaSpace 区 OOM"></a>场景三：MetaSpace 区 OOM</h2><p><strong>3.1 现象</strong></p>
<p>JVM 在启动后或者某个时间点开始，MetaSpace 的已使用大小在持续增长，同时每次 GC 也无法释放，调大 MetaSpace 空间也无法彻底解决。</p>
<p><strong>3.2 原因</strong></p>
<p>在讨论为什么会 OOM 之前，我们先来看一下这个区里面会存什么数据，Java 7 之前字符串常量池被放到了 Perm 区，所有被 intern 的 String 都会被存在这里，由于 String.intern 是不受控的，所以 -XX:MaxPermSize 的值也不太好设置，经常会出现 java.lang.OutOfMemoryError: PermGen space 异常，所以在 Java 7 之后常量池等字面量（Literal）、类静态变量（Class Static）、符号引用（Symbols Reference）等几项被移到 Heap 中。而 Java 8 之后 PermGen 也被移除，取而代之的是 MetaSpace。</p>
<p>在最底层，JVM 通过 mmap 接口向操作系统申请内存映射，每次申请 2MB 空间，这里是虚拟内存映射，不是真的就消耗了主存的 2MB，只有之后在使用的时候才会真的消耗内存。申请的这些内存放到一个链表中 VirtualSpaceList，作为其中的一个 Node。</p>
<p>在上层，MetaSpace 主要由 Klass Metaspace 和 NoKlass Metaspace 两大部分组成。</p>
<ul>
<li><p>Klass MetaSpace：就是用来存 Klass 的，就是 Class 文件在 JVM 里的运行时数据结构，这部分默认放在 Compressed Class Pointer Space 中，是一块连续的内存区域，紧接着 Heap。Compressed Class Pointer Space 不是必须有的，如果设置了 -XX:-UseCompressedClassPointers，或者 -Xmx 设置大于 32 G，就不会有这块内存，这种情况下 Klass 都会存在 NoKlass Metaspace 里。</p>
</li>
<li><p>NoKlass MetaSpace：专门来存 Klass 相关的其他的内容，比如 Method，ConstantPool 等，可以由多块不连续的内存组成。虽然叫做 NoKlass Metaspace，但是也其实可以存 Klass 的内容，上面已经提到了对应场景。</p>
</li>
</ul>
<p>MetaSpace 的对象为什么无法释放，我们看下面两点：</p>
<ul>
<li><p>MetaSpace 内存管理：类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在 Metaspace 中的类元数据也是存活的，不能被回收。每个加载器有单独的存储空间，通过 ClassLoaderMetaspace 来进行管理 SpaceManager* 的指针，相互隔离的。</p>
</li>
<li><p>MetaSpace 弹性伸缩：由于 MetaSpace 空间和 Heap 并不在一起，所以这块的空间可以不用设置或者单独设置，一般情况下避免 MetaSpace 耗尽 VM 内存都会设置一个 MaxMetaSpaceSize，在运行过程中，如果实际大小小于这个值，JVM 就会通过 -XX:MinMetaspaceFreeRatio 和 -XX:MaxMetaspaceFreeRatio 两个参数动态控制整个 MetaSpace 的大小，具体使用可以看 MetaSpaceGC::compute_new_size() 方法（下方代码），这个方法会在 CMSCollector 和 G1CollectorHeap 等几个收集器执行 GC 时调用。这个里面会根据 used_after_gc，MinMetaspaceFreeRatio 和 MaxMetaspaceFreeRatio 这三个值计算出来一个新的 _capacity_until_GC 值（水位线）。然后根据实际的 _capacity_until_GC 值使用 MetaspaceGC::inc_capacity_until_GC() 和 MetaspaceGC::dec_capacity_until_GC() 进行 expand 或 shrink，这个过程也可以参照场景一中的伸缩模型进行理解。</p>
</li>
</ul>
<p>由场景一可知，为了避免弹性伸缩带来的额外 GC 消耗，我们会将 -XX:MetaSpaceSize 和 -XX:MaxMetaSpaceSize 两个值设置为固定的，但是这样也会导致在空间不够的时候无法扩容，然后频繁地触发 GC，最终 OOM。所以关键原因就是 ClassLoader 不停地在内存中 load 了新的 Class ，一般这种问题都发生在动态类加载等情况上。</p>
<p><strong>3.3 策略</strong></p>
<p>了解大概什么原因后，如何定位和解决就很简单了，可以 dump 快照之后通过 JProfiler 或 MAT 观察 Classes 的 Histogram（直方图） 即可，或者直接通过命令即可定位， jcmd 打几次 Histogram 的图，看一下具体是哪个包下的 Class 增加较多就可以定位了。不过有时候也要结合InstBytes、KlassBytes、Bytecodes、MethodAll 等几项指标综合来看下。如下图便是笔者使用 jcmd 排查到一个 Orika 的问题。</p>
<p><code>jcmd &lt;PID&gt; GC.class_stats|awk &#39;&#123;print$13&#125;&#39;|sed  &#39;s/\(.*\)\.\(.*\)/\1/g&#39;|sort |uniq -c|sort -nrk1</code></p>
<p>如果无法从整体的角度定位，可以添加 -XX:+TraceClassLoading 和 -XX:+TraceClassUnLoading 参数观察详细的类加载和卸载信息。</p>
<p><strong>3.4 小结</strong></p>
<p>原理理解比较复杂，但定位和解决问题会比较简单，经常会出问题的几个点有 Orika 的 classMap、JSON 的 ASMSerializer、Groovy 动态加载类等，基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等的技术点上。另外就是及时给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。</p>
<h2 id="场景四：过早晋升"><a href="#场景四：过早晋升" class="headerlink" title="场景四：过早晋升"></a>场景四：过早晋升</h2><p><strong>4.1 现象</strong></p>
<p>这种场景主要发生在分代的收集器上面，专业的术语称为“Premature Promotion”。90% 的对象朝生夕死，只有在 Young 区经历过几次 GC 的洗礼后才会晋升到 Old 区，每经历一次 GC 对象的 GC Age 就会增长 1，最大通过 -XX:MaxTenuringThreshold 来控制。</p>
<p>过早晋升一般不会直接影响 GC，总会伴随着浮动垃圾、大对象担保失败等问题，但这些问题不是立刻发生的，我们可以观察以下几种现象来判断是否发生了过早晋升。</p>
<p>分配速率接近于晋升速率，对象晋升年龄较小。</p>
<p>GC 日志中出现“Desired survivor size 107347968 bytes, new threshold 1(max 6)”等信息，说明此时经历过一次 GC 就会放到 Old 区。</p>
<p>Full GC 比较频繁，且经历过一次 GC 之后 Old 区的变化比例非常大。</p>
<p>比如说 Old 区触发的回收阈值是 80%，经历过一次 GC 之后下降到了 10%，这就说明 Old 区的 70% 的对象存活时间其实很短。</p>
<p>过早晋升的危害：</p>
<ul>
<li><p>Young GC 频繁，总的吞吐量下降。</p>
</li>
<li><p>Full GC 频繁，可能会有较大停顿。</p>
</li>
</ul>
<p><strong>4.2 原因</strong></p>
<p>主要的原因有以下两点：</p>
<ul>
<li><p>Young&#x2F;Eden 区过小：过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升，Young GC 采用的是复制算法，由基础篇我们知道 copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是 copy 的时间（CMS 扫描 Card Table 或 G1 扫描 Remember Set 出问题的情况另说），没来及回收的对象增大了回收的代价，所以 Young GC  时间增加，同时又无法快速释放空间，Young GC 次数也跟着增加。</p>
</li>
<li><p>分配速率过大：可以观察出问题前后 Mutator 的分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。</p>
</li>
</ul>
<p>同时无法 GC 掉对象还会带来另外一个问题，引发动态年龄计算：JVM 通过 -XX:MaxTenuringThreshold 参数来控制晋升年龄，每经过一次 GC，年龄就会加一，达到最大年龄就可以进入 Old 区，最大值为 15（因为 JVM 中使用 4 个比特来表示对象的年龄）。设定固定的 MaxTenuringThreshold 值作为晋升条件：</p>
<ul>
<li><p>MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在 Survivor 区，直到 Survivor 区溢出，一旦溢出发生，Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。</p>
</li>
<li><p>MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。</p>
</li>
</ul>
<p>相同应用在不同时间的表现不同，特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面问题，所以 Hotspot 会使用动态计算的方式来调整晋升的阈值。</p>
<p><strong>4.3 策略</strong></p>
<p>知道问题原因后我们就有解决的方向，如果是 Young&#x2F;Eden 区过小，我们可以在总的 Heap 内存不变的情况下适当增大 Young 区，具体怎么增加？一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。</p>
<p>拿笔者的一次典型过早晋升优化来看，原配置为 Young 1.2G + Old 2.8G，通过观察 CMS GC 的情况找到存活对象大概为 300~400M，于是调整 Old 1.5G 左右，剩下 2.5G 分给 Young 区。仅仅调了一个 Young 区大小参数（-Xmn），整个 JVM 一分钟 Young GC 从 26 次降低到了 11 次，单次时间也没有增加，总的 GC 时间从 1100ms 降低到了 500ms，CMS GC 次数也从 40 分钟左右一次降低到了 7 小时 30 分钟一次。</p>
<p>如果是分配速率过大：</p>
<ul>
<li><p>偶发较大：通过内存分析工具找到问题代码，从业务逻辑上做一些优化。</p>
</li>
<li><p>一直较大：当前的 Collector 已经不满足 Mutator 的期望了，这种情况要么扩容 Mutator 的 VM，要么调整 GC 收集器类型或加大空间。</p>
</li>
</ul>
<p><strong>4.4 小结</strong></p>
<p>过早晋升问题一般不会特别明显，但日积月累之后可能会爆发一波收集器退化之类的问题，所以我们还是要提前避免掉的，可以看看自己系统里面是否有这些现象，如果比较匹配的话，可以尝试优化一下。一行代码优化的 ROI 还是很高的。</p>
<p>如果在观察 Old 区前后比例变化的过程中，发现可以回收的比例非常小，如从 80% 只回收到了 60%，说明我们大部分对象都是存活的，Old 区的空间可以适当调大些。</p>
<h2 id="场景五：CMS-Old-GC-频繁"><a href="#场景五：CMS-Old-GC-频繁" class="headerlink" title="场景五：CMS Old GC 频繁"></a>场景五：CMS Old GC 频繁</h2><p><strong>5.1 现象</strong></p>
<p>Old 区频繁的做 CMS GC，但是每次耗时不是特别长，整体最大 STW 也在可接受范围内，但由于 GC 太频繁导致吞吐下降比较多。</p>
<p><strong>5.2 原因</strong></p>
<p>这种情况比较常见，基本都是一次 Young GC 完成后，负责处理 CMS GC 的一个后台线程 concurrentMarkSweepThread 会不断地轮询，使用 shouldConcurrentCollect() 方法做一次检测，判断是否达到了回收条件。如果达到条件，使用 collect_in_background() 启动一次 Background 模式 GC。轮询的判断是使用 sleepBeforeNextCycle() 方法，间隔周期为 -XX:CMSWaitDuration 决定，默认为2s。</p>
<p>是否触发 GC，分为以下几种情况：</p>
<ul>
<li><p>CMS 默认采用 JVM 运行时的统计数据判断是否需要触发 CMS GC，如果需要根据 -XX:CMSInitiatingOccupancyFraction 的值进行判断，需要设置参数 -XX:+UseCMSInitiatingOccupancyOnly。</p>
</li>
<li><p>如果开启了 -XX:UseCMSInitiatingOccupancyOnly 参数，判断当前 Old 区使用率是否大于阈值，则触发 CMS GC，该阈值可以通过参数 -XX:CMSInitiatingOccupancyFraction 进行设置，如果没有设置，默认为 92%。</p>
</li>
<li><p>如果之前的 Young GC 失败过，或者下次 Young 区执行 Young GC 可能失败，这两种情况下都需要触发 CMS - GC。</p>
</li>
<li><p>CMS 默认不会对 MetaSpace 或 Perm 进行垃圾收集，如果希望对这些区域进行垃圾收集，需要设置参数 -XX:+CMSClassUnloadingEnabled。</p>
</li>
</ul>
<p><strong>5.3 策略</strong></p>
<p>我们这里还是拿最常见的达到回收比例这个场景来说，与过早晋升不同的是这些对象确实存活了一段时间，Survival Time 超过了 TP9999 时间，但是又达不到长期存活，如各种数据库、网络链接，带有失效时间的缓存等。</p>
<p>处理这种常规内存泄漏问题基本是一个思路，主要步骤如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291402967.png" alt="img"></p>
<p>Dump Diff 和 Leak Suspects 比较直观就不介绍了，这里说下其它几个关键点：</p>
<ul>
<li><p>内存 Dump：使用 jmap、arthas 等 dump 堆进行快照时记得摘掉流量，同时分别在 CMS GC 的发生前后分别 dump 一次。</p>
</li>
<li><p>分析 Top Component：要记得按照对象、类、类加载器、包等多个维度观察 Histogram，同时使用 outgoing 和 incoming 分析关联的对象，另外就是 Soft Reference 和 Weak Reference、Finalizer 等也要看一下。</p>
</li>
<li><p>分析 Unreachable：重点看一下这个，关注下 Shallow 和 Retained 的大小。如下图所示，笔者之前一次 GC 优化，就根据 Unreachable Objects 发现了 Hystrix 的滑动窗口问题。</p>
</li>
</ul>
<p><strong>5.4 小结</strong></p>
<p>经过整个流程下来基本就能定位问题了，不过在优化的过程中记得使用控制变量的方法来优化，防止一些会加剧问题的改动被掩盖。</p>
<h2 id="场景六：单次-CMS-Old-GC-耗时长"><a href="#场景六：单次-CMS-Old-GC-耗时长" class="headerlink" title="场景六：单次 CMS Old GC 耗时长"></a>场景六：单次 CMS Old GC 耗时长</h2><p><strong>6.1 现象</strong></p>
<p>CMS GC 单次 STW 最大超过 1000ms，不会频繁发生，如下图所示最长达到了 8000ms。某些场景下会引起“雪崩效应”，这种场景非常危险，我们应该尽量避免出现。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291403799.png" alt="img"></p>
<p><strong>6.2 原因</strong></p>
<p>CMS 在回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段，也是导致 CMS Old GC 最多的原因，另外有些情况就是在 STW 前等待 Mutator 的线程到达 SafePoint 也会导致时间过长，但这种情况较少，我们在此处主要讨论前者。发生收集器退化或者碎片压缩的场景请看场景七。</p>
<p>想要知道这两个阶段为什么会耗时，我们需要先看一下这两个阶段都会干什么。整个过程中会 STW 的主要是 initial Mark 和 Final Remark。</p>
<ul>
<li><p>CMS Init Mark整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。</p>
</li>
<li><p>CMS Final Remark是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行，如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 Card Table 遍历、Reference 实例的清理并将其加入到 Reference 维护的 pend_list 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源。</p>
</li>
</ul>
<p><strong>6.3 策略</strong></p>
<p>知道了两个 STW 过程执行流程，我们分析解决就比较简单了，由于大部分问题都出在 Final Remark 过程，这里我们也拿这个场景来举例，主要步骤：</p>
<p>【方向】观察详细 GC 日志，找到出问题时 Final Remark 日志，分析下 Reference 处理和元数据处理 real 耗时是否正常，详细信息需要通过 -XX:+PrintReferenceGC 参数开启。基本在日志里面就能定位到大概是哪个方向出了问题，耗时超过 10% 的就需要关注。</p>
<p>【根因】有了具体的方向我们就可以进行深入的分析，一般来说最容易出问题的地方就是 Reference 中的 FinalReference 和元数据信息处理中的 scrub symbol table 两个阶段，想要找到具体问题代码就需要内存分析工具 MAT 或 JProfiler 了，注意要 dump 即将开始 CMS GC 的堆。在用 MAT 等工具前也可以先用命令行看下对象 Histogram，有可能直接就能定位问题。</p>
<ul>
<li><p>对 FinalReference 的分析主要观察 java.lang.ref.Finalizer 对象的 dominator tree，找到泄漏的来源。经常会出现问题的几个点有 Socket 的 SocksSocketImpl 、Jersey 的 ClientRuntime、MySQL 的 ConnectionImpl 等等。</p>
</li>
<li><p>scrub symbol table 表示清理元数据符号引用耗时，符号引用是 Java 代码被编译成字节码时，方法在 JVM 中的表现形式，生命周期一般与 Class 一致，当 _should_unload_classes 被设置为 true 时在 CMSCollector::refProcessingWork() 中与 Class Unload、String Table 一起被处理。</p>
</li>
</ul>
<p>【策略】知道 GC 耗时的根因就比较好处理了，这种问题不会大面积同时爆发，不过有很多时候单台 STW 的时间会比较长，如果业务影响比较大，及时摘掉流量，具体后续优化策略如下：</p>
<ul>
<li><p>FinalReference：找到内存来源后通过优化代码的方式来解决，如果短时间无法定位可以增加 -XX:+ParallelRefProcEnabled 对 Reference 进行并行处理。</p>
</li>
<li><p>symbol table：观察 MetaSpace 区的历史使用峰值，以及每次 GC 前后的回收情况，一般没有使用动态类加载或者 DSL 处理等，MetaSpace 的使用率上不会有什么变化，这种情况可以通过 -XX:-CMSClassUnloadingEnabled 来避免 MetaSpace 的处理，JDK8 会默认开启 CMSClassUnloadingEnabled，这会使得 CMS 在 CMS-Remark 阶段尝试进行类的卸载。</p>
</li>
</ul>
<p><strong>6.4 小结</strong></p>
<p>正常情况进行的 Background CMS GC，出现问题基本都集中在 Reference 和 Class 等元数据处理上，在 Reference 类的问题处理方面，不管是 FinalReference，还是 SoftReference、WeakReference 核心的手段就是找准时机 dump 快照，然后用内存分析工具来分析。Class 处理方面目前除了关闭类卸载开关，没有太好的方法。</p>
<p>在 G1 中同样有 Reference 的问题，可以观察日志中的 Ref Proc，处理方法与 CMS 类似。</p>
<h2 id="场景七：内存碎片-收集器退化"><a href="#场景七：内存碎片-收集器退化" class="headerlink" title="场景七：内存碎片&amp;收集器退化"></a>场景七：内存碎片&amp;收集器退化</h2><p><strong>7.1 现象</strong></p>
<p>并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：</p>
<ul>
<li><p>带压缩动作的算法，称为 MSC，上面我们介绍过，使用标记-清理-压缩，单线程全暂停的方式，对整个堆进行垃圾收集，也就是真正意义上的 Full GC，暂停时间要长于普通 CMS。</p>
</li>
<li><p>不带压缩动作的算法，收集 Old 区，和普通的 CMS 算法比较相似，暂停时间相对 MSC 算法短一些。</p>
</li>
</ul>
<p><strong>7.2 原因</strong></p>
<p>CMS 发生收集器退化主要有以下几种情况。</p>
<ul>
<li>晋升失败（Promotion Failed）</li>
</ul>
<p>顾名思义，晋升失败就是指在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。直觉上乍一看这种情况可能会经常发生，但其实因为有 concurrentMarkSweepThread 和担保机制的存在，发生的条件是很苛刻的，除非是短时间将 Old 区的剩余空间迅速填满，例如上文中说的动态年龄判断导致的过早晋升（见下文的增量收集担保失败）。另外还有一种情况就是内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。</p>
<p>使用 CMS 作为 GC 收集器时，运行过一段时间的 Old 区如下图所示，清除算法导致内存出现多段的不连续，出现大量的内存碎片。</p>
<p>碎片带来了两个问题：</p>
<ol>
<li><p>空间分配效率较低：上文已经提到过，如果是连续的空间 JVM 可以通过使用 pointer bumping 的方式来分配，而对于这种有大量碎片的空闲链表则需要逐个访问 freelist 中的项来访问，查找可以存放新建对象的地址。</p>
</li>
<li><p>空间利用效率变低：Young 区晋升的对象大小大于了连续空间的大小，那么将会触发 Promotion Failed ，即使整个 Old 区的容量是足够的，但由于其不连续，也无法存放新对象，也就是本文所说的问题。</p>
</li>
</ol>
<ul>
<li>增量收集担保失败</li>
</ul>
<p>分配内存失败后，会判断统计得到的 Young GC 晋升到 Old 的平均大小，以及当前 Young 区已使用的大小也就是最大可能晋升的对象大小，是否大于 Old 区的剩余空间。只要 CMS 的剩余空间比前两者的任意一者大，CMS 就认为晋升还是安全的，反之，则代表不安全，不进行Young GC，直接触发Full GC。</p>
<ul>
<li>显式 GC</li>
</ul>
<p>这种情况参见场景二。</p>
<ul>
<li>并发模式失败（Concurrent Mode Failure）</li>
</ul>
<p>最后一种情况，也是发生概率较高的一种，在 GC 日志中经常能看到 Concurrent Mode Failure 关键字。这种是由于并发 Background CMS GC 正在执行，同时又有 Young GC 晋升的对象要放入到了 Old 区中，而此时 Old 区空间不足造成的。</p>
<p>为什么 CMS GC 正在执行还会导致收集器退化呢？主要是由于 CMS 无法处理浮动垃圾（Floating Garbage）引起的。CMS 的并发清理阶段，Mutator 还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。所以 Old 区回收的阈值不能太高，否则预留的内存空间很可能不够，从而导致 Concurrent Mode Failure 发生。</p>
<p><strong>7.3 策略</strong></p>
<p>分析到具体原因后，我们就可以针对性解决了，具体思路还是从根因出发，具体解决策略：</p>
<ul>
<li><p>内存碎片：通过配置 -XX:UseCMSCompactAtFullCollection&#x3D;true 来控制 Full GC的过程中是否进行空间的整理（默认开启，注意是Full GC，不是普通CMS GC），以及 -XX: CMSFullGCsBeforeCompaction&#x3D;n 来控制多少次 Full GC 后进行一次压缩。</p>
</li>
<li><p>增量收集：降低触发 CMS GC 的阈值，即参数 -XX:CMSInitiatingOccupancyFraction 的值，让 CMS GC 尽早执行，以保证有足够的连续空间，也减少 Old 区空间的使用大小，另外需要使用 -XX:+UseCMSInitiatingOccupancyOnly 来配合使用，不然 JVM 仅在第一次使用设定值，后续则自动调整。</p>
</li>
<li><p>浮动垃圾：视情况控制每次晋升对象的大小，或者缩短每次 CMS GC 的时间，必要时可调节 NewRatio 的值。另外就是使用 -XX:+CMSScavengeBeforeRemark 在过程中提前触发一次 Young GC，防止后续晋升过多对象。</p>
</li>
</ul>
<p><strong>7.4 小结</strong></p>
<p>正常情况下触发并发模式的 CMS GC，停顿非常短，对业务影响很小，但 CMS GC 退化后，影响会非常大，建议发现一次后就彻底根治。只要能定位到内存碎片、浮动垃圾、增量收集相关等具体产生原因，还是比较好解决的，关于内存碎片这块，如果 -XX:CMSFullGCsBeforeCompaction 的值不好选取的话，可以使用 -XX:PrintFLSStatistics 来观察内存碎片率情况，然后再设置具体的值。</p>
<p>最后就是在编码的时候也要避免需要连续地址空间的大对象的产生，如过长的字符串，用于存放附件、序列化或反序列化的 byte 数组等，还有就是过早晋升问题尽量在爆发问题前就避免掉。</p>
<h2 id="场景八：堆外内存-OOM"><a href="#场景八：堆外内存-OOM" class="headerlink" title="场景八：堆外内存 OOM"></a>场景八：堆外内存 OOM</h2><p><strong>8.1 现象</strong></p>
<p>内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，通过 top 命令发现 Java 进程的 RES 甚至超过了 -Xmx 的大小。出现这些现象时，基本可以确定是出现了堆外内存泄漏。</p>
<p><strong>8.2 原因</strong></p>
<p>JVM 的堆外内存泄漏，主要有两种的原因：</p>
<ul>
<li><p>通过 UnSafe#allocateMemory，ByteBuffer#allocateDirect 主动申请了堆外内存而没有释放，常见于 NIO、Netty 等相关组件。</p>
</li>
<li><p>代码中有通过 JNI 调用 Native Code 申请的内存没有释放。</p>
</li>
</ul>
<p><strong>8.3 策略</strong></p>
<p>哪种原因造成的堆外内存泄漏？</p>
<p>首先，我们需要确定是哪种原因导致的堆外内存泄漏。这里可以使用 NMT（NativeMemoryTracking） 进行分析。在项目中添加 -XX:NativeMemoryTracking&#x3D;detail JVM参数后重启项目（需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗）。使用命令 jcmd pid VM.native_memory detail 查看内存分布。重点观察 total 中的 committed，因为 jcmd 命令显示的内存包含堆内内存、Code 区域、通过 Unsafe.allocateMemory 和 DirectByteBuffer 申请的内存，但是不包含其他 Native Code（C 代码）申请的堆外内存。</p>
<p>如果 total 中的 committed 和 top 中的 RES 相差不大，则应为主动申请的堆外内存未释放造成的，如果相差较大，则基本可以确定是 JNI 调用造成的。</p>
<ul>
<li>原因一：主动申请未释放</li>
</ul>
<p>JVM 使用 -XX:MaxDirectMemorySize&#x3D;size 参数来控制可申请的堆外内存的最大值。在 Java 8 中，如果未配置该参数，默认和 -Xmx 相等。</p>
<p>NIO 和 Netty 都会取 -XX:MaxDirectMemorySize 配置的值，来限制申请的堆外内存的大小。NIO 和 Netty 中还有一个计数器字段，用来计算当前已申请的堆外内存大小，NIO 中是 java.nio.Bits#totalCapacity、Netty 中 io.netty.util.internal.PlatformDependent#DIRECT_MEMORY_COUNTER。</p>
<p>当申请堆外内存时，NIO 和 Netty 会比较计数器字段和最大值的大小，如果计数器的值超过了最大值的限制，会抛出 OOM 的异常。</p>
<p>NIO 中是：OutOfMemoryError: Direct buffer memory。</p>
<p>Netty 中是：OutOfDirectMemoryError: failed to allocate capacity byte(s) of direct memory (used: usedMemory , max: DIRECT_MEMORY_LIMIT )。</p>
<p>我们可以检查代码中是如何使用堆外内存的，NIO 或者是 Netty，通过反射，获取到对应组件中的计数器字段，并在项目中对该字段的数值进行打点，即可准确地监控到这部分堆外内存的使用情况。</p>
<p>此时，可以通过 Debug 的方式确定使用堆外内存的地方是否正确执行了释放内存的代码。另外，需要检查 JVM 的参数是否有 -XX:+DisableExplicitGC 选项，如果有就去掉，因为该参数会使 System.gc 失效。（场景二：显式 GC 的去与留）</p>
<ul>
<li>原因二：通过 JNI 调用的 Native Code 申请的内存未释放</li>
</ul>
<p>这种情况排查起来比较困难，我们可以通过 Google perftools + Btrace 等工具，帮助我们分析出问题的代码在哪里。</p>
<p>gperftools 是 Google 开发的一款非常实用的工具集，它的原理是在 Java 应用程序运行时，当调用 malloc 时换用它的 libtcmalloc.so，这样就能对内存分配情况做一些统计。我们使用 gperftools 来追踪分配内存的命令。如下图所示，通过 gperftools 发现 Java_java_util_zip_Inflater_init 比较可疑。</p>
<p>接下来可以使用 Btrace，尝试定位具体的调用栈。Btrace 是 Sun 推出的一款 Java 追踪、监控工具，可以在不停机的情况下对线上的 Java 程序进行监控。如下图所示，通过 Btrace 定位出项目中的 ZipHelper 在频繁调用 GZIPInputStream ，在堆外内存分配对象。</p>
<p>最终定位到是，项目中对 GIPInputStream 的使用错误，没有正确的 close()。</p>
<p>除了项目本身的原因，还可能有外部依赖导致的泄漏，如 Netty 和 Spring Boot，详细情况可以学习下这两篇文章：《疑案追踪：Spring Boot内存泄露排查记》、《Netty堆外内存泄露排查盛宴》。</p>
<p><strong>8.4 小结</strong></p>
<p>首先可以使用 NMT + jcmd 分析泄漏的堆外内存是哪里申请，确定原因后，使用不同的手段，进行原因定位。</p>
<h2 id="场景九：JNI-引发的-GC-问题"><a href="#场景九：JNI-引发的-GC-问题" class="headerlink" title="场景九：JNI 引发的 GC 问题"></a>场景九：JNI 引发的 GC 问题</h2><p><strong>9.1 现象</strong></p>
<p>在 GC 日志中，出现 GC Cause 为 GCLocker Initiated GC。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-09-23T16:49:09.727+0800: 504426.742: [GC (GCLocker Initiated GC) 504426.742: [ParNew (promotion failed): 209716K-&gt;6042K(1887488K), 0.0843330 secs] 1449487K-&gt;1347626K(3984640K), 0.0848963 secs] [Times: user=0.19 sys=0.00, real=0.09 secs]</span><br><span class="line">2020-09-23T16:49:09.812+0800: 504426.827: [Full GC (GCLocker Initiated GC) 504426.827: [CMS: 1341583K-&gt;419699K(2097152K), 1.8482275 secs] 1347626K-&gt;419699K(3984640K), [Metaspace: 297780K-&gt;297780K(1329152K)], 1.8490564 secs] [Times: user=1.62 sys=0.20, real=1.85 secs]</span><br></pre></td></tr></table></figure>
<p><strong>9.2 原因</strong></p>
<p>JNI（Java Native Interface）意为 Java 本地调用，它允许 Java 代码和其他语言写的 Native 代码进行交互。</p>
<p>JNI 如果需要获取 JVM 中的 String 或者数组，有两种方式：</p>
<ul>
<li><p>拷贝传递。</p>
</li>
<li><p>共享引用（指针），性能更高。</p>
</li>
</ul>
<p>由于 Native 代码直接使用了 JVM 堆区的指针，如果这时发生 GC，就会导致数据错误。因此，在发生此类 JNI 调用时，禁止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。</p>
<p>GC Locker 可能导致的不良后果有：</p>
<ul>
<li><p>如果此时是 Young 区不够 Allocation Failure 导致的 GC，由于无法进行 Young GC，会将对象直接分配至 Old 区。</p>
</li>
<li><p>如果 Old 区也没有空间了，则会等待锁释放，导致线程阻塞。</p>
</li>
<li><p>可能触发额外不必要的 Young GC，JDK 有一个 Bug，有一定的几率，本来只该触发一次 GCLocker Initiated GC 的 Young GC，实际发生了一次 Allocation Failure GC 又紧接着一次 GCLocker Initiated GC。是因为 GCLocker Initiated GC 的属性被设为 full，导致两次 GC 不能收敛。</p>
</li>
</ul>
<p><strong>9.3 策略</strong></p>
<ul>
<li><p>添加 -XX+PrintJNIGCStalls 参数，可以打印出发生 JNI 调用时的线程，进一步分析，找到引发问题的 JNI 调用。</p>
</li>
<li><p>JNI 调用需要谨慎，不一定可以提升性能，反而可能造成 GC 问题。</p>
</li>
<li><p>升级 JDK 版本到 14，避免 JDK-8048556 导致的重复 GC。</p>
</li>
</ul>
<p><strong>9.4 小结</strong></p>
<p>JNI 产生的 GC 问题较难排查，需要谨慎使用。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/MeituanTech/article/details/109664525">https://blog.csdn.net/MeituanTech/article/details/109664525</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>GC相关</category>
      </categories>
  </entry>
  <entry>
    <title>G1日志</title>
    <url>/2024/04/01/Java/JVM/GC%E7%9B%B8%E5%85%B3/G1%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="Young-Collection日志"><a href="#Young-Collection日志" class="headerlink" title="Young Collection日志"></a>Young Collection日志</h1> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016-09-29T16:58:43.298+0800: 84662.983: [GC pause (G1 Evacuation Pause) (young)</span><br><span class="line">   [Parallel Time: 39.5 ms, GC Workers: 13]</span><br><span class="line">      [GC Worker Start (ms): Min: 84662997.2, Avg: 84662997.6, Max: 84662997.8, Diff: 0.6]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 1.0, Avg: 1.6, Max: 6.2, Diff: 5.2, Sum: 21.0]</span><br><span class="line">      [Update RS (ms): Min: 8.1, Avg: 12.4, Max: 13.1, Diff: 5.0, Sum: 161.1]</span><br><span class="line">         [Processed Buffers: Min: 9, Avg: 17.8, Max: 26, Diff: 17, Sum: 231]</span><br><span class="line">      [Scan RS (ms): Min: 5.8, Avg: 6.2, Max: 6.3, Diff: 0.5, Sum: 80.2]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Object Copy (ms): Min: 18.4, Avg: 18.6, Max: 18.7, Diff: 0.3, Sum: 241.2]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.2, Max: 0.2, Diff: 0.2, Sum: 2.1]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 149.4, Max: 197, Diff: 196, Sum: 1942]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 1.1]</span><br><span class="line">      [GC Worker Total (ms): Min: 38.7, Avg: 39.0, Max: 39.3, Diff: 0.6, Sum: 506.8]</span><br><span class="line">      [GC Worker End (ms): Min: 84663036.5, Avg: 84663036.5, Max: 84663036.6, Diff: 0.1]</span><br><span class="line">   [Code Root Fixup: 0.1 ms]</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line">   [Clear CT: 1.1 ms]</span><br><span class="line">   [Other: 17.8 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 1.9 ms]</span><br><span class="line">      [Ref Enq: 0.1 ms]</span><br><span class="line">      [Redirty Cards: 0.4 ms]</span><br><span class="line">      [Humongous Register: 11.8 ms]</span><br><span class="line">      [Humongous Reclaim: 0.1 ms]</span><br><span class="line">      [Free CSet: 1.1 ms]</span><br><span class="line">   [Eden: 7968.0M(7968.0M)-&gt;0.0B(13.8G) Survivors: 0.0B-&gt;0.0B Heap: 31.9G(96.0G)-&gt;24.3G(96.0G)]</span><br></pre></td></tr></table></figure>

<p>GC pause (G1 Evacuation Pause) (young) - 表示此时GC暂停是YGC。</p>
<span id="more"></span>

<p>Parallel Time与GC Workers  – 并行阶段总的停顿时间和GC工作线程数量。紧跟着的几行显示并行阶段的执行任务。</p>
<blockquote>
<p>GC Worker Start与GC Worker End – 各个工作线程(workers)启动和结束的时间戳(Timestamp)的统计值</p>
<p>External Root Scanning - 扫描外部根花费的时间统计值</p>
<p>Update RS - 更新Remembered Set。</p>
<p>Scan RS - 扫描CSet中的region的Remembered Sets，查找指向Collection Set的references。</p>
<p>Code Root Scanning – 扫描code root set查找指向CSet的引用。</p>
<p>Object copy – 每个独立的线程在拷贝和转移对象时所消耗的时间.</p>
<p>Termination time - 结束时间，当worker线程完成了自己那部分对象的复制和扫描任务,就进入终止协议(termination protocol)。它会查找未完成的工作(looks for work to steal), 一旦它完成就会再进入终止协议。终止尝试记录(Termination attempt counts)所有查找工作的尝试次数(attempts to steal work).</p>
<p>GC worker other – 每个GC线程中不能归属到之前列出的阶段任务（usual task）的其他时间。</p>
<p>GC Worker Total -每个独立的 GC worker 线程消耗的时间，包含“usual” and “unusual”任务的执行时间。并行任务完成之后将开始串行任务，该阶段主GC线程updates code roots with the new location of evacuated objects and also purges the code root set table. clear CT phase (which is carried out in parallel with the help of parallel worker threads) clears the card table marks。</p>
</blockquote>
<p>[Code Root Fixup: 0.1 ms]</p>
<p>[Code Root Purge: 0.0 ms]</p>
<p>[Clear CT: 1.1 ms]</p>
<blockquote>
<p>Choose CSet – 确定要进行垃圾回收的region集合时消耗的时间. 通常很小,在必须选择 old 区时会稍微长一点点。</p>
<p>Ref Proc -处理GC前面阶段产生的sofe、weak等引用所使用的时间</p>
<p>Ref Enq -将soft, weak, 等引用放置到待处理列表(pending list)花费的时间.</p>
<p>Free CSet -释放刚被垃圾收集的 heap区所消耗的时间,包括对应的remembered sets。</p>
</blockquote>
<h1 id="concurrent-mark-日志"><a href="#concurrent-mark-日志" class="headerlink" title="concurrent mark 日志"></a>concurrent mark 日志</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016-10-10T17:14:28.807+0800: 12.742: [GC pause (Metadata GC Threshold) (young) (initial-mark)</span><br><span class="line">12.742: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 3712, predicted base time: 49.13 ms, remaining time: 50.87 ms, target pause time: 100.00 ms]</span><br><span class="line"> 12.742: [G1Ergonomics (CSet Construction) add young regions to CSet, eden: 61 regions, survivors: 0 regions, predicted young region time: 4418.18 ms]</span><br><span class="line"> 12.742: [G1Ergonomics (CSet Construction) finish choosing CSet, eden: 61 regions, survivors: 0 regions, old: 0 regions, predicted pause time: 4467.31 ms, target pause time: 100.00 ms]</span><br><span class="line">2016-10-10T17:14:29.002+0800: 12.936: [SoftReference, 0 refs, 0.0003939 secs]2016-10-10T17:14:29.002+0800: 12.937: [WeakReference, 233 refs, 0.0003051 secs]2016-10-10T17:14:29.002+0800: 12.937: [FinalReference, 4741 refs, 0.0025090 secs]2016-10-10T17:14:29.005+0800: 12.940: [PhantomReference, 0 refs, 0 refs, 0.0004143 secs]2016-10-10T17:14:29.005+0800: 12.940: [JNI Weak Reference, 0.0010498 secs] 12.944: [G1Ergonomics (Mixed GCs) do not start mixed GCs, reason: concurrent cycle is about to start]</span><br><span class="line">, 0.2020456 secs]</span><br><span class="line">   [Parallel Time: 193.9 ms, GC Workers: 13]</span><br><span class="line">      [GC Worker Start (ms): Min: 12742.2, Avg: 12742.3, Max: 12742.5, Diff: 0.4]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 5.5, Avg: 6.8, Max: 8.5, Diff: 2.9, Sum: 88.7]</span><br><span class="line">      [Update RS (ms): Min: 0.4, Avg: 0.8, Max: 1.3, Diff: 0.9, Sum: 9.8]</span><br><span class="line">         [Processed Buffers: Min: 1, Avg: 1.9, Max: 3, Diff: 2, Sum: 25]</span><br><span class="line">      [Scan RS (ms): Min: 19.9, Avg: 20.4, Max: 20.7, Diff: 0.9, Sum: 265.1]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.1, Max: 0.9, Diff: 0.9, Sum: 1.9]</span><br><span class="line">      [Object Copy (ms): Min: 161.0, Avg: 162.9, Max: 166.0, Diff: 5.0, Sum: 2117.1]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 2.5, Max: 3.2, Diff: 3.2, Sum: 32.8]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 2354.8, Max: 2844, Diff: 2843, Sum: 30612]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.0, Sum: 0.4]</span><br><span class="line">      [GC Worker Total (ms): Min: 193.3, Avg: 193.5, Max: 193.7, Diff: 0.3, Sum: 2515.7]</span><br><span class="line">      [GC Worker End (ms): Min: 12935.8, Avg: 12935.9, Max: 12935.9, Diff: 0.0]</span><br><span class="line">   [Code Root Fixup: 0.4 ms]</span><br><span class="line">   [Code Root Purge: 0.2 ms]</span><br><span class="line">   [Clear CT: 0.3 ms]</span><br><span class="line">   [Other: 7.3 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 4.9 ms]</span><br><span class="line">      [Ref Enq: 0.3 ms]</span><br><span class="line">      [Redirty Cards: 0.5 ms]</span><br><span class="line">      [Humongous Register: 0.0 ms]</span><br><span class="line">      [Humongous Reclaim: 0.1 ms]</span><br><span class="line">      [Free CSet: 0.2 ms]</span><br><span class="line">   [Eden: 1952.0M(3904.0M)-&gt;0.0B(3904.0M) Survivors: 0.0B-&gt;0.0B Heap: 2391.8M(96.0G)-&gt;1067.5M(96.0G)]</span><br><span class="line">Heap after GC invocations=3 (full 0):</span><br><span class="line"> garbage-first heap   total 100663296K, used 1093164K [0x00007f6a8c000000, 0x00007f6a8e006000, 0x00007f828c000000)</span><br><span class="line">  region size 32768K, 0 young (0K), 0 survivors (0K)</span><br><span class="line"> Metaspace       used 35815K, capacity 36387K, committed 36476K, reserved 36864K</span><br><span class="line">&#125;</span><br><span class="line"> [Times: user=2.19 sys=0.19, real=0.20 secs] </span><br><span class="line">2016-10-10T17:14:29.009+0800: 12.944: [GC concurrent-root-region-scan-start]</span><br><span class="line">2016-10-10T17:14:29.009+0800: 12.944: [GC concurrent-root-region-scan-end, 0.0000715 secs]</span><br><span class="line">2016-10-10T17:14:29.009+0800: 12.944: [GC concurrent-mark-start]</span><br><span class="line">2016-10-10T17:14:29.391+0800: 13.325: [GC concurrent-mark-end, 0.3816054 secs]</span><br><span class="line">2016-10-10T17:14:29.391+0800: 13.326: [GC remark 2016-10-10T17:14:29.391+0800: 13.326: [Finalize Marking, 0.0003442 secs] 2016-10-10T17:14:29.391+0800: 13.326: [GC ref-proc2016-10-10T17:14:29.391+0800: 13.326: [SoftReference, 0 refs, 0.0008952 secs]2016-10-10T17:14:29.392+0800: 13.327: [WeakReference, 210 refs, 0.0006089 secs]2016-10-10T17:14:29.393+0800: 13.328: [FinalReference, 403 refs, 0.0005809 secs]2016-10-10T17:14:29.393+0800: 13.328: [PhantomReference, 0 refs, 1 refs, 0.0009118 secs]2016-10-10T17:14:29.394+0800: 13.329: [JNI Weak Reference, 0.0000346 secs], 0.0031823 secs] 2016-10-10T17:14:29.394+0800: 13.329: [Unloading, 0.0073561 secs], 0.0128419 secs]</span><br><span class="line"> [Times: user=0.16 sys=0.01, real=0.02 secs] </span><br><span class="line">2016-10-10T17:14:29.404+0800: 13.339: [GC cleanup 1379M-&gt;1119M(96G), 0.0030896 secs]</span><br><span class="line"> [Times: user=0.04 sys=0.00, real=0.00 secs] </span><br><span class="line">2016-10-10T17:14:29.407+0800: 13.342: [GC concurrent-cleanup-start]</span><br><span class="line">2016-10-10T17:14:29.407+0800: 13.342: [GC concurrent-cleanup-end, 0.0001273 secs]</span><br></pre></td></tr></table></figure>

<p>GC pause (Metadata GC Threshold) (young) (initial-mark) — 显示本次GC暂停是由于Metadata空间不足引发初始标记阶段。除了Metadata GC Threshold触发并发标记，还可能会有G1 Humongous Allocation、G1 Evacuation Pause（主要是该原因触发），以上两者本质上貌似还是occupancy higher than threshold。initial-mark实质上是一次YGC，有STW，暂停时间为real&#x3D;0.20 secs。</p>
<p>concurrent-root-region-scan — 并发根扫描阶段。</p>
<p>concurrent-mark — 并发标记阶段。</p>
<p>remark — 重新标记阶段，会有STW，暂停时间为real&#x3D;0. 02 secs。</p>
<p>cleanup — 清除阶段，会有STW，暂停时间为real&#x3D;0. 00 secs（因为显示的值是保留了两位小数后的值，real值可能很小）。清除阶段显示会将260M空间清理，于是紧接着会有额外的concurrent-cleanup阶段。倘若没有空间清理，concurrent-cleanup就不会存在。</p>
<h1 id="Mixed-GC日志"><a href="#Mixed-GC日志" class="headerlink" title="Mixed GC日志"></a>Mixed GC日志</h1><p>​    在分析MixedGC前，先看下配置的JVM参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms96g </span><br><span class="line">-Xmx96g </span><br><span class="line">-XX:+UseG1GC </span><br><span class="line">-XX:MaxGCPauseMillis=100 </span><br><span class="line">-XX:G1HeapRegionSize=32m </span><br><span class="line">-XX:InitiatingHeapOccupancyPercent=70 </span><br><span class="line">-XX:G1HeapWastePercent=5 </span><br><span class="line">-XX:G1MixedGCCountTarget=16 </span><br><span class="line">-XX:+UnlockExperimentalVMOptions </span><br><span class="line">-XX:G1OldCSetRegionThresholdPercent=5 </span><br><span class="line">-XX:G1NewSizePercent=4</span><br><span class="line">-XX:G1MaxNewSizePercent=15</span><br></pre></td></tr></table></figure>

<p>​    堆空间是96G,每个region大小32M，那么G1会划分出3072个region，G1OldCSetRegionThresholdPercent限制每次能进入CSet的old region容量最大为5%的堆空间，即4915.2M，合计153.6个old region，四舍五入为154。</p>
<p>接下来分析日志。</p>
<p>在每次并发标记阶段会紧接着一次YGC，来决定是否触发Mixed GC。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016-10-11T08:26:26.848+0800: 54730.783: [GC pause (G1 Evacuation Pause) (young)</span><br><span class="line">Desired survivor size 973078528 bytes, new threshold 0 (max 0)</span><br><span class="line"> 54730.783: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 43647, predicted base time: 22.69 ms, remaining time: 77.31 ms, target pause time: 100.00 ms]</span><br><span class="line"> 54730.783: [G1Ergonomics (CSet Construction) add young regions to CSet, eden: 460 regions, survivors: 0 regions, predicted young region time: 51.94 ms]</span><br><span class="line"> 54730.783: [G1Ergonomics (CSet Construction) finish choosing CSet, eden: 460 regions, survivors: 0 regions, old: 0 regions, predicted pause time: 74.63 ms, target pause time: 100.00 ms]</span><br><span class="line">2016-10-11T08:26:26.885+0800: 54730.819: [SoftReference, 0 refs, 0.0004022 secs]2016-10-11T08:26:26.885+0800: 54730.820: [WeakReference, 2 refs, 0.0002807 secs]2016-10-11T08:26:26.885+0800: 54730.820: [FinalReference, 1882 refs, 0.0003305 secs]2016-10-11T08:26:26.886+0800: 54730.820: [PhantomReference, 0 refs, 0 refs, 0.0005704 secs]2016-10-11T08:26:26.886+0800: 54730.821: [JNI Weak Reference, 0.0000176 secs] 54730.825: [G1Ergonomics (Mixed GCs) start mixed GCs, reason: candidate old regions available, candidate old regions: 1509 regions, reclaimable: 48974333808 bytes (47.51 %), threshold: 5.00 %]</span><br><span class="line">, 0.0423105 secs]</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>从第四行可以看出，这次YGC后发现并发标记阶段选出的可以进行垃圾回收的old region数量有1509个，可回收空间占47.51 %，大于能容忍浪费的5%，于是需要开始 mixed GC。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016-10-11T08:26:34.619+0800: 54738.554: [GC pause (G1 Evacuation Pause) (mixed)</span><br><span class="line">Desired survivor size 268435456 bytes, new threshold 0 (max 0)</span><br><span class="line"> 54738.554: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 39963, predicted base time: 19.99 ms, remaining time: 80.01 ms, target pause time: 100.00 ms]</span><br><span class="line"> 54738.554: [G1Ergonomics (CSet Construction) add young regions to CSet, eden: 122 regions, survivors: 0 regions, predicted young region time: 7.65 ms]</span><br><span class="line"> 54738.554: [G1Ergonomics (CSet Construction) finish adding old regions to CSet, reason: old CSet region num reached max, old: 154 regions, max: 154 regions]</span><br><span class="line"> 54738.554: [G1Ergonomics (CSet Construction) finish choosing CSet, eden: 122 regions, survivors: 0 regions, old: 154 regions, predicted pause time: 40.99 ms, target pause time: 100.00 ms]</span><br><span class="line">2016-10-11T08:26:34.643+0800: 54738.578: [SoftReference, 0 refs, 0.0004954 secs]2016-10-11T08:26:34.644+0800: 54738.579: [WeakReference, 2 refs, 0.0002238 secs]2016-10-11T08:26:34.644+0800: 54738.579: [FinalReference, 654 refs, 0.0003230 secs]2016-10-11T08:26:34.645+0800: 54738.579: [PhantomReference, 0 refs, 0 refs, 0.0004906 secs]2016-10-11T08:26:34.645+0800: 54738.580: [JNI Weak Reference, 0.0000171 secs] 54738.586: [G1Ergonomics (Mixed GCs) continue mixed GCs, reason: candidate old regions available, candidate old regions: 1355 regions, reclaimable: 43813651360 bytes (42.50 %), threshold: 5.00 %]</span><br><span class="line">, 0.0325863 secs]</span><br><span class="line">   [Parallel Time: 23.8 ms, GC Workers: 13]</span><br><span class="line">      [GC Worker Start (ms): Min: 54738554.3, Avg: 54738554.5, Max: 54738554.6, Diff: 0.4]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 0.6, Avg: 0.9, Max: 1.4, Diff: 0.8, Sum: 11.1]</span><br><span class="line">      [Update RS (ms): Min: 6.5, Avg: 6.8, Max: 7.0, Diff: 0.5, Sum: 89.0]</span><br><span class="line">         [Processed Buffers: Min: 12, Avg: 16.5, Max: 29, Diff: 17, Sum: 214]</span><br><span class="line">      [Scan RS (ms): Min: 5.5, Avg: 5.7, Max: 5.8, Diff: 0.4, Sum: 73.5]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Object Copy (ms): Min: 6.5, Avg: 7.0, Max: 10.0, Diff: 3.5, Sum: 90.4]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 3.2, Max: 3.5, Diff: 3.5, Sum: 42.1]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 7.6, Max: 11, Diff: 10, Sum: 99]</span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.2]</span><br><span class="line">      [GC Worker Total (ms): Min: 23.4, Avg: 23.6, Max: 23.7, Diff: 0.4, Sum: 306.3]</span><br><span class="line">      [GC Worker End (ms): Min: 54738578.0, Avg: 54738578.0, Max: 54738578.0, Diff: 0.0]</span><br><span class="line">   [Code Root Fixup: 0.1 ms]</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line">   [Clear CT: 3.3 ms]</span><br><span class="line">   [Other: 5.4 ms]</span><br><span class="line">      [Choose CSet: 0.3 ms]</span><br><span class="line">      [Ref Proc: 1.7 ms]</span><br><span class="line">      [Ref Enq: 0.1 ms]</span><br><span class="line">      [Redirty Cards: 0.3 ms]</span><br><span class="line">      [Humongous Register: 0.1 ms]</span><br><span class="line">      [Humongous Reclaim: 0.0 ms]</span><br><span class="line">      [Free CSet: 2.4 ms]</span><br><span class="line">   [Eden: 3904.0M(3904.0M)-&gt;0.0B(3904.0M) Survivors: 0.0B-&gt;0.0B Heap: 51.7G(96.0G)-&gt;43.3G(96.0G)]</span><br><span class="line">Heap after GC invocations=1403 (full 0):</span><br><span class="line"> garbage-first heap   total 100663296K, used 45351362K [0x00007f6a8c000000, 0x00007f6a8e006000, 0x00007f828c000000)</span><br><span class="line">  region size 32768K, 0 young (0K), 0 survivors (0K)</span><br><span class="line"> Metaspace       used 58740K, capacity 59866K, committed 62352K, reserved 63488K</span><br><span class="line">&#125;</span><br><span class="line"> [Times: user=0.35 sys=0.00, real=0.03 secs]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一行显示这次疏散暂停的类型—混合GC，紧接着的几行中显示开始筛选CSet，predicted base time是预测花费时间，依据添加到CSet的young和old region时间。</p>
<p>可以发现本次CSet筛选了154个old region到CSet中，这个数值就是之前计算出的最大能加入到CSet的数量（G1会尝试一次将最大数量的region加入CSet，根据暂停时间来调整下次进入CSet的old region数量）。</p>
<p>第七行显示这次Mixed GC后，还剩1355个candidate  old region（1509-154），可回收空间占42.50%，于是G1决定将继续Mixed GC（continue mixed GCs）。垃圾收集时间0.0325863 secs，在目标停顿100ms以内，G1认为154个old region回收将是可行的数量，于是会在下一次的Mixed GC也选择这个数量的old region进入CSet。</p>
<p>倘若超过了目标停顿时间，Mixed GC可能会在下次回收阶段只筛选95个old region。为什么是95个？因为开始MixedGC前的那次YGC，发现有1509个候选old region，设置的G1MixedGCCountTarget为16，那么每次进入CSet的old region数量最小必须是95（1509&#x2F;16 &#x3D; 94.31）。如果只筛选95个old region后暂停时间又小于目标停顿时间，G1又会适当的添加进入CSet的old region数量，来得到一个理想的old region数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016-10-11T08:27:04.339+0800: 54768.274: [GC pause (G1 Evacuation Pause) (mixed)</span><br><span class="line">Desired survivor size 268435456 bytes, new threshold 0 (max 0)</span><br><span class="line"> 54768.274: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 43339, predicted base time: 25.53 ms, remaining time: 74.47 ms, target pause time: 100.00 ms]</span><br><span class="line"> 54768.274: [G1Ergonomics (CSet Construction) add young regions to CSet, eden: 122 regions, survivors: 0 regions, predicted young region time: 12.28 ms]</span><br><span class="line"> 54768.275: [G1Ergonomics (CSet Construction) finish adding old regions to CSet, reason: predicted time is too high, predicted time: 0.81 ms, remaining time: 0.00 ms, old: 95 regions, min: 95 regions]</span><br><span class="line"> 54768.275: [G1Ergonomics (CSet Construction) added expensive regions to CSet, reason: old CSet region num not reached min, old: 95 regions, expensive: 1 regions, min: 95 regions, remaining time: 0.00 ms]</span><br><span class="line"> 54768.275: [G1Ergonomics (CSet Construction) finish choosing CSet, eden: 122 regions, survivors: 0 regions, old: 95 regions, predicted pause time: 100.70 ms, target pause time: 100.00 ms]</span><br><span class="line">2016-10-11T08:27:04.395+0800: 54768.330: [SoftReference, 0 refs, 0.0004168 secs]2016-10-11T08:27:04.396+0800: 54768.331: [WeakReference, 2 refs, 0.0002792 secs]2016-10-11T08:27:04.396+0800: 54768.331: [FinalReference, 559 refs, 0.0015823 secs]2016-10-11T08:27:04.398+0800: 54768.333: [PhantomReference, 0 refs, 0 refs, 0.0004088 secs]2016-10-11T08:27:04.398+0800: 54768.333: [JNI Weak Reference, 0.0000167 secs] 54768.341: [G1Ergonomics (Mixed GCs) continue mixed GCs, reason: candidate old regions available, candidate old regions: 798 regions, reclaimable: 25241566672 bytes (24.49 %), threshold: 5.00 %]</span><br><span class="line">, 0.0676436 secs]</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>这是期间的某一次Mixed GC日志，这一次只选择了95个old regions进入CSet，注意上次Mixed GC后还剩893 candidate old regions，并且上次Mixed GC暂停时间是0.0841628 secs，尚不清除为什么只选择了95个。但是这里关注的是added expensive regions to CSet，当进入CSet的candidate old region数量没超出最小数量阈值95时，G1会尝试回收expensive region，expensive region表示存活对象的占用空间超过G1MixedGCLiveThresholdPercent的区域，G1不会将该region标注为candidate old regions以供Mixed GC使用，因为这类region的存活率高，疏散代价较高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016-10-11T08:27:55.749+0800: 54819.684: [GC pause (G1 Evacuation Pause) (mixed)</span><br><span class="line">Desired survivor size 268435456 bytes, new threshold 0 (max 0)</span><br><span class="line"> 54819.684: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 40201, predicted base time: 19.36 ms, remaining time: 80.64 ms, target pause time: 100.00 ms]</span><br><span class="line"> 54819.684: [G1Ergonomics (CSet Construction) add young regions to CSet, eden: 122 regions, survivors: 0 regions, predicted young region time: 10.68 ms]</span><br><span class="line"> 54819.685: [G1Ergonomics (CSet Construction) finish adding old regions to CSet, reason: reclaimable percentage not over threshold, old: 41 regions, max: 154 regions, reclaimable: 5142537400 bytes (4.99 %), threshold: 5.00 %]</span><br><span class="line"> 54819.685: [G1Ergonomics (CSet Construction) finish choosing CSet, eden: 122 regions, survivors: 0 regions, old: 41 regions, predicted pause time: 95.51 ms, target pause time: 100.00 ms]</span><br><span class="line">2016-10-11T08:27:55.795+0800: 54819.730: [SoftReference, 0 refs, 0.0004575 secs]2016-10-11T08:27:55.796+0800: 54819.730: [WeakReference, 1 refs, 0.0002457 secs]2016-10-11T08:27:55.796+0800: 54819.731: [FinalReference, 405 refs, 0.0003508 secs]2016-10-11T08:27:55.796+0800: 54819.731: [PhantomReference, 0 refs, 0 refs, 0.0004201 secs]2016-10-11T08:27:55.797+0800: 54819.731: [JNI Weak Reference, 0.0000157 secs] 54819.739: [G1Ergonomics (Mixed GCs) do not continue mixed GCs, reason: reclaimable percentage not over threshold, candidate old regions: 187 regions, reclaimable: 5142537400 bytes (4.99 %), threshold: 5.00 %]</span><br><span class="line">, 0.0555605 secs]</span><br></pre></td></tr></table></figure>

<p>这次MixedGC后，可回收空间是4.99 %，低于阈值5.00 %，G1将决定不再继续Mixed GC。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>GC相关</category>
      </categories>
  </entry>
  <entry>
    <title>G1垃圾收集器</title>
    <url>/2024/04/01/Java/JVM/GC%E7%9B%B8%E5%85%B3/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;G1垃圾收集器（Garbage First）是一个并行的、并发的、面向服务器的垃圾收集器的垃圾收集器。G1在Oracle JDK 7 update 4 及以上版本中得到完全支持，它的长远目标时代替CMS收集器。相较于CMS，G1是一款压缩型的收集器，不会产生内存碎片；可以极高概率满足GC停顿时间，实现低停顿垃圾回收。G1优先回收存活数据较少的区域。存活数据少就表示里面的垃圾对象多，这也是名字 Garbage First 的由来。</p>
<span id="more"></span>
<p>&emsp;&emsp;G1是区域化、分代式垃圾回收器， Java对象堆被划分成若干个大小相同的区域（Region）。</p>
<p>&emsp;&emsp;启动时，JVM初始化的时候决定region的大小，可以用<code>-XX:G1HeapReginSize</code>指定，Region的大小一定是1 MB到32 MB之间数，并且是2的幂，例如4M、16M。所有的Region都是指定的大小，在JVM生命周期内不会改变。G1的目标是产生不超过2048 个同样大小的区域，但是如果设置的Java堆大于64G，JVM会适当增加region的数量，但是region大小一定不会超过32M。G1会并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次从可回收空间最多的区域开始，尽可能回收更多的堆空间，同时尽可能不超出暂停时间目。</p>
<p>&emsp;&emsp;在G1中没有物理上的Yong(Eden&#x2F;Survivor)、Old Generation，它们是逻辑的，使用一些非连续的区域(Region)组成的。而且不需要在JVM启动时决定哪些Region属于老年代，哪些属于年轻代，一个Region可能这次GC是young region，而下次GC却是old region。而且G1 GC 有一个力求达到的暂停时间目标（软实时），在年轻代回收期间，G1 GC还会调整其年轻代空间（young region个数）以满足软实时目标。</p>
<h1 id="Region类型"><a href="#Region类型" class="headerlink" title="Region类型"></a>Region类型</h1><ul>
<li><p>Available region：可用的空闲区域。</p>
</li>
<li><p>Eden region: 新生代的eden区。</p>
</li>
<li><p>Survivor region：新生代的survivor区。</p>
</li>
<li><p>Humongous region: 大区，超过region的大小50%的对象占用的region被称作Humongous region，可被认为是老年代的一部分。</p>
</li>
</ul>
<p>&emsp;&emsp;注意：eden region和survivor region的数量并不固定，可能伴随着GC而发生变化(young, mixed, or full GCs)。</p>
<p>&emsp;&emsp;对G1来说，任何超过区域一半大小的对象都被视为“巨型对象（Humongous Object）”。当需要分配这种对象时，G1会找出总计内存足够包含该对象的一组连续的可用区域来分配该对象，第一个region会标记为“StartsHumongous” ，其它延续的region被标记为“ContinuesHumongous”。在分配任何巨型区域之前，会检查标记阈值，如有必要，还会启动一个并发周期。如果没有这么大的连续的可用区域，G1会作一次FGC来压缩Java堆。尽管只有一个对象，Humongous regions被认为是老年代的一部分。这样设计的目的是为了使G1在并发标记阶段，如果发现对象不可用时尽早的回收掉这些region。</p>
<h1 id="G1-中的重要数据结构、算法"><a href="#G1-中的重要数据结构、算法" class="headerlink" title="G1 中的重要数据结构、算法"></a>G1 中的重要数据结构、算法</h1><h2 id="Card-Table"><a href="#Card-Table" class="headerlink" title="Card Table"></a>Card Table</h2><p>&emsp;&emsp;在每个分区内部又被分成了若干个大小为512 Byte卡片(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p>
<p>&emsp;&emsp;<strong>这里可以记录老年代对新生代的 跨代引用。</strong></p>
<h2 id="CSets-Collection-Sets-待收集集合"><a href="#CSets-Collection-Sets-待收集集合" class="headerlink" title="CSets(Collection Sets)待收集集合"></a>CSets(Collection Sets)待收集集合</h2><p>&emsp;&emsp;CSet即Collection Set，它是需要回收的region集合，在年轻代垃圾收集中CSet仅包含young region，在混合垃圾收集中CSet不仅包含young region，还有一些old region。</p>
<h2 id="RSet（Remembered-Set）"><a href="#RSet（Remembered-Set）" class="headerlink" title="RSet（Remembered Set）"></a>RSet（Remembered Set）</h2><p>&emsp;&emsp;在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(RSet)，内部类似一个反向指针，记录引用分区内对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p>
<p>&emsp;&emsp;G1中每个Region都有一个与之对应的Remembered Set，用以维护和跟踪Region之间的对象引用。每个region有独立的Remembered Set（RSet），减少了全堆扫描获取信息的耗时。</p>
<p>&emsp;&emsp;虚拟机发现程序在对Reference类型的数据进行写操作时，会检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查引是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。 独立的 RSet 可以并行、独立地回收区域，因为只需要对区域（而不是整个堆）的 RSet 进行区域引用扫描。</p>
<p>&emsp;&emsp;关于三色标记里存在的漏标问题，G1采用的<strong>SATB</strong>方法就使用到了RSet。Card Table里记录了RSet，RSet里记录了其他对象指向自己的引用，这样就不需要再扫描其他区域，只要扫描RSet就可以了。也就是说 灰色–&gt;白色 引用消失时，如果没有 黑色–&gt;白色，引用会被push到堆栈，下次扫描时拿到这个引用，由于有RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。SATB配合RSet浑然天成。</p>
<h2 id="Per-Region-Table-PRT"><a href="#Per-Region-Table-PRT" class="headerlink" title="Per Region Table (PRT)"></a>Per Region Table (PRT)</h2><p>&emsp;&emsp;RSet在内部使用Per Region Table(PRT)记录分区的引用情况。由于RSet的记录要占用分区的空间，如果一个分区非常”受欢迎”，那么RSet占用的空间会上升，从而降低分区的可用空间。G1应对这个问题采用了改变RSet的密度的方式，在PRT中将会以三种模式记录引用：</p>
<ul>
<li>稀少：直接记录引用对象的卡片索引</li>
<li>细粒度：记录引用对象的分区索引</li>
<li>粗粒度：只记录引用情况，每个分区对应一个比特位</li>
</ul>
<p>由上可知，粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。</p>
<h2 id="Snapshot-At-The-Beginning-SATB"><a href="#Snapshot-At-The-Beginning-SATB" class="headerlink" title="Snapshot-At-The-Beginning(SATB)"></a>Snapshot-At-The-Beginning(SATB)</h2><p>&emsp;&emsp;SATB是在G1 GC在并发标记阶段使用的增量式的标记算法。并发标记是并发多线程的，但并发线程在同一时刻只扫描一个分区。<br>&emsp;&emsp;在解释SATB前先要了解三色标记法。三色标记法是将对象的存活状态用三种颜色标记，从黑色到灰色逐层标记：</p>
<blockquote>
<p>黑：该对象被标记了，并且其引用的对象也都被标记完成。<br>灰：对象被标记了，但其引用的对象还没有被标记完。<br>白：对象还没有被标记，标记阶段结束后，会被回收。</p>
</blockquote>
<p>&emsp;&emsp;在CMS GC中，并发标记阶段使用的是Incremental update批量更新算法，在增加引用时的写屏障中触发新的对象引用的标记（三色标记法）。<br>&emsp;&emsp;G1的并发标记算法，使用的是SATB。在GC开始时先创建一个对象快照，STAB可以在并发标记时标记所有快照中当时的存活对象。标记过程中新分配的对象也会被标记为存活对象，不会被回收。</p>
<h1 id="GC方式"><a href="#GC方式" class="headerlink" title="GC方式"></a>GC方式</h1><p>G1在运行过程中主要包含如下4种GC方式。</p>
<h2 id="1-年轻代垃圾收集-young-collection-cycle"><a href="#1-年轻代垃圾收集-young-collection-cycle" class="headerlink" title="1.年轻代垃圾收集(young collection cycle)"></a>1.年轻代垃圾收集(young collection cycle)</h2><p>&emsp;&emsp;当应用程序开始分配对象时，G1会在eden region分配新对象，直到eden region不够分配新对象时，young GC开始垃圾回收。在年轻代垃圾回收期间，G1 GC会同时回收eden区域和survivor区域。此阶段会有一次stop the world(STW)暂停。</p>
<p>&emsp;&emsp;垃圾收集过程，G1将所有存活的对象从Eden Region移动到Survivor Region，即“copy to survivor”；然后晋升年轻代的存活对象到新的survivor区，对于那些年龄达到阈值（tenuring threshold）的对象会晋升到老年代。对象的晋升过程发生在负责晋升的GC线程（promoting GC thread）的本地分配缓冲区（promotion local allocation buffer，PLAB），每个GC-thread都有针对与survivor区或old区的PLAB。</p>
<p>&emsp;&emsp;每次YGC暂停阶段G1会依据此次垃圾收集时间总时间、RSet大小、年轻代大小、暂停目标等指标计算此次年轻代垃圾收集代价，在暂停阶段结束后会基于此来重新调整年轻代的大小。</p>
<p>&emsp;&emsp;年轻代GC 通过多线程并行进行.</p>
<p> YoungGC的回收过程如下：</p>
<ul>
<li>根扫描,跟CMS类似，Stop the world，扫描GC Roots对象。</li>
<li>处理Dirty card,更新RSet.</li>
<li>扫描RSet,扫描RSet中所有old区对扫描到的young区或者survivor去的引用。</li>
<li>拷贝扫描出的存活的对象到survivor2&#x2F;old区</li>
<li>处理引用队列，软引用，弱引用，虚引用（下一篇优化中会再讲一下这三种引用对gc的影响）</li>
</ul>
<h2 id="2-并发标记（concurrent-marking-cycle）"><a href="#2-并发标记（concurrent-marking-cycle）" class="headerlink" title="2.并发标记（concurrent marking cycle）"></a>2.并发标记（concurrent marking cycle）</h2><p>&emsp;&emsp;一次GC之后，当老年代的占用空间超过设置的阈值、metaspace空间超过阈值时，G1开始执行老年代的垃圾回收。通过<code>-XX:InitiatingHeapOccupancyPercent</code>来设置阈值，默认是45，即占用空间达到堆空间（the entire Java heap）的45%时开始并发标记阶段。</p>
<p>&emsp;&emsp;并发标记包括以下几个阶段：</p>
<ul>
<li><p><strong>initial marking（初始标记阶段）</strong>：在此阶段对所有的GC root进行标记，会触发一次young GC，需要stop-the-world。对应GC日志中的GC pause (young) (inital-mark)。</p>
</li>
<li><p><strong>concurrent root region scanning（根区域扫描阶段）</strong>：扫描和跟踪survivor区中的对象的所有的引用。该阶段是并发的，GC线程和应用线程一起执行。只有完成该阶段，才会开始下一次年轻代GC。因为下一次年轻代GC时产生的新的survivor对象，是不同于initial marking阶段后的survivor对象。</p>
</li>
<li><p><strong>concurrent marking（并发标记阶段）</strong>：在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<code>-XX:ConcGCThreads</code>可以设置该过程的并行度，默认是ParallelGCThreads数量的四分之一。</p>
</li>
<li><p><strong>remarking（重新标记阶段）</strong>：该阶段会有停顿(STW)，帮助完成标记周期，用来标记并发标记阶段产生新的垃圾。G1 GC清空 SATB日志缓冲区，跟踪未被访问的存活对象，并执行引用处理。该阶段是并行的，<code>-XX:ParallelGCThreads</code>指定并行数。</p>
</li>
<li><p><strong>cleanup（清理阶段）</strong>：在这个最后阶段，G1 GC 执行统计和RSet重置，会有短暂STW。在统计期间，G1 GC会识别完全空闲的区域和可供进行混合垃圾回收的区域。如果有不包含存活对象的region（即完全空闲的区域），将会有额外的concurrent-cleanup阶段，该阶段将空白区域重置并返回到空闲列表。G1会依据老年代的“GC efficiency”作排序。</p>
</li>
</ul>
<p>&emsp;&emsp;注意：如果应用程序的存活对象图非常大，那么concurrent marking cycle所耗用的时间也就越多，而且concurrent marking cycle阶段被young collection打断的次数也会变得频繁。</p>
<p>&emsp;&emsp;marking threshold的设置非常重要，过大会导致增大发生evacuation failures的风险，过小会导致过早的触发并发标记阶段，而且可能没有垃圾需要回收。如果marking threshold的设置恰当，但并发周期的时间过长，导致混合GC阶段回收速率跟不上分配速率而触发evacuation failures，那么可以适当的增加并发线程。<code>-XX:ConcGCThreads</code>默认是<code>-XX:ParallelGCThreads</code>的四分之一，可以直接增大并发线程数量或则增大并行数。但是，需要考虑的是，增加并发线程会影响应用程序的线程，因为总的硬件资源一定。</p>
<h2 id="3-混合垃圾收集（mixed-collection-cycle）"><a href="#3-混合垃圾收集（mixed-collection-cycle）" class="headerlink" title="3.混合垃圾收集（mixed collection cycle）"></a>3.混合垃圾收集（mixed collection cycle）</h2><p>&emsp;&emsp;并发标记周期完成后将紧接着发生一次young collection，young collection的目的是决定是否需要触发mixed collection，如果可回收的region容量大于<code>-XX:G1HeapWastePercent</code>，则开始Mixed GC。</p>
<p>&emsp;&emsp;在混合垃圾收集期间，G1 GC不仅将eden和survivor区添加到CSet，还包括并发标记阶段标记出的old区的一部分添加到CSet来作垃圾回收。所添加old区域的确切数量由一系列标志控制。G1 GC 回收了足够的old区域后（经过多次混合垃圾回收），G1 将恢复执行年轻代垃圾回收，直到下一个并发标记周期完成。</p>
<h2 id="4-Full-GC"><a href="#4-Full-GC" class="headerlink" title="4.Full GC"></a>4.Full GC</h2><p>&emsp;&emsp;Full GC采用的类似于Serial GC一样的收集算法，当Full GC发生时，整个Java堆将会做一次压缩，以确保足够多的内存可用。但是G1中的FGC是单线程的，也会导致很长的停顿时间。当to-space exhausted&#x2F;overflow发生时G1将采取Full GC，当然可以通过适当的参数调优，可以不触发FGC也能满足应用的性能目标。</p>
<h1 id="Evacuation-Failure"><a href="#Evacuation-Failure" class="headerlink" title="Evacuation Failure"></a>Evacuation Failure</h1><p>&emsp;&emsp;对 survivors&#x2F;promoted objects 进行GC时，如果JVM的heap区不足就会发生提升失败(promotion failure)，如果Java堆又不能再继续扩展时将导致evacuation failure，此后就会进行一次FGC。</p>
<p>&emsp;&emsp;当使用 <code>-XX:+PrintGCDetails</code>出现evacuation failure将会在GC日志中显示：      </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space exhausted), 0.1957310 secs]</span><br><span class="line">或</span><br><span class="line">924.897:[GC pause (G1 Evacuation Pause) (mixed) (to-space overflow), 0.1957310 secs]</span><br></pre></td></tr></table></figure>

<p>如何避免evacuation failure，请尝试以下调整：</p>
<ul>
<li>增加 <code>-XX:G1ReservePercent</code>选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量，在需要更大’to-space’的情况下会尝试从该预存内存获取。</li>
<li>通过减少 <code>-XX:InitiatingHeapOccupancyPercent</code> 提前启动标记周期。</li>
<li>增加 <code>-XX:ConcGCThreads</code> 选项的值来增加并发标记时的并行标记线程数目，以尽快的完成标记从而进入混合GC。</li>
</ul>
<h1 id="G1相关的JVM参数"><a href="#G1相关的JVM参数" class="headerlink" title="G1相关的JVM参数"></a>G1相关的JVM参数</h1><ul>
<li><p>-XX:+UseG1GC<br> 启用G1垃圾收集器</p>
</li>
<li><p>-XX:G1HeapRegionSize&#x3D;n<br>区域的大小。值是2的幂，范围是1 MB到32 MB之间。目标是根据最小的Java 堆大小划分出约 2048 个区域。这个值的默认值是根据堆的大小决定的。</p>
</li>
<li><p>-XX:MaxGCPauseMillis&#x3D;200<br>最长暂停时间设置目标值。默认值是200 毫秒。</p>
</li>
<li><p>-XX:G1NewSizePercent&#x3D;5</p>
</li>
</ul>
<p>设置年轻代大小最小值的堆百分比。默认值是Java 堆的5%。相当于最少有5%的堆内存会作为年轻代来使用。</p>
<ul>
<li>-XX:G1MaxNewSizePercent&#x3D;60</li>
</ul>
<p>设置要用作年轻代大小最大值的堆大小百分比。默认值是Java堆的 60%。相当于最多有60%的堆内存会作为年轻代来使用。</p>
<ul>
<li>-XX:InitiatingHeapOccupancyPercent&#x3D;45</li>
</ul>
<p>触发标记周期的Java堆占用率阈值。默认占用率是整个Java堆的 45%。</p>
<ul>
<li>-XX:G1ReservePercent&#x3D;10</li>
</ul>
<p>作为空闲空间的预留内存百分比，以降低 to空间内存不足的风险。默认值是10%。</p>
<p>保留的空间用于年代之间的提升，注意这个空间保留后就不会用在年轻代。调高此值同时也意味着降低了老年代的实际可用空间。</p>
<ul>
<li>-XX:G1HeapWastePercent&#x3D;5</li>
</ul>
<p>可容忍的浪费堆空间百分比（触发Mixed GC的堆垃圾占比）。如果可回收百分比小于该设置的百分比，JVM不会启动混合垃圾回收周期。默认值为10％。</p>
<ul>
<li>-XX:G1MixedGCCountTarget&#x3D;8</li>
</ul>
<p>标记周期完成后，对要执行垃圾回收的候选old区域收集完毕需要执行Mixed GC的目标次数。默认值是8。MixedGC的目标是要控制在此目标次数以内完成对上次标记周期标记出的候选old region的回收。该值设置过小，会导致每次Mixed GC疏散的old region数量过多，导致停顿时间变长。该值可以限制每次Mixed GC最少要回收的old region数量。</p>
<ul>
<li>-XX:G1OldCSetRegionThresholdPercent&#x3D;10</li>
</ul>
<p>混合垃圾收集期间，每次能进入CSet的old region的最大阈值（进入CSet表示要垃圾收集）。默认值是Java堆的 10%。如果该值设置过大，则每次Mixed GC需要疏散的old region数量会变多，导致停顿时间拉长。该值可以限制每次Mixed GC最多能回收的old region数量。</p>
<ul>
<li>-XX:ParallelGCThreads&#x3D;n</li>
</ul>
<p>STW时并行工作的线程数。一般可以将 n 的值设置为逻辑处理器数的 5&#x2F;8 左右。</p>
<ul>
<li>-XX:ConcGCThreads&#x3D;n</li>
</ul>
<p>并行标记的线程数。可以将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1&#x2F;4 左右。</p>
<ul>
<li><p>-XX:+ParallelRefProcEnabled</p>
<p>并行处理Ref Proc阶段，默认HotSpot使用单线程处理引用对象。</p>
</li>
<li><p>-XX:+UnlockExperimentalVMOptions</p>
</li>
</ul>
<p>要更改实验性标志的值，必须先对其解锁。显式地设置该参数。</p>
<p>-XX:+G1PrintRegionLivenessInfo</p>
<p>打印堆内存里每个Region的存活对象信息。这个信息在标记结束后打印出来。这是一个实验性的标志。</p>
<ul>
<li>-XX:+G1TraceConcRefinement</li>
</ul>
<p>如果启用，并行回收阶段的日志就会被详细打印出来；这是一个实验性的标志。</p>
<ul>
<li>-XX:+G1TraceEagerReclaimHumongousObject</li>
</ul>
<p>如果启用，会打印大对象的回收日志；这是一个实验性的标志。</p>
<ul>
<li>-XX:+UseStringDeduplication</li>
</ul>
<p>开启Java String对象的分割工作，这个是JDK8u20之后新增的参数，主要用于相同String避免重复申请内存，节约Region的使用。</p>
<ul>
<li>-XX:G1MixedGCLiveThresholdPercent&#x3D;85</li>
</ul>
<p>&emsp;&emsp;在并发标记阶段怎么识别old region需要被回收而标记成candidate old region，以便在Mixed GC阶段进入CSet而被回收呢？是通过G1MixedGCLiveThresholdPercent来控制的，当region中的存活数据占比率不超过该阈值时，则表示要被回收，默认占用率为85%。</p>
<p>&emsp;&emsp;在并发标记阶段每个region中的存活数据占比率会被重新计算，那些存活数据占比较多的region，疏散时的代价相对较昂贵，它们还会被标记为expensive region。如果在MixedGC阶段这种region大量进入CSet中可能会导致MixedGC的停顿时间过长。G1为了区分开这些region而做了分开标记，在MixedGC阶段优先回收candidate old region，如果代价许可，会尝试回收expensive region。</p>
<p>​	在全局并发标记阶段，如果一个Region的存活对象的空间占比低于此值，则会被纳入Cset。此值直接影响到Mixed GC选择回收的区域，当发现GC时间较长时，可以尝试调低此阈值，尽量优先选择回收垃圾占比高的Region，但此举也可能导致垃圾回收的不够彻底，最终触发Full GC。</p>
<ul>
<li><p>-XX:SoftRefLRUPolicyMSPerMB</p>
<p>谨慎使用Soft Reference。如果SoftReference过多，会有频繁的老年代收集。-XX:SoftRefLRUPolicyMSPerMB参数，可以指定每兆堆空闲空间的软引用的存活时间，默认值是1000，也就是1秒。可以调低这个参数来触发更早的回收软引用。如果调高的话会有更多的存活数据，可能在GC后堆占用空间比会增加。 对于软引用，还是建议尽量少用，会增加存活数据量，增加GC的处理时间。</p>
</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>年轻代大小：避免使用-Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小，这会干扰到 G1收集器的默认行为，G1在垃圾收集时将不再关心暂停时间指标. 所以从本质上说,设置年轻代的大小将禁用暂停时间目标.G1在必要时也不能够增加或者缩小年轻代的空间. 因为大小是固定的,所以对更改大小无能为力。</li>
<li>暂停时间目标：每当对垃圾回收进行评估或调优时，都会涉及到延迟与吞吐量的权衡。G1是增量垃圾回收器， 其吞吐量目标是 90% 的应用程序时间和 10%的垃圾回收时间。因此，暂停时间目标不要太严苛。目标太过严苛表示愿意承受更多的垃圾回收开销，而这会直接影响到吞吐量。</li>
<li>混合模式的GC: 在调优混合模式的GC时，可以尝试以下选项。<br>-XX:InitiatingHeapOccupancyPercent: 设置标记周期的触发阈值。<br>-XX:G1MixedGCLiveThresholdPercent 和 -XX:G1HeapWastePercent: 调整混合模式GC相关的策略。<br>-XX:G1MixedGCCountTarget 和 -XX:G1OldCSetRegionThresholdPercent 用于优化调整CSet中的老年代region比例。</li>
<li>为了能观察到详细的暂停时间信息，可以添加调试的启动参数  -XX:+G1SummarizeRSetStats、-XX:+PrintReferenceGC、-XX:+PrintAdaptiveSizePolicy</li>
</ul>
<h2 id="GC日志中内存溢出和内存耗尽的信息"><a href="#GC日志中内存溢出和内存耗尽的信息" class="headerlink" title="GC日志中内存溢出和内存耗尽的信息"></a>GC日志中内存溢出和内存耗尽的信息</h2><p>如果我们在GC日志中看到 to-space overflow&#x2F;exhausted， 则表明G1没有足够的内存来存放存活区或者需要提升的对象，或者两者都不足。 这时候Java堆内存一般都已达到最大值，无法自动扩容。 示例如下：</p>
<p><code>924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space exhausted), 0.1957310 secs] </code><br>或者是这样:</p>
<p><code>924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space overflow), 0.1957310 secs]</code><br>要解决此类问题，可以尝试进行以下调整：</p>
<p>加大 <code>-XX:G1ReservePercent</code> 选项的值, 以增加保留的 “to-space” 大小，一般来说，堆内存的总大小也需要相应地加大。<br>降低 <code>-XX:InitiatingHeapOccupancyPercent</code> 来尽早触发标记周期。<br>适当加大 <code>-XX:ConcGCThreads</code> 选项的值，增加并发标记的线程数。<br>这些选项的具体信息，请参考前面的描述。</p>
<h2 id="大对象-巨型对象的内存分配"><a href="#大对象-巨型对象的内存分配" class="headerlink" title="大对象&#x2F;巨型对象的内存分配"></a>大对象&#x2F;巨型对象的内存分配</h2><p>如果某个对象超过单个 region 空间的一半，则会被G1视为 【大对象&#x2F;巨型对象】（Humongous object）。 例如一个很大的数组或者String。<br>这样的对象会直接分配到老年代的 “大对象region区（Humongous region）”。 一个大对象region区就是一组虚拟地址空间连续的region。 StartsHumongous 标志着开头的region，而 ContinuesHumongous 则标记随后的region集合。</p>
<p>在分配大对象region区之前，G1会先判断是否达到开启标记周期的阈值，在必要时会启动并发标记周期。</p>
<p>在标记周期最后的清理阶段，以及FullGC的清理过程中，都会释放不再使用的巨型对象。</p>
<p>为了减少内存复制的开销，所有转移暂停GC都不进行巨型对象的压缩和整理。 Full GC 时才会将巨型对象整理到位。</p>
<p>由于每个 StartsHumongous 和 ContinuesHumongous 组成的集合中都只保存一个巨型对象， 因此这个组合内部，最后面的空间总有一部分是浪费的。<br>如果某个对象占用的空间，只比N个region大上那么一点点，那么未使用的那部分空间实际上就产生了内存碎片。</p>
<p>如果在GC日志中，看到由 Humongous 分配而触发的大量并发周期，而且在老年代中形成了大量的内存碎片，就需要加大 -XX:G1HeapRegionSize 的值，让之前的巨型对象不再被当成巨无霸，而是走常规的对象分配方式【只要其小于region的50%即可】。</p>
<hr>
<p>参考：<br><a href="http://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html">http://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html</a><br><a href="http://blog.csdn.net/renfufei/article/details/41897113">http://blog.csdn.net/renfufei/article/details/41897113</a><br><a href="http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</a><br><a href="http://blog.csdn.net/lujinhong2/article/details/51130910">http://blog.csdn.net/lujinhong2/article/details/51130910</a><br><a href="https://renfufei.blog.csdn.net/article/details/108476781">https://renfufei.blog.csdn.net/article/details/108476781</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>GC相关</category>
      </categories>
  </entry>
  <entry>
    <title>GC优化案例</title>
    <url>/2024/04/01/Java/JVM/GC%E7%9B%B8%E5%85%B3/GC%E4%BC%98%E5%8C%96%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="案例一-Major-GC和Minor-GC频繁"><a href="#案例一-Major-GC和Minor-GC频繁" class="headerlink" title="案例一 Major GC和Minor GC频繁"></a><strong>案例一 Major GC和Minor GC频繁</strong></h2><p>服务情况：Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major GC耗时200ms，接口响应时间50ms。</p>
<span id="more"></span>

<p><strong>优化</strong></p>
<p>首先优化Minor GC频繁问题。通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。例如在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。</p>
<p>这时很多人有这样的疑问，扩容Eden区虽然可以减少Minor GC的次数，但会增加单次Minor GC时间么？根据上面公式，如果单次Minor GC时间也增加，很难保证最后的优化效果。我们结合下面情况来分析，单次Minor GC时间主要受哪些因素影响？是否和新生代大小存在线性关系？<br>首先，单次Minor GC时间由以下两部分组成：T1（扫描新生代）和 T2（复制存活对象到Survivor区）。（注：这里为了简化问题，我们认为T1只扫描新生代判断对象是否存活的时间，其实该阶段还需要扫描部分老年代，后面案例中有详细描述。）</p>
<ul>
<li>扩容前：新生代容量为R ，假设对象A的存活时间为750ms，Minor GC间隔500ms，那么本次Minor GC时间&#x3D; T1（扫描新生代R）+T2（复制对象A到S）。</li>
<li>扩容后：新生代容量为2R ，对象A的生命周期为750ms，那么Minor GC间隔增加为1000ms，此时Minor GC对象A已不再存活，不需要把它复制到Survivor区，那么本次GC时间 &#x3D; 2 × T1（扫描新生代R），没有T2复制时间。</li>
</ul>
<p>可见，扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次<strong>Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小</strong>。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。下面需要确认下服务中对象的生命周期分布情况：</p>
<img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291332455.png" alt="image-20240318224643473" style="zoom: 200%;" /> 

<p>通过上图GC日志中两处红色框标记内容可知：</p>
<ol>
<li>new threshold &#x3D; 2（动态年龄判断，对象的晋升年龄阈值为2），对象仅经历2次Minor GC后就晋升到老年代，这样老年代会迅速被填满，直接导致了频繁的Major GC。</li>
<li>Major GC后老年代使用空间为300M+，意味着此时绝大多数(86% &#x3D; 2G&#x2F;2.3G)的对象已经不再存活，也就是说生命周期长的对象占比很小。</li>
</ol>
<p>由此可见，服务中存在大量短期临时对象，扩容新生代空间后，Minor GC频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC频率自然也会降低。</p>
<p><strong>优化结果</strong></p>
<p>通过扩容新生代为为原来的三倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。</p>
<p><strong>小结</strong></p>
<p>如何选择各分区大小应该依赖应用程序中<strong>对象生命周期的分布情况：如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。</strong></p>
<p><strong>更多思考</strong></p>
<p>关于上文中提到晋升年龄阈值为2，很多同学有疑问，为什么设置了MaxTenuringThreshold&#x3D;15，对象仍然仅经历2次Minor GC，就晋升到老年代？这里涉及到“动态年龄计算”的概念。</p>
<p><strong>动态年龄计算</strong>：Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。在本案例中，调优前：Survivor区 &#x3D; 64M，desired survivor &#x3D; 32M，此时Survivor区中age&lt;&#x3D;2的对象累计大小为41M，41M大于32M，所以晋升年龄阈值被设置为2，下次Minor GC时将年龄超过2的对象被晋升到老年代。</p>
<p>JVM引入动态年龄计算，主要基于如下两点考虑：</p>
<ol>
<li>如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件：<br> a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样对象老化的机制就失效了。<br> b）MaxTenuringThreshold设置的过小，“过早晋升”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。</li>
<li>相同应用在不同时间的表现不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。</li>
</ol>
<p>  总结来说，为了更好的适应不同程序的内存情况，虚拟机并不总是要求对象年龄必须达到Maxtenuringthreshhold再晋级老年代。</p>
<h2 id="案例二-请求高峰期发生GC，导致服务可用性下降"><a href="#案例二-请求高峰期发生GC，导致服务可用性下降" class="headerlink" title="案例二 请求高峰期发生GC，导致服务可用性下降"></a><strong>案例二 请求高峰期发生GC，导致服务可用性下降</strong></h2><p>  GC日志显示，高峰期CMS在重标记（Remark）阶段耗时1.39s。Remark阶段是Stop-The-World（以下简称为STW）的，即在执行垃圾回收时，Java应用程序中除了垃圾回收器线程之外其他所有线程都被挂起，意味着在此期间，用户正常工作的线程全部被暂停下来，这是低延时服务不能接受的。本次优化目标是降低Remark时间。</p>
<p><strong>优化</strong></p>
<p>  解决问题前，先回顾一下CMS的四个主要阶段，以及各个阶段的工作内容。</p>
<ol>
<li>Init-mark初始标记(STW) ，该阶段进行可达性分析，标记GC ROOT能直接关联到的对象，所以很快。</li>
<li>Concurrent-mark并发标记，由前阶段标记过的对象出发，所有可到达的对象都在本阶段中标记。</li>
<li>Remark重标记(STW) ，暂停所有用户线程，重新扫描堆中的对象，进行可达性分析，标记活着的对象。因为并发标记阶段是和用户线程并发执行的过程，所以该过程中可能有用户线程修改某些活跃对象的字段，指向了一个未标记过的对象。特别需要注意一点，这个阶段是以新生代中对象为根来判断对象是否存活的。</li>
<li>并发清理，进行并发的垃圾清理。</li>
</ol>
<p>可见，Remark阶段主要是通过扫描堆来判断对象是否存活。那么准确判断对象是否存活，需要扫描哪些对象？CMS对老年代做回收，Remark阶段仅扫描老年代是否可行？结论是不可行，新生代对象持有老年代中对象的引用，这种情况称为<strong>“跨代引用”</strong>。因它的存在，Remark阶段必须扫描整个堆来判断对象是否存活。</p>
<p><strong>新生代GC和老年代的GC是各自分开独立进行的</strong>，只有Minor GC时才会使用根搜索算法，标记新生代对象是否可达，也就是说虽然一些对象已经不可达，但在Minor GC发生前不会被标记为不可达，CMS也无法辨认哪些对象存活，只能全堆扫描（新生代+老年代）。由此可见堆中对象的数目影响了Remark阶段耗时。</p>
<p>分析GC日志可以得出同样的规律，Remark耗时&gt;500ms时，新生代使用率都在75%以上。这样降低Remark阶段耗时问题转换成如何减少新生代对象数量。新生代中对象的特点是“朝生夕灭”，这样如果Remark前执行一次Minor GC，大部分对象就会被回收。CMS就采用了这样的方式，在Remark前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。此阶段在Eden区使用超过2M时启动，当然2M是默认的阈值，可以通过参数修改。如果此阶段执行时等到了Minor GC，Reamark阶段需要扫描的对象就少了。</p>
<p>除此之外CMS为了避免这个阶段没有等到Minor GC而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime ，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生Minor GC，都会中止此阶段，进入Remark。如果可中断的并发预清理执行，超过了设置的5s，期间没有等到Minor GC ，那么Remark时新生代中仍然有很多对象。</p>
<p>对于这种情况，CMS提供CMSScavengeBeforeRemark参数，用来保证Remark前强制进行一次Minor GC。</p>
<p><strong>优化结果</strong></p>
<p>经过增加CMSScavengeBeforeRemark参数，单次执行时间&gt;200ms的GC停顿消失，从监控上观察，GCtime和业务波动保持一致，不再有明显的毛刺。</p>
<p><strong>小结</strong></p>
<p>通过案例分析了解到，由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆，同时为了避免扫描时新生代有很多对象，增加了可中断的预清理阶段用来等待Minor GC的发生。只是该阶段有时间限制，如果超时等不到Minor GC，Remark时新生代仍然有很多对象，我们的调优策略是，通过参数强制Remark前进行一次Minor GC，从而降低Remark阶段的时间。</p>
<p><strong>更多思考</strong></p>
<p>案例中只涉及老年代GC，其实新生代GC存在同样的问题，即老年代可能持有新生代对象引用，所以Minor GC时也必须扫描老年代。</p>
<p><strong>JVM是如何避免Minor GC时扫描全堆的？</strong><br> 经过统计信息显示，老年代持有新生代对象引用的情况不足1%，根据这一特性JVM引入了卡表（card table）来实现这一目的。如下图所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291334551.png" alt="image-20240318225450787"> </p>
<p><strong>卡表</strong>的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。如上图所示，卡表3被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后Minor GC时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。</p>
<p>总结来说，CMS的设计聚焦在获取最短的时延，为此它“不遗余力”地做了很多工作，包括尽量让应用程序和GC线程并发、增加可中断的并发预清理阶段、引入卡表等，虽然这些操作牺牲了一定吞吐量但获得了更短的回收停顿时间。</p>
<h2 id="案例三-发生Stop-The-World的GC"><a href="#案例三-发生Stop-The-World的GC" class="headerlink" title="案例三 发生Stop-The-World的GC"></a><strong>案例三 发生Stop-The-World的GC</strong></h2><p>  在GC日志中，Full GC是用来说明这次垃圾回收的停顿类型，代表STW类型的GC，并不特指老年代GC，根据日志有Full GC耗时1.23s的情况。这个在线服务同样要求低时延高可用。本次优化目标是降低单次STW回收停顿时间，提高可用性。</p>
<p><strong>优化</strong></p>
<p>首先，什么时候可能会触发STW的Full GC呢？</p>
<ol>
<li>Perm空间不足；</li>
<li>CMS GC时出现promotion failed和concurrent     mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）；</li>
<li>统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间；</li>
<li>主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。</li>
</ol>
<p>然后，我们来逐一分析一下：</p>
<ul>
<li>排除原因2：如果是原因2中两种情况，日志中会有特殊标识，目前没有。</li>
<li>排除原因3：根据GC日志，当时老年代使用量仅为20%，也不存在大于2G的大对象产生。</li>
<li>排除原因4：因为当时没有相关命令执行。</li>
<li>锁定原因1：根据日志发现Full GC后，Perm区变大了，推断是由于永久代空间不足容量扩展导致的。</li>
</ul>
<p>找到原因后解决方法有两种：</p>
<ol>
<li>通过把-XX:PermSize参数和-XX:MaxPermSize设置成一样，强制虚拟机在启动的时候就把永久代的容量固定下来，避免运行时自动扩容。</li>
<li>CMS默认情况下不会回收Perm区，通过参数CMSPermGenSweepingEnabled、CMSClassUnloadingEnabled ，可以让CMS在Perm区容量不足时对其回收。</li>
</ol>
<p>由于该服务没有生成大量动态类，回收Perm区收益不大，所以我们采用方案1，启动时将Perm区大小固定，避免进行动态扩容。</p>
<p><strong>优化结果</strong></p>
<p>调整参数后，服务不再有Perm区扩容导致的STW GC发生。</p>
<p><strong>小结</strong></p>
<p>对于性能要求很高的服务，建议将MaxPermSize和MinPermSize设置成一致（JDK8开始，Perm区完全消失，转而使用元空间。而元空间是直接存在内存中，不在JVM中），Xms和Xmx也设置为相同，这样可以减少内存自动扩容和收缩带来的性能损失。虚拟机启动的时候就会把参数中所设定的内存全部化为私有，即使扩容前有一部分内存不会被用户代码用到，这部分内存在虚拟机中被标识为虚拟内存，也不会交给其他进程使用。</p>
<p>转载自：<br><a href="https://tech.meituan.com/jvm_optimize.html">https://tech.meituan.com/jvm_optimize.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>GC相关</category>
      </categories>
  </entry>
  <entry>
    <title>G1对比CMS</title>
    <url>/2024/04/01/Java/JVM/GC%E7%9B%B8%E5%85%B3/G1%E5%AF%B9%E6%AF%94CMS/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="如何处理跨代引用"><a href="#如何处理跨代引用" class="headerlink" title="如何处理跨代引用"></a>如何处理跨代引用</h2><p>​        在垃圾回收的时候都是从Root开始搜索，这会先经过年轻代再到老年代，对于年轻代引用老年代的这种跨代不需要单独处理。但是老年代引用年轻代的会影响young gc，这种跨代需要处理。<br>​        为了避免在回收年轻代的时候扫描整个老年代，需要记录老年代对年轻代的引用，young gc的时候只要扫描这个记录。</p>
<p>​        CMS和G1都用到了<strong>Card Table</strong>，但是用法不太一样。JVM将内存分成一个个固定大小的card，然后有一个专门的数据结构(即这里的Card Table)维护每个Card的状态，一个字节对应一个Card，有点像内存page的概念，只是page是硬件上的，Card Table是软件上的。当一个Card上的对象的引用发生变化的时候，就将这个Card对应的Card Table上的状态置为dirty，young gc的时候扫描状态是dirty的Card即可。这是基本的用法，CMS基本上就是这么使用。<br>​        G1在Card Table的基础上引入的Remembered Set(下面简称RSet)。每个region都会维护一个RSet，记录着引用到本region中的对象的其他region的Card。比如A对象在regionA，B对象在regionB，且B.f &#x3D; A，则在regionA的RSet中需要记录B所在的Card的地址。这样的好处是可以对region进行单独回收，这要求RSet不只是维护老年代到年轻代的引用，也要维护这老年代到老年代的引用，对于跨代引用的每次只要扫描这个region的RSet上的Card即可。<br>​       上面说过年轻代到老年代的引用不需要单独处理，这带来了很大的性能上的提升，因为年轻代的对象引用变化很大，如果都需要记录下来成本会很高。同时也说明只需要在老年代维护Card Table。</p>
<span id="more"></span>

<h2 id="如何处理并发过程的对象变化"><a href="#如何处理并发过程的对象变化" class="headerlink" title="如何处理并发过程的对象变化"></a>如何处理并发过程的对象变化</h2><p>​        CMS和G1都有并发处理过程，这个过程应用程序跟着gc线程一起运行，会产生新对象，也会有旧的对象死去，对象之间的引用关系也会发生变化。这部分数据可以暂时不处理，留到下一次再处理吗？如果可以这样的话问题就会变得很简单，但是答案是不行。</p>
<p>​        考虑下图的场景(图中每一行表示一个内存状态，每一列表示一个Card，这里有4个)：</p>
<blockquote>
<p>第一步a是并发标记中途的一个状态，标记了a b c e四个对象，0 1两个Card已经标记好；</p>
<p>第二步b并发标记的同时引用发生变化，g不再指向d，而b不再指向c，变成指向d，这个时候处理Card 2，会标记到g，然后就标记结束了，导致d对象丢失。</p>
</blockquote>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291347046.png" alt="img"></p>
<p>​        CMS初始标记的时候会标记所有从root直接可达的对象，并发标记的时候再从这些对象进一步搜索其他可达对象，最终构成一个存活的对象图。并发标记过程中引用发生变化的也是通过Card Table来记录。但是young gc的时候如果一个dirty card没有包含到年轻代的引用，这个card会重新标记为clean，这有可能将并发标记过程产生的dirty card错误清除，因此CMS引入了另一个数据结构mod union table，这里一个bit对应一个Card，young gc在将Card Table设置为clean的时候会将对应的mod union table置为dirty。最终标记的时候会将Card Table或者mod union table是dirty的Card也作为root去扫描，从而解决并发标记过程产生的引用变化。CMS还需要处理并发过程从年轻代晋升到老年代的对象，处理方式是将这部分对象也作为root去扫描。<br>​        G1使用一个称为snapshot at the beginning(下面简称SATB)的算法，在初始标记的时候得到一个从root直接可达的snapshot，之后从这个snapshot不可达的对象都是可以回收的垃圾，并发过程产生的对象都默认是活的对象，留到下一次再处理。对于引用关系发生变化的，将这个对象对应的Card放到一个SATB队列里，在最终标记的时候进行处理(如果超过一定的阈值并发标记的时候也会处理一部分)，处理的过程就是以队列中的Card作为root进行扫描。</p>
<h2 id="Write-Barrier"><a href="#Write-Barrier" class="headerlink" title="Write Barrier"></a>Write Barrier</h2><p>Write Barrier可以理解为在写的时候插入一条特定的操作。<br>在CMS中老年代引用年轻代的时候就是通过触发一个Write Barrier来更新Card Table的标志位。这是一个同步操作，在更新引用的时候顺带执行，只需要两个指令，引入的消耗不大。</p>
<p>G1比较复杂，在两个地方用到了Write Barrier，分别是更新RSet的rememberd set Write Barrier和记录引用变化的Concurrent Marking Write Barrier，前者发生在引用更新之后，称为Post Write Barrier，后者发生在引用变化之前，称为Pre Write Barrier。G1为了提高性能，这两个Write Barrier都是先放到队列中，再异步进行处理。</p>
<h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>导致CMS Full GC的可能原因主要有两个：Promotion Failure和Concurrent Mode Failure，前者是在年轻代晋升的时候老年代没有足够的连续空间容纳，很有可能是内存碎片导致的；后者是在并发过程中jvm觉得在并发过程结束前堆就会满了，需要提前触发Full GC。</p>
<p>CMS的Full GC是一个多线程STW的Mark-Compact过程，，需要尽量避免或者降低频率。</p>
<p>G1的初衷就是要避免Full GC的出现，Full GC会会对所有region做Evacuation-Compact，而且是单线程的STW，非常耗时间。导致G1 Full GC的原因可能有两个：1. Evacuation的时候没有足够的to-space来存放晋升的对象；2. 并发处理过程完成之前空间耗尽。这两个原因跟CMS类似。</p>
<hr>
<p><strong>卡表(Card Table)</strong><br>       有个场景，老年代的对象可能引用新生代的对象，那标记存活对象的时候，需要扫描老年代中的所有对象。因为该对象拥有对新生代对象的引用，那么这个引用也会被称为GC Roots。那不是得又做全堆扫描？成本太高了吧。<br>        HotSpot给出的解决方案是一项叫做卡表(Card Table)的技术。该技术将整个堆划分为一个个大小为512字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。<br>        在进行Minor GC的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到Minor GC的GC Roots里。当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零。<br>        想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么]v虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。卡表能用于减少老年代的全堆空间扫描，这能很大的提升GC效率。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/kuaipao19950507/article/details/105809365">https://blog.csdn.net/kuaipao19950507/article/details/105809365</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>GC相关</category>
      </categories>
  </entry>
  <entry>
    <title>通过SQL分析数据库加锁</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/MySQL/%E5%8E%9F%E7%90%86/InnoDB%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<p>[toc]<br>&emsp;&emsp;InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。（还有一个支持外键）</p>
<h3 id="获取InnoDB行锁争用情况"><a href="#获取InnoDB行锁争用情况" class="headerlink" title="获取InnoDB行锁争用情况"></a>获取InnoDB行锁争用情况</h3><p>&emsp;&emsp;可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p>
<h3 id="InnoDB的行锁模式及加锁方法"><a href="#InnoDB的行锁模式及加锁方法" class="headerlink" title="InnoDB的行锁模式及加锁方法"></a>InnoDB的行锁模式及加锁方法</h3><p>&emsp;&emsp;InnoDB实现了以下两种类型的行锁。</p>
<ul>
<li>共享锁（S, shared locks）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（X, exclusive locks）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>&emsp;&emsp;InnoDB支持多粒度的锁，也即，除了行锁外还支持表锁，表锁通过意向锁实现，用以提示事务即将对表中的行添加什么样的锁。InnoDB有两种内部使用的意向锁（Intention Locks）：</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li>
</ul>
<p>&emsp;&emsp;上述锁模式的兼容情况具体如表:<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171003468.png"></p>
<span id="more"></span>
<p>&emsp;&emsp;如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p>
<p>&emsp;&emsp;意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。<br>&emsp;&emsp;i：共享锁（S）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code><br>&emsp;&emsp;ii：排他锁（X）：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code></p>
<p>&emsp;&emsp;用 SELECT … IN SHARE MODE 获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。</p>
<p>&emsp;&emsp;从InnoDB锁住的对象来看，InnoDB又可分为<code>Record Lock</code>, <code>Gap Lock</code>和<code>Next-Key Lock</code>。其中Record Lock只对索引记录加锁，Gap Lock在索引记录之间的”间隙“加锁，这个”间隙“也包含第一条索引记录之前和最后一条索引记录之后的”间隙“。Next-Key Lock是Record Lock和Gap Lock的结合，除了锁住索引记录本身外还锁住索引记录之前的”间隙“。（注意Record Lock只对索引记录加锁，即使创建表时没有指定任何索引（此时InnoDB创建一个隐藏的索引使用该索引加锁））。</p>
<p>&emsp;&emsp;默认情况下，InnoDB引擎使用 REPEATABLE READ 事务隔离级别和<code>innodb_locks_unsafe_for_binlog=0</code>的设置。此时，InnoDB使用Next-Key Lock来避免”幻象“读问题。</p>
<p>&emsp;&emsp;假定索引包含4,9,12,18几条记录，Record Lock直接在4,9,12,18这几条索引记录上加锁，Gap Lock覆盖的间隙包括(-,4)、(4,9)、(9,12)、(12,18)、(18,-)，而Next-Key Lock可能锁定的区间包括(-,4]、(4,9]、(9,12]、(12,18]、(18,-)。<br>&emsp;&emsp;若事务持有索引R上的S锁或X锁，另外的事务便无法在R之前的间隙插入记录（这避免幻象读的基本原理）。如果，使用了唯一索引来检索唯一的行（不包括搜索条件只包含多列唯一索引中的部分列的情况）不会使用Gap Lock。例如user表id列上有唯一索引则SELECT * FROM user WHERE id &#x3D; 100只会在id&#x3D;100的行上对唯一索引加Record Lock，若该id不存在或者该列上无唯一索引则语句会锁住对应的间隙。</p>
<p>&emsp;&emsp;InnoDB中存在一种称为 insert intention gap lock的Gap Lock，由INSERT语句在执行插入操作前设置，用以表明多个事务向相同的索引间隙插入数据时若在间隙内插入的位置不同则不必相互等待。假定有值为4和7的索引记录。两个不同的事务分别同时向4和7之间的间隙插入5和6两条记录，在获取插入行上的X锁前会先获取间隙内的插入意向锁，因为行并不冲突，所以不会相互阻塞。</p>
<p>&emsp;&emsp;需要特别注意的是，不同的事务可以在同一gap上持有不兼容的锁类型。也即，对于Gap lock来说，gap X-lock与gap S-lock是等价的。Gap lock仅用来阻止其他事务在gap内插入。</p>
<p>&emsp;&emsp;在讲解InnoDB四种事务隔离级别的时候，讲到过”幻象“读问题，也即在”READ COMMITTED“隔离级别下，同一事务的两次相同的查询可能返回不同的结果，或者”REPEATABLE READ“事务隔离级别下，事务B的更新对另一事务A的更新语句可见，且在事务A在对更新后的结果进行了更新后随后同一事务中的SELECT能够看到之前不存在的记录更新后的结果。具体可以参考对应章节的示例。InnoDB使用Next-key Lock来解决”幻读“。InnoDB默认事务隔离级别为REPEATABLE READ，该隔离级别下InnoDB使用Next-key Lock来锁住相关索引记录以及记录之前的”间隙“，以保证其他session中的事务不仅不能更新记录而且不能在其中插入数据，从而避免”幻读“问题。</p>
<p>&emsp;&emsp;还用最初的表做实验，删除原有记录并在表t中插入i&#x3D;4,9,12,20,30几条记录。</p>
<p>&emsp;&emsp;先将事务隔离级别调整为READ-COMMITED，我们已经知道，该隔离级别下用非锁定读时可以读取到其他事务中提交的更新，使前后两次同样条件的查询读取到的结果不一致，那么使用锁定读呢？从下边的例子可以看出，在READ-COMMITED隔离级别下，SESSION A中的事务使用锁定读(这里为X锁)，可以阻塞SESSION B中的事务对锁定的记录进行更新或删除，”一定程度上“避免了”不可重复读“或者”幻读”,但是，这里的锁只锁定了记录本身，也即Record Lock，没能阻止SESSION B中的事务在锁定的记录之间插入新的记录，因此当其他事物在这些”间隙“内插入记录并提交后SESSION A中的事务能够看到新插入的记录，还是存在”不可重复读“或者”幻读”。</p>
<p>&emsp;&emsp;接下来将隔离级别调整为REATABLE READ，该隔离级别下使用非锁定读一般不会读取到其他事物提交的更新，但其他事务中的更新对其更新操作是可见的，当该事务对更新后的记录进行了更新后，同一事物内的查询便可以看到最新的结果，造成前后两次读取结果不一致（前边已有例子进行说明）。那么该隔离级别下使用锁定读呢？会不会也不能避免其他事物在锁定记录的”间隙“插入新的记录呢？答案是否定的，该隔离级别下，InnoDB使用Next-key Lock，除了锁定记录本身外还会锁定记录之间的”间隙”，从而阻止其他事物在读取的记录键插入新的记录，避免前后同一查询条件查询结果却不一致的问题。</p>
<h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>&emsp;&emsp;Innodb Lock大体上可以分为：</p>
<ul>
<li>共享锁，shared locks（S锁）</li>
<li>排它锁，exclusive locks（X锁）</li>
<li>意向锁，intention lock，分为 意向共享锁(IS锁) 和 意向排它锁(IX锁)</li>
<li>行锁，（record Locks、gap locks、next-key locks、Insert Intention Locks)</li>
<li>自增锁，auto-inc locks</li>
</ul>
<p>&emsp;&emsp;<br>&emsp;&emsp;行锁的作用范围是行级别，数据库能够确定那些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。举个例子，一个用户表user，有主键id和用户生日birthday，当使用<code>update ... where id=?</code>这样的语句数据库明确知道会影响哪一行，它就会使用行锁，当使用<code>update ... where birthday=?</code>这样的的语句的时候因为事先不知道会影响哪些行就可能会使用表锁。</p>
<ul>
<li><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p>
</li>
<li><p>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。</p>
</li>
<li><p>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。</p>
</li>
<li><p>即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。 因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p>
</li>
<li><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚集索引来对记录加锁。InnoDB行锁主要分为3种情形：</p>
<ul>
<li>Record lock：对索引项加锁</li>
<li>Gap lock：对索引项之间的“间隙”、第一条记录前的“间隙”或最后一条记录后的“间隙”加锁</li>
<li>Next-key lock：前两种的组合，对记录及其前面的间隙加锁。</li>
</ul>
</li>
</ul>
<h4 id="共享-排他锁"><a href="#共享-排他锁" class="headerlink" title="共享&#x2F;排他锁"></a>共享&#x2F;排他锁</h4><p>&emsp;&emsp;行锁分为：S Lock 和 X Lock。S Lock是共享锁，可以理解为读锁；X Lock即写锁。<br>&emsp;&emsp;兼容性：读锁可以读，读锁不可写；写锁不可读也不可写。</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>&emsp;&emsp;InnoDB支持多粒度的锁，即：允许表锁和行锁同时存在。但是，假如表锁覆盖了行锁的数据，所以表锁和行锁也会产生冲突。为了解决这种表锁和行锁共存的问题，就产生了意向锁这个东西。意向锁：从字面意思也很好理解，就是提前表明一个“意向”。</p>
<p>&emsp;&emsp;意向锁分为：</p>
<ul>
<li>意向共享锁。它预示着，事务有意向对表中的”某些行”加S锁。select xxxx lock in share mode，要设置IS锁。</li>
<li>意向排他锁。它预示着，事务有意向表中的“某些行”加X锁。select xxx for update，要设置IX锁。</li>
</ul>
<p>&emsp;&emsp;但意向锁仅仅是表明意向，它其实非常弱，意向锁之间可以相互并行，并不是排斥的：</p>
<p>InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p>
<ol>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li>
</ol>
<p>如果一个事务请求的锁模式与当前的锁兼容，innodb 就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p>
<p>意向锁是 innodb 自动加的，不需要用户干预。对于 update、delete 和 insert 语句，innodb 会自动给涉及数据集加排它锁（X）；对于普通 select 语句，innodb 不会加任何锁。</p>
<h4 id="主键自增锁"><a href="#主键自增锁" class="headerlink" title="主键自增锁"></a>主键自增锁</h4><p>&emsp;&emsp;自增锁(auto-inc Locks)是一种特殊的表级锁，专门针对事务插入AUTO_INCREMENT类型的列，往往就是主键列。可以保证主键的值自增是“原子操作”，不会出现一致性、唯一性问题。</p>
<p>&emsp;&emsp;</p>
<h3 id="行锁的具体分类"><a href="#行锁的具体分类" class="headerlink" title="行锁的具体分类"></a>行锁的具体分类</h3><h4 id="记录锁-Record-Lock"><a href="#记录锁-Record-Lock" class="headerlink" title="记录锁(Record Lock)"></a>记录锁(Record Lock)</h4><p>&emsp;&emsp;记录锁(Record Lock)  是会去锁住索引记录， 记录锁也叫 行锁。<br>&emsp;&emsp;例如：<code>SELECT * FROM `test` WHERE `id`=1 FOR UPDATE;</code><br>&emsp;&emsp;假如没有任何一个索引，那么InnoDB会锁住隐形创建的那个主键。注意：这里锁的是索引，不一定只是主键索引，还可能是二级普通索引。</p>
<h4 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁(Gap Lock)"></a>间隙锁(Gap Lock)</h4><p>&emsp;&emsp;顾名思义，它会封锁索引记录中的“间隔”，限制其他事务在“间隔”中插入数据。它锁定的是一个不包含索引本身的范围。<br>&emsp;&emsp;举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，<code>select * from  emp where empid &gt; 100 for update;</code>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>
<h4 id="临键锁-Next-Key-Lock"><a href="#临键锁-Next-Key-Lock" class="headerlink" title="临键锁(Next-Key Lock)"></a>临键锁(Next-Key Lock)</h4><p>&emsp;&emsp;Next-Key Lock 可以说是记录锁(Record Lock)和间隙锁（Gap Lock）的组合，它的封锁范围，既包含索引记录，又包含索引区间。<br>&emsp;&emsp;临键锁的主要目的，也是为了避免幻读。如果把事务的隔离级别降级为RC，临键锁则也会失效。</p>
<h3 id="不可重复读-No-Reaptable-Read-和幻读-Phantom-Problem"><a href="#不可重复读-No-Reaptable-Read-和幻读-Phantom-Problem" class="headerlink" title="不可重复读(No Reaptable Read)和幻读(Phantom Problem)"></a>不可重复读(No Reaptable Read)和幻读(Phantom Problem)</h3><p>&emsp;&emsp;不可重复读：修改。在同一个事务中，主要是说多次读取一条记录, 发现该记录中某些列值被修改过。<br>&emsp;&emsp;幻读: 增加或者删除。在同一个事务中，同一条完全相同的查询语句返回的结果集行数不同。</p>
<p>&emsp;&emsp;多版本并发控制 MVCC（读）和 临键锁 Next-Key Lock（写）共同解决了幻读问题。<br>&emsp;&emsp;关于MVCC的原理，就是每份数据会有快照，事务中读取数据(简单的select xxx from，select xx from xx for update或者select xx from xxx in share mode不行)的时候，如果数据被锁住了，就读以前留下的快照数据。</p>
<p>&emsp;&emsp;MVCC只在 Read Committed 和 Repeatable Read 下会开启。但是在这两种隔离级别下对于快照指定的数据定义不同。<br>&emsp;&emsp;在Read Committed下，MVCC读取的是被锁定数据的最新的一份数据。<br>&emsp;&emsp;在Repeatable Read下，MVCC读取的是事务刚开始时候的数据。</p>
<h3 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h3><p>&emsp;&emsp;InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p>
<p>&emsp;&emsp;在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p>
<p>（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。<br>（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。<br>（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。<br>（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p>
<h3 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）"></a>间隙锁（Next-Key锁）</h3><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>
<p>举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p>
<p>Select * from  emp where empid &gt; 100 for update;</p>
<p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>
<p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对锁机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况，在后续的章节中会做进一步介绍。</p>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<p>还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/u013967628/article/details/85293041">https://blog.csdn.net/u013967628/article/details/85293041</a><br><a href="https://blog.csdn.net/wangyiyungw/article/details/81002256">https://blog.csdn.net/wangyiyungw/article/details/81002256</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>MySQL</category>
        <category>原理</category>
      </categories>
  </entry>
  <entry>
    <title>redo log、undo log、binlog</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/MySQL/%E5%8E%9F%E7%90%86/redo%20log%E3%80%81undo%20log%E3%80%81binlog/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><p>​        在innoDB的存储引擎中，事务日志通过 redolog 和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。</p>
<p>​        事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是Write-Ahead Logging。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</p>
<p>​        在系统启动的时候，就已经为redo log分配了一块连续的存储空间,以顺序追加的方式记录redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的redo Log按语句的执行顺序，依次交替的记录在一起。如下一个简单示例：</p>
<ul>
<li>记录1：&lt;trx1, insert…&gt;</li>
<li>记录2：&lt;trx2, delete…&gt;</li>
<li>记录3：&lt;trx3, update…&gt;</li>
<li>记录4：&lt;trx1, update…&gt;</li>
<li>记录5：&lt;trx3, insert…&gt;</li>
</ul>
<span id="more"></span>

<p>​        InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块 “粉板”总共就可以记录 4GB 的操作。</p>
<p>​        <strong>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</strong> </p>
<p>​        在概念上，innodb通过<strong>force log at commit</strong>机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。 为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中**都会调用一次操作系统的fsync操作(fsync函数同步内存中所有已修改的文件数据到储存设备)**。因为MariaDB&#x2F;MySQL是工作在用户空间的，MariaDB&#x2F;MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件,undo:share tablespace或.ibd文件)，中间还要经过操作系统内核空间的os buffer，调用fsync()的作用就是将OS buffer中的日志刷到磁盘上的log file中。 也就是说，从redo log buffer写日志到磁盘的redo log file中，过程如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170950942.png" alt="mysql日志redo log、undo log、binlog以及作用看这篇就可以啦"></p>
<p>​        在此处需要注意一点，一般所说的log file并不是磁盘上的物理日志文件，而是操作系统缓存中的log file，官方手册上的意思也是如此(例如：With a value of 2, the contents of the <strong>InnoDB log buffer are written to the log file</strong> after each transaction commit and <strong>the log file is flushed to disk approximately once per second</strong>)。但说实话，这不太好理解，既然都称为file了，应该已经属于物理文件了。所以在本文后续内容中都以os buffer或者file system buffer来表示官方手册中所说的Log file，然后log file则表示磁盘上的物理日志文件，即log file on disk。</p>
<p>​        另外，之所以要经过一层os buffer，是因为open日志文件的时候，open没有使用O_DIRECT标志位，该标志位意味着绕过操作系统层的os buffer，IO直写到底层存储设备。不使用该标志位意味着将日志进行缓冲，缓冲到了一定容量，或者显式fsync()才会将缓冲中的刷到存储设备。使用该标志位意味着每次都要发起系统调用。比如写abcde，不使用o_direct将只发起一次系统调用，使用o_object将发起5次系统调用。 MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量<br>innodb_flush_log_at_trx_commit 的值来决定。该变量有3种值：0、1、2，默认为1。但注意，这个变量只是控制commit动作是否刷新log buffer到磁盘。</p>
<p>​        当设置为1的时候，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。</p>
<p>​        当设置为0的时候，事务提交时不会将log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</p>
<p>​        当设置为2的时候，每次提交都仅写入到os buffer，然后是每秒调用fsync()将os buffer中的日志写入到log file on disk。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170950807.png" alt="mysql日志redo log、undo log、binlog以及作用看这篇就可以啦"></p>
<p>注意，有一个变量<br>innodb_flush_log_at_timeout 的值为1秒，该变量表示的是刷日志的频率，很多人误以为是控制 innodb_flush_log_at_trx_commit 值为0和2时的1秒频率，实际上并非如此。测试时将频率设置为5和设置为1，当 innodb_flush_log_at_trx_commit 设置为0和2的时候性能基本都是不变的。关于这个频率是控制什么的，在后面的”刷日志到磁盘的规则”中会说。 在主从复制结构中，要保证事务的持久性和一致性，需要对日志相关变量设置为如下：</p>
<p><strong>如果启用了二进制日志，则设置sync_binlog&#x3D;1，即每提交一次事务同步写到磁盘中。</strong></p>
<p><strong>总是设置innodb_flush_log_at_trx_commit&#x3D;1，即每提交一次事务都写到磁盘中。</strong></p>
<p>上述两项变量的设置保证了：每次提交事务都写入二进制日志和事务日志，并在提交时将它们刷新到磁盘中。 选择刷日志的时间会严重影响数据修改时的性能，特别是刷到磁盘的过程。</p>
<h1 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h1><p>​        undo log主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</p>
<p>​        以下是undo+redo事务的简化过程：假设有2个数值，分别为A&#x3D;1和B&#x3D;2，然后将A修改为3，B修改为4</p>
<blockquote>
<ol>
<li>start transaction;</li>
<li>记录 A&#x3D;1 到undo log;</li>
<li>update A &#x3D; 3；</li>
<li>记录 A&#x3D;3 到redo log；</li>
<li>记录 B&#x3D;2 到undo log；</li>
<li>update B &#x3D; 4；</li>
<li>记录B &#x3D; 4 到redo log；</li>
<li>将redo log刷新到磁盘</li>
<li>commit</li>
</ol>
</blockquote>
<p>​        在1-8步骤的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响。如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为此时redo log已经持久化。若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘。</p>
<p>​        所以，<strong>redo log其实保证的是事务的持久性和一致性，而undo log则保证了事务的原子性</strong>。undo log是逻辑日志，可以理解为:</p>
<ul>
<li>当delete一条记录时，undo log中会记录一条对应的insert记录</li>
<li>当insert一条记录时，undo log中会记录一条对应的delete记录</li>
<li>当update一条记录时，它记录一条对应相反的update记录</li>
</ul>
<h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>​        关于mysql主从同步，相信大家都不陌生，随着系统应用访问量逐渐增大，单台数据库读写访问压力也随之增大，当读写访问达到一定瓶颈时，将数据库的读写效率骤然下降，甚至不可用；为了解决此类问题，通常会采用mysql集群，当主库宕机后，集群会自动将一个从库升级为主库，继续对外提供服务；那么主库和从库之间的数据是如何同步的呢？其实就是通过binlog主从同步binlog来实现的。</p>
<p>▪ Binlog是server层的日志，主要做mysql功能层面的事情</p>
<p>▪ 与redo日志的区别:</p>
<blockquote>
<p>redo是innodb独有的，binlog是所有引擎都可以使用的。</p>
<p>redo是物理日志，记录的是在某个数据页上做了什么修改，binlog是逻辑日志，记录的是这个语句的原始逻辑。 </p>
<p>redo是循环写的，空间会用完，binlog是可以追加写的，不会覆盖之前的日志信息。</p>
</blockquote>
<p>Binlog中会记录所有的逻辑，并且采用追加写的方式。</p>
<p>一般在企业中数据库会有备份系统，可以定期执行备份，备份的周期可以自己设置。</p>
<p>恢复数据的过程:找到最近一次的全量备份数据。 从备份的时间点开始，将备份的binlog取出来，重放到要恢复的那个时刻。</p>
<hr>
<p>转载自：<br><a href="https://www.toutiao.com/a6845545335599661579/?log_from=b4450f87a3ecd_1635169016770">https://www.toutiao.com/a6845545335599661579/?log_from=b4450f87a3ecd_1635169016770</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>MySQL</category>
        <category>原理</category>
      </categories>
  </entry>
  <entry>
    <title>InnoDB的MVCC原理</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/MySQL/%E5%8E%9F%E7%90%86/InnoDB%E7%9A%84MVCC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="什么是MVVC"><a href="#什么是MVVC" class="headerlink" title="什么是MVVC"></a>什么是MVVC</h3><p>&emsp;&emsp;MVCC (Multi-Version Concurrency Control) 是一种基于多版本的并发控制协议，只有在InnoDB引擎下存在。MVCC是为了实现事务的隔离性，通过版本号，避免同一数据在不同事务间的竞争，可以把它当成基于多版本号的一种乐观锁。当然，这种乐观锁只在事务级别未提交锁和已提交锁时才会生效。MVCC最大的好处，读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能。</p>
<p>&emsp;&emsp;可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p>&emsp;&emsp;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。</p>
<span id="more"></span>


<h3 id="MVVC的实现机制"><a href="#MVVC的实现机制" class="headerlink" title="MVVC的实现机制"></a>MVVC的实现机制</h3><p>&emsp;&emsp;InnoDB存储引擎在每行数据都增加三个隐藏字段，一个唯一行号，一个记录创建的版本号，一个记录回滚的版本号。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170953200.png"></p>
<ul>
<li><strong>6字节的事务ID(DB_TRX_ID)字段</strong>：用来标识最近一次对本行记录做修改(insert|update)的事务的标识符，即最后一次修改本行记录的事务id。至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted，并非真正删除。</li>
<li><strong>7字节的回滚指针(DB_ROLL_PTR)字段</strong>：指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。如果一行记录被更新, 则 undo log record 包含 ‘重建该行记录被更新之前内容’  所必须的信息。</li>
<li><strong>6字节的DB_ROW_ID字段</strong>：包含一个随着新行插入而单调递增的行ID，当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。</li>
</ul>
<p>&emsp;&emsp;注意：执行删除SQL时，并不是直接将记录从数据页中抹掉，而是通过一个<strong>删除位（delete_flag）来进行标识</strong>，将该字段置为1即标识这行数据已经被删除了；同时和其他写一样会记录操作事务的trx_id。</p>
<p>&emsp;&emsp;在多版本并发控制中，为了保证数据操作在多线程过程中，保证事务隔离的机制，降低锁竞争的压力，保证较高的并发量。<br>&emsp;&emsp;在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新（包括增删改）操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170953954.png"></p>
<blockquote>
<p>上面的例子，当事务T2更改该行的值时，会进行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用排他锁锁定该行</span><br><span class="line">记录redo log</span><br><span class="line">把该行修改前的值Copy到undo log，即上图中T1行</span><br><span class="line">修改当前行的值，填写事务编号，使回滚指针指向undo log中的修改前的行</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&emsp;&emsp;上面例子里undo log中有两行记录，并且通过回滚指针连在一起。因此，如果undo log一直不删除，则会通过当前记录的回滚指针回溯到该行创建时的初始内容，所幸的是在Innodb中存在purge线程，它会查询那些比现在最老的活动事务还早的undo log，并删除它们，从而保证undo log文件不至于无限增长。<br>&emsp;&emsp;当事务正常提交时只需要更改事务状态为Commit即可，不需做其他额外的工作，而Rollback则稍微复杂点，需要根据当前回滚指针从undo log中找出事务修改前的版本并恢复。如果事务影响的行非常多，回滚则可能会变的效率不高，根据经验值没事务行数在1000～10000之间，Innodb效率还是非常高的。很显然，Innodb是一个Commit效率比Rollback高的存储引擎。</p>
<p><strong>undo-log</strong><br>&emsp;&emsp;undo log是为回滚而用，具体内容就是copy事务前的数据库内容（行）到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。</p>
<p>&emsp;&emsp;undo log的具体记录字段可以稍微了解下：</p>
<blockquote>
<ol>
<li><code>insert into...</code> ：含主键；</li>
<li><code>delete ..</code> ：含所有字段的之前的值。</li>
<li><code>update ..</code> ：含需要更新字段的之前的值；<br> 如果是更新主键，等同于将之前行记录的删除，然后再插入，将产生两条undo log。</li>
</ol>
</blockquote>
<h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="事务快照"><a href="#事务快照" class="headerlink" title="事务快照"></a>事务快照</h4><p>&emsp;&emsp;如果我们给数据库中的事务拍一张照片的话，我们会看到：在拍照的那一瞬间，<strong>有的事务已经提交，有的正在运行中，有的事务尚未开始</strong>：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170954866.png" alt="image-20240717095405418"></p>
<p>&emsp;&emsp;事务快照，黑色表示事务已提交。就如上图中的快照，trx_id小于15的事务都已经提交了，大于等于31的则尚未开始；中间的15&#x2F;25还在跑，而20&#x2F;30已经提交。如果你现在的事务id为25，当隔离级别为【可重复读】时：你能到哪些事务修改的数据呢？答案是显然的，<strong>已经提交的则看得见</strong>（图中黑色），<strong>还没提交的自然就看不见</strong>，否则就是<strong>脏读</strong>了。</p>
<p>&emsp;&emsp;可时间是会变化的，假设后来15进行了提交，那我们能否看得见该事务的修改记录呢（比如 a&#x3D;1 修改为了 a&#x3D;2）？这个也是应该看不见的，因为如果事务15提交前我们看到的是a&#x3D;1，而提交后变为a&#x3D;2了，这就出现了<strong>不可重复读</strong>了，这显然和【可重复读】相悖了。<br>&emsp;&emsp;<strong>在【可重复读】隔离级别下，一旦触发快照后，这个快照会一直存在，直至事务结束</strong>。哪些事务已提交，哪些没提交，也会在这一瞬间定格。这也就保证了我们永远都在同一张照片里面“找”数据，从而保证了【可重复读】。接下来我们来看一下怎样基于事务快照来“找”数据。</p>
<blockquote>
<p>注：【可重复读】隔离级别下，事务快照的触发时机主要有：</p>
<ul>
<li>开启事务后（<code>begin/start transaction;</code>），执行第一条常规读SQL（<code>select</code>）时；</li>
<li>开启事务时，直接开启快照：<code>start transaction with consistent snapshot</code>.</li>
</ul>
</blockquote>
<h4 id="MVCC查询基本流程"><a href="#MVCC查询基本流程" class="headerlink" title="MVCC查询基本流程"></a>MVCC查询基本流程</h4><p>基于数据快照和多版本数据，查询的大概过程为：</p>
<ol>
<li><strong>触发事务快照</strong>；</li>
<li>根据查询条件找到的<strong>数据页中的记录</strong>，获取该数据的版本号（即<strong>写入该记录的事务trx_id</strong>）</li>
<li>基于快照，判断这个<strong>写入记录的事务（trx_id）对于快照来讲是否可见</strong>：<br> 3.1 如果可见，则返回结果；<br> 3.2 如果不可见，继续找下一个版本的数据。</li>
</ol>
<p>我们可以用一个简单的数据结构（Read View）来记录事务快照（建议结合上节的事务快照图看）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Read_View &#123;</span><br><span class="line">  <span class="comment">// 最小的事务id，数据版本号 &lt; min_id 表示可见</span></span><br><span class="line">  <span class="type">long</span> min_id;      </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大的事务id，数据版本号 &gt;= max_id 表示不可见</span></span><br><span class="line">  <span class="type">long</span> max_id;      </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中间还在跑的事务id，数据版本号在里面则表示不可见（排除本事务，自己肯定看得到自己修改的记录）</span></span><br><span class="line">  <span class="type">long</span>[] running_ids;   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否可见</span></span><br><span class="line">  <span class="type">bool</span> <span class="title function_">canSee</span><span class="params">(<span class="type">long</span> data_version_trx_id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data_version_trx_id &lt; min_id || !running_ids.contains(data_version_trx_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>&emsp;&emsp;MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读)， 是通过 “行排他锁+MVCC” 一起实现的，不仅可以保证可重复读，还可以部分防止幻读，而非完全防止；为什么是部分防止幻读，而不是完全防止?</p>
<p>&emsp;&emsp;场景: 在如果事务B在事务A执行中，insert了一条数据并提交，事务A再次查询，虽然读取的是undo中的旧版本数据(防止了部分幻读)，但是事务A中执行update或者delete都是可以成功的。</p>
<p>&emsp;&emsp;因为在innodb中的操作可以分为当前读(current read)和快照读(snapshot read)：</p>
<p>&emsp;&emsp;<strong>快照读</strong>：读取的是快照版本，也就是历史版本<br>&emsp;&emsp;简单的select操作(当然不包括 select … lock in share mode, select … for update)</p>
<p>&emsp;&emsp;<strong>当前读</strong>：读取的是最新版本<br>&emsp;&emsp;UPDATE、DELETE、INSERT、SELECT …  LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读。当前读返回的记录都会加上锁，这样保证了了其他事务不会再并发修改这条记录。</p>
<p>&emsp;&emsp;在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。innodb在快照读的情况下并没有真正的避免幻读，但是在当前读的情况下避免了不可重复读和幻读。</p>
<p>&emsp;&emsp;通过举例来理解快照读与当前读吧：MySQL innoDB的RR隔离级别下，假设你开启了两个事务，分别是A和B，这里有个张user表，里面有四条数据。</p>
<p>&emsp;&emsp;当你执行select *之后，在A与B事务中都会返回4条一样的数据，这是不用想的，RR隔离级别下当执行普通的select查询时，innodb默认会执行快照读，相当于就是给你目前的状态找了一张照片，以后执行select 的时候就会返回当前照片里面的数据，当其他事务提交了也对你不造成影响，和你没关系，这就实现了可重复读，那这个照片是什么时候生成的呢？<br>&emsp;&emsp;不是开启事务的时候，是当你第一次执行select的时候，也就是说，当A开启了事务，然后没有执行任何操作，这时候B insert了一条数据然后commit，这时候A在事务中执行select，那么就能看到有B在自己在事务中添加的那条数据…，在这之后无论再有其他事务commit都没有关系，因为照片已经生成了，而且不会再生成了，以后都会参考这张照片。</p>
<p><strong>一个事务快照的创建过程可以概括为：</strong></p>
<ul>
<li>查看当前所有的未提交并活跃的事务，存储在数组中</li>
<li>选取未提交并活跃的事务中最小的XID，记录在快照的xmin中</li>
<li>选取所有已提交事务中最大的XID，加1后记录在xmax中</li>
</ul>
<p>&emsp;&emsp;Read View （主要是用来做可见性判断的）：创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表。对于Read View快照的生成时机，也非常关键，正是因为生成时机的不同，造成了RC，RR两种隔离级别的不同可见性；</p>
<ol>
<li><p>在repeatable read级别，事务在begin&#x2F;start transaction之后的第一条select读操作后，会创建一个快照(Read View)，将当前系统中活跃的其他事务记录记录起来；</p>
</li>
<li><p>在repeatable committed级别，事务中每条select语句都会创建一个快照(Read View)；</p>
</li>
</ol>
<h3 id="MVVC下的CRUD"><a href="#MVVC下的CRUD" class="headerlink" title="MVVC下的CRUD"></a>MVVC下的CRUD</h3><p><strong>SELECT：</strong>当隔离级别是REPEATABLE READ时select操作，InnoDB必须每行数据来保证它符合两个条件：</p>
<blockquote>
<ol>
<li>InnoDB必须找到一个行的版本，它至少要和事务的版本一样老(也即它的版本号不大于事务的版本号)。这保证了不管是事务开始之前，或者事务创建时，或者修改了这行数据的时候，这行数据是存在的。</li>
<li>这行数据的删除版本必须是未定义的或者比事务版本要大。这可以保证在事务开始之前这行数据没有被删除。<br>符合这两个条件的行可能会被当作查询结果而返回。</li>
</ol>
</blockquote>
<p><strong>INSERT</strong>：InnoDB为这个新行记录当前的系统版本号。<br><strong>DELETE</strong>：InnoDB将当前的系统版本号设置为这一行的删除ID。<br><strong>UPDATE</strong>：InnoDB会写一个这行数据的新拷贝，这个拷贝的版本为当前的系统版本号。它同时也会将这个版本号写到旧行的删除版本里。</p>
<p>&emsp;&emsp;这种额外的记录所带来的结果就是对于大多数查询来说根本就不需要获得一个锁。只是简单地以最快的速度来读取数据，确保只选择符合条件的行。这个方案的缺点在于存储引擎必须为每一行存储更多的数据，做更多的检查工作，处理更多的善后操作。</p>
<p>&emsp;&emsp;MVCC只工作在REPEATABLE READ和READ COMMITED隔离级别下。READ UNCOMMITED不是MVCC兼容的，因为查询不能找到适合他们事务版本的行版本；它们每次都只能读到最新的版本。SERIABLABLE也不与MVCC兼容，因为读操作会锁定他们返回的每一行数据。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/huaishu/article/details/89924250">https://blog.csdn.net/huaishu/article/details/89924250</a><br><a href="https://blog.csdn.net/fighterandknight/article/details/125197574?spm=1001.2014.3001.5502">https://blog.csdn.net/fighterandknight/article/details/125197574?spm=1001.2014.3001.5502</a><br><a href="https://www.jianshu.com/p/d9bdf90005cb">https://www.jianshu.com/p/d9bdf90005cb</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>MySQL</category>
        <category>原理</category>
      </categories>
  </entry>
  <entry>
    <title>一条 SQL 的执行过程详解</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/MySQL/%E5%8E%9F%E7%90%86/%E4%B8%80%E6%9D%A1%20SQL%20%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一条SQL语句(select)在mysql里面的执行过程如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171000112.png" alt="image-20240321000935431"></p>
<span id="more"></span>

<h2 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1.连接器"></a>1.连接器</h2><h2 id="2-分析器（语法解析分析）"><a href="#2-分析器（语法解析分析）" class="headerlink" title="2.分析器（语法解析分析）"></a>2.分析器（语法解析分析）</h2><p>SQL 语句进行解析</p>
<p>生成语法树</p>
<h2 id="3-优化器（生成执行计划，选择索引）"><a href="#3-优化器（生成执行计划，选择索引）" class="headerlink" title="3.优化器（生成执行计划，选择索引）"></a>3.优化器（生成执行计划，选择索引）</h2><p>MySQL 会帮我们去使用它自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面, IO 成本和 CPU 成本。</p>
<p><strong>IO 成本</strong>: 即从磁盘把数据加载到内存的成本，默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是 1。所以 IO 的成本主要和页的大小有关</p>
<p><strong>CPU 成本</strong>：将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是 0.2。</p>
<p>MySQL 优化器 会计算 「IO 成本 + CPU」 成本最小的那个索引来执。</p>
<h2 id="4-执行器（操作引擎，获取结果）"><a href="#4-执行器（操作引擎，获取结果）" class="headerlink" title="4.执行器（操作引擎，获取结果）"></a>4.执行器（操作引擎，获取结果）</h2><p>真正执行 SQL 的动作是在存储引擎中完成的。数据是被存放在内存或者是磁盘中的。</p>
<p>执行器最终最根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行。</p>
<hr>
<h1 id="关于存储引擎"><a href="#关于存储引擎" class="headerlink" title="关于存储引擎"></a>关于存储引擎</h1><p>以一个更新的SQL语句来说明，SQL 如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students <span class="keyword">SET</span> stuName <span class="operator">=</span> <span class="string">&#x27;小强&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当系统发出这样的查询去交给 MySQL 的时候，MySQL 会按照上面介绍的一系列的流程最终通过执行器调用存储引擎去执行。在执行这个 SQL 的时候 SQL 语句对应的数据要么是在内存中，要么是在磁盘中，如果直接在磁盘中操作，那这样的随机IO读写的速度肯定让人无法接受的，所以每次在执行 SQL 的时候都会将其数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：<strong>缓冲池 Buffer Pool</strong></p>
<h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>Buffer Pool （缓冲池）是 InnoDB 存储引擎中非常重要的内存结构，顾名思义，缓冲池其实就是类似 Redis 一样的作用，起到一个缓存的作用，因为我们都知道 MySQL 的数据最终是存储在磁盘中的，如果没有这个 Buffer Pool 那么我们每次的数据库请求都会磁盘中查找，这样必然会存在 IO 操作，这肯定是无法接受的。但是有了 Buffer Pool 就是我们第一次在查询的时候会将查询的结果存到 Buffer Pool 中，这样后面再有请求的时候就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后在放到 Buffer Pool 中，如下图</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171000734.png" alt="image-20240321112818701"></p>
<p>按照上面的那幅图，这条 SQL 语句的执行步骤大致是这样子的</p>
<ul>
<li>innodb 存储引擎会在缓冲池中查找 id&#x3D;1 的这条数据是否存在</li>
<li>发现不存在，那么就会去磁盘中加载，并将其存放在缓冲池中</li>
<li>该条记录会被加上一个独占锁</li>
</ul>
<h2 id="undo-日志文件：记录数据被修改前的样子"><a href="#undo-日志文件：记录数据被修改前的样子" class="headerlink" title="undo 日志文件：记录数据被修改前的样子"></a>undo 日志文件：记录数据被修改前的样子</h2><p>undo 顾名思义，就是没有做，没发生的意思。undo log 就是没有发生事情（原本事情是什么）的一些日志</p>
<p>我们刚刚已经说了，在准备更新一条语句的时候，该条语句已经被加载到 Buffer pool 中了，实际上这里还有这样的操作，就是在将该条语句加载到 Buffer Pool 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 id&#x3D;1 的这条记录的原来的值记录下来。</p>
<p><strong>这样做的目的是什么</strong>？</p>
<p>Innodb 存储引擎的最大特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有的操作都必须回滚到执行前的样子，也就是说当事务失败的时候，也不会对原始数据有影响，看图说话</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171000403.png" alt="image-20240321112942157"></p>
<p>到这一步，我们的执行的 SQL 语句已经被加载到 Buffer Pool 中了，然后开始更新这条语句，更新的操作实际是在Buffer Pool中执行的，那问题来了，按照我们平时开发的一套理论缓冲池中的数据和数据库中的数据不一致时候，我们就认为缓存中的数据是脏数据，那此时 Buffer Pool 中的数据岂不是成了脏数据？没错，目前这条数据就是脏数据，Buffer Pool 中的记录是小强 数据库中的记录是旺财 ，这种情况 MySQL是怎么处理的呢，继续往下看</p>
<h2 id="redo-日志文件：记录数据被修改后的样子"><a href="#redo-日志文件：记录数据被修改后的样子" class="headerlink" title="redo 日志文件：记录数据被修改后的样子"></a>redo 日志文件：记录数据被修改后的样子</h2><p>除了从磁盘中加载文件和将操作前的记录保存到 undo 日志文件中，其他的操作是在内存中完成的，内存中的数据的特点就是：断电丢失。如果此时 MySQL 所在的服务器宕机了，那么 Buffer Pool 中的数据会全部丢失的。这个时候 redo 日志文件就需要来大显神通了</p>
<p><strong>画外音：redo 日志文件是 InnoDB 特有的，他是存储引擎级别的，不是 MySQL 级别的</strong></p>
<p>redo 记录的是数据修改之后的值，不管事务是否提交都会记录下来，例如，此时将要做的是update students set stuName&#x3D;’小强’ where id&#x3D;1; 那么这条操作就会被记录到 redo log buffer 中，啥？怎么又出来一个 redo log buffer ,很简单，MySQL 为了提高效率，所以将这些操作都先放在内存中去完成，然后会在某个时机将其持久化到磁盘中。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171000136.png" alt="image-20240321113116733"></p>
<p>截至目前，我们应该都熟悉了 MySQL 的执行器调用存储引擎是怎么将一条 SQL 加载到缓冲池和记录哪些日志的，流程如下：</p>
<ul>
<li>准备更新一条 SQL 语句</li>
<li>MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中</li>
<li>在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</li>
<li>innodb 会在 Buffer Pool 中执行更新操作</li>
<li>更新后的数据会记录在 redo log buffer 中</li>
</ul>
<p>上面说的步骤都是在正常情况下的操作，但是程序的设计和优化并不仅是为了这些正常情况而去做的，也是为了<strong>那些临界区和极端情况下出现的问题去优化</strong>设计的</p>
<p>这个时候如果服务器宕机了，那么缓存中的数据还是丢失了。真烦，竟然数据总是丢失，那能不能不要放在内存中，直接保存到磁盘呢？很显然不行，因为在上面也已经介绍了，在内存中的操作目的是为了提高效率。</p>
<p>此时，如果 MySQL 真的宕机了，那么没关系的，因为 MySQL 会认为本次事务是失败的，所以数据依旧是更新前的样子，并不会有任何的影响。</p>
<p>好了，语句也更新好了那么需要将更新的值提交啊，也就是需要提交本次的事务了，因为只要事务成功提交了，才会将最后的变更保存到数据库，在提交事务前仍然会具有相关的其他操作</p>
<p>将 redo Log Buffer 中的数据持久化到磁盘中，就是将 redo log buffer 中的数据写入到 redo log 磁盘文件中，一般情况下，redo log Buffer 数据写入磁盘的策略是立即刷入磁盘（具体策略情况在下面小总结出会详细介绍）,上图</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171000199.png" alt="image-20240321113224473"></p>
<p>如果 redo log Buffer 刷入磁盘后，数据库服务器宕机了，那我们更新的数据怎么办？此时数据是在内存中，数据岂不是丢失了？不，这次数据就不会丢失了，因为 redo log buffer 中的数据已经被写入到磁盘了，已经被持久化了，就算数据库宕机了，在下次重启的时候 MySQL 也会将 redo 日志文件内容恢复到 Buffer Pool 中（这边我的理解是和 Redis 的持久化机制是差不多的，在 Redis 启动的时候会检查 rdb 或者是 aof 或者是两者都检查，根据持久化的文件来将数据恢复到内存中）</p>
<p>到此为止，<strong>从执行器开始调用存储引擎接口做了哪些事情呢</strong>？</p>
<ul>
<li>准备更新一条 SQL 语句</li>
<li>MySQL（innodb）会先去缓冲池（BufferPool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（BufferPool）中</li>
<li>在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中</li>
<li>innodb 会在 Buffer Pool 中执行更新操作</li>
<li>更新后的数据会记录在 redo log buffer 中</li>
<li>MySQL 提交事务的时候，会将 redo log buffer 中的数据写入到 redo 日志文件中 刷磁盘可以通过 innodb_flush_log_at_trx_commit 参数来设置 <ul>
<li>值为 0 表示不刷入磁盘</li>
<li>值为 1 表示立即刷入磁盘</li>
<li>值为 2 表示先刷到 os cache</li>
</ul>
</li>
<li>myslq 重启的时候会将 redo 日志恢复到缓冲池中</li>
</ul>
<p>截止到目前位置，MySQL 的执行器调用存储引擎的接口去执行【执行计划】提供的 SQL 的时候 InnoDB 做了哪些事情也就基本差不多了，但是这还没完。下面还需要介绍下 MySQL 级别的日志文件 bin log</p>
<h2 id="bin-log-日志文件：记录整个操作过程"><a href="#bin-log-日志文件：记录整个操作过程" class="headerlink" title="bin log 日志文件：记录整个操作过程"></a>bin log 日志文件：记录整个操作过程</h2><p>上面介绍到的redo log是 InnoDB 存储引擎特有的日志文件，而bin log属于是 MySQL 级别的日志。redo log记录的东西是偏向于物理性质的，如：“对什么数据，做了什么修改”。bin log是偏向于逻辑性质的，类似于：“对 students 表中的 id 为 1 的记录做了更新操作” 两者的主要特点总结如下:</p>
<table>
<thead>
<tr>
<th>性质</th>
<th>redo Log</th>
<th>bin Log</th>
</tr>
</thead>
<tbody><tr>
<td>文件大小</td>
<td>redo log 的大小是固定的（配置中也可以设置，一般默认的就足够了）</td>
<td>bin log 可通过配置参数max_bin log_size设置每个bin log文件的大小（但是一般不建议修改）。</td>
</tr>
<tr>
<td>实现方式</td>
<td>redo log是InnoDB引擎层实现的（也就是说是 Innodb 存储引擎独有的）</td>
<td>bin log是 MySQL 层实现的，所有引擎都可以使用 bin log日志</td>
</tr>
<tr>
<td>记录方式</td>
<td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td>
<td>bin log 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td>
</tr>
<tr>
<td>使用场景</td>
<td>redo log适用于崩溃恢复(crash-safe)（这一点其实非常类似与 Redis 的持久化特征）</td>
<td>bin log 适用于主从复制和数据恢复</td>
</tr>
</tbody></table>
<p><strong>bin log文件是如何刷入磁盘的</strong>?</p>
<p>bin log 的刷盘是有相关的策略的，策略可以通过sync_bin log来修改，默认为 0，表示先写入 os cache，也就是说在提交事务的时候，数据不会直接到磁盘中，这样如果宕机bin log数据仍然会丢失。所以建议将sync_bin log设置为 1 表示直接将数据写入到磁盘文件中。</p>
<p>刷入 bin log 有以下几种模式</p>
<ul>
<li><strong>STATMENT</strong></li>
</ul>
<p>基于 SQL 语句的复制(statement-based replication, SBR)，每一条会修改数据的 SQL 语句会记录到 bin log 中</p>
<p>【优点】：不需要记录每一行的变化，减少了 bin log 日志量，节约了 IO , 从而提高了性能</p>
<p>【缺点】：在某些情况下会导致主从数据不一致，比如执行sysdate()、sleep()等</p>
<ul>
<li><strong>ROW</strong></li>
</ul>
<p>基于行的复制(row-based replication, RBR)，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了</p>
<p>【优点】：不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题</p>
<p>【缺点】：会产生大量的日志，尤其是 alter table 的时候会让日志暴涨</p>
<ul>
<li><strong>MIXED</strong></li>
</ul>
<p>基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 bin log ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 bin log</p>
<p>那既然bin log也是日志文件，那它是在什么记录数据的呢？</p>
<p>其实 MySQL 在提交事务的时候，不仅仅会将 redo log buffer 中的数据写入到redo log 文件中，同时也会将本次修改的数据记录到 bin log文件中，同时会将本次修改的bin log文件名和修改的内容在bin log中的位置记录到redo log中，最后还会在redo log最后写入 commit 标记，这样就表示本次事务被成功的提交了。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171000058.png" alt="image-20240321113430084"></p>
<p>如果在数据被写入到bin log文件的时候，刚写完，数据库宕机了，数据会丢失吗？</p>
<p>首先可以确定的是，只要redo log最后没有 commit 标记，说明本次的事务一定是失败的。但是数据是没有丢失了，因为已经被记录到redo log的磁盘文件中了。在 MySQL 重启的时候，就会将 redo log 中的数据恢复（加载）到Buffer Pool中。</p>
<p>好了，到目前为止，一个更新操作我们基本介绍得差不多，但是你有没有感觉少了哪件事情还没有做？是不是你也发现这个时候被更新记录仅仅是在内存中执行的，哪怕是宕机又恢复了也仅仅是将更新后的记录加载到Buffer Pool中，这个时候 MySQL 数据库中的这条记录依旧是旧值，也就是说内存中的数据在我们看来依旧是脏数据，那这个时候怎么办呢？</p>
<p>其实 MySQL 会有一个后台线程，它会在某个时机将我们Buffer Pool中的脏数据刷到 MySQL 数据库中，这样就将内存和数据库的数据保持统一了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从准备更新一条数据到事务的提交的流程描述</p>
<ul>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li>
<li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li>
<li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事 <ul>
<li>将redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li>
</ul>
</li>
</ul>
<p>至此表示整个更新事务已经完成</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171000785.png" alt="image-20240321181005651"></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171011734.png" alt="image-20240321181122330"></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171012550.png" alt="image-20240321181224983"></p>
<hr>
<hr>
<p>基于2PC的一致性保障：必须保证Redo Log和Binlog在事务提交时的数据一致性，要么都存在，要么都不存在。MySQL是通过 2PC（two-phase commit protocol）来实现的。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407171000367.png" alt="img"></p>
<p>来看如下三种情况：</p>
<p>情况一：一阶段提交之后崩溃了，即<code>写入 redo log，处于 prepare 状态</code>的时候崩溃了，此时：</p>
<p>由于 binlog 还没写，redo log 处于 prepare 状态还没提交，所以崩溃恢复的时候，这个事务会回滚，此时 binlog 还没写，所以也不会传到备库。</p>
<p>情况二：假设写完 binlog 之后崩溃了，此时：</p>
<p>redolog 中的日志是不完整的，处于 prepare 状态，还没有提交，那么恢复的时候，首先检查 binlog 中的事务是否存在并且完整，如果存在且完整，则直接提交事务，如果不存在或者不完整，则回滚事务。</p>
<p>情况三：假设 redolog 处于 commit 状态的时候崩溃了，那么重启后的处理方案同情况二。</p>
<p>由此可见，两阶段提交能够确保数据的一致性。</p>
<p>redo log、binlog如何关联？<br>二者有个共同数据字段XID。崩溃恢复时，会从最后一次checkpoint的位置开始顺序扫描redo log，若碰到既有prepare、又有commit的redo log，直接提交事务。若碰到只有prepare、无commit的redo log，就拿XID去binlog找对应事务，此时若binlog完整则提交事务，否则回滚事务。</p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>MySQL</category>
        <category>原理</category>
      </categories>
  </entry>
  <entry>
    <title>ZGC的探索和实践</title>
    <url>/2024/07/01/Java/JVM/GC%E7%9B%B8%E5%85%B3/ZGC%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：</p>
<ul>
<li><p>停顿时间不超过10ms；</p>
</li>
<li><p>停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</p>
</li>
<li><p>支持8MB~4TB级别的堆（未来支持16TB）。</p>
</li>
</ul>
<p>从设计目标来看，我们知道ZGC适用于大内存低延迟服务的内存管理和回收。本文主要介绍ZGC在低延时场景中的应用和卓越表现，文章内容主要分为四部分：</p>
<ul>
<li><p>GC之痛：介绍实际业务中遇到的GC痛点，并分析CMS收集器和G1收集器停顿时间瓶颈；</p>
</li>
<li><p>ZGC原理：分析ZGC停顿时间比G1或CMS更短的本质原因，以及背后的技术原理；</p>
</li>
<li><p>ZGC调优实践：重点分享对ZGC调优的理解，并分析若干个实际调优案例；</p>
</li>
<li><p>升级ZGC效果：展示在生产环境应用ZGC取得的效果。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="GC之痛"><a href="#GC之痛" class="headerlink" title="GC之痛"></a>GC之痛</h2><p>很多低延迟高可用Java服务的系统可用性经常受GC停顿的困扰。GC停顿指垃圾回收期间STW，当STW时，所有应用线程停止活动，等待GC停顿结束。GC停顿对响应时间的影响较大。为了降低GC停顿对系统可用性的影响，我们从降低单次GC时间和降低GC频率两个角度出发进行了调优，还测试过G1垃圾回收器，但这三项措施均未能降低GC对服务可用性的影响。</p>
<h3 id="CMS与G1停顿时间瓶颈"><a href="#CMS与G1停顿时间瓶颈" class="headerlink" title="CMS与G1停顿时间瓶颈"></a>CMS与G1停顿时间瓶颈</h3><p>在介绍ZGC之前，首先回顾一下CMS和G1的GC过程以及停顿时间的瓶颈。CMS新生代的Young GC、G1和ZGC都基于标记-复制算法，但算法具体实现的不同就导致了巨大的性能差异。</p>
<p>标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段：</p>
<ul>
<li><p>标记阶段，即从GC Roots集合开始，标记活跃对象；</p>
</li>
<li><p>转移阶段，即把活跃对象复制到新的内存地址上；</p>
</li>
<li><p>重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。</p>
</li>
</ul>
<p>下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291337940.png" alt="img"></p>
<p>G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。</p>
<p><strong>标记阶段停顿分析</strong></p>
<ul>
<li><p>初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。</p>
</li>
<li><p>并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。</p>
</li>
<li><p>再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。</p>
</li>
</ul>
<p><strong>清理阶段停顿分析</strong></p>
<p>清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。</p>
<p><strong>复制阶段停顿分析</strong></p>
<p>复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。</p>
<p>四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。<strong>转移阶段要处理所有存活的对象，耗时会较长</strong>。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是G1未能解决转移过程中准确定位对象地址的问题。</p>
<p>G1的Young GC和CMS的Young GC，其标记-复制全过程STW，这里不再详细阐述。</p>
<h2 id="ZGC原理"><a href="#ZGC原理" class="headerlink" title="ZGC原理"></a>ZGC原理</h2><h3 id="全并发的ZGC"><a href="#全并发的ZGC" class="headerlink" title="全并发的ZGC"></a>全并发的ZGC</h3><p>与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。</p>
<p>首先看ZGC的堆内存布局，ZGC 也采用基于 Region 的堆内存布局，但与 G1 不同的是， ZGC 的 Region 具有动态性，也就是可以动态创建和动态销毁，容量大小也是动态的，有大、中、小三类容量：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291337478.webp" alt="img"></p>
<ul>
<li><p>小型 Region (Small Region)：容量固定为 2MB，用于放置小于 256KB 的小对象。</p>
</li>
<li><p>中型 Region (Medium Region)：容量固定为 32MB，用于放置大于等于 256KB 但小于 4MB 的对 象。</p>
</li>
<li><p>大型 Region (Large Region)：容量不固定，可以动态变化，但必须是N*2MB，用于放置 4MB 或以上的大对象。每个Large Region 中只会存放一个大对象，并且是不会被重新分配的。虽然名字叫作“大型 Region”，但它的实际容量完全有可能小于中型 Region，最小容量可低至 4MB。</p>
</li>
</ul>
<p>ZGC垃圾回收周期如下图所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291338880.png" alt="img"></p>
<p>ZGC只有三个STW阶段：<strong>初始标记</strong>，<strong>再标记</strong>，<strong>初始转移</strong>。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。</p>
<h3 id="ZGC关键技术"><a href="#ZGC关键技术" class="headerlink" title="ZGC关键技术"></a>ZGC关键技术</h3><p>ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：     </p>
<blockquote>
<p>并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。<br>假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出&gt; &gt; 来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。</p>
</blockquote>
<p>那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。</p>
<h4 id="着色指针"><a href="#着色指针" class="headerlink" title="着色指针"></a>着色指针</h4><p>着色指针是一种将信息存储在指针中的技术。</p>
<p>ZGC出现之前，GC信息保存在对象头的Mark Word中，比如64位JVM里，前62位保存GC信息，最后2位保存了锁标志。ZGC的一大创举是将GC信息保存在了着色指针上。ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。</p>
<p>在64位JVM中，对象指针是64位，如下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291339457.webp" alt="img"></p>
<ul>
<li>Marked0 &#x2F;Marked1：标记位，标记对象是否可用，</li>
<li>Remapped：记录对象是否进入过重分配集（对象是否移动过）</li>
<li>Finalizable：标记对象是否只能通过fnalize()访问</li>
</ul>
<p>当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC同时会为该对象在Marked0、Marked1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址(mmap技术)，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。</p>
<h4 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h4><p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。</p>
<p>读屏障示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> obj.FieldA   <span class="comment">// 从堆中读取引用，需要加入屏障</span></span><br><span class="line">&lt;Load barrier&gt;</span><br><span class="line"><span class="type">Object</span> <span class="variable">p</span> <span class="operator">=</span> o  <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line">o.dosomething() <span class="comment">// 无需加入屏障，因为不是从堆中读取引用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  obj.FieldB  <span class="comment">//无需加入屏障，因为不是对象引用</span></span><br></pre></td></tr></table></figure>

<p><strong>ZGC中读屏障的代码作用</strong>：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。</p>
<p>接下来详细介绍ZGC一次垃圾回收周期中地址视图的切换过程：</p>
<ul>
<li><p>初始化：ZGC初始化之后，整个内存空间的地址视图被设置为Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。</p>
</li>
<li><p>并发标记阶段：第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。</p>
</li>
<li><p>并发转移阶段：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。</p>
</li>
</ul>
<p>其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。即第二次进入并发标记阶段后，地址视图调整为M1，而非M0。</p>
<p>着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在ZGC中，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291339322.png" alt="img"></p>
<h2 id="ZGC调优实践"><a href="#ZGC调优实践" class="headerlink" title="ZGC调优实践"></a>ZGC调优实践</h2><p>ZGC不是“银弹”，需要根据服务的具体特点进行调优。本文的一个目的是列举一些使用ZGC时常见的问题，帮助大家使用ZGC提高服务可用性。</p>
<p>调优基础知识</p>
<h3 id="理解ZGC重要配置参数"><a href="#理解ZGC重要配置参数" class="headerlink" title="理解ZGC重要配置参数"></a>理解ZGC重要配置参数</h3><p>以我们服务在生产环境中ZGC参数配置为例，说明各个参数的作用：</p>
<p>重要参数配置样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms10G -Xmx10G </span><br><span class="line">-XX:ReservedCodeCacheSize=256m -XX:InitialCodeCacheSize=256m </span><br><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC </span><br><span class="line">-XX:ConcGCThreads=2 -XX:ParallelGCThreads=6 </span><br><span class="line">-XX:ZCollectionInterval=120 -XX:ZAllocationSpikeTolerance=5 </span><br><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:-ZProactive </span><br><span class="line">-Xlog:safepoint,classhisto*=trace,age*,gc*=info:file=/opt/logs/logs/gc-%t.log:time,tid,tags:filecount=5,filesize=50m </span><br></pre></td></tr></table></figure>

<p><strong>-Xms -Xmx</strong>：堆的最大内存和最小内存，这里都设置为10G，程序的堆内存将保持10G不变。<br><strong>-XX:ReservedCodeCacheSize -XX:InitialCodeCacheSize</strong>: 设置CodeCache的大小， JIT编译的代码都放在CodeCache中，一般服务64m或128m就已经足够。我们的服务因为有一定特殊性，所以设置的较大，后面会详细介绍。<br><strong>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</strong>：启用ZGC的配置。<br><strong>-XX:ConcGCThreads</strong>：并发回收垃圾的线程。默认是总核数的12.5%，8核CPU默认是1。调大后GC变快，但会占用程序运行时的CPU资源，吞吐会受到影响。<br><strong>-XX:ParallelGCThreads</strong>：STW阶段使用线程数，默认是总核数的60%。<br><strong>-XX:ZCollectionInterval</strong>：ZGC发生的最小时间间隔，单位秒。<br><strong>-XX:ZAllocationSpikeTolerance</strong>：ZGC触发自适应算法的修正系数，默认2，数值越大，越早的触发ZGC。<br><strong>-XX:+UnlockDiagnosticVMOptions -XX:-ZProactive</strong>：是否启用主动回收，默认开启，这里的配置表示关闭。<br><strong>-Xlog</strong>：设置GC日志中的内容、格式、位置以及每个日志的大小。</p>
<h3 id="理解ZGC触发时机"><a href="#理解ZGC触发时机" class="headerlink" title="理解ZGC触发时机"></a>理解ZGC触发时机</h3><p>相比于CMS和G1的GC触发机制，ZGC的GC触发机制有很大不同。ZGC的核心特点是并发，GC过程中一直有新的对象产生。如何保证在GC完成之前，新产生的对象不会将堆占满，是ZGC参数调优的第一大目标。因为在ZGC中，当垃圾来不及回收将堆占满时，会导致正在运行的线程停顿，持续时间可能长达秒级之久。</p>
<p>ZGC有多种GC触发机制，总结如下：</p>
<ul>
<li><p>阻塞内存分配请求触发：当垃圾来不及回收，垃圾将堆占满时，会导致部分线程阻塞。我们应当避免出现这种触发方式。日志中关键字是“Allocation Stall”。</p>
</li>
<li><p>基于分配速率的自适应算法：最主要的GC触发方式，其算法原理可简单描述为”ZGC根据近期的对象分配速率以及GC时间，计算出当内存占用达到什么阈值时触发下一次GC”。自适应算法的详细理论可参考彭成寒《新一代垃圾回收器ZGC设计与实现》一书中的内容。通过ZAllocationSpikeTolerance参数控制阈值大小，该参数默认2，数值越大，越早的触发GC。我们通过调整此参数解决了一些问题。日志中关键字是“Allocation Rate”。</p>
</li>
<li><p>基于固定时间间隔：通过ZCollectionInterval控制，适合应对突增流量场景。流量平稳变化时，自适应算法可能在堆使用率达到95%以上才触发GC。流量突增时，自适应算法触发的时机可能会过晚，导致部分线程阻塞。我们通过调整此参数解决流量突增场景的问题，比如定时活动、秒杀等场景。日志中关键字是“Timer”。</p>
</li>
<li><p>主动触发规则：类似于固定间隔规则，但时间间隔不固定，是ZGC自行算出来的时机，我们的服务因为已经加了基于固定时间间隔的触发机制，所以通过-ZProactive参数将该功能关闭，以免GC频繁，影响服务可用性。日志中关键字是“Proactive”。</p>
</li>
<li><p>预热规则：服务刚启动时出现，一般不需要关注。日志中关键字是“Warmup”。</p>
</li>
<li><p>外部触发：代码中显式调用System.gc()触发。日志中关键字是“System.gc()”。</p>
</li>
<li><p>元数据分配触发：元数据区不足时导致，一般不需要关注。日志中关键字是“Metadata GC Threshold”。</p>
</li>
</ul>
<h3 id="理解ZGC日志"><a href="#理解ZGC日志" class="headerlink" title="理解ZGC日志"></a>理解ZGC日志</h3><p>一次完整的GC过程，需要注意的点已在图中标出。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9oRXgwM2NGZ1VzVUZUSENpYkN3S01YWmNIVkRpYk8xUXo0cnRmQ1FwVndkWlkzTWliSXYzTXRJWlg0SExYNXphUExRa3JnYVhjRXNvNHd4aWFGZUdpY2dFYXF3LzY0MA?x-oss-process=image/format,png" alt="img"></p>
<p>注意：该日志过滤了进入安全点的信息。正常情况，在一次GC过程中还穿插着进入安全点的操作。</p>
<p>GC日志中每一行都注明了GC过程中的信息，关键信息如下：</p>
<ul>
<li><p>Start：开始GC，并标明的GC触发的原因。上图中触发原因是自适应算法。</p>
</li>
<li><p>Phase-Pause Mark Start：初始标记，会STW。</p>
</li>
<li><p>Phase-Pause Mark End：再次标记，会STW。</p>
</li>
<li><p>Phase-Pause Relocate Start：初始转移，会STW。</p>
</li>
<li><p>Heap信息：记录了GC过程中Mark、Relocate前后的堆大小变化状况。High和Low记录了其中的最大值和最小值，我们一般关注High中Used的值，如果达到100%，在GC过程中一定存在内存分配不足的情况，需要调整GC的触发时机，更早或者更快地进行GC。</p>
</li>
<li><p>GC信息统计：可以定时的打印垃圾收集信息，观察10秒内、10分钟内、10个小时内，从启动到现在的所有统计信息。利用这些统计信息，可以排查定位一些异常点。</p>
</li>
</ul>
<p>日志中内容较多，关键点已用红线标出，含义较好理解，更详细的解释大家可以自行在网上查阅资料。</p>
<h3 id="理解ZGC停顿原因"><a href="#理解ZGC停顿原因" class="headerlink" title="理解ZGC停顿原因"></a>理解ZGC停顿原因</h3><p>我们在实战过程中共发现了6种使程序停顿的场景，分别如下：</p>
<ul>
<li><p>GC时，初始标记：日志中Pause Mark Start。</p>
</li>
<li><p>GC时，再标记：日志中Pause Mark End。</p>
</li>
<li><p>GC时，初始转移：日志中Pause Relocate Start。</p>
</li>
<li><p>内存分配阻塞：当内存不足时线程会阻塞等待GC完成，关键字是”Allocation Stall”。</p>
</li>
<li><p>安全点：所有线程进入到安全点后才能进行GC，ZGC定期进入安全点判断是否需要GC。先进入安全点的线程需要等待后进入安全点的线程直到所有线程挂起。</p>
</li>
<li><p>dump线程、内存：比如jstack、jmap命令。</p>
</li>
</ul>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/MeituanTech/article/details/107853015">https://blog.csdn.net/MeituanTech/article/details/107853015</a><br><a href="https://www.jianshu.com/p/ab457e102bdd">https://www.jianshu.com/p/ab457e102bdd</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>GC相关</category>
      </categories>
  </entry>
  <entry>
    <title>通过SQL分析数据库加锁</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/MySQL/%E5%8E%9F%E7%90%86/%E9%80%9A%E8%BF%87SQL%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E9%94%81/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="Update-Delete语句加锁"><a href="#Update-Delete语句加锁" class="headerlink" title="Update &amp; Delete语句加锁"></a>Update &amp; Delete语句加锁</h2><h3 id="1）主键索引（查询命中）"><a href="#1）主键索引（查询命中）" class="headerlink" title="1）主键索引（查询命中）"></a>1）主键索引（查询命中）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE students SET score = 100 WHERE id = 15; // id主键</span><br></pre></td></tr></table></figure>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170956106.png" alt="图片"></p>
<p>RC、RR都是对聚簇索引加X锁。</p>
<span id="more"></span>

<h3 id="2）主键索引（查询未命中）"><a href="#2）主键索引（查询未命中）" class="headerlink" title="2）主键索引（查询未命中）"></a>2）主键索引（查询未命中）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE students SET score = 100 WHERE id = 16; // id主键</span><br></pre></td></tr></table></figure>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170956235.png" alt="图片"></p>
<p>RC不加锁，RR在16之前和之后的范围里加GAP锁。</p>
<h3 id="3）二级唯一索引（查询命中）"><a href="#3）二级唯一索引（查询命中）" class="headerlink" title="3）二级唯一索引（查询命中）"></a>3）二级唯一索引（查询命中）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE students SET score = 100 WHERE no = &#x27;S0003&#x27;;  // id主键，no唯一索引</span><br></pre></td></tr></table></figure>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170956849.jpeg" alt="图片"></p>
<p>RC、RR会对二级和主键索引都加X锁（防止其他事务通过聚簇改数据）。</p>
<h3 id="4）二级唯一索引（查询未命中）"><a href="#4）二级唯一索引（查询未命中）" class="headerlink" title="4）二级唯一索引（查询未命中）"></a>4）二级唯一索引（查询未命中）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE students SET score = 100 WHERE no = &#x27;S0008&#x27;;  // id主键，no唯一索引</span><br></pre></td></tr></table></figure>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170956030.jpeg" alt="图片"></p>
<p>RC不加锁，RR只在二级索引加GAP。</p>
<h3 id="5）二级非唯一索引（查询命中）"><a href="#5）二级非唯一索引（查询命中）" class="headerlink" title="5）二级非唯一索引（查询命中）"></a>5）二级非唯一索引（查询命中）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE students SET score = 100 WHERE name = &#x27;Tom&#x27;;  // id主键，name非唯一索引</span><br></pre></td></tr></table></figure>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170957467.jpeg" alt="图片"></p>
<p>RC对二级和聚簇加X锁，RR对二级加X锁和Gap对聚簇加X锁。</p>
<h3 id="6）二级非唯一索引（查询未命中）"><a href="#6）二级非唯一索引（查询未命中）" class="headerlink" title="6）二级非唯一索引（查询未命中）"></a>6）二级非唯一索引（查询未命中）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE students SET score = 100 WHERE name = &#x27;John&#x27;;  // id主键，name非唯一索引</span><br></pre></td></tr></table></figure>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170957449.jpeg" alt="图片"></p>
<p>RC不加锁，RR只在二级索引加GAP。</p>
<h2 id="INSERT语句加锁"><a href="#INSERT语句加锁" class="headerlink" title="INSERT语句加锁"></a>INSERT语句加锁</h2><ul>
<li>为了防止幻读，如果记录之间加有GAP锁，此时不能INSERT。</li>
<li>如果INSERT的记录和已有记录造成唯一键冲突，此时不能INSERT。</li>
</ul>
<h2 id="MySQL的加锁分析实战"><a href="#MySQL的加锁分析实战" class="headerlink" title="MySQL的加锁分析实战"></a>MySQL的加锁分析实战</h2><p>下面两条简单的SQL，他们加什么锁？</p>
<ul>
<li><strong>SQL1：</strong>select * from t1 where id &#x3D; 10;</li>
<li><strong>SQL2：</strong>delete from t1 where id &#x3D; 10;</li>
</ul>
<p>针对这个问题，该怎么回答？我能想象到的一个答案是：</p>
<ul>
<li><strong>SQL1：</strong>不加锁。因为MySQL是使用多版本并发控制的，读不加锁。</li>
<li><strong>SQL2：</strong>对id &#x3D; 10的记录加写锁 (走主键索引)。</li>
</ul>
<p>这个答案对吗？说不上来。即可能是正确的，也有可能是错误的，已知条件不足，这个问题没有答案。如果让我来回答这个问题，我必须还要知道以下的一些前提，前提不同，我能给出的答案也就不同。要回答这个问题，还缺少哪些前提条件？</p>
<ul>
<li><strong>前提一：</strong>id列是不是主键？</li>
<li><strong>前提二：</strong>当前系统的隔离级别是什么？</li>
<li><strong>前提三：</strong>id列如果不是主键，那么id列上有索引吗？</li>
<li><strong>前提四：</strong>id列上如果有二级索引，那么这个索引是唯一索引吗？</li>
<li><strong>前提五：</strong>两个SQL的执行计划是什么？索引扫描？全表扫描？</li>
</ul>
<p>没有这些前提，直接就给定一条SQL，然后问这个SQL会加什么锁，都是很业余的表现。而当这些问题有了明确的答案之后，给定的SQL会加什么锁，也就一目了然。下面，我将这些问题的答案进行组合，然后按照从易到难的顺序，逐个分析每种组合下，对应的SQL会加哪些锁？</p>
<p><strong>注：</strong>下面的这些组合，我做了一个前提假设，也就是有索引时，执行计划一定会选择使用索引进行过滤 (索引扫描)。但实际情况会复杂很多，真正的执行计划，还是需要根据MySQL输出的为准。</p>
<ul>
<li><strong>组合一：</strong>id列是主键，RC隔离级别</li>
<li><strong>组合二：</strong>id列是二级唯一索引，RC隔离级别</li>
<li><strong>组合三：</strong>id列是二级非唯一索引，RC隔离级别</li>
<li><strong>组合四：</strong>id列上没有索引，RC隔离级别</li>
<li><strong>组合五：</strong>id列是主键，RR隔离级别</li>
<li><strong>组合六：</strong>id列是二级唯一索引，RR隔离级别</li>
<li><strong>组合七：</strong>id列是二级非唯一索引，RR隔离级别</li>
<li><strong>组合八：</strong>id列上没有索引，RR隔离级别</li>
<li><strong>组合九：</strong>Serializable隔离级别</li>
</ul>
<p>排列组合还没有列举完全，但是看起来，已经很多了。真的有必要这么复杂吗？事实上，要分析加锁，就是需要这么复杂。但是从另一个角度来说，只要你选定了一种组合，SQL需要加哪些锁，其实也就确定了。接下来，就让我们来逐个分析这9种组合下的SQL加锁策略。</p>
<p>注：在前面八种组合下，也就是RC，RR隔离级别下，SQL1：select操作均不加锁，采用的是快照读，因此在下面的讨论中就忽略了，主要讨论SQL2：delete操作的加锁。</p>
<h3 id="1-组合一：id主键-RC"><a href="#1-组合一：id主键-RC" class="headerlink" title="1 组合一：id主键+RC"></a><strong>1 组合一：id主键+RC</strong></h3><p>这个组合，是最简单，最容易分析的组合。</p>
<p>id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id &#x3D; 10; 只需要将主键上，id &#x3D; 10的记录加上X锁即可。如下图所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170957661.png" alt="img"></p>
<p>结论：id是主键时，此SQL只需要在id&#x3D;10这条记录上加X锁即可。</p>
<h3 id="2-组合二：id唯一索引-RC"><a href="#2-组合二：id唯一索引-RC" class="headerlink" title="2 组合二：id唯一索引+RC"></a>2 组合二：id唯一索引+RC</h3><p>这个组合，id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id &#x3D; 10; 需要加什么锁呢？见下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170957632.png" alt="img"></p>
<p>​        此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id&#x3D;10的记录后，首先会将unique索引上的id&#x3D;10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name &#x3D; ‘d’ 对应的主键索引项加X锁。</p>
<p>​        为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id &#x3D; 100 where name &#x3D; ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新&#x2F;删除需要串行执行的约束。</p>
<p>​        结论：若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id &#x3D; 10的记录，另一把锁对应于聚簇索引上的[name&#x3D;’d’,id&#x3D;10]的记录。</p>
<h3 id="3-组合三：id非唯一索引-RC"><a href="#3-组合三：id非唯一索引-RC" class="headerlink" title="3 组合三：id非唯一索引+RC"></a>3 组合三：id非唯一索引+RC</h3><p>相对于组合一、二，组合三又发生了变化，隔离级别仍旧是RC不变，但是id列上的约束又降低了，id列不再唯一，只有一个普通的索引。假设delete from t1 where id &#x3D; 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170957687.png" alt="img"></p>
<p>根据此图，可以看到，首先，id列索引上，满足id &#x3D; 10查询条件的记录，均已加锁。同时，这些记录对应的主键索引上的记录也都加上了锁。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，而组合三会将所有满足查询条件的记录都加锁。</p>
<p>结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p>
<h3 id="4-组合四：id无索引-RC"><a href="#4-组合四：id无索引-RC" class="headerlink" title="4 组合四：id无索引+RC"></a>4 组合四：id无索引+RC</h3><p>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id &#x3D; 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id &#x3D; 10;的记录加上X锁。那么实际情况呢？请看下图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170957701.png" alt="img"></p>
<p>​        由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p>
<p>​        有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。</p>
<p>​       注：在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p>
<p>​        <strong>结论：</strong>若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁&#x2F;放锁动作不会省略。同时，优化也违背了2PL的约束。</p>
<h3 id="5-组合五：id主键-RR"><a href="#5-组合五：id主键-RR" class="headerlink" title="5 组合五：id主键+RR"></a><strong>5 组合五：id主键+RR</strong></h3><p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。</p>
<p>组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id &#x3D; 10; 这条SQL，加锁与组合一致。</p>
<h3 id="6-组合六：id唯一索引-RR"><a href="#6-组合六：id唯一索引-RR" class="headerlink" title="6 组合六：id唯一索引+RR"></a><strong>6 组合六：id唯一索引+RR</strong></h3><p>与组合五类似，组合六的加锁，与组合二：一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</p>
<h3 id="7-组合七：id非唯一索引-RR"><a href="#7-组合七：id非唯一索引-RR" class="headerlink" title="7 组合七：id非唯一索引+RR"></a><strong>7 组合七：id非唯一索引+RR</strong></h3><p>还记得前面提到的MySQL的四种隔离级别的区别吗？RC隔离级别允许幻读，而RR隔离级别，不允许存在幻读。但是在组合五、组合六中，加锁行为又是与RC下的加锁行为完全一致。那么RR隔离级别下，如何防止幻读呢？问题的答案，就在组合七中揭晓。</p>
<p>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id &#x3D; 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170957087.png" alt="img"></p>
<p>此图，相对于组合三看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？</p>
<p>其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id &#x3D; 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。</p>
<p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p>
<p>如图中所示，有哪些位置可以插入新的满足条件的项 (id &#x3D; 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id&#x3D;10的记录；[6,c]与[10,b]间可以插入[10, aa]；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p>
<p>Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id&#x3D;10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p>
<p>有心的朋友看到这儿，可以会问：既然防止幻读，需要靠GAP锁的保护，为什么组合五、组合六，也是RR隔离级别，却不需要加GAP锁呢？</p>
<p>首先，这是一个好问题。其次，回答这个问题，也很简单。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。而组合五，id是主键；组合六，id是unique键，都能够保证唯一性。一个等值查询，最多只能返回一条记录，而且新的相同取值的记录，一定不会在新插入进来，因此也就避免了GAP锁的使用。</p>
<p><strong>结论：</strong>Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id &#x3D; 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p>
<h3 id="8-组合八：id无索引-RR"><a href="#8-组合八：id无索引-RR" class="headerlink" title="8 组合八：id无索引+RR"></a><strong>8 组合八：id无索引+RR</strong></h3><p>组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id &#x3D; 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407170957035.png" alt="img"></p>
<p>如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？</p>
<p>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p>
<p>当然，跟组合四类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了innodb_locks_unsafe_for_binlog参数。更详细的关于semi-consistent read的介绍，可参考我之前的一篇博客：<a href="http://hedengcheng.com/?p=220">MySQL+InnoDB semi-consitent read原理及实现分析</a> 。</p>
<p><strong>结论：</strong>在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新&#x2F;删除&#x2F;插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</p>
<h3 id="9-组合九：Serializable"><a href="#9-组合九：Serializable" class="headerlink" title="9 组合九：Serializable"></a><strong>9 组合九：Serializable</strong></h3><p>针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id &#x3D; 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。</p>
<p>Serializable隔离级别，影响的是SQL1：select * from t1 where id &#x3D; 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。</p>
<p><strong>结论：</strong>在MySQL&#x2F;InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/fedorafrog/article/details/104249140">https://blog.csdn.net/fedorafrog/article/details/104249140</a><br><a href="https://blog.csdn.net/huaishu/article/details/112977474?spm=1001.2014.3001.5502">https://blog.csdn.net/huaishu/article/details/112977474?spm=1001.2014.3001.5502</a></p>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>MySQL</category>
        <category>原理</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka索引的二分查找算法</title>
    <url>/2024/04/06/MQ/Kafka%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="Kafka的底层日志结构"><a href="#Kafka的底层日志结构" class="headerlink" title="Kafka的底层日志结构"></a>Kafka的底层日志结构</h2><p>基本结构的展示：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272250173.jpeg"></p>
<p>每个Topic都包含一个或多个Partition，不同Partition可位于不同节点。同时Partition在物理上对应一个本地文件夹(也就是个日志对象Log)，每个Partition包含一个或多个Segment，每个Segment包含一个数据文件和多个与之对应的索引文件。在逻辑上，可以把一个Partition当作一个非常长的数组，可通过这个“数组”的索引（offset）去访问其数据。</p>
<span id="more"></span>

<p>一个segment包含一个.log后缀的文件和多个index后缀的文件。</p>
<blockquote>
<ul>
<li><p>.log文件：具体存储消息的日志文件</p>
</li>
<li><p>.index文件：位移索引文件，可根据消息的位移值快速地从查询到消息的物理文件位置</p>
</li>
<li><p>.timeindex文件：时间戳索引文件，可根据时间戳查找到对应的位移信息</p>
</li>
<li><p>.txnindex文件：已中止事物索引文件</p>
</li>
</ul>
</blockquote>
<p>除了.log是实际存储消息的文件以外，其他的几个文件都是索引文件。索引本身设计的原来是一种空间换时间的概念，在这里kafka是为了加速查询所使用。</p>
<p><strong>kafka索引</strong>不会为每一条消息建立索引关系，这个也很好理解，毕竟对一条消息建立索引的成本还是比较大的，所以它是一种稀疏索引的概念，就好比我们常见的跳表，都是一种稀疏索引。</p>
<p><strong>kafka日志的文件名</strong>一般都是该segment写入的第一条消息的起始位移值baseOffset，比如000000000123.log，这里面的123就是baseOffset，具体索引文件里面纪录的数据是相对于起始位移的相对位移值relativeOffset，baseOffset与relativeOffse的加和即为实际消息的索引值。假设一个索引文件为：00000000000000000100.index，那么起始位移值即 100，当存储位移为 150 的消息索引时，在索引文件中的相对位移则为 150 - 100 &#x3D; 50，这么做的好处是使用 4 字节保存位移即可，可以节省非常多的磁盘空间。</p>
<h2 id="kafka索引文件"><a href="#kafka索引文件" class="headerlink" title="kafka索引文件"></a>kafka索引文件</h2><p>每个索引文件包含若干条索引项。不同索引文件的索引项的大小不同，比如offsetIndex索引项大小是8B，timeIndex索引项的大小是12B。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272251862.jpeg"></p>
<p>上图是OffsetIndex的结构，位移值用 4 个字节来表示，物理磁盘位置也用 4 个字节来表示。可能会疑问，位移值offset不是长整型吗，应该是 8 个字节才对啊？这是因为offset&#x3D;baseOffset+relativeOffse，使用相对位移值可以节省磁盘空间。<br>注意，relativeOffse是4字节，那么就限定了kafka中的每个日志段文件的大小不会超过2^32&#x3D;4GB。<br>TimeIndex 中的时间戳类型是长整型，占用 8 个字节，位移依然使用相对位移值， 占用 4 个字节，因此总共需要 12 个字节。</p>
<p>kafka对索引文件的存取用到了零拷贝技术—mmap，<strong>即 Java 中的 MappedByteBuffer</strong>。mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。在很多操作系统中(比如 Linux)，这段映射的内存区域实际上就是内核的页缓存 (Page Cache)。这就意味着，里面的数据不需要重复拷贝到用户态空间，避免了很多不 必要的时间、空间消耗。</p>
<h2 id="kafka的二分查找算法"><a href="#kafka的二分查找算法" class="headerlink" title="kafka的二分查找算法"></a>kafka的二分查找算法</h2><p><strong>1）普通二分查找</strong><br>offsetIndex每个索引项大小是8B，但操作系统访问内存时的最小单元是页，一般是4KB，即4096B，会包含了512个索引项。而<strong>找出在索引中的指定偏移量，对于操作系统访问内存时则变成了找出指定偏移量所在的页</strong>。</p>
<p>假设索引的大小有13个页，如下图所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272252039.jpeg"></p>
<p>由于Kafka读取消息，一般都是读取最新的偏移量，所以要查询的页就集中在尾部，即第12号页上。根据二分查找，将依次访问6、9、11、12号页。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272253311.jpeg"></p>
<p>当随着Kafka接收消息的增加，索引文件也会增加至第13号页，这时根据二分查找，将依次访问7、10、12、13号页。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272253713.jpeg"></p>
<p>可以看出这次访问的页和上一次的页完全不同。</p>
<p>之前在只有12号页的时候，Kafka读取索引时会频繁访问6、9、11、12号页，而由于Kafka使用了mmap来提高速度，即读写操作都将通过操作系统的page cache，所以6、9、11、12号页会被缓存到page cache中，避免磁盘加载。</p>
<p>但是当增至13号页时，则需要访问7、10、12、13号页，而由于7、10号页长时间没有被访问（现代操作系统都是使用LRU或其变体来管理page cache），很可能已经不在page cache中了，那么就会造成**缺页中断(Page Fault)**（线程被阻塞等待从磁盘加载没有被缓存到page cache的数据）。在Kafka的官方测试中，这种情况会造成几毫秒至1秒的延迟。</p>
<p><strong>2）kafka优化的二分查找</strong></p>
<p>Kafka对二分查找进行了改进。既然一般读取数据集中在索引的尾部。那么将索引中最后的 8192B（8KB）划分为“热区”(刚好缓存两页数据)，其余部分划分为“冷区”，分别进行二分查找。这样做的好处是，在频繁查询尾部的情况下，尾部的页基本都能在page cahce中，从而避免缺页中断。</p>
<p>下面我们还是用之前的例子来看下。由于每个页最多包含512个索引项，而最后的1024个索引项所在页会被认为是热区。那么当12号页未满时，则10、11、12会被判定是热区；而当12号页刚好满了的时候，则11、12被判定为热区；当增至13号页且未满时，11、12、13被判定为热区。假设我们读取的是最新的消息，则在热区中进行二分查找的情况如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272259613.jpeg"></p>
<p>当12号页未满时，依次访问11、12号页，当12号页满时，访问页的情况相同。当13号页出现的时候，依次访问12、13号页，不会出现访问长时间未访问的页，则能有效避免缺页中断。</p>
<hr>
<p>转载自：<br><a href="https://baijiahao.baidu.com/s?id=1770010432876434780&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1770010432876434780&amp;wfr=spider&amp;for=pc</a></p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
  </entry>
  <entry>
    <title>揭秘Nacos的AP架构「Distro一致性协议」</title>
    <url>/2024/04/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%8F%AD%E7%A7%98Nacos%E7%9A%84AP%E6%9E%B6%E6%9E%84%E3%80%8CDistro%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E3%80%8D/</url>
    <content><![CDATA[<p>[toc]<br>每个 Nacos 节点虽然只负责属于自己的客户端，但是每个节点都是包含有所有的客户端信息的，所以当客户端想要查询注册信息时，可以直接从请求的 Nacos 的节点拿到全量数据。</p>
<h3 id="Nacos-的架构"><a href="#Nacos-的架构" class="headerlink" title="Nacos 的架构"></a>Nacos 的架构</h3><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272304276.png" alt="img"></p>
<p>​        Nacos 是支持两种分布式定理的：CP(分区一致性)和 AP(分区可用性) ，而 AP 是通过 Nacos 自研的 Distro 协议来保证的，CP 是通过 Nacos 的 JRaft 协议来保证的。</p>
<p>​        因为注册中心作为系统中很重要的的一个服务，需要尽最大可能对外提供可用的服务，所以选择 AP 来保证服务的高可用，另外 Nacos 还采取了心跳机制来自动完成服务数据补偿的机制，所以说 Distro 协议是弱一致性的。</p>
<p>​        如果采用 CP 协议，则需要当前集群可用的节点数过半才能工作。</p>
<p>​        问题：Nacos 哪些地方用到了 AP 和 CP?</p>
<ul>
<li>针对临时服务实例，采用 AP 来保证注册中心的可用性，Distro 协议。</li>
<li>针对持久化服务实例，采用 CP 来保证各个节点的强一致性，JRaft 协议。(JRaft 是 Nacos 对 Raft 的一种改造)</li>
<li>针对配置中心，无 Database 作为存储的情况下，Nacos 节点之间的内存数据为了保持一致，采用 CP。Nacos 提供这种模式只是为了方便用户本机运行，降低对存储依赖，生产环境一般都是通过外置存储组件来保证数据一致性。</li>
<li>针对配置中心，有 Database 作为存储的情况下，Nacos 通过持久化后通知其他节点到数据库拉取数据来保证数据一致性，另外采用读写分离架构来保证高可用，所以这里我认为这里采用的 AP，欢迎探讨。</li>
<li>针对 异地多活，采用 AP 来保证高可用。</li>
</ul>
<span id="more"></span>



<h2 id="一、Distro-的设计思想和六大机制"><a href="#一、Distro-的设计思想和六大机制" class="headerlink" title="一、Distro 的设计思想和六大机制"></a>一、Distro 的设计思想和六大机制</h2><p>Distro 协议是 Nacos 对于临时实例数据开发的一致性协议。Distro 协议是集 Gossip + Eureka 协议的优点并加以优化后出现的。</p>
<p>Gossip 协议有什么坑? 由于随机选取发送的节点，不可避免地存在消息重复发送给同一节点的情况，增加了网络的传输的压力，给消息节点带来额外的处理负载。</p>
<p>Distro协议的优化：每个节点负责一部分数据，然后将数据同步给其他节点，有效地降低了消息冗余的问题。</p>
<p>关于临时实例数据：临时数据其实是存储在内存缓存中的，并且在其他节点在启动时会进行全量数据同步，然后节点也会定期进行数据校验。</p>
<p>AP 中的 P 代表网络分区，所以 Distro 在分布式集群环境下才能真正发挥其作用。它保证了在多个 Nacos 节点组成的 Nacos 集群环境中，当其中某个 Nacos 宕机后，整个集群还是能正常工作。</p>
<p>Distro 的设计机制：</p>
<ul>
<li>平等机制：Nacos 的每个节点是平等的，都可以处理写的请求。</li>
<li>异步复制机制：Nacos 把变更的数据异步复制到其他节点。</li>
<li>健康检查机制：每个节点只存了部分数据，定期检查客户端状态保持数据一致性。</li>
<li>本地读机制： 每个节点独立处理读请求，及时从本地发出响应。</li>
<li>新节点同步机制：Nacos 启动时，从其他节点同步数据。</li>
<li>路由转发机制：客户端发送的写请求，如果属于自己则处理，否则路由转发给其他节点。</li>
</ul>
<h2 id="二、异步复制机制：写入数据后同步给其他节点"><a href="#二、异步复制机制：写入数据后同步给其他节点" class="headerlink" title="二、异步复制机制：写入数据后同步给其他节点"></a>二、异步复制机制：写入数据后同步给其他节点</h2><p>当注册请求交给 Nacos 节点来处理时，这里面会做几件事：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272308094.png" alt="img"></p>
<p>添加实例信息的流程</p>
<p>① 将实例信息存放到内存缓存 ConcurrentHashMap 里面。</p>
<p>② 添加一个任务到 BlockingQueue 里面，这个任务就是将最新的实例列表通过 UDP 的方式推送给所有客户端(服务实例)，这样客户端就拿到了最新的服务实例列表，缓存到本地。</p>
<p>③ 开启 1s 的延迟任务，将数据通过给其他 Nacos 节点。</p>
<p>说明：第二件事是 Nacos 和 客户端如何保持数据一致性的，第三件事是 Nacos 集群间如何保持数据一致性的，因本篇重点讲解 Nacos 的 AP 原理，所以会针对第三件事来进行阐述。而第二件事，会在后续文章中重点讲解。</p>
<h2 id="三、定时同步：如何保持数据一致性"><a href="#三、定时同步：如何保持数据一致性" class="headerlink" title="三、定时同步：如何保持数据一致性"></a>三、定时同步：如何保持数据一致性</h2><h3 id="3-1-为什么需要定时同步"><a href="#3-1-为什么需要定时同步" class="headerlink" title="3.1 为什么需要定时同步"></a>3.1 为什么需要定时同步</h3><p>在 Nacos 集群模式下，它作为一个完整的注册中心，必须具有高可用特性。</p>
<p>在集群模式下，客户端只需要和其中一个 Nacos 节点通信就可以了，但是每个节点其实是包含所有客户端信息的，这样做的好处是每个 Nacos 节点只需要负责自己的客户端就可以(分摊压力)，而当客户端想要拉取全量注册表到本地时，从任意节点都可以读取到(数据一致性)。</p>
<p>那么 Nacos 集群之间是如何通过 Distro 协议来保持数据一致性的呢?</p>
<h4 id="3-2-定期检验元数据"><a href="#3-2-定期检验元数据" class="headerlink" title="3.2 定期检验元数据"></a>3.2 定期检验元数据</h4><p>在版本 v1 中 ，采用的是定期检验元信息的方式。元信息就是当前节点包含的客户端信息的 md5 值。</p>
<p>检验的原理如下图所示：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272309523.png" alt="img"></p>
<p>Nacos 各个节点会有一个心跳任务，定期向其他机器发送一次数据检验请求，在校验的过程中，当某个节点发现其他机器上的数据的元信息和本地数据的元信息不一致，则会发起一次全量拉取请求，将数据补齐。</p>
<h3 id="3-3-关于版本迭代的说明"><a href="#3-3-关于版本迭代的说明" class="headerlink" title="3.3 关于版本迭代的说明"></a>3.3 关于版本迭代的说明</h3><p>在版本 v2 中，定期校验数据已经不用了，采用的是健康检查机制，来和其他节点来保持数据的同步，由于涉及的内容还挺多，放到下一讲来专门讲解 Nacos 的健康检查机制：</p>
<p>客户端与 Nacos 节点的健康检查机制。</p>
<p>集群模式下的健康检查机制。</p>
<h2 id="四、新节点同步机制，如何保持数据一致性"><a href="#四、新节点同步机制，如何保持数据一致性" class="headerlink" title="四、新节点同步机制，如何保持数据一致性"></a>四、新节点同步机制，如何保持数据一致性</h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1 原理"></a>4.1 原理</h3><p>新加入的 Distro 节点会进行全量数据拉取，轮询所有的 Distro 节点，向其他节点发送请求拉取全量数据。</p>
<p>在全量拉取操作完成之后，每台机器上都维护了当前的所有注册上来的非持久化实例数据。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272310361.png" alt="img"></p>
<h2 id="五、本地读机制"><a href="#五、本地读机制" class="headerlink" title="五、本地读机制"></a>五、本地读机制</h2><h3 id="5-1-原理"><a href="#5-1-原理" class="headerlink" title="5.1 原理"></a>5.1 原理</h3><p>每个 Nacos 节点虽然只负责属于自己的客户端，但是每个节点都是包含有所有的客户端信息的，所以当客户端想要查询注册信息时，可以直接从请求的 Nacos 的节点拿到全量数据。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272310529.png" alt="img"></p>
<p>读操作的原理</p>
<p>这样设计的好处是保证了高可用(AP)，分为两个方面：</p>
<ul>
<li><p>① 读操作都能进行及时的响应，不需要到其他节点拿数据。</p>
</li>
<li><p>② 当脑裂发生时，Nacos 的节点也能正常返回数据，即使数据可能不一致，当网络恢复时，通过健康检查机制或数据检验也能达到数据一致性。</p>
</li>
</ul>
<hr>
<p>转载自：<br><a href="https://www.51cto.com/article/707999.html">https://www.51cto.com/article/707999.html</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>UnexpectedRollbackException:Transaction rolled back because it has been marked as rollback-only</title>
    <url>/2024/03/20/Spring/UnexpectedRollbackExceptionTransaction%EF%BC%9Arolled%20back%20because%20it%20has%20been%20marked%20as%20rollback-only/</url>
    <content><![CDATA[<p><strong>PROPAGATION_REQUIRES_NEW</strong>：原有事务A新起事务B，事务B中的commit和rollback不会影响外部事务A的commit和rollback，相互独立，如果事务B抛出异常，肯定会影响外事务A的。</p>
<p><strong>PROPAGATION_NESTED</strong>：表示嵌套事务，看如下示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceA &#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 事务属性配置为 PROPAGATION_REQUIRED </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Transactional(propagation=Propagation.REQUIRED)</span> <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        insertData(); <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServiceB.methodB();   <span class="comment">//3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SomeException) &#123;  </span><br><span class="line">            <span class="comment">// 执行其他业务, 如 ServiceC.methodC();   //5</span></span><br><span class="line">        &#125;</span><br><span class="line">        updateData(); <span class="comment">//6</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServiceB &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation=Propagation.NESTED)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        updateData(); <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的1，将开起新事务A，2的时候会插入数据，此时事务A挂起，没有commit，3的时候，使用<strong>PROPAGATION_NESTED</strong>传播，将在3点的时候新建一个savepoint保存2插入的数据，不提交。<br>如果methodB出现异常，将回滚4的操作，不影响2的操作，同时可以处理后面的5,6逻辑，最后一起commit: 2,5,6；<br>如果methodB没有出现异常，那么将一起commit: 2,4,6。</p>
 <span id="more"></span>

<p>假如methodB使用的<strong>PROPAGATION_REQUIRES_NEW</strong><br>那么B异常，会commit: 2,5,6，和NESTED一致，如果methodB没有出现异常，那么会先commit4，再commit:6，那么事务将分离开，不能保持一致，假如执行6报错，2和6将回滚，而4却没有被回滚，不能达到预期效果。</p>
<hr>
<p>最近在项目中发现了一则报错：“org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only”。根据报错信息来看是spring框架中的事务管理报错：事务回滚了，因为它被标记为回滚状态。</p>
<p>报错原因：<br><strong>多层嵌套事务中，如果使用了默认的事务传播方式，当内层事务抛出异常，外层事务捕捉并正常执行完毕时，就会报出rollback-only异常。</strong></p>
<p>spring框架是使用AOP的方式来管理事务，如果一个被事务管理的方法正常执行完毕，方法结束时spring会将方法中的sql进行提交。如果方法执行过程中出现异常，则回滚。<br>spring框架的默认事务传播方式是 <strong>PROPAGATION_REQUIRED</strong>：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。<br>在项目中，一般我们都会使用默认的传播方式，这样无论外层事务和内层事务任何一个出现异常，那么所有的sql都不会执行。在嵌套事务场景中，内层事务的sql和外层事务的sql会在外层事务结束时进行提交或回滚。如果内层事务抛出异常e，在内层事务结束时，spring会把事务标记为“rollback-only”。这时如果外层事务捕捉了异常e，那么外层事务方法还会继续执行代码，直到外层事务也结束时，spring发现事务已经被标记为“rollback-only”，但方法却正常执行完毕了，这时spring就会抛出“org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only”。</p>
<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class ServiceA &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;serviceB&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ServiceB b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.b()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class ServiceB &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用a()时，就会报出“rollback-only”异常。</p>
<p>解决方案：</p>
<ul>
<li>如果希望内层事务抛出异常时中断程序执行，直接在外层事务的catch代码块中抛出e；</li>
<li>如果希望程序正常执行完毕，并且希望外层事务结束时全部提交，需要在内层事务中做异常捕获处理：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void b() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;catch (Exception e) &#123;  </span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果希望内层事务回滚，但不影响外层事务提交，需要将内层事务的传播方式指定为Propagation.REQUIRES_NEW（A和B不需要同一个事务，把事务分开）或者NESTED（A和B同一个事务，但是B回滚的时候A不会回滚）。注：PROPAGATION_NESTED基于数据库savepoint实现的嵌套事务，外层事务的提交和回滚能够控制嵌内层事务，而内层事务报错时，可以返回原始savepoint，外层事务可以继续提交。</li>
</ul>
<hr>
<p>转载自：</p>
<p><a href="https://dongguabai.blog.csdn.net/article/details/114686998">https://dongguabai.blog.csdn.net/article/details/114686998</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot微服务性能降九成！用Arthas定根因</title>
    <url>/2024/03/20/Spring/Spring%20Boot%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E9%99%8D%E4%B9%9D%E6%88%90%EF%BC%81%E7%94%A8Arthas%E5%AE%9A%E6%A0%B9%E5%9B%A0/</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>接收到公司业务部门的开发反馈，应用在升级公司内部框架后，UAT（预生产）环境接口性能压测不达标。<br>升级前压测报告：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291727596.png" alt="1.png"></p>
<p>升级后压测报告：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291727434.png" alt="img"></p>
<p>在机器配置（1C4G）相同的情况下，吞吐量从原来的 53.9&#x2F;s 下降到了 6.4&#x2F;s，且 CPU 负载较高。</p>
<p>并且开发反馈从公司全链路监控系统 SkyWalking 中查询到的链路信息可以得知大部分请求 Feign 调用的耗时不太正常（390ms），而实际被调用的下游服务响应速度很快（3ms）。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291727321.png" alt="img"></p>
<span id="more"></span>
<h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>在接收到反馈以后，我立即申请了相应机器的权限，并往相应机器上传了 Arthas（version 3.4.3）。让业务方保持压测，开始问题定位。</p>
<h4 id="1-执行-profiler-命令对-CPU-进行性能分析"><a href="#1-执行-profiler-命令对-CPU-进行性能分析" class="headerlink" title="1. 执行 profiler 命令对 CPU 进行性能分析"></a>1. 执行 profiler 命令对 CPU 进行性能分析</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[arthas@17962]$ profiler start -d 30 -f /tmp/arthas/1.txt</span><br></pre></td></tr></table></figure>

<p>等待 30s 后，打开 1.txt，查看 CPU 性能分析结果，开头部分示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- 1630160766 ns (4.24%), 141 samples</span><br><span class="line">  ......</span><br><span class="line">  [14] org.springframework.boot.loader.LaunchedURLClassLoader.definePackageIfNecessary</span><br><span class="line">  [15] org.springframework.boot.loader.LaunchedURLClassLoader.loadClass</span><br><span class="line">  [16] java.lang.ClassLoader.loadClass</span><br><span class="line">  [17] java.lang.Class.forName0</span><br><span class="line">  [18] java.lang.Class.forName</span><br><span class="line">  [19] org.springframework.util.ClassUtils.forName</span><br><span class="line">  [20] org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.registerWellKnownModulesIfAvailable</span><br><span class="line">  [21] org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.configure</span><br><span class="line">  [22] org.springframework.http.converter.json.Jackson2ObjectMapperBuilder.build</span><br><span class="line">  [23] org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport.addDefaultHttpMessageConverters</span><br><span class="line">  [24] org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport.getMessageConverters</span><br><span class="line">  [25] org.springframework.boot.autoconfigure.http.HttpMessageConverters$1.defaultMessageConverters</span><br><span class="line">  [26] org.springframework.boot.autoconfigure.http.HttpMessageConverters.getDefaultConverters</span><br><span class="line">  [27] org.springframework.boot.autoconfigure.http.HttpMessageConverters.&lt;init&gt;</span><br><span class="line">  [28] org.springframework.boot.autoconfigure.http.HttpMessageConverters.&lt;init&gt;</span><br><span class="line">  [29] org.springframework.boot.autoconfigure.http.HttpMessageConverters.&lt;init&gt;</span><br><span class="line">  [30] com.zhangmen.xxx.DefaultFeignConfig.lambda$feignDecoder$0</span><br><span class="line">  [31] com.zhangmen.xxx.DefaultFeignConfig$$Lambda$704.256909008.getObject</span><br><span class="line">  [32] org.springframework.cloud.openfeign.support.SpringDecoder.decode</span><br><span class="line">  [33] org.springframework.cloud.openfeign.support.ResponseEntityDecoder.decode</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>



<h4 id="2-对可疑的方法执行-trace-命令输出方法路径上每个节点的耗时"><a href="#2-对可疑的方法执行-trace-命令输出方法路径上每个节点的耗时" class="headerlink" title="2. 对可疑的方法执行 trace 命令输出方法路径上每个节点的耗时"></a>2. 对可疑的方法执行 trace 命令输出方法路径上每个节点的耗时</h4><p>分析上一步得到的 CPU 性能分析结果，可以发现最占用 CPU 的栈中，确实有 Feign 相关的栈帧。</p>
<p>并且发现 Feign 相关的栈帧周围出现了 com.zhangmen 相关的栈帧：<br><code>com.zhangmen.xxx.DefaultFeignConfig$$Lambda$704.256909008.getObject</code> 和 <code>com.zhangmen.xxx.DefaultFeignConfig.lambda$feignDecoder$0</code>。</p>
<p>在 1.txt 中搜索<br><code>com.zhangmen.xxx.DefaultFeignConfig</code>，发现有 340 次命中，因此认为这是一个非常可疑的方法。</p>
<p>执行 trace 命令输出该方法路径上每个节点的耗时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[arthas@17962]$ trace com.zhangmen.xxx.DefaultFeignConfig * &#x27;#cost&gt;200&#x27; -n 3</span><br><span class="line">`---[603.999323ms] com.zhangmen.xxx.DefaultFeignConfig:lambda$feignEncoder$1()</span><br><span class="line">    `---[603.856565ms] org.springframework.boot.autoconfigure.http.HttpMessageConverters:&lt;init&gt;() #42</span><br></pre></td></tr></table></figure>

<p>发现HttpMessageConverters:() 比较耗时，并继续一层层 trace 追踪下去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[arthas@17962]$ trace org.springframework.boot.autoconfigure.http.HttpMessageConverters &lt;init&gt; &#x27;#cost&gt;200&#x27; -n 3</span><br><span class="line">......</span><br><span class="line">[arthas@17962]$ trace org.springframework.http.converter.json.Jackson2ObjectMapperBuilder registerWellKnownModulesIfAvailable &#x27;#cost&gt;200&#x27; -n 3</span><br></pre></td></tr></table></figure>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291728343.png" alt="img"></p>
<p>最终发现<br>org.springframework.util.ClassUtils:forName() 比较耗时，并且抛出了异常。使用 watch 命令查看具体的异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[arthas@17962]$ watch org.springframework.util.ClassUtils forName -e &quot;throwExp&quot; -n </span><br></pre></td></tr></table></figure>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291728297.webp" alt="图片"></p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>将定位到的问题，反馈给相关业务开发，并建议引入 jackson-datatype-joda 依赖。 引入依赖后压测报告：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291728118.png" alt="img"></p>
<p>吞吐量从原来的 6.4&#x2F;s 提升到了 69.3&#x2F;s。</p>
<p>这时候相关业务开发反馈，这个问题是代码中自定义了 Feign 的编解码器（下图所示）导致的，并且这个编解码器在升级框架前也是一直存在的。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291729917.webp" alt="图片"></p>
<p>于是，对升级框架前的代码进行压测并在压测过程中使用 Arthas 执行以下命令：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291729044.png" alt="img"></p>
<p>发现同样有这个异常。引入 jackson-datatype-joda 依赖，再次进行压测，压测报告如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291729570.webp" alt="图片"></p>
<p>汇总前面的压测结果：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291729222.webp" alt="图片"></p>
<p>可以发现一个新的问题：为什么新旧版本同时不引入依赖，吞吐量相差近 8 倍，新旧版本同时引入依赖，吞吐量相差近 1 倍？</p>
<h3 id="进一步定位问题"><a href="#进一步定位问题" class="headerlink" title="进一步定位问题"></a>进一步定位问题</h3><p>根据上一步中发现的新问题，接下来对 未升级框架并引入依赖的版本 和 升级框架并引入依赖的版本 分别进行压测，并在压测过程中使用 Arthas 的 profiler 命令采样 CPU 性能分析数据，得到样本 1 和样本 2 。并从样本 1 和样本 2 中找到相似栈进行对比：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291730598.webp" alt="图片"></p>
<p>通过对比可以发现，两个样本的相似栈的前 17 行有所不同。并对样本 2 中的可疑栈帧进行 trace 追踪：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[arthas@10561]$ trace org.apache.catalina.loader.WebappClassLoaderBase$CombinedEnumeration * &#x27;#cost&gt;100&#x27; -n 3</span><br><span class="line">`---[171.744137ms] org.apache.catalina.loader.WebappClassLoaderBase$CombinedEnumeration:hasMoreElements()</span><br><span class="line">    `---[171.736943ms] org.apache.catalina.loader.WebappClassLoaderBase$CombinedEnumeration:inc() #2685</span><br><span class="line">        `---[171.724546ms] org.apache.catalina.loader.WebappClassLoaderBase$CombinedEnumeration:inc()</span><br></pre></td></tr></table></figure>

<p>发现升级框架后，在类加载器这部分存在比较耗时的情况。</p>
<p>而对样本 1 中这部分进行 trace 追踪没有出现耗时大于 100ms 的情况。又进一步使用 profiler 命令，分别生成两个版本在压测场景下的火焰图，并找到相似栈进行对比：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[arthas@10561]$ profiler start -d 30 -f /tmp/arthas/1.svg</span><br></pre></td></tr></table></figure>

<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291731985.webp" alt="图片"></p>
<p>发现 升级框架并引入依赖的版本 还多出了一些 <code>org/springframework/boot/loader/</code> 相关的栈。</p>
<h3 id="进一步解决问题"><a href="#进一步解决问题" class="headerlink" title="进一步解决问题"></a>进一步解决问题</h3><p>将新的发现反馈给相关业务开发。他们反映此次除了框架升级外，还有 Spring Boot war to jar 部署的调整。从使用独立的 Tomcat war 部署，改造成用 Spring Boot 内嵌 Tomcat java -jar 部署。故怀疑两种部署方式在类加载器上存在性能差异。</p>
<p>相关业务开发在我上一步定位问题期间，根据我最初定位到的问题，在 Google 搜索 feign<br>com.fasterxml.jackson.datatype.joda.JodaModule，找到了一篇相关的文章《loadClass 导致线上服务卡顿分析》。或参考：<a href="https://blog.csdn.net/weixin_35762553/article/details/112087522">feign 序列化_Feign编码不规范，导致CPU100%</a>。</p>
<p>看了这篇文章后，我又 Debug 了部分源码，最后了解到问题产生的根本原因是：<strong>SpringEncoder &#x2F; SpringDecoder 在每次编码 &#x2F; 解码时都会调用 ObjectFactory.getObject()).getConverters() 获取 HttpMessageConverters</strong>。而我们自定义的 DefaultFeignConfig 中配置的ObjectFactory 的实现是每次都 new 一个新的 HttpMessageConverters 对象。</p>
<p>HttpMessageConverters 的构造方法又默认会执行 getDefaultConverters 方法获取默认的 HttpMessageConverter 集合，并初始化这些默认的 HttpMessageConverter。其中的<br>MappingJackson2HttpMessageConverter（有两个，见下图） 每次初始化时都会加载不在 classpath 中的 <code>com.fasterxml.jackson.datatype.joda.JodaModule</code>和 <code>com.fasterxml.jackson.datatype.joda$JodaModule</code>（org.springframework.util.ClassUtils 加载不到类时，会尝试再加载一下内部类），并抛出 ClassNotFoundException，且该异常最后被生吞。</p>
<p>而部分和 XML 相关的默认的 HttpMessageConverter，<br>SourceHttpMessageConverter 和 Jaxb2RootElementHttpMessageConverter（各有两个，见下图）每次初始化时，会执行 TransformerFactory.newInstance()，执行过程中会使用 SPI 扫描 classpath 下的 <code>META-INF/services</code> 目录获取具体的实现，并且每次扫描完也没有获取到具体的实现，最终使用默认指定的 <code>com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl</code>作为实现。</p>
<p>最终导致每一次 Feign 调用（包含编码和解码），都会加载 4 次不在 classpath 中的<br><code>com.fasterxml.jackson.datatype.joda.JodaModule</code> 和 <code>com.fasterxml.jackson.datatype.joda$JodaModule</code>（共8次），且 8 次使用 SPI 扫描 classpath 下的 META-INF &#x2F; services 目录获取查找不到的实现，而 war to jar 后，类加载器在频繁查找和加载资源上的性能有所下降，最终导致严重影响接口性能。</p>
<p>默认的 HttpMessageConverter 集合：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291731227.webp" alt="图片"></p>
<p>部分关键代码如下。<code>org/springframework/boot/autoconfigure/http/HttpMessageConverters</code>：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291731188.webp" alt="图片"></p>
<p><code>org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.registerWellKnownModulesIfAvailable</code>：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291731115.webp" alt="图片"></p>
<p><code>org/springframework/util.ClassUtils.forName</code>：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291731748.webp" alt="图片"></p>
<p><code>org/springframework/http/converter/xml/SourceHttpMessageConverter：</code></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291732320.webp" alt="图片"></p>
<p><code>javax/xml/transform/FactoryFinder.find</code>：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291732239.webp" alt="图片"></p>
<p>文章中对于这个问题还提供了两种解决方法：</p>
<p><strong>第一种方法</strong>，就是我最初建议的引入 jackson-datatype-joda 依赖，避免每次初始化默认的<br>MappingJackson2HttpMessageConverter 时 ClassLoader 反复加载不在 classpath 中的 <code>com.fasterxml.jackson.datatype.joda.JodaModule</code> 和 <code>com.fasterxml.jackson.datatype.joda$JodaModule</code>。</p>
<p><strong>第二种方法</strong>，不初始化默认的 HttpMessageConverter。由于我们此处只需要使用自定义的<br>FastJsonHttpMessageConverter 来执行编解码，完全可以避免执行 getDefaultConverters 方法，重复初始化许多用不到的默认的 HttpMessageConverter。因此在 new HttpMessageConverters 对象时 ，可以将 addDefaultConverters 参数设置为 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectFactory&lt;HttpMessageConverters&gt; objectFactory = () -&gt; <span class="keyword">new</span> <span class="title class_">HttpMessageConverters</span>(</span><br><span class="line">  <span class="literal">false</span>, </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HttpMessageConverter</span>[] &#123; (HttpMessageConverter)fastJsonHttpMessageConverter &#125;);</span><br></pre></td></tr></table></figure>

<p>实际上，我们还可以修改 DefaultFeignConfig 中 ObjectFactory 的实现，避免每次都 new 一个新的 HttpMessageConverters 对象（重复初始化 HttpMessageConverters），实现进一步优化。<br>故建议相关业务开发，将 DefaultFeignConfig 修改成如下代码：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291732191.webp" alt="图片"></p>
<p>在相关业务开发将新旧版本代码中的 DefaultFeignConfig 都进行改进并部署到 FAT（测试）环境以后，我在自己本机用 JMeter 对 FAT 环境进行了模拟压测。</p>
<p>旧版改进后压测结果：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291732573.webp" alt="图片"></p>
<p>新版改进后压测结果：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291732097.webp" alt="图片"></p>
<p>发现此时，两个版本的接口性能已经基本相同。</p>
<p>最终测试人员在 UAT 环境，对升级框架并改进 DefaultFeignConfig 后的代码再次进行压测，压测结果如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291732539.webp" alt="图片"></p>
<p>吞吐量从最初不达标的 6.4&#x2F;s，提升到了160.4&#x2F;s。</p>
<p>那为什么 war to jar 部署的调整，会导致类加载器在频繁查找和加载资源时性能有所下降呢？</p>
<p>在对 SpringBoot 可执行 jar 的原理做了一番了解以后。怀疑和 Spring Boot 为了做到能够以一个 fat jar 来启动，从而扩展了 JDK 的 JarFile URL 协议，并定制了自己的 ClassLoader 和 jar 文件协议的 Hander，实现了 jar in jar、jar in directory 的加载方式有关。</p>
<h3 id="War2Jar-类加载器性能下降根因探究"><a href="#War2Jar-类加载器性能下降根因探究" class="headerlink" title="War2Jar 类加载器性能下降根因探究"></a>War2Jar 类加载器性能下降根因探究</h3><p>为了验证自己的猜测，我在自己本机搭建了一个简单的 Demo。Demo 中有两个服务，A 和 B。将 A 和 B 都注册到 Eureka 注册中心，并且 A 通过 Feign 调用 B。接下来使用 Jmeter 在相同的配置下对各种场景进行压测，并在压测过程中使用 Arthas 的 profiler 命令生成各种场景下的火焰图。</p>
<p>压测结果如下（-Xms512m -Xmx512m）：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291733630.webp" alt="图片"></p>
<p>通过对比表格三和表格四可以得知，代码优化后，是否引入依赖，对吞吐量几乎没有影响。</p>
<p>通过表格三和表格四可以得知，代码优化后，在不会频繁查找和加载不存在的资源时，三种部署方式的吞吐量基本一致。</p>
<p>通过表格二可以得知，在频繁使用 SPI 获取 classpath 下查找不到的实现时，Tomcat war 部署性能更好。</p>
<p>通过表格一可以得知，在频繁加载不存在的类时，将 jar 包解压后通过 JarLauncher 启动性能更好。</p>
<p>对比表格一中 ③ 和 ② 相似栈的火焰图：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291733017.webp" alt="图片"></p>
<p>可以发现两者在<br><code>org/springframework/boot/loader/LaunchedURLClassLoader.loadClass</code> 加载类时，存在差异。</p>
<p>② 不仅会执行<br>java&#x2F;lang&#x2F;ClassLoader.loadClass，还会执行 org&#x2F;springframework&#x2F;boot&#x2F;loader&#x2F;LaunchedURLClassLoader.definePackageIfNecessary。</p>
<p>查看<br>org&#x2F;springframework&#x2F;boot&#x2F;loader&#x2F;LaunchedURLClassLoader.loadClass 的源码：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291733821.webp" alt="图片"></p>
<p>发现存在一个条件分支。</p>
<p>查看<code>org/springframework/boot/loader/Launcher.createArchive</code> 的源码：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291734293.webp" alt="图片"></p>
<p>发现这个条件的值与应用是 可执行 jar 文件 还是 文件目录 有关。</p>
<p>对 ② 再次进行压测，并<code> trace org/springframework/boot/loader/LaunchedURLClassLoader.definePackageIfNecessary</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`---[165.770773ms] org.springframework.boot.loader.LaunchedURLClassLoader:definePackageIfNecessary()</span><br><span class="line">    +---[0.00347ms] org.springframework.boot.loader.LaunchedURLClassLoader:getPackage() #197</span><br><span class="line">    `---[165.761244ms] org.springframework.boot.loader.LaunchedURLClassLoader:definePackage() #199</span><br></pre></td></tr></table></figure>

<p>发现这个地方确实存在比较耗时的情况。</p>
<p>阅读该部分源码，从注释中即可得知，definePackageIfNecessary 主要是为了在调用 findClass 之前尝试根据类名去定义类所在的 package，确保 jar 文件嵌套 jar 包里的 manifest 能够和 package 关联起来。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291734845.webp" alt="图片"></p>
<p>Debug definePackageIfNecessary 这部分代码，发现在 definePackage 时，会遍历 <code>BOOT-INF/lib/</code> 下所有的 jar 包 以及 <code>BOOT-INF/classes/</code>。如果发现这些资源中存在指定的类，就继续调用 definePackage 方法，否则遍历完直接返回 null。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291734311.webp" alt="图片"></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291734310.webp" alt="图片"></p>
<p>前面说过，每一次 Feign 调用都会加载 4 次不在 classpath 中的<br><code>com.fasterxml.jackson.datatype.joda.JodaModule</code> 和<code>com.fasterxml.jackson.datatype.joda$JodaModule</code> （共8次）。而我这个简单的 Demo 应用依赖的 jar 有 117 个（实际企业级项目将会更多）。那么每一次 Feign 调用，就会执行 8 * (117 + 1)，总计 944 次循环里的逻辑。而逻辑中的 org.springframework.boot.loader.jar.Handler.openConnection 方法在执行过程中又会涉及到比较耗时的 IO 操作，最终导致严重影响接口性能。从生成的火焰图中，也可以看到这部分处理逻辑。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291734976.webp" alt="图片"></p>
<p>至此，已经可以确认 war to jar 部署的调整，导致类加载器在频繁查找和加载资源时性能有所下降的根因就是：Spring Boot 为了做到能够以一个 fat jar 来启动，增加了一些定制的处理逻辑，而这部分定制的处理逻辑在频繁执行时，会对程序性能产生较大影响。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大家在自定义 Feign 的编解码器时，如果用到了 SpringEncoder &#x2F; SpringDecoder，应避免 HttpMessageConverters 的重复初始化。如果不需要使用那些默认的 HttpMessageConverter，可以在初始化 HttpMessageConverters 时将第一个入参设置为 false，从而不初始化那些默认的 HttpMessageConverter。</p>
<p>另外，应该了解不同的部署方式在类加载器频繁查找和加载资源时是存在性能差异的。</p>
<p>我们在写代码时，也应该要避免重复初始化，以及反复查找和加载不存在的资源。</p>
<p>最后，善用SkyWalking 和Arthas 可以帮助我们更加高效地排查程序错误和性能瓶颈。</p>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>如果应用使用了 SkyWalking Agent，再使用 Arthas，可能会遇到 Arthas 部分命令（trace、watch 等会对类进行增强的命令）不能正常工作的问题。</p>
<p>解决方案：<br><a href="https://github.com/apache/skywalking/blob/master/docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md">https://github.com/apache/skywalking/blob/master/docs/en/FAQ/Compatible-with-other-javaagent-bytecode-processing.md</a></p>
<p>而当 Arthas 可以正常工作以后，我们对于 SkyWalking Agent 已经增强过的类的方法执行 trace 等命令时，最好在方法名后面加上一个 * 符号进行模糊匹配。Arthas 最终会将所有匹配方法的 trace 追踪结果进行汇总展示。</p>
<p>方法名不加 * 进行 trace：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291735772.webp" alt="图片"></p>
<p>方法名加上 * 进行trace：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291735346.webp" alt="图片"></p>
<p>可以看到方法名加上 * 以后，trace 得到的结果才是我们理想的结果。</p>
<p>这是由于 SkyWalking Agent 使用了 ByteBuddy 做字节码增强。而 ByteBuddy 每增强一个方法，都会为该方法生成一个辅助内部类（HelloController$auxiliary$jiu2bTqU），并且会对当前类（HelloController）中的原方法（test1）进行重命名（test1$original$lyu0XDob），并生成一个与原方法同名的方法（test1）和一个不同名但仅供辅助内部类调用的方法（test1$original$lyu0XDob$accessor$8F82ImAF）。</p>
<p>使用同事开发的 Java 反编译工具可以直观地看到相关代码：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291735424.webp" alt="图片"></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291735027.webp" alt="图片"></p>
<p>另外，在使用 Arthas 的时候，建议选择最新的版本。比如，3.4.2 以前的版本 trace 追踪大方法时就可能会导致 JVM Metaspace OOM。详情见：<a href="https://zhuanlan.zhihu.com/p/359329753">《记一次由 Arthas 引起的 Metaspace OOM 问题》</a>。</p>
<p>如果你想要基于 Arthas 打造企业级在线诊断平台，可以参考<a href="https://www.wangt.cc/2020/10/%E5%B7%A5%E5%95%86%E9%93%B6%E8%A1%8C%E6%89%93%E9%80%A0%E5%9C%A8%E7%BA%BF%E8%AF%8A%E6%96%AD%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/">《工商银行打造在线诊断平台的探索与实践》</a>。</p>
<hr>
<p>转载自：<br><a href="https://www.toutiao.com/article/6927425570175271431/?log_from=fef855f940eae_1706251588291">https://www.toutiao.com/article/6927425570175271431/?log_from=fef855f940eae_1706251588291</a><br><a href="https://mp.weixin.qq.com/s/RuqltkN9VdVQ1K3GKuJ-Gw">https://mp.weixin.qq.com/s/RuqltkN9VdVQ1K3GKuJ-Gw</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>整合Mysql项目:数据库连接池hikari配置信息</title>
    <url>/2024/03/20/Spring/%E6%95%B4%E5%90%88Mysql%E9%A1%B9%E7%9B%AE%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0hikari%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> </span><br><span class="line">    <span class="attr">password:</span> </span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="comment"># 默认使用的hikari作为连接池，具体配置参考：https://github.com/brettwooldridge/HikariCP</span></span><br><span class="line">      <span class="attr">poolName:</span> <span class="string">hikariPool</span></span><br><span class="line">      <span class="attr">minimumIdle:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">maximumPoolSize:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">connectionTimeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">idleTimeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">maxLifetime:</span> <span class="number">1800000</span></span><br><span class="line">      <span class="attr">connectionTestQuery:</span> <span class="string">SELECT</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Primary</span><br><span class="line">@Bean(name = &quot;mysqlDataSource&quot;)</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)</span><br><span class="line">public DataSource mysqlDataSource(DataSourceProperties dataSourceProperties) &#123;</span><br><span class="line">    return dataSourceProperties.initializeDataSourceBuilder()</span><br><span class="line">            .type(HikariDataSource.class)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这里需要注意，dataSourceProperties是spring容器自动加载的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title class_">BeanClassLoaderAware</span>, InitializingBean</span><br></pre></td></tr></table></figure>

<p>主要用了 driverClassName、url、username、password等参数。</p>
<p>通过上面的例子创建DataSource并指定type的话，就会把dataSourceProperties的参数传给HikariDataSource。否则就需要这样搞：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="comment"># 默认使用的hikari作为连接池，具体配置参考：https://github.com/brettwooldridge/HikariCP</span></span><br><span class="line">      <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">      <span class="attr">username:</span> </span><br><span class="line">      <span class="attr">password:</span> </span><br><span class="line">      <span class="attr">jdbcUrl:</span> <span class="string">jdbc:mysql://</span></span><br><span class="line">      <span class="attr">poolName:</span> <span class="string">hikariPool</span></span><br><span class="line">      <span class="attr">minimumIdle:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">maximumPoolSize:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">connectionTimeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">idleTimeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">maxLifetime:</span> <span class="number">1800000</span></span><br><span class="line">      <span class="attr">connectionTestQuery:</span> <span class="string">SELECT</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>应该懂了吧。</p>
<p>@ConfigurationProperties(prefix &#x3D; “spring.datasource.hikari”)<br>这个会把配置值赋 给返回的bean即HikariDataSource。是在bean实例化完之后处理的。</p>
<p>如果是多数据源配置，需要注意，参考：</p>
<p><a href="https://blog.csdn.net/qq_17229141/article/details/128408860">https://blog.csdn.net/qq_17229141/article/details/128408860</a></p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#howto-two-datasources">https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#howto-two-datasources</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line">###############################################hikari############################################</span><br><span class="line">spring.datasource.type=com.zaxxer.hikari.HikariDataSource</span><br><span class="line">#指定数据库驱动名称，不支持XA data。如果使用jdbcUrl配置则不需要配置该值。默认值：none。</span><br><span class="line">#参考https://github.com/brettwooldridge/HikariCP#popular-datasource-class-names</span><br><span class="line">spring.datasource.hikari.dataSourceClassName=</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF8&amp;useSSL=false</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.hikari.autoCommit=true</span><br><span class="line">#连接建立超时时间 单位ms 默认30000</span><br><span class="line">spring.datasource.hikari.connectionTimeout=30000</span><br><span class="line">#空闲连接超时时间 单位ms 最小10000(10s) 默认600000(10min)</span><br><span class="line">#当minimumIdle小于maximumPoolSize时有效</span><br><span class="line">#0 空闲连接永远不会被移除</span><br><span class="line">spring.datasource.hikari.idleTimeout=30000</span><br><span class="line">#最小空闲连接数，默认值maximumPoolSize。当空闲连接低于该值且总连接数低于maximumPoolSize时，HikariCP会立即添加连接来保证一个高效的性能</span><br><span class="line">#但是，HikariCP 不建议配置该值，建议使用默认值，让HikariCP维护一个固定连接数的连接池来保持高效。</span><br><span class="line">spring.datasource.hikari.minimumIdle=</span><br><span class="line">#最大连接数（包含空闲和正在使用的连接），默认值10.当连接数达到该值时，新的连接申请会被阻塞直到超时。</span><br><span class="line">spring.datasource.hikari.maximumPoolSize=10</span><br><span class="line">#一个连接在连接池中的最长存活时间，正在被使用的链接如果超时会等到关闭后被移除</span><br><span class="line">#最小30000ms (30 seconds). Default: 1800000 (30 minutes)</span><br><span class="line">#0 连接永不超时</span><br><span class="line">spring.datasource.hikari.maxLifetime=1800000 </span><br><span class="line">#连接测试查询语句，如果驱动支持JDBC4，强烈建议不配置该属性</span><br><span class="line">#尝试不配置该属性来运行连接池，如果驱动不支持JDBC4，HikariCP会打出一个错误日志通知你。默认值：none</span><br><span class="line">spring.datasource.hikari.connectionTestQuery=</span><br><span class="line">#指标记录，默认：none。这个属性只适用于程序配置或ioc容器，允许你指定一个Codahale/Dropwizard MetricRegistry来记录指标。</span><br><span class="line">#参考：https://github.com/brettwooldridge/HikariCP/wiki/Dropwizard-Metrics</span><br><span class="line">spring.datasource.hikari.metricRegistry=</span><br><span class="line">#健康检查，默认：none。允许你指定一个Codahale/Dropwizard HealthCheckRegistry来报告当前健康信息。</span><br><span class="line">#参考https://github.com/brettwooldridge/HikariCP/wiki/Dropwizard-HealthChecks</span><br><span class="line">spring.datasource.hikari.healthCheckRegistry=</span><br><span class="line">#连接池名称。Default: auto-generated</span><br><span class="line">spring.datasource.hikari.poolName=hikariPool</span><br><span class="line"> </span><br><span class="line">##########################HikariCP不常用的配置#####################</span><br><span class="line">spring.datasource.hikari.initializationFailTimeout=1</span><br><span class="line">#是否在其自己的事务中隔离内部池查询</span><br><span class="line">#由于这些查询通常是只读查询，所以很少需要将它们封装在自己的事务中。</span><br><span class="line">#此属性仅适用于禁用autoCommit的情况。默认值：false</span><br><span class="line">spring.datasource.hikari.isolateInternalQueries=false</span><br><span class="line">#连接池是否可以被JMX挂起和恢复。在挂起状态下，获取连接将不会超时，会被阻塞直到连接池恢复。，默认false。</span><br><span class="line">spring.datasource.hikari.allowPoolSuspension=false</span><br><span class="line">#指定从连接池获取到的连接在默认情况下是否是只读模式的。这个取决于数据库和应用，默认false。</span><br><span class="line">spring.datasource.hikari.readOnly=false</span><br><span class="line">#是否注册Mbeans，默认false。</span><br><span class="line">spring.datasource.hikari.registerMbeans=false</span><br><span class="line">#连接初始化sql。当一个连接被创建后，在放入连接池之前，执行这条语句来确认是否是有效连接。默认值none。</span><br><span class="line">spring.datasource.hikari.connectionInitSql=</span><br><span class="line">#支配驱动类名称，一般不需要配置，hikari会根绝jdbcUrl来解析使用响应的驱动，如果找不到会打印错误日志来通知你。</span><br><span class="line">spring.datasource.hikari.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">#指定从连接池获取到的连接的默认事务隔离级别。枚举值来自Connection class的常量。例如TRANSACTION_READ_COMMITTED, TRANSACTION_REPEATABLE_READ等。</span><br><span class="line">#默认情况下是数据库的默认隔离级别。</span><br><span class="line">#spring.datasource.hikari.transactionIsolation=</span><br><span class="line">#连接测试超时时间。最小值250ms，不能超过connectionTimeout。默认值5000</span><br><span class="line">spring.datasource.hikari.validationTimeout=5000</span><br><span class="line">#连接离开连接池后一定时间，会通过日志记录可能存在连接泄漏。该属性配置的是这个时间。</span><br><span class="line">#0 表示不启用连接泄漏检测。最小值是2000 单位ms。默认值0。</span><br><span class="line">spring.datasource.hikari.leakDetectionThreshold=0</span><br><span class="line">#指定数据源。你可以自己封装数据源，不用通过hikari来反射生成。</span><br><span class="line">#配置了该属性后，dataSourceClassName和所有DataSource-specific的属性都会被忽略。</span><br><span class="line">#spring.datasource.hikari.dataSource=</span><br><span class="line">#指定hikari连接池创建线程的线程工厂。默认值none。ThreadFactory 实例</span><br><span class="line">spring.datasource.hikari.threadFactory=</span><br><span class="line">#提供ScheduledExecutorService 实例。HikariCP在setRemoveOnCancelPolicy(true)时会使用。默认值none。</span><br><span class="line">spring.datasource.hikari.scheduledExecutor=</span><br><span class="line">#为支持catalog的数据库设置默认的catalog，默认依赖于jdbc驱动。</span><br><span class="line">spring.datasource.hikari.catalog=</span><br><span class="line">#为支持schema的数据库设置默认的schema，默认依赖于jdbc驱动。</span><br><span class="line">spring.datasource.hikari.schema=</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">allowPoolSuspension:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">autoCommit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">catalog:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">connectionInitSql:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">connectionTestQuery:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">connectionTimeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">dataSourceClassName:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">      <span class="attr">healthCheckRegistry:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">idleTimeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">initializationFailTimeout:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">isolateInternalQueries:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">leakDetectionThreshold:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">maxLifetime:</span> <span class="number">1800000.0</span></span><br><span class="line">      <span class="attr">maximumPoolSize:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">metricRegistry:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">minimumIdle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">poolName:</span> <span class="string">hikariPool</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">registerMbeans:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">scheduledExecutor:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">schema:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">threadFactory:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">validationTimeout:</span> <span class="number">5000</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>用mybatis插件抓取最终sql</title>
    <url>/2024/03/20/Spring/%E7%94%A8mybatis%E6%8F%92%E4%BB%B6%E6%8A%93%E5%8F%96%E6%9C%80%E7%BB%88sql/</url>
    <content><![CDATA[<h2 id="痛点概述"><a href="#痛点概述" class="headerlink" title="痛点概述"></a>痛点概述</h2><p>当我们在排查bug ，需要看执行的完整sql 时，在 console可以拿到如图的sql <img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291722242.png" alt="img"></p>
<p>然后手工一个一个的替换问号占位符后，去MySQL 执行，看sql有木有什么问题。如果sql简单，那比较好说， 如果是个复杂sql，手动替换N个问号占位符，这种痛相信大家都经历过。 今天介绍的 MybatisFinalSqlPlugin 插件 正是解决了这样的痛点，可以直接抓到最终sql。</p>
<span id="more"></span>

<h2 id="MybatisFinalSqlPlugin插件"><a href="#MybatisFinalSqlPlugin插件" class="headerlink" title="MybatisFinalSqlPlugin插件"></a>MybatisFinalSqlPlugin插件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.anuo.app.common.datalayer.mybatisplugin;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Stopwatch;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.statement.StatementHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.SystemMetaObject;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Intercepts(&#123; @Signature(type = StatementHandler.class, method = &quot;prepare&quot;, args = &#123; Connection.class,Integer.class &#125;) &#125;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">MybatisFinalSqlPlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">stopwatch</span> <span class="operator">=</span> Stopwatch.createStarted();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (invocation.getTarget() <span class="keyword">instanceof</span> StatementHandler) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//获取Statement 对象</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> (Connection) invocation.getArgs()[<span class="number">0</span>];</span><br><span class="line">            <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (StatementHandler) invocation.getTarget();</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> handler.prepare(conn, <span class="number">30</span>);</span><br><span class="line">            handler.parameterize(stmt);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//获取真实对象</span></span><br><span class="line">            <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> SystemMetaObject.forObject(stmt);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">while</span> (metaObject.hasGetter(<span class="string">&quot;h&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> metaObject.getValue(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">                <span class="comment">// 将对象包装成MetaObject对象后就成了真实对象，然后就可以通过反射技术可以操作真实对象的所有属性</span></span><br><span class="line">                metaObject = SystemMetaObject.forObject(obj);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//通过反射获取 Statement 对象上的FinalSql</span></span><br><span class="line">            <span class="comment">//todo:后续用 metaObject.getValue() 重构下面的反射代码，提升性能</span></span><br><span class="line"> </span><br><span class="line">            <span class="type">Field</span> <span class="variable">hField</span> <span class="operator">=</span> metaObject.getClass().getDeclaredField(<span class="string">&quot;originalObject&quot;</span>);</span><br><span class="line">            hField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">hObj</span> <span class="operator">=</span> hField.get(metaObject);</span><br><span class="line"> </span><br><span class="line">            <span class="type">Field</span> <span class="variable">statementField</span> <span class="operator">=</span> hObj.getClass().getDeclaredField(<span class="string">&quot;statement&quot;</span>);</span><br><span class="line">            statementField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">statementObj</span> <span class="operator">=</span> statementField.get(hObj);</span><br><span class="line"> </span><br><span class="line">            <span class="type">Field</span> <span class="variable">stmtField</span> <span class="operator">=</span> statementObj.getClass().getDeclaredField(<span class="string">&quot;stmt&quot;</span>);</span><br><span class="line">            stmtField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">stmtObj</span> <span class="operator">=</span> stmtField.get(statementObj);</span><br><span class="line"> </span><br><span class="line">            <span class="type">Field</span> <span class="variable">statementArrivedField</span> <span class="operator">=</span> stmtObj.getClass().getDeclaredField(<span class="string">&quot;statement&quot;</span>);</span><br><span class="line">            statementArrivedField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">statementArrivedFieldObj</span> <span class="operator">=</span> statementArrivedField.get(stmtObj);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="type">String</span> <span class="variable">finalSql</span> <span class="operator">=</span> statementArrivedFieldObj.toString();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//去掉不要的字符串</span></span><br><span class="line">            finalSql = finalSql.substring(finalSql.lastIndexOf(<span class="string">&quot;:&quot;</span>) + <span class="number">1</span>, finalSql.length() - <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">            log.info(<span class="string">&quot;最终sql： \n &quot;</span> + finalSql);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//做了下性能测试 平均耗时为 1，2毫秒，非常低，不错！</span></span><br><span class="line">        log.debug(<span class="string">&quot;抓取最终sql 耗时：&quot;</span> + stopwatch);</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> StatementHandler) &#123;</span><br><span class="line">            <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>记一次HandlerMethodArgumentResolver失效的问题</title>
    <url>/2024/07/06/Spring/%E8%AE%B0%E4%B8%80%E6%AC%A1HandlerMethodArgumentResolver%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>起因:</strong><br>对代码进行重构,把解析token的方法从Controller迁移到自定义的参数解析器中,实现代码复用。</p>
<p><strong>问题:</strong><br>按照正常流程搭建自定义参数解析器,发现最终请求未进入该自定义参数解析器。</p>
<p>Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@NeedDistinct</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">livenessDetect</span><span class="params">(<span class="meta">@RequestHeader</span> Map&lt;String, String&gt; headers, <span class="meta">@RequestBody</span> LivenessParam livenessParam)</span> &#123;</span><br><span class="line">	<span class="comment">//重构前的token解析方法</span></span><br><span class="line">    <span class="comment">//Long uid = userService.getUidByToken(getToken(headers));</span></span><br><span class="line">    <span class="keyword">if</span> (uid == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNotExistException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>UserInfoArgumentResolver自定义参数解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoArgumentResolver</span> <span class="keyword">extends</span> <span class="title class_">BaseArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">    	<span class="comment">//若方法存在@NeedDistinct,则返回true执行下面的resolveArgument方法</span></span><br><span class="line">        <span class="keyword">return</span> parameter.hasMethodAnnotation(NeedDistinct.class);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    	<span class="comment">//对token进行解析</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>配置类实现WebMvcConfigurer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfoArgumentResolver userInfoArgumentResolver;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//把自定义解析器添加到解析器集合当中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> &#123;</span><br><span class="line">        resolvers.add(userInfoArgumentResolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>原因：因为在获得参数解析器的过程中，Controller的入参存在@RequestHeader注解的Map参数，mvc优先解析到其他的参数解析器，从而跳过了自定义参数解析器的判断与执行。</p>
<p>解决思路：<br>通过idea的栈信息，往上层找到调用参数解析器中 supportsParameter 与 resolveArgument的方法，然后定位到HandlerMethodArgumentResolverComposite中的getArgumentResolver方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title function_">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">    <span class="type">HandlerMethodArgumentResolver</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HandlerMethodArgumentResolver resolver : <span class="built_in">this</span>.argumentResolvers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">                result = resolver;</span><br><span class="line">                <span class="built_in">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时对该方法进行debug，发现在遍历argumentResolvers的过程中，优先加载到一个RequestHeaderMethodArgumentResolver的类执行成功，并且放到缓存中。下一次每次发送该Controller的请求，会直接从缓存中获得。</p>
<p>从上面的方法可以看出,mvc在获得参数解析器时, 会先从缓存中获得参数解析器,若不存在,则遍历argumentResolvers,若有一个解析器的supportsParameter结果为true,则对该解析器进行缓存,并退出遍历。<br>意味着只要有一个其他的参数解析器比我们自定义的UserInfoArgumentResolver优先加载成功,则不会执行我们自定义的解析器的逻辑。</p>
<p>此时再查看argumentResolvers中的解析器。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/20240711121835.png" alt="img"></p>
<p>发现在argumentResolvers集合中，RequestHeaderMethodArgumentResolver类的index比我们自定义解析器的index小，从而优先加载到RequestHeaderMethodArgumentResolver，跳过了我们的自定义解析器。</p>
<p>然后查看查看RequestHeaderMethodArgumentResolver中的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (parameter.hasParameterAnnotation(RequestHeader.class) &amp;&amp;</span><br><span class="line">            !Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> NamedValueInfo <span class="title function_">createNamedValueInfo</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">    <span class="type">RequestHeader</span> <span class="variable">ann</span> <span class="operator">=</span> parameter.getParameterAnnotation(RequestHeader.class);</span><br><span class="line">    Assert.state(ann != <span class="literal">null</span>, <span class="string">&quot;No RequestHeader annotation&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestHeaderNamedValueInfo</span>(ann);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现当传入参数包含注解@RequestHeader，并且参数为Map时，该参数解析器则返回为true。</p>
<p>所以，看到这里就可以得知，我们只需要把原来Controller中的headers去掉，RequestHeaderMethodArgumentResolver则会返回false，argumentResolvers会继续遍历，直到遍历到我们自定义的UserInfoArgumentResolver为止。或者我们可以在Controller中添加一个自定义参数，即解决走不到自定义解析器的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@NeedDistinct</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Void&gt; <span class="title function_">livenessDetect</span><span class="params">(<span class="meta">@RequestBody</span> LivenessParam livenessParam, <span class="meta">@RequestBody</span> LivenessParam livenessParam, String needDistinct)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (uid == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNotExistException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<p>转载自：<br><a href="https://dongguabai.blog.csdn.net/article/details/135724410?spm=1001.2014.3001.5502">https://dongguabai.blog.csdn.net/article/details/135724410?spm=1001.2014.3001.5502</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>注解@Configuration和@Component区别</title>
    <url>/2024/04/01/Spring/spring%20boot/@Configuration%E5%92%8C@Component%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ol>
<li>@Configuration 注解是 Spring 组件注解的一种，通过普通的 Bean 扫描也可以扫描到 @Configuration。</li>
<li>@Configuration 注解注册到 Spring 中的 Bean 是一个 CGLIB 代理的 Bean，而不是原始 Bean，这一点和 @Component 不一样，@Component 注册到 Spring 容器中的还是原始 Bean。</li>
</ol>
<span id="more"></span>

<p>@Configuration中所有带@Bean注解的方法都会被动态代理，调用该方法返回的都是同一个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从定义来看，@Configuration注解本质上还是@Component，因此<code>&lt;context:component-scan/&gt;</code>或者@ComponentScan都能处理@Configuration注解的类。</p>
<p>@Configuration 标记的类必须符合下面的要求：</p>
<ul>
<li>配置类必须以类的形式提供（不能是工厂方法返回的实例），允许通过生成子类在运行时增强（cglib 动态代理）。</li>
<li>配置类不能是 final 类（没法动态代理）。</li>
<li>配置注解通常为了通过 @Bean 注解生成 Spring 容器管理的类。</li>
<li>配置类必须是非本地的（即不能在方法中声明，不能是 private）。</li>
<li>任何嵌套配置类都必须声明为static。</li>
<li>@Bean方法不能创建进一步的配置类（也就是返回的bean如果带有@Configuration，也不会被特殊处理，只会作为普通的 bean）。</li>
</ul>
<p>Spring 容器在启动时，会加载默认的一些PostProcessor，其中就有 ConfigurationClassPostProcessor，这个后置处理程序专门处理带有@Configuration注解的类，会在bean定义加载完成后，在bean初始化前进行处理。主要处理的过程就是使用 cglib 动态代理增强类，而且是对其中带有@Bean注解的方法进行处理。</p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setDog(dog());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Dog <span class="title function_">dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例，获取从容器JavaConfig这个bean返回的是一个被代理的 JavaConfig 对象。</p>
<p>在 user() 方法中调用 dog() 方法的时候，调用的是一个代理对象的 dog 方法，在这个代理对象的 dog 方法中，会首先去检查 Spring 容器中是否存在 Dog 对象，如果存在，则直接使用 Spring 容器中的 dog 对象，就不会真正去执行 dog 方法而获取到一个新的 dog 对象了，如果 Spring 容器中不存在 dog 对象，才会创建新的 dog 对象出来。</p>
<p>当然也可以用@Component替换@Configuration：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">final</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setDog(dog());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Dog <span class="title function_">dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但上面的示例，获取从容器JavaConfig这个bean返回的是一个原始的 JavaConfig 对象。</p>
<p>由于没有被代理，因此在 user 方法中调用 dog 方法的时候，就直接调用了，因此 user 中的 dog 和最终 dog 方法注册到 Spring 容器中的 dog 不是同一个。如果想要确保 user 中的 dog 和 Spring 容器中的 dog 是同一个，那么可以通过参数将所需要的对象注入进来，类似下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">final</span> User <span class="title function_">user</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setDog(dog);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Dog <span class="title function_">dog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>转载：谈谈我对技术架构的理解</title>
    <url>/2024/04/06/%E7%9B%AE%E5%BD%95%E5%BE%85%E5%AE%9A/%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>关于架构师的角色，聊一聊自己的想法。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272326803.jpeg"></p>
<span id="more"></span>

<p><strong>第一点是型散而神不散</strong></p>
<p>架构其实是每个业务线都有，有些技术同学本身也是架构师的角色。阿里很早以前是专门有架构师岗位，专门的去做架构，但是做着做着架构师就做没了。因为很不接地气，它没有解决具体、真实、实际的问题。但现在，阿里的架构师岗位逐渐增加了，他们的价值在于抽象这些技术问题，解决这些问题。所以第一点是形散神不散。优秀的技术同学一直在<strong>用架构的意识，解决实际的技术和业务问题</strong>，这就跟普通的技术同学有本质的区别。他不光是解决这一个问题，他可能解决这一类问题，用架构的思想去解决问题。</p>
<p><strong>第二点是前瞻性</strong></p>
<p>为什么你能解决这个问题，并且能解决这一类问题？一定是需要你看的多，想的多，这背后是大量的实践和知识的积累，并且是站在过去的肩膀上。</p>
<p>阿里电商系统很早就建立了，我们这一代一代人在里面去做架构，都是站在前一代人的肩膀上。要去看前一代人为什么要这么设计，去想或跟他去聊，吸取他好的地方。现在可能遇到新的问题，通过其他的方法来解决一些新的问题，需要有实践和知识的积累。</p>
<p>接触更多的人和事，用新方法解决新问题，这个很关键。不能只看代码看一个月，要找真实的业务方，你的上游、下游、合作伙伴。比如说做双 11，我是 2016年12月到业务平台，我花了整整三个月，跟每年双 11 的大队长、重要人去聊双 11。他们是怎么理解，怎么来思考的，他们认为什么地方有问题。我再找他们要一些建议：我应该怎么去做。跟他们聊的过程中才知道我们需要做什么样的大促，要把握什么是关键点，这都是一些宝贵的财富。</p>
<p><strong>第三点是解决复杂问题</strong></p>
<p>好的架构师都在解决复杂的问题。只有复杂的问题，它才需要更多不一样的技术或更新的技术来彻底解决。高并发高可用是阿里电商面临的基本问题，但是架构师要有不一样的高并发和高稳定性的解决思路。</p>
<p>当前最紧急的问题，比如说用户体验、提升效率、低成本等，这些问题其实是非常复杂的。很多同学都想解决这个问题，很多种方法都在解决，但是整体来说效果不是特别明显。因为它链路太长了，链路长代表影响的业务和影响的人更多，你必须得换一种<strong>新的思路</strong>来考虑这个问题。同时用户分层，内部的技术人员增多，这就倒逼我们去把复杂的问题简化，所以我会把解决复杂问题定义为架构师的一个典型角色。</p>
<hr>
<p>架构师需要什么样的能力？参考了外面一些同学的分享，总结出来其实就是<strong>发现问题、分析定义问题、解决问题。</strong></p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272330154.jpeg"></p>
<p><strong>发现问题</strong></p>
<p>对局部和全局的问题需要有发现的眼光，更应该有发现未发生问题的能力，哪些需要治标，哪些需要治本，这是发现问题的基本判断力。现在系统可能没什么大问题，但你要有发现的眼光，这些问题如果不解决，未来业务可能遇到更严重的问题。<strong>架构师看问题的眼光和别人不一样，不要只看见眼前这一个问题，还要看见这个问题背后是什么，这一类问题背后是什么，我怎么能用抽象的方法解决一类问题</strong>。想好了以后，我就把当前的这个问题先解决掉，其他的问题用抽象的方式去解决它。</p>
<p><strong>定义和分析问题</strong></p>
<p>阿里不缺解决问题的同学，但是缺定义问题的同学。你怎么知道这是个问题，并且把这个问题定义清楚。需要将发现的问题进行抽象和归纳，定义出问题的基本要素，同时定义出问题的短期和长期方案，推进技术整体的进步。</p>
<p>定义问题这个要求非常高。大家平时在解决业务技术问题的时候，也需要具备分析和定义问题的能力，把一个问题定义清楚了，可以真正推动业务往前进。</p>
<p><strong>解决问题</strong></p>
<p>解决问题需要<strong>实施路径和解决方案，协同团队和上下游，推进问题的解决</strong>。架构要解决的问题一定不是一个局部问题，一定是一个全局问题。架构师一定会碰到各种各样的角色和链路，他要有这个能力去定义问题的解决方案和实施路径，同时要协同团队。他不能闷头做事，真的要抬头，并且要有良好的沟通能力，跟所有的同学达成共识才能往前进。</p>
<p><strong>第一点就是沟通能力非常关键</strong>。你怎么把这个问题说清楚，切中问题的点，同时也能帮助上下游带来实际的效果。第二点是架构师需要能救火，但不仅仅是救眼前的火，应该救未来的火，架构师救火能力要很强。</p>
<p>我来阿里之前在做一个 CRM 系统。后来我要解决很多业务的问题，要把它抽象出来，去做业务问题下面的基础平台。再后来发现基础平台的问题如果要解决得更彻底，还要做下面的中间件，这样层层深入就会把整个链路打通看懂。</p>
<p>从 2017 年到业务平台以后，我学到了很多，包括它的系统链路是什么样的，数据链路是怎么样的，整个调用链路是怎么样的，它和底层的关系是什么样的，可能遇到什么样的问题？现在可能出现这个问题，再往后运行是不是会出现其他的问题。通过救火的过程，一次次积累对系统的了解。所以，每一次过去的积累对于解决现在的问题还都有很大的帮助，每一次问题的解决又能让自己对全局有更深的理解。</p>
<hr>
<p><img src="https://p1-tt.byteimg.com/origin/pgc-image/SOliWqPDuuTv2S?from=pc" alt="新的一年，谈谈我对技术架构的理解"></p>
<p><strong>第一点是全局式的视角</strong></p>
<p>比如看到“会员”这个业务功能，你不能仅仅看到这个功能本身，你要看到会员上面的业务是什么，谁在用会员，这叫全局。同时，会员用得最多的是导购和交易，登录仅仅是会员本身一个很小的业务功能而已。基于会员，我们有导购、有交易，把这些东西要串起来看明白，就能完整的认识到会员到底提供了什么，一定要有一个全局视角。</p>
<p><strong>第二点是技术广度</strong></p>
<p>阿里的技术特别复杂，能入职到阿里来，把阿里的整个技术栈完整摸一遍的同学真的是很了不起。以单元化架构为例，我们可能需要了解端，有 iOS、安卓、PC，还要了解 CDN、网络、接入层、服务发现、服务路由、HSF 等。数据库包括储存同步、多点写，还有消息中间件等。这些技术和产品其实平时同学们都在用，但<strong>架构师不仅在用，架构师真的是要去把玩，彻底了解透彻这些东西，这是关键点</strong>。</p>
<p>给大家举个例子，像数据库组成的强同步，对我们后续技术架构演进和业务的改进都有极大的影响，这个时候大家要对数据库有一个全局的认识。</p>
<p>2009 年 Oracle 数据库用得非常多。我当时不是做数据库相关的，但是为了把 Oracle 数据库研究透，去学了非常多 Oracle 数据库相关的内容。了解里面的逻辑，知道它的开发态、运行态、管理态等。知识都是有延续的，后来到了阿里，可能花很短的几个小时就能把现在阿里的数据库吃透。</p>
<p>技术的广度非常<strong>依赖于积累</strong>。你一定要带着问题去想，这个时候你才有记忆力，有了积累，慢慢的你技术的广度就会越来越深。你要了解数据库，你必须对下层的网络了解，所以我们要对网络、CDN 有更进一步的认识。</p>
<p>2009 年，我大概花了两年的时间学习网络，对交换机、路由器、骨干网、城域网，运营商怎么建网，自建的 IDC 怎么建网有了比较全面的了解，包括每天跟网络怎么交互，为什么重传高？为什么延时高，TCP&#x2F;IP 第 4 层的下面 IP 第 3 层是怎么操作的，IP 下面的 MAC 层是怎么操作的，大家都要深入了解一下。</p>
<p>这些积累最能体现出价值的就是在救火的时候。我去救火时根本不会用现在那些平台化的工具，直接上手用 TCP 代码抓原始发文，马上能分析出很多问题。这就是平时的积累，慢慢的你就会对全局有认知。</p>
<p>2019 年整个核心系统上云的时候，同样跟技术的广度有关系，我们上云发生了什么变化？整个底座到云上去了，计算、存储、网络全到云上去了，那要了解云啊。在2018 年的时候，我基本把阿里云的云产品都了解了一遍，这时就会对阿里云的网络、技术有本质的了解。</p>
<p>架构师一定要有技术的广度。大家一定要学会积累，积累到一定程度以后，你会做到无师自通。比如你了解网络、数据库，然后你又了解了磁盘30%，当这些知识逐渐成体系了，你是有能力去消化和打通不同技术点背后的相关性，对于你的个人能力的提升和认知层面的提升有巨大的帮助。</p>
<p><strong>第三点是持续的学习</strong></p>
<p>每时每刻都在发生技术的升级和变革，只有持续不断的学习，才能对老的架构有新的认识，对于老的问题产生新的解法。要了解业界最近在发生什么变化，这个领域最关键的项目和人在做什么，学习他们的技术，学习他们的论文。我以前每天大概 2 到 3 个小时是用来学习，这几个小时的学习时间是我最放松的时间，不用去想太多事。</p>
<p>学习也不是说去瞎学，一定要有体系化的。首先跟你工作相关的，要体系化的去学习，从最下到最上体系化去学习，学习完了以后你会有新的不一样的认识。把你的想法可以向你的团队说出来，向你的主管说出来。</p>
<p>还有就是要去看论文。跟数据相关的，OLTP 和 OLAP 都有非常好的论文。看了论文以后再看其他人对论文的理解。一定要去看一些比较好的东西，跟工作相关的都可以去看，每天去学习。每天花 2 到 3 个小时去学习，三年以后你就知道自己跟别人完全不一样。有人说过：在一个行业你能付出 1 万个小时，你会跟别人形成本质的区别。但是在我们这个领域，1000 个小时就形成差别。</p>
<p><strong>第四点是业务理解</strong></p>
<p>这个一定要到实践中去，不是业务离不开架构，而是架构离不开业务，<strong>业务、架构、技术要三位一体才能达到最佳的效果。</strong>我们平时学习、实践的过程就在磨刀，但你不能说你天天在磨刀，总得要用这个刀。这就是跟业务结合起来，用不一样的思路解决实际的业务问题，会带来更低的成本、更高的效率。</p>
<p><strong>结果</strong></p>
<p>要将技术的先进性转化为业务的先进性，忘掉屁股。这个“忘掉屁股”就是你做很多事情不是你一个人能搞定的，复杂、越大的事情是要协同更多的人。如果你就是为了你自己，比如说 KPI 去做事，我告诉你，这个事情做一次两次可以，但后面就没人跟你配合。你一定要忘掉屁股，才能慢慢的把这个事情做成，真正做到你想要的结果。</p>
<p>遇山开道、遇水架桥，这讲的是决心。很多时候问题确实很难解决，也需要协调更多的人。很多人可能会放弃。我们最近在做架构的升级，用国产化芯片，从底到上全链路的。如果有一方配合不到位，这事情就很难推进了。从 4 月份一直到 7 月底被阻碍了两次，第三次如果再没办法开展下去，这个事情就彻底的结束了。我们当时把整个团队召集到一起，互相打气：一定要干成。遇山开道、遇水架桥，有什么问题抛出来，大家一起来解决，要有决心，更要果断。</p>
]]></content>
      <categories>
        <category>目录待定</category>
      </categories>
  </entry>
  <entry>
    <title>注解@ControllerAdvice</title>
    <url>/2024/04/01/Spring/spring%20boot/@ControllerAdvice%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>@ControllerAdvice ，很多初学者可能都没有听说过这个注解，实际上，这是一个非常有用的注解，顾名思义，这是一个增强的 Controller。使用这个 Controller ，可以实现三个方面的功能：</p>
<ul>
<li>全局异常处理</li>
<li>全局数据绑定</li>
<li>全局数据预处理</li>
</ul>
<p>全局异常处理<br>使用 @ControllerAdvice 实现全局异常处理，只需要定义类，添加该注解即可定义方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class MyGlobalExceptionHandler &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public ModelAndView customException(Exception e) &#123;</span><br><span class="line">        ModelAndView mv = new ModelAndView();</span><br><span class="line">        mv.addObject(&quot;message&quot;, e.getMessage());</span><br><span class="line">        mv.setViewName(&quot;myerror&quot;);</span><br><span class="line">        return mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该类中，可以定义多个方法，不同的方法处理不同的异常，例如专门处理空指针的方法、专门处理数组越界的方法…，也可以直接向上面代码一样，在一个方法中处理所有的异常信息。</p>
<p>@ExceptionHandler 注解用来指明异常的处理类型，即如果这里指定为 NullpointerException，则数组越界异常就不会进到这个方法中来。</p>
<span id="more"></span>

<p>全局数据绑定<br>全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了 @ControllerAdvice 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。</p>
<p>使用步骤，首先定义全局数据，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">public class MyGlobalExceptionHandler &#123;</span><br><span class="line">    @ModelAttribute(name = &quot;md&quot;)</span><br><span class="line">    public Map&lt;String,Object&gt; mydata() &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;age&quot;, 99);</span><br><span class="line">        map.put(&quot;gender&quot;, &quot;男&quot;);</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 @ModelAttribute 注解标记该方法的返回数据是一个全局数据，默认情况下，这个全局数据的 key 就是返回的变量名，value 就是方法返回值，当然开发者可以通过 @ModelAttribute 注解的 name 属性去重新指定 key。</p>
<p>定义完成后，在任何一个Controller 的接口中，都可以获取到这里定义的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello(Model model) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = model.asMap();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        int i = 1 / 0;</span><br><span class="line">        return &quot;hello controller advice&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局数据预处理<br>考虑我有两个实体类，Book 和 Author，分别定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Long price;</span><br><span class="line">    //getter/setter</span><br><span class="line">&#125;</span><br><span class="line">public class Author &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    //getter/setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，如果我定义一个数据添加接口，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/book&quot;)</span><br><span class="line">public void addBook(Book book, Author author) &#123;</span><br><span class="line">    System.out.println(book);</span><br><span class="line">    System.out.println(author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，添加操作就会有问题，因为两个实体类都有一个 name 属性，从前端传递时 ，无法区分。此时，通过 @ControllerAdvice 的全局数据预处理可以解决这个问题</p>
<p>解决步骤如下:</p>
<p>1.给接口中的变量取别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/book&quot;)</span><br><span class="line">public void addBook(@ModelAttribute(&quot;b&quot;) Book book, @ModelAttribute(&quot;a&quot;) Author author) &#123;</span><br><span class="line">    System.out.println(book);</span><br><span class="line">    System.out.println(author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.进行请求数据预处理<br>在 @ControllerAdvice 标记的类中添加如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@InitBinder(&quot;b&quot;)</span><br><span class="line">public void b(WebDataBinder binder) &#123;</span><br><span class="line">    binder.setFieldDefaultPrefix(&quot;b.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@InitBinder(&quot;a&quot;)</span><br><span class="line">public void a(WebDataBinder binder) &#123;</span><br><span class="line">    binder.setFieldDefaultPrefix(&quot;a.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@InitBinder(“b”) 注解表示该方法用来处理和Book和相关的参数,在方法中,给参数添加一个 b 前缀,即请求参数要有b前缀.</p>
<p>3.发送请求</p>
<p>请求发送时,通过给不同对象的参数添加不同的前缀,可以实现参数的区分.<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291751567.png"></p>
<p><a href="http://www.javaboy.org/2019/0422/springmvc-controlleradvice.html">http://www.javaboy.org/2019/0422/springmvc-controlleradvice.html</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>注解@Async的使用以及原理、源码分析</title>
    <url>/2024/04/01/Spring/spring%20boot/@Async%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Spring中用@Async注解标记的方法，称为异步方法，它会在调用方的当前线程之外的独立的线程中执行，其实就相当于我们自己new Thread(()-&gt; System.out.println(“hello world !”))这样在另一个线程中去执行相应的业务逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @Async 若把注解放在类上或者接口上，那么他所有的方法都会异步执行了~~~~（包括私有方法）</span><br><span class="line">public interface HelloService &#123;</span><br><span class="line">    Object hello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class HelloServiceImpl implements HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Async // 注意此处加上了此注解</span><br><span class="line">    @Override</span><br><span class="line">    public Object hello() &#123;</span><br><span class="line">        System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName());</span><br><span class="line">        return &quot;service hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后只需要在配置里，开启对异步的支持即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAsync // 开启异步注解的支持</span><br><span class="line">public class RootConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的是线程池SimpleAsyncTaskExecutor，这也是Spring默认给我们提供的线程池。</p>
<span id="more"></span>


<h3 id="Async注解使用细节"><a href="#Async注解使用细节" class="headerlink" title="@Async注解使用细节"></a>@Async注解使用细节</h3><ol>
<li>@Async注解一般用在方法上，如果用在类上，那么这个类所有的方法都是异步执行的；</li>
<li>@Async可以放在任何方法上，即使是private的；</li>
<li>所使用的@Async注解方法的类对象应该是Spring容器管理的bean对象；</li>
<li>@Async可以放在接口处（或者接口方法上）。但是只有使用的是JDK的动态代理时才有效，CGLIB会失效。因此建议：统一写在实现类的方法上；</li>
<li>需要注解@EnableAsync来开启异步注解的支持；</li>
<li>若你希望得到异步调用的返回值，请你的返回值用Futrue变量包装起来</li>
</ol>
<h3 id="EnableAsync"><a href="#EnableAsync" class="headerlink" title="@EnableAsync"></a>@EnableAsync</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AsyncConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAsync &#123;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//默认情况下，要开启异步操作，要在相应的方法或者类上加上@Async注解或者EJB3.1规范下的@Asynchronous注解。</span></span><br><span class="line">	 <span class="comment">//这个属性使得开发人员可以自己设置开启异步操作的注解(可谓非常的人性化了，但是大多情况下用Spring的就足够了)</span></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotation() <span class="keyword">default</span> Annotation.class;</span><br><span class="line">	<span class="comment">// true表示启用CGLIB代理</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 代理方式：默认是PROXY  采用Spring的动态代理（含JDK动态代理和CGLIB）</span></span><br><span class="line">	<span class="comment">// 若改为：AdviceMode.ASPECTJ表示使用AspectJ静态代理方式。</span></span><br><span class="line">	<span class="comment">// 它能够解决同类内方法调用不走代理对象的问题，但是一般情况下都不建议这么去做，不要修改这个参数值</span></span><br><span class="line">	AdviceMode <span class="title function_">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY;</span><br><span class="line">	<span class="comment">// 直接定义：它的执行顺序（因为可能有多个@EnableXXX）</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Async &#123;</span><br><span class="line">	<span class="comment">// May be used to determine the target executor to be used when executing this method</span></span><br><span class="line">	<span class="comment">// 意思是这个value值是用来指定执行器的（写入执行器BeanName即可采用特定的执行器去执行此方法）</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>最重要的，还是上面的@Import注解导入的类：AsyncConfigurationSelector</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AsyncConfigurationSelector extends AdviceModeImportSelector&lt;EnableAsync&gt; &#123;</span><br><span class="line"></span><br><span class="line">	// 这类 我也不知道在哪？是用于支持AspectJ这种静态代理Mode的,忽略吧~~~~</span><br><span class="line">	private static final String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME =</span><br><span class="line">			&quot;org.springframework.scheduling.aspectj.AspectJAsyncConfiguration&quot;;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		// 这里AdviceMode 进行不同的处理，从而向Spring容器注入了不同的Bean~~~</span><br><span class="line">		switch (adviceMode) &#123;</span><br><span class="line">			// 大多数情况下都走这里，ProxyAsyncConfiguration会被注入到Bean容器里面~~~</span><br><span class="line">			case PROXY:</span><br><span class="line">				return new String[] &#123; ProxyAsyncConfiguration.class.getName() &#125;;</span><br><span class="line">			case ASPECTJ:</span><br><span class="line">				return new String[] &#123; ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME &#125;;</span><br><span class="line">			default:</span><br><span class="line">				return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用：抽象实现支持了AdviceMode，并且支持通用的@EnableXXX模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@since 3.1  它是一个`ImportSelector`</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AdviceModeImportSelector</span>&lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认都叫mode</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME</span> <span class="operator">=</span> <span class="string">&quot;mode&quot;</span>;</span><br><span class="line">	<span class="comment">// 显然也允许子类覆盖此方法</span></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">getAdviceModeAttributeName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// importingClassMetadata：注解的信息</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">		<span class="comment">// 这里泛型，拿到泛型类型~~~</span></span><br><span class="line">		Class&lt;?&gt; annType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class);</span><br><span class="line">		Assert.state(annType != <span class="literal">null</span>, <span class="string">&quot;Unresolvable type argument for AdviceModeImportSelector&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 根据类型，拿到该类型的这个注解，然后转换为AnnotationAttributes</span></span><br><span class="line">		<span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> AnnotationConfigUtils.attributesFor(importingClassMetadata, annType);</span><br><span class="line">		<span class="keyword">if</span> (attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format( <span class="string">&quot;@%s is not present annType.getSimpleName(), importingClassMetadata.getClassName()));</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">		// 拿到AdviceMode，最终交给子类，让它自己去实现，决定导入哪个Bean</span></span><br><span class="line"><span class="string">		AdviceMode adviceMode = attributes.getEnum(this.getAdviceModeAttributeName());</span></span><br><span class="line"><span class="string">		String[] imports = selectImports(adviceMode);</span></span><br><span class="line"><span class="string">		if (imports == null) &#123;</span></span><br><span class="line"><span class="string">			throw new IllegalArgumentException(String.format(&quot;</span>Unknown AdviceMode: <span class="string">&#x27;%s&#x27;</span><span class="string">&quot;, adviceMode));</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		return imports;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	// 子类去实现  具体导入哪个Bean</span></span><br><span class="line"><span class="string">	@Nullable</span></span><br><span class="line"><span class="string">	protected abstract String[] selectImports(AdviceMode adviceMode);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<p>@EnableAsync最终是向容器内注入了ProxyAsyncConfiguration这个Bean。由名字可议看出，它是一个配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它是一个配置类，角色为ROLE_INFRASTRUCTURE  框架自用的Bean类型</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyAsyncConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractAsyncConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 它的作用就是诸如了一个AsyncAnnotationBeanPostProcessor，它是个BeanPostProcessor</span></span><br><span class="line">	<span class="meta">@Bean(name = TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME)</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	<span class="keyword">public</span> AsyncAnnotationBeanPostProcessor <span class="title function_">asyncAdvisor</span><span class="params">()</span> &#123;</span><br><span class="line">		Assert.notNull(<span class="built_in">this</span>.enableAsync, <span class="string">&quot;@EnableAsync annotation metadata was not injected&quot;</span>);</span><br><span class="line">		<span class="type">AsyncAnnotationBeanPostProcessor</span> <span class="variable">bpp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncAnnotationBeanPostProcessor</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// customAsyncAnnotation：自定义的注解类型</span></span><br><span class="line">		<span class="comment">// AnnotationUtils.getDefaultValue(EnableAsync.class, &quot;annotation&quot;) 为拿到该注解该字段的默认值</span></span><br><span class="line">		Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; customAsyncAnnotation = <span class="built_in">this</span>.enableAsync.getClass(<span class="string">&quot;annotation&quot;</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 相当于如果你指定了AsyncAnnotationType,那就set进去吧</span></span><br><span class="line">		<span class="keyword">if</span> (customAsyncAnnotation != AnnotationUtils.getDefaultValue(EnableAsync.class, <span class="string">&quot;annotation&quot;</span>)) &#123;</span><br><span class="line">			bpp.setAsyncAnnotationType(customAsyncAnnotation);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 只有自定义了AsyncConfigurer的实现类，自定义了一个线程执行器，这里才会有值</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.executor != <span class="literal">null</span>) &#123;</span><br><span class="line">			bpp.setExecutor(<span class="built_in">this</span>.executor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 同上，异步线程异常的处理器~~~~~</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.exceptionHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">			bpp.setExceptionHandler(<span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 这两个参数，就不多说了。</span></span><br><span class="line">		<span class="comment">// 可以看到，order属性值，最终决定的是BeanProcessor的执行顺序的</span></span><br><span class="line">		bpp.setProxyTargetClass(<span class="built_in">this</span>.enableAsync.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>));</span><br><span class="line">		bpp.setOrder(<span class="built_in">this</span>.enableAsync.&lt;Integer&gt;getNumber(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> bpp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProxyAsyncConfiguration的父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAsyncConfiguration</span> <span class="keyword">implements</span> <span class="title class_">ImportAware</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此注解@EnableAsync的元信息</span></span><br><span class="line">	<span class="keyword">protected</span> AnnotationAttributes enableAsync;</span><br><span class="line">	<span class="comment">// 异步线程池</span></span><br><span class="line">	<span class="keyword">protected</span> Executor executor;</span><br><span class="line">	<span class="comment">// 异步异常的处理器</span></span><br><span class="line">	<span class="keyword">protected</span> AsyncUncaughtExceptionHandler exceptionHandler;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> &#123;</span><br><span class="line">		<span class="comment">// 拿到@EnableAsync注解的元数据信息~~~</span></span><br><span class="line">		<span class="built_in">this</span>.enableAsync = AnnotationAttributes.fromMap(importMetadata.getAnnotationAttributes(EnableAsync.class.getName(), <span class="literal">false</span>));</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.enableAsync == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;@EnableAsync is not present on importing class &quot;</span> + importMetadata.getClassName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Collect any &#123;<span class="doctag">@link</span> AsyncConfigurer&#125; beans through autowiring.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">// doc说得很明白。它会把所有的`AsyncConfigurer`的实现类都搜集进来，然后进行类似属性的合并</span></span><br><span class="line">	 <span class="comment">// 备注  虽然这里用的是Collection 但是AsyncConfigurer的实现类只允许有一个</span></span><br><span class="line">	<span class="meta">@Autowired(required = false)</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setConfigurers</span><span class="params">(Collection&lt;AsyncConfigurer&gt; configurers)</span> &#123;</span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">if</span> (CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	  	<span class="comment">//AsyncConfigurer用来配置线程池配置以及异常处理器，而且在Spring环境中最多只能有一个</span></span><br><span class="line">	  	<span class="comment">//在这里我们知道了，如果想要自己去配置线程池，只需要实现AsyncConfigurer接口，并且不可以在Spring环境中有多个实现AsyncConfigurer的类。</span></span><br><span class="line">		<span class="keyword">if</span> (configurers.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Only one AsyncConfigurer may exist&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 拿到唯一的AsyncConfigurer ，然后赋值~~~~   默认的请参照这个类：AsyncConfigurerSupport（它并不会被加入进Spring容器里）</span></span><br><span class="line">		<span class="type">AsyncConfigurer</span> <span class="variable">configurer</span> <span class="operator">=</span> configurers.iterator().next();</span><br><span class="line">		<span class="built_in">this</span>.executor = configurer.getAsyncExecutor();</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = configurer.getAsyncUncaughtExceptionHandler();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上可知，真正做文章的最终还是 <strong>AsyncAnnotationBeanPostProcessor</strong> 这个后置处理器，继承自AbstractAdvisingBeanPostProcessor，从这个名字也能看出来。它主要处理AdvisingBean，也就是处理Advisor和Bean的关系的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它继承自，ProxyProcessorSupport，说明它也拥有AOP的通用配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAdvisingBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Advisor advisor;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="variable">beforeExistingAdvisors</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 缓存合格的Bean们</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Boolean&gt; eligibleBeans = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">	  </span><br><span class="line">	<span class="comment">// 当遇到一个pre-object的时候，是否把该processor所持有得advisor放在现有的增强器们之前执行</span></span><br><span class="line">	<span class="comment">// 默认是false，会放在最后一个位置上的</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeforeExistingAdvisors</span><span class="params">(<span class="type">boolean</span> beforeExistingAdvisors)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.beforeExistingAdvisors = beforeExistingAdvisors;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 不处理</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Bean已经实例化、初始化完成之后执行。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="comment">// 忽略AopInfrastructureBean的Bean，并且如果没有advisor也会忽略不处理~~~~~</span></span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> AopInfrastructureBean || <span class="built_in">this</span>.advisor == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Ignore AOP infrastructure such as scoped proxies.</span></span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果这个Bean已经被代理过了（比如已经被AOP切中了），那本处就无需再重复创建代理了嘛</span></span><br><span class="line">		<span class="comment">// 直接向里面添加advisor就成了</span></span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">			<span class="type">Advised</span> <span class="variable">advised</span> <span class="operator">=</span> (Advised) bean;</span><br><span class="line">			<span class="comment">// 注意此advised不能是已经被冻结了的。且源对象必须是Eligible合格的</span></span><br><span class="line">			<span class="keyword">if</span> (!advised.isFrozen() &amp;&amp; isEligible(AopUtils.getTargetClass(bean))) &#123;</span><br><span class="line">				<span class="comment">// Add our local Advisor to the existing proxy&#x27;s Advisor chain...</span></span><br><span class="line">				<span class="comment">// 把自己持有的这个advisor放在首位（如果beforeExistingAdvisors=true）</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">this</span>.beforeExistingAdvisors) &#123;</span><br><span class="line">					advised.addAdvisor(<span class="number">0</span>, <span class="built_in">this</span>.advisor);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 否则就是尾部位置</span></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					advised.addAdvisor(<span class="built_in">this</span>.advisor);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 最终直接返回即可，因为已经没有必要再创建一次代理对象了</span></span><br><span class="line">				<span class="keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 如果这个Bean事合格的（此方法下面有解释）   这个时候是没有被代理过的</span></span><br><span class="line">		<span class="keyword">if</span> (isEligible(bean, beanName)) &#123;</span><br><span class="line">			<span class="comment">// 以当前的配置，创建一个ProxyFactory </span></span><br><span class="line">			<span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> prepareProxyFactory(bean, beanName);</span><br><span class="line">			<span class="comment">// 如果不是使用CGLIB常见代理，那就去分析出它所实现的接口们  然后放进ProxyFactory 里去</span></span><br><span class="line">			<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">				evaluateProxyInterfaces(bean.getClass(), proxyFactory);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 切面就是当前持有得advisor</span></span><br><span class="line">			proxyFactory.addAdvisor(<span class="built_in">this</span>.advisor);</span><br><span class="line">			<span class="comment">// 留给子类，自己还可以对proxyFactory进行自定义~~~~~</span></span><br><span class="line">			customizeProxyFactory(proxyFactory);</span><br><span class="line">			<span class="comment">// 最终返回这个代理对象~~~~~</span></span><br><span class="line">			<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// No async proxy needed.（相当于没有做任何的代理处理,返回原对象）</span></span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 检查这个Bean是否是合格的</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isEligible</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> isEligible(bean.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isEligible</span><span class="params">(Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">		<span class="comment">// 如果已经被缓存着了，那肯定靠谱啊</span></span><br><span class="line">		<span class="type">Boolean</span> <span class="variable">eligible</span> <span class="operator">=</span> <span class="built_in">this</span>.eligibleBeans.get(targetClass);</span><br><span class="line">		<span class="keyword">if</span> (eligible != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> eligible;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果没有切面（就相当于没有给配置增强器，那铁定是不合格的）</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.advisor == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 这个重要了：看看这个advisor是否能够切入进targetClass这个类，能够切入进取的也是合格的</span></span><br><span class="line">		eligible = AopUtils.canApply(<span class="built_in">this</span>.advisor, targetClass);</span><br><span class="line">		<span class="built_in">this</span>.eligibleBeans.put(targetClass, eligible);</span><br><span class="line">		<span class="keyword">return</span> eligible;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 子类可以复写。比如`AbstractBeanFactoryAwareAdvisingPostProcessor`就复写了这个方法~~~</span></span><br><span class="line">	<span class="keyword">protected</span> ProxyFactory <span class="title function_">prepareProxyFactory</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">		proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line">		proxyFactory.setTarget(bean);</span><br><span class="line">		<span class="keyword">return</span> proxyFactory;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 子类复写~</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeProxyFactory</span><span class="params">(ProxyFactory proxyFactory)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>AbstractBeanFactoryAwareAdvisingPostProcessor从名字可以看出，它相较于父类，就和BeanFactory有关了，也就是和Bean容器相关了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBeanFactoryAwareAdvisingPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractAdvisingBeanPostProcessor</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bean工厂</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> ConfigurableListableBeanFactory beanFactory;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果这个Bean工厂不是ConfigurableListableBeanFactory ，那就set一个null</span></span><br><span class="line">	<span class="comment">// 我们的`DefaultListableBeanFactory`显然就是它的子类~~~~~</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.beanFactory = (beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory ?</span><br><span class="line">				(ConfigurableListableBeanFactory) beanFactory : <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> ProxyFactory <span class="title function_">prepareProxyFactory</span><span class="params">(Object bean, String beanName)</span> &#123;		<span class="comment">// 如果Bean工厂是正常的，那就把这个Bean  expose一个特殊的Bean，记录下它的类型</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">			AutoProxyUtils.exposeTargetClass(<span class="built_in">this</span>.beanFactory, beanName, bean.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="built_in">super</span>.prepareProxyFactory(bean, beanName);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 这里创建代理也是和`AbstractAutoProxyCreator`差不多的逻辑。</span></span><br><span class="line">		<span class="comment">// 如果没有显示的设置为CGLIB，并且toProxyUtils.shouldProxyTargetClass还被暴露过时一个特殊的Bean，那就强制使用CGLIB代理吧    这里一般和Scope无关的话，都返回false了</span></span><br><span class="line">		<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass() &amp;&amp; <span class="built_in">this</span>.beanFactory != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">				AutoProxyUtils.shouldProxyTargetClass(<span class="built_in">this</span>.beanFactory, beanName)) &#123;</span><br><span class="line">			proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> proxyFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面就可以看看具体的两个实现类了：<br>AsyncAnnotationBeanPostProcessor，该实现类就是具体和@Async相关的一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactoryAwareAdvisingPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建议换成AsyncExecutionAspectSupport.DEFAULT_TASK_EXECUTOR_BEAN_NAME  这样语意更加的清晰些</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TASK_EXECUTOR_BEAN_NAME</span> <span class="operator">=</span> AnnotationAsyncExecutionInterceptor.DEFAULT_TASK_EXECUTOR_BEAN_NAME;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 注解类型</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; asyncAnnotationType;</span><br><span class="line">	<span class="comment">// 异步的执行器</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Executor executor;</span><br><span class="line">	<span class="comment">// 异步异常处理器</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> AsyncUncaughtExceptionHandler exceptionHandler;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此处特别注意：这里设置为true，也就是说@Async的Advisor会放在首位</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">		setBeforeExistingAdvisors(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可以设定需要扫描哪些注解类型。默认只扫描@Async以及`javax.ejb.Asynchronous`这个注解</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsyncAnnotationType</span><span class="params">(Class&lt;? extends Annotation&gt; asyncAnnotationType)</span> &#123;</span><br><span class="line">		Assert.notNull(asyncAnnotationType, <span class="string">&quot;&#x27;asyncAnnotationType&#x27; must not be null&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.asyncAnnotationType = asyncAnnotationType;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果没有指定。那就将执行全局得默认查找。在上下文中查找唯一的`TaskExecutor`类型的Bean，或者一个名称为`taskExecutor`的Executor</span></span><br><span class="line">	<span class="comment">// 当然，如果上面途径都没找到。那就会采用一个默认的任务池</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExecutor</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.executor = executor;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExceptionHandler</span><span class="params">(AsyncUncaughtExceptionHandler exceptionHandler)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = exceptionHandler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写了父类的方法。然后下面：自己new了一个AsyncAnnotationAdvisor ，传入executor和exceptionHandler</span></span><br><span class="line">	<span class="comment">// 并且最终this.advisor = advisor </span></span><br><span class="line">	<span class="comment">// 因此可议看出：AsyncAnnotationAdvisor 才是重点了。它定义了它的匹配情况~~~~</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>.setBeanFactory(beanFactory);</span><br><span class="line">	</span><br><span class="line">		<span class="type">AsyncAnnotationAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncAnnotationAdvisor</span>(<span class="built_in">this</span>.executor, <span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.asyncAnnotationType != <span class="literal">null</span>) &#123;</span><br><span class="line">			advisor.setAsyncAnnotationType(<span class="built_in">this</span>.asyncAnnotationType);</span><br><span class="line">		&#125;</span><br><span class="line">		advisor.setBeanFactory(beanFactory);</span><br><span class="line">		<span class="built_in">this</span>.advisor = advisor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>AsyncAnnotationAdvisor:可以看出，它是一个PointcutAdvisor，并且Pointcut是一个AnnotationMatchingPointcut，因此是为注解来匹配的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncAnnotationAdvisor</span> <span class="keyword">extends</span> <span class="title class_">AbstractPointcutAdvisor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> AsyncUncaughtExceptionHandler exceptionHandler;</span><br><span class="line">	<span class="comment">// 增强器</span></span><br><span class="line">	<span class="keyword">private</span> Advice advice;</span><br><span class="line">	<span class="comment">// 切点</span></span><br><span class="line">	<span class="keyword">private</span> Pointcut pointcut;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 两个都为null，那就是都会采用默认的方案</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncAnnotationAdvisor</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建一个AsyncAnnotationAdvisor实例，可以自己指定Executor 和 AsyncUncaughtExceptionHandler </span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncAnnotationAdvisor</span><span class="params">(<span class="meta">@Nullable</span> Executor executor, <span class="meta">@Nullable</span> AsyncUncaughtExceptionHandler exceptionHandler)</span> &#123;</span><br><span class="line">		<span class="comment">// 这里List长度选择2，应为绝大部分情况下只会支持这两种@Async和@Asynchronous</span></span><br><span class="line">		Set&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;&gt; asyncAnnotationTypes = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">		asyncAnnotationTypes.add(Async.class);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			asyncAnnotationTypes.add((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;)</span><br><span class="line">					ClassUtils.forName(<span class="string">&quot;javax.ejb.Asynchronous&quot;</span>, AsyncAnnotationAdvisor.class.getClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="comment">// If EJB 3.1 API not present, simply ignore.</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (exceptionHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.exceptionHandler = exceptionHandler;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若没指定，那就使用默认的SimpleAsyncUncaughtExceptionHandler（它仅仅是输出了一句日志而已）</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.exceptionHandler = <span class="keyword">new</span> <span class="title class_">SimpleAsyncUncaughtExceptionHandler</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 这两个方法是重点，下面会重点介绍</span></span><br><span class="line">		<span class="built_in">this</span>.advice = buildAdvice(executor, <span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">		<span class="built_in">this</span>.pointcut = buildPointcut(asyncAnnotationTypes);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果set了Executor,advice会重新构建。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTaskExecutor</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.advice = buildAdvice(executor, <span class="built_in">this</span>.exceptionHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里注意：如果你自己指定了注解类型。那么将不再扫描其余两个默认的注解，因此pointcut也就需要重新构建了</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsyncAnnotationType</span><span class="params">(Class&lt;? extends Annotation&gt; asyncAnnotationType)</span> &#123;</span><br><span class="line">		Assert.notNull(asyncAnnotationType, <span class="string">&quot;&#x27;asyncAnnotationType&#x27; must not be null&quot;</span>);</span><br><span class="line">		Set&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;&gt; asyncAnnotationTypes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		asyncAnnotationTypes.add(asyncAnnotationType);</span><br><span class="line">		<span class="built_in">this</span>.pointcut = buildPointcut(asyncAnnotationTypes);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果这个advice也实现了BeanFactoryAware，那就也把BeanFactory放进去</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.advice <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">			((BeanFactoryAware) <span class="built_in">this</span>.advice).setBeanFactory(beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Advice <span class="title function_">getAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.advice;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Pointcut <span class="title function_">getPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.pointcut;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这个最终又是委托给`AnnotationAsyncExecutionInterceptor`，它是一个具体的增强器，有着核心内容</span></span><br><span class="line">	<span class="keyword">protected</span> Advice <span class="title function_">buildAdvice</span><span class="params">(<span class="meta">@Nullable</span> Executor executor, AsyncUncaughtExceptionHandler exceptionHandler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationAsyncExecutionInterceptor</span>(executor, exceptionHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Calculate a pointcut for the given async annotation types, if any</span></span><br><span class="line">	<span class="keyword">protected</span> Pointcut <span class="title function_">buildPointcut</span><span class="params">(Set&lt;Class&lt;? extends Annotation&gt;&gt; asyncAnnotationTypes)</span> &#123;</span><br><span class="line">		<span class="comment">// 采用一个组合切面：ComposablePointcut （因为可能需要支持多个注解嘛）</span></span><br><span class="line">		<span class="type">ComposablePointcut</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; asyncAnnotationType : asyncAnnotationTypes) &#123;</span><br><span class="line">			<span class="comment">// 这里为何new出来两个AnnotationMatchingPointcut？？？？？？</span></span><br><span class="line">			<span class="comment">// 第一个：类匹配（只需要类上面有这个注解，所有的方法都匹配）this.methodMatcher = MethodMatcher.TRUE;</span></span><br><span class="line">			<span class="comment">// 第二个：方法匹配。所有的类都可议。但是只有方法上有这个注解才会匹配上</span></span><br><span class="line">			<span class="type">Pointcut</span> <span class="variable">cpc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationMatchingPointcut</span>(asyncAnnotationType, <span class="literal">true</span>);</span><br><span class="line">			<span class="type">Pointcut</span> <span class="variable">mpc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationMatchingPointcut</span>(<span class="literal">null</span>, asyncAnnotationType, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">				result = <span class="keyword">new</span> <span class="title class_">ComposablePointcut</span>(cpc);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				result.union(cpc);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 最终的结果都是取值为并集的~~~~~~~</span></span><br><span class="line">			result = result.union(mpc);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//  最后一个处理厉害了：也就是说你啥类型都木有的情况下，是匹配所有类的所有方法~~~</span></span><br><span class="line">		<span class="keyword">return</span> (result != <span class="literal">null</span> ? result : Pointcut.TRUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上的源码可议看出，默认是支持@Asycn以及EJB的那个异步注解的。但是最终的增强行为，委托给了AnnotationAsyncExecutionInterceptor。AnnotationAsyncExecutionInterceptor是一个MethodInterceptor，并且继承自AsyncExecutionAspectSupport。<br>AsyncExecutionAspectSupport从类名就可以看出，它是用来支持处理异步线程执行器的，若没有指定，靠它提供一个默认的异步执行器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AsyncExecutionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这是备选的。如果找到多个类型为TaskExecutor的Bean，才会备选的再用这个名称去找的~~~</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TASK_EXECUTOR_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;taskExecutor&quot;</span>;</span><br><span class="line">	<span class="comment">// 缓存~~~AsyncTaskExecutor是TaskExecutor的子接口</span></span><br><span class="line">	<span class="comment">// 从这可以看出：不同的方法，对应的异步执行器还不一样咯~~~~~~</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, AsyncTaskExecutor&gt; executors = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">	<span class="comment">// 默认的线程执行器</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Executor defaultExecutor;</span><br><span class="line">	<span class="comment">// 异步异常处理器</span></span><br><span class="line">	<span class="keyword">private</span> AsyncUncaughtExceptionHandler exceptionHandler;</span><br><span class="line">	<span class="comment">// Bean工厂</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncExecutionAspectSupport</span><span class="params">(<span class="meta">@Nullable</span> Executor defaultExecutor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(defaultExecutor, <span class="keyword">new</span> <span class="title class_">SimpleAsyncUncaughtExceptionHandler</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AsyncExecutionAspectSupport</span><span class="params">(<span class="meta">@Nullable</span> Executor defaultExecutor, AsyncUncaughtExceptionHandler exceptionHandler)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.defaultExecutor = defaultExecutor;</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = exceptionHandler;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExecutor</span><span class="params">(Executor defaultExecutor)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.defaultExecutor = defaultExecutor;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExceptionHandler</span><span class="params">(AsyncUncaughtExceptionHandler exceptionHandler)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.exceptionHandler = exceptionHandler;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 该方法是找到一个异步执行器，去执行这个方法~~~~~~</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> AsyncTaskExecutor <span class="title function_">determineAsyncExecutor</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">		<span class="comment">// 如果缓存中能够找到该方法对应的执行器，就立马返回了</span></span><br><span class="line">		<span class="type">AsyncTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="built_in">this</span>.executors.get(method);</span><br><span class="line">		<span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">			Executor targetExecutor;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 抽象方法：`AnnotationAsyncExecutionInterceptor`有实现。就是@Async注解的value值</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">qualifier</span> <span class="operator">=</span> getExecutorQualifier(method);</span><br><span class="line">			<span class="comment">// 现在知道@Async直接的value值的作用了吧。就是制定执行此方法的执行器的（容器内执行器的Bean的名称）</span></span><br><span class="line">			<span class="comment">// 当然有可能为null。注意此处是支持@Qualified注解标注在类上来区分Bean的</span></span><br><span class="line">			<span class="comment">// 注意：此处targetExecutor仍然可能为null</span></span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasLength(qualifier)) &#123;</span><br><span class="line">				targetExecutor = findQualifiedExecutor(<span class="built_in">this</span>.beanFactory, qualifier);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 注解没有指定value值，那就去找默认的执行器</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				targetExecutor = <span class="built_in">this</span>.defaultExecutor;</span><br><span class="line">				<span class="keyword">if</span> (targetExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 去找getDefaultExecutor()~~~</span></span><br><span class="line">					<span class="keyword">synchronized</span> (<span class="built_in">this</span>.executors) &#123;</span><br><span class="line">						<span class="keyword">if</span> (<span class="built_in">this</span>.defaultExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">							<span class="built_in">this</span>.defaultExecutor = getDefaultExecutor(<span class="built_in">this</span>.beanFactory);</span><br><span class="line">						&#125;</span><br><span class="line">						targetExecutor = <span class="built_in">this</span>.defaultExecutor;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 若还未null，那就返回null吧</span></span><br><span class="line">			<span class="keyword">if</span> (targetExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 把targetExecutor 包装成一个AsyncTaskExecutor返回，并且缓存起来。</span></span><br><span class="line">			<span class="comment">// TaskExecutorAdapter就是AsyncListenableTaskExecutor的一个实现类</span></span><br><span class="line">			executor = (targetExecutor <span class="keyword">instanceof</span> AsyncListenableTaskExecutor ?</span><br><span class="line">					(AsyncListenableTaskExecutor) targetExecutor : <span class="keyword">new</span> <span class="title class_">TaskExecutorAdapter</span>(targetExecutor));</span><br><span class="line">			<span class="built_in">this</span>.executors.put(method, executor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> executor;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 子类去复写此方法。也就是拿到对应的key，从而方便找bean吧（执行器）</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">getExecutorQualifier</span><span class="params">(Method method)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// @since 4.2.6  也就是根据</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Executor <span class="title function_">findQualifiedExecutor</span><span class="params">(<span class="meta">@Nullable</span> BeanFactory beanFactory, String qualifier)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;BeanFactory must be set on &quot;</span> + getClass().getSimpleName() +</span><br><span class="line">					<span class="string">&quot; to access qualified executor &#x27;&quot;</span> + qualifier + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> BeanFactoryAnnotationUtils.qualifiedBeanOfType(beanFactory, Executor.class, qualifier);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// @since 4.2.6 </span></span><br><span class="line">	<span class="comment">// Retrieve or build a default executor for this advice instance  检索或者创建一个默认的executor </span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Executor <span class="title function_">getDefaultExecutor</span><span class="params">(<span class="meta">@Nullable</span> BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 这个处理很有意思，它是用用的try catch的技巧去处理的</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 如果容器内存在唯一的TaskExecutor（子类），就直接返回了</span></span><br><span class="line">				<span class="keyword">return</span> beanFactory.getBean(TaskExecutor.class);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (NoUniqueBeanDefinitionException ex) &#123;</span><br><span class="line">				<span class="comment">// 这是出现了多个TaskExecutor类型的话，那就按照名字去拿  `taskExecutor`且是Executor类型</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 如果再没有找到，也不要报错，而是接下来创建一个默认的处理器</span></span><br><span class="line">				<span class="comment">// 这里输出一个info信息</span></span><br><span class="line">				<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex2) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> beanFactory.getBean(DEFAULT_TASK_EXECUTOR_BEAN_NAME, Executor.class);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex2) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 这里还没有获取到，就放弃。 用本地默认的executor吧~~~</span></span><br><span class="line">				<span class="comment">// 子类可以去复写此方法，发现为null的话可议给一个默认值~~~~比如`AsyncExecutionInterceptor`默认给的就是`SimpleAsyncTaskExecutor`作为执行器的</span></span><br><span class="line">				<span class="comment">// Giving up -&gt; either using local default executor or none at all...</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Delegate for actually executing the given task with the chosen executor</span></span><br><span class="line">	<span class="comment">// 用选定的执行者实际执行给定任务的委托</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">doSubmit</span><span class="params">(Callable&lt;Object&gt; task, AsyncTaskExecutor executor, Class&lt;?&gt; returnType)</span> &#123;</span><br><span class="line">		<span class="comment">// 根据不同的返回值类型，来采用不同的方案去异步执行，但是执行器都是executor</span></span><br><span class="line">		<span class="keyword">if</span> (CompletableFuture.class.isAssignableFrom(returnType)) &#123;</span><br><span class="line">			<span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> task.call();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CompletionException</span>(ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, executor);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ListenableFuture接口继承自Future  是Spring自己扩展的一个接口。</span></span><br><span class="line">		<span class="comment">// 同样的AsyncListenableTaskExecutor也是Spring扩展自AsyncTaskExecutor的</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ListenableFuture.class.isAssignableFrom(returnType)) &#123;</span><br><span class="line">			<span class="keyword">return</span> ((AsyncListenableTaskExecutor) executor).submitListenable(task);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 普通的submit</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Future.class.isAssignableFrom(returnType)) &#123;</span><br><span class="line">			<span class="keyword">return</span> executor.submit(task);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 没有返回值的情况下  也用sumitt提交，按时返回null</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			executor.submit(task);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 处理错误</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleError</span><span class="params">(Throwable ex, Method method, Object... params)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	 	<span class="comment">// 如果方法的返回值类型是Future,就rethrowException，表示直接throw出去</span></span><br><span class="line">		<span class="keyword">if</span> (Future.class.isAssignableFrom(method.getReturnType())) &#123;</span><br><span class="line">			ReflectionUtils.rethrowException(ex);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Could not transmit the exception to the caller with default executor</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="built_in">this</span>.exceptionHandler.handleUncaughtException(ex, method, params);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">				logger.error(<span class="string">&quot;Exception handler for async method &#x27;&quot;</span> + method.toGenericString() +</span><br><span class="line">						<span class="string">&quot;&#x27; threw unexpected exception itself&quot;</span>, ex2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类相当于已经做了大部分的工作了，接下来继续看子类：AsyncExecutionInterceptor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 他继承自AsyncExecutionAspectSupport 来处理异步方法的处理，同时是个MethodInterceptor，来增强复合条件的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncExecutionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">AsyncExecutionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, Ordered &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 显然这个方法它直接返回null，因为XML配置嘛~~~~</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">getExecutorQualifier</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个厉害了。如果父类返回的defaultExecutor 为null，那就new一个SimpleAsyncTaskExecutor作为默认的执行器</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Executor <span class="title function_">getDefaultExecutor</span><span class="params">(<span class="meta">@Nullable</span> BeanFactory beanFactory)</span> &#123;</span><br><span class="line">		<span class="type">Executor</span> <span class="variable">defaultExecutor</span> <span class="operator">=</span> <span class="built_in">super</span>.getDefaultExecutor(beanFactory);</span><br><span class="line">		<span class="keyword">return</span> (defaultExecutor != <span class="literal">null</span> ? defaultExecutor : <span class="keyword">new</span> <span class="title class_">SimpleAsyncTaskExecutor</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最高优先级  希望的是最优先执行（XML配置就是这种优先级）</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最重要的当然是这个invoke方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// 注意：此处是getMostSpecificMethod  拿到最终要执行的那个方法</span></span><br><span class="line">		<span class="type">Method</span> <span class="variable">specificMethod</span> <span class="operator">=</span> ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass);</span><br><span class="line">		<span class="comment">// 桥接方法~~~~~~~~~~~~~~</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">Method</span> <span class="variable">userDeclaredMethod</span> <span class="operator">=</span> BridgeMethodResolver.findBridgedMethod(specificMethod);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// determine一个用于执行此方法的异步执行器</span></span><br><span class="line">		<span class="type">AsyncTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> determineAsyncExecutor(userDeclaredMethod);</span><br><span class="line">		<span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">					<span class="string">&quot;No executor specified and no default executor set on AsyncExecutionInterceptor either&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 构造一个任务，Callable(此处不采用Runable，因为需要返回值)</span></span><br><span class="line">		Callable&lt;Object&gt; task = () -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// result就是返回值</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">				<span class="comment">// 注意此处的处理~~~~  相当于如果不是Future类型，就返回null了</span></span><br><span class="line">				<span class="keyword">if</span> (result <span class="keyword">instanceof</span> Future) &#123;</span><br><span class="line">					<span class="keyword">return</span> ((Future&lt;?&gt;) result).get();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 处理执行时可能产生的异常~~~~~~</span></span><br><span class="line">			<span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">				handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				handleError(ex, userDeclaredMethod, invocation.getArguments());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 提交任务~~~~invocation.getMethod().getReturnType()为返回值类型</span></span><br><span class="line">		<span class="keyword">return</span> doSubmit(task, executor, invocation.getMethod().getReturnType());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SimpleAsyncTaskExecutor：异步执行用户任务的SimpleAsyncTaskExecutor。每次执行客户提交给它的任务时，它会启动新的线程，并允许开发者控制并发线程的上限（concurrencyLimit），从而起到一定的资源节流作用。默认时，concurrencyLimit取值为-1，即<strong>不启用</strong>资源节流<br>所以它不是真的线程池，这个类不重用线程，每次调用都会创建一个新的线程（因此建议我们在使用@Aysnc的时候，自己配置一个线程池，节约资源）</p>
<p>AnnotationAsyncExecutionInterceptor很显然，他是在AsyncExecutionInterceptor的基础上，提供了对@Async注解的支持。所以它是继承它的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它继承自AsyncExecutionInterceptor ，只复写了一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationAsyncExecutionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">AsyncExecutionInterceptor</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 由此可以见它就是去拿到@Async的value值。以方法的为准，其次是类上面的</span></span><br><span class="line">	<span class="comment">// 备注：发现这里是不支持EJB的@Asynchronous注解的，它是不能指定执行器的</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">getExecutorQualifier</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">		<span class="comment">// Maintainer&#x27;s note: changes made here should also be made in</span></span><br><span class="line">		<span class="comment">// AnnotationAsyncExecutionAspect#getExecutorQualifier</span></span><br><span class="line">		<span class="type">Async</span> <span class="variable">async</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotation(method, Async.class);</span><br><span class="line">		<span class="keyword">if</span> (async == <span class="literal">null</span>) &#123;</span><br><span class="line">			async = AnnotatedElementUtils.findMergedAnnotation(method.getDeclaringClass(), Async.class);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (async != <span class="literal">null</span> ? async.value() : <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>使用推荐配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">//对应的@Enable注解，最好写在属于自己的配置文件上，保持内聚性</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>); <span class="comment">//核心线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);  <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">1000</span>); <span class="comment">//队列大小</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">300</span>); <span class="comment">//线程最大空闲时间</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;fsx-Executor-&quot;</span>); 指定用于新创建的线程名称的前缀。</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()); <span class="comment">// 拒绝策略（一共四种，此处省略）</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 这一步千万不能忘了，否则报错： java.lang.IllegalStateException: ThreadPoolTaskExecutor not initialized</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异常处理器：当然你也可以自定义的，这里我就这么简单写了~~~</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAsyncUncaughtExceptionHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>注解@Async引发的Spring循环依赖分析</title>
    <url>/2024/04/01/Spring/spring%20boot/@Async%E6%B3%A8%E8%A7%A3%E5%BC%95%E5%8F%91%E7%9A%84Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>首先有一点可以确定，spring可以是解决某些循环依赖的，示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子，AService与BService存在循环依赖，运行也是没有问题的。现在开启异步(添加<code>@EnableAsync</code>），修改AService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行，就有会有如下报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR org.springframework.boot.SpringApplication - Application startup failed</span><br><span class="line">org.springframework.beans.factory.BeanCurrentlyInCreationException: </span><br><span class="line">  Error creating bean with name &#x27;AService&#x27;: </span><br><span class="line">  Bean with name &#x27;AService&#x27; has been injected into other beans [BService] in its raw version as part of a circular reference, </span><br><span class="line">  but has eventually been wrapped. </span><br><span class="line">  This means that said other beans do not use the final version of the bean. </span><br><span class="line">  This is often the result of over-eager type matching - consider using &#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>要想了解原因，首先得分析下 <code>@Aysnc</code> 注解的Bean的创建代理的时机。<code>@EnableAsync</code>开启时会向容器注入AsyncAnnotationBeanPostProcessor，它是一个BeanPostProcessor，实现了postProcessAfterInitialization，具体的实现在其父类AbstractAdvisingBeanPostProcessor中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> AopInfrastructureBean) &#123;</span><br><span class="line">		<span class="comment">// Ignore AOP infrastructure such as scoped proxies.</span></span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">		<span class="type">Advised</span> <span class="variable">advised</span> <span class="operator">=</span> (Advised) bean;</span><br><span class="line">		<span class="keyword">if</span> (!advised.isFrozen() &amp;&amp; isEligible(AopUtils.getTargetClass(bean))) &#123;</span><br><span class="line">			<span class="comment">// Add our local Advisor to the existing proxy&#x27;s Advisor chain...</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.beforeExistingAdvisors) &#123;</span><br><span class="line">				advised.addAdvisor(<span class="number">0</span>, <span class="built_in">this</span>.advisor);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				advised.addAdvisor(<span class="built_in">this</span>.advisor);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isEligible(bean, beanName)) &#123;</span><br><span class="line">		<span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> prepareProxyFactory(bean, beanName);</span><br><span class="line">		<span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">			evaluateProxyInterfaces(bean.getClass(), proxyFactory);</span><br><span class="line">		&#125;</span><br><span class="line">		proxyFactory.addAdvisor(<span class="built_in">this</span>.advisor);</span><br><span class="line">		customizeProxyFactory(proxyFactory);</span><br><span class="line">		<span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No async proxy needed.</span></span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isEligible</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> isEligible(bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isEligible</span><span class="params">(Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">	<span class="type">Boolean</span> <span class="variable">eligible</span> <span class="operator">=</span> <span class="built_in">this</span>.eligibleBeans.get(targetClass);</span><br><span class="line">	<span class="keyword">if</span> (eligible != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> eligible;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 方法有 @Aysnc 注解，AopUtils.canApply 会判断为 true</span></span><br><span class="line">	eligible = AopUtils.canApply(<span class="built_in">this</span>.advisor, targetClass);</span><br><span class="line">	<span class="built_in">this</span>.eligibleBeans.put(targetClass, eligible);</span><br><span class="line">	<span class="keyword">return</span> eligible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 AService，AopUtils.canApply 返回 true，那么postProcessAfterInitialization就会返回一个proxy对象。</p>
<p>来看看示例异常错误的地方(AbstractAutowireCapableBeanFactory.class)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the bean.</span></span><br><span class="line">	<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//...略</span></span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">	<span class="comment">//...略</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">	<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">//...略</span></span><br><span class="line">		<span class="comment">// 这里提前暴露</span></span><br><span class="line">		addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">				<span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		<span class="keyword">if</span> (exposedObject != <span class="literal">null</span>) &#123;</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="comment">//...略</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 这里报错了</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(dependentBeans.length);</span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">							<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">							<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">							<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">							<span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> <span class="comment">//...略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对AService，因为它支持提前暴露，因此会先加到缓存中addSingletonFactory；之后在populateBean方法中，由于依赖了BService，开始初始化BService，BService依赖AService，因此直接调用了getEarlyBeanReference得到了AService，此时BService获取到的是AService的原始类型引用。</p>
<p>之后AService继续执行到了initializeBean方法，会执行BeanPostProcessor，拿到的是一个代理对象，即exposedObject是一个代理对象，在后面判断的代码就返回了报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">			exposedObject = earlySingletonReference;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br></pre></td></tr></table></figure>





<p>但是同样是注解，<code>@Transactional</code>却不会跟<code>@Async</code>有同样的问题，原因在于处理<code>@Transactional</code>注解的是InfrastructureAdvisorAutoProxyCreator，它是SmartInstantiationAwareBeanPostProcessor的子类，在getEarlyBeanReference方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="literal">null</span> &amp;&amp; !mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">				<span class="type">SmartInstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">				exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">				<span class="keyword">if</span> (exposedObject == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SmartInstantiationAwareBeanPostProcessor中，复写了getEarlyBeanReference方法，暴露出去的就是代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">		<span class="built_in">this</span>.earlyProxyReferences.add(cacheKey);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后postProcessAfterInitialization方法中，判断是否代理过，是的话，直接返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>参考：<br><a href="https://segmentfault.com/a/1190000021217176">https://segmentfault.com/a/1190000021217176</a><br><a href="https://cloud.tencent.com/developer/article/1497689">https://cloud.tencent.com/developer/article/1497689</a><br><a href="https://blog.csdn.net/f641385712/article/details/89430276">https://blog.csdn.net/f641385712/article/details/89430276</a><br><a href="https://www.jb51.net/article/185794.htm">https://www.jb51.net/article/185794.htm</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>&#92;@Value(&quot;#{}&quot;) 与 @Value(&quot;${}&quot;) 的区别</title>
    <url>/2024/04/01/Spring/spring%20boot/@Value(%E2%80%9D#%7B%7D%E2%80%9C)%20%E4%B8%8E%20@Value(%E2%80%9C$%7B%7D%E2%80%9D)%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="Value-“-”"><a href="#Value-“-”" class="headerlink" title="@Value(“#{}”)"></a>@Value(“#{}”)</h3><p><code>@Value(&quot;#&#123;&#125;&quot;) </code>表示SpEl表达式，通常用来获取bean的属性，或者调用bean的某个方法。当然还有可以表示常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number; <span class="comment">//获取数字 1  </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;Spring Expression Language&#x27;&#125;&quot;)</span> <span class="comment">//获取字符串常量  </span></span><br><span class="line">    <span class="keyword">private</span> String str;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;dataSource.url&#125;&quot;)</span> <span class="comment">//获取bean的属性  </span></span><br><span class="line">    <span class="keyword">private</span> String jdbcUrl;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> DataSourceTransactionManager transactionManager;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;login&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String name,String password)</span> <span class="keyword">throws</span> FileNotFoundException&#123; </span><br><span class="line">        System.out.println(number);  </span><br><span class="line">        System.out.println(str);  </span><br><span class="line">        System.out.println(jdbcUrl);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Value-“-”-1"><a href="#Value-“-”-1" class="headerlink" title="@Value(“${}”)"></a>@Value(“${}”)</h3><p>通过<code>@Value(&quot;$&#123;&#125;&quot;) </code>可以获取对应属性文件中定义的属性值。假如有一个<code>application.properties</code>文件 里面规定了一组值： <code>web.view.prefix =/WEB-INF/views/</code>。在controller文件中通过下面代码即可获取这个配置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;web.view.prefix&#125;&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> String prefix;  </span><br></pre></td></tr></table></figure>



<hr>
<hr>
<p>SpEL表达式语言是一种表达式语言，是一种可以与一个基于spring的应用程序中的运行时对象交互的东西。有点类似于ognl表达式。</p>
<p>总得来说SpEL表达式是一种简化开发的表达式，通过使用表达式来简化开发，减少一些逻辑、配置的编写。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>BeanPostProcessor</title>
    <url>/2024/04/01/Spring/spring%20boot/BeanPostProcessor/</url>
    <content><![CDATA[<p>[toc]</p>
<p>BeanPostProcessor 从名字上就能看出来，这是一个 Bean 的后置处理器，也就是说，BeanPostProcessor 其实主要是对已经创建出来的 Bean 做一些后置处理，而 BeanFactoryPostProcessor 主要是针对 BeanDefinition 做后置处理（此时 Bean 对象还没创建出来）。</p>
<p>但是，BeanPostProcessor 家族里边也有例外，即 MergedBeanDefinitionPostProcessor，这是一个 BeanPostProcessor，但是却可以处理 BeanDefinition。</p>
<span id="more"></span>

<h1 id="1-BeanPostProcessor"><a href="#1-BeanPostProcessor" class="headerlink" title="1. BeanPostProcessor"></a>1. BeanPostProcessor</h1><p>先来看一下 BeanPostProcessor 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是两个方法，理解这两个方法有一个大的前提，就是此时 Spring 容器已经通过 Java 反射创建出来 Bean 对象了，只不过在初始化这个 Bean 对象的时候，又提供了一些配置接口：</p>
<ul>
<li>postProcessBeforeInitialization：这个是在 Bean 初始化之前触发，此时已经有一个 Bean 对象，populateBean已执行，但是 Bean 中一些生命周期方法如 InitializingBean 接口的 afterPropertiesSet 方法、自定义的 init-method 方法等都尚未执行，在这些方法执行之前触发 postProcessBeforeInitialization 方法。</li>
<li>postProcessAfterInitialization：类似于上面，在 afterPropertiesSet 和自定义的 init-method 之后触发该方法。</li>
</ul>
<p>BeanPostProcessor 的应用非常广泛，在整个 Spring 体系中，也扮演了非常重要的角色，如 @Bean 注解的解析、AOP 动态代理的生成等等许多我们日常使用的功能，都是通过 BeanPostProcessor 来实现的。</p>
<h1 id="2-MergedBeanDefinitionPostProcessor"><a href="#2-MergedBeanDefinitionPostProcessor" class="headerlink" title="2. MergedBeanDefinitionPostProcessor"></a>2. MergedBeanDefinitionPostProcessor</h1><p>MergedBeanDefinitionPostProcessor 算是整个 BeanPostProcessor 家族中比较另类的一个接口了，它虽然是 BeanPostProcessor，但是却可以处理 BeanDefinition。MergedBeanDefinitionPostProcessor 介入的时机就是bean 创建成功之后，bean 中各个属性填充之前。</p>
<p>MergedBeanDefinitionPostProcessor 用于在beanDefinition合并之后对合并后的 bean 进行后置处理。它的作用是允许开发者在beanDefinition合并完成后，对合并后的 bean 进行自定义的修改或扩展操作。通常情况下，这个接口用于处理带有注解的 bean 定义，例如 @Autowired 或 @Value 等注解的处理。通过实现 MergedBeanDefinitionPostProcessor 接口，开发者可以在beanDefinition合并后，对这些注解进行解析和处理，以实现自定义的逻辑。</p>
<p>来看下 MergedBeanDefinitionPostProcessor 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MergedBeanDefinitionPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">resetBeanDefinition</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就两个方法，一个是处理合并后的 beanDefinition，还有一个是重置 Bean 的。</p>
<h1 id="3-收集-BeanPostProcessor"><a href="#3-收集-BeanPostProcessor" class="headerlink" title="3. 收集 BeanPostProcessor"></a>3. 收集 BeanPostProcessor</h1><p>接下来看 BeanPostProcessor 的处理流程，首先第一步就是在容器启动的时候，收集到用户注册在系统中的 BeanPostProcessor，无论是 Java 配置还是 XML 配置，在 refresh 方法中都会调用到 registerBeanPostProcessors，这个方法就是用来收集 BeanPostProcessor 的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">beanProcessorTargetCount</span> <span class="operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));</span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            priorityOrderedPostProcessors.add(pp);</span><br><span class="line">            <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        orderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        nonOrderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line">    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用来存储 BeanPostProcessor 的集合一共有四个，分别是：</p>
<ul>
<li><p><strong>priorityOrderedPostProcessors</strong>：由于 BeanPostProcessor 可能存在多个，所以需要给这多个 BeanPostProcessor 进行排序，排序的方式有两种，一种就是在定义 BeanPostProcessor 的时候，让其实现 PriorityOrdered 接口，那么这里就是把所有实现了 PriorityOrdered 接口的 BeanPostProcessor 收集到一起。</p>
</li>
<li><p><strong>orderedPostProcessors</strong>：类似于上面的，这里是收集所有实现了 Ordered 接口的 BeanPostProcessor。</p>
</li>
<li><p><strong>nonOrderedPostProcessors</strong>：这个里边保存了所有不需要排序的 BeanPostProcessor。</p>
</li>
<li><p><strong>internalPostProcessors</strong>：这个里边保存了 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor，前三种互相之间不会重复，而 internalPostProcessors 可能会和前三种有重复。</p>
</li>
</ul>
<p>将收集并且排序好的 BeanPostProcessor，调用 registerBeanPostProcessors 方法进行注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">		ConfigurableListableBeanFactory beanFactory, List&lt;? extends BeanPostProcessor&gt; postProcessors)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> AbstractBeanFactory abstractBeanFactory) &#123;</span><br><span class="line">		<span class="comment">// Bulk addition is more efficient against our CopyOnWriteArrayList there</span></span><br><span class="line">		abstractBeanFactory.addBeanPostProcessors(postProcessors);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最终就是把收集到的 BeanPostProcessor 添加到容器的 beanPostProcessors 变量中。</p>
<p>现在，容器中已经有了 BeanPostProcessor 了，接下来看什么时候执行。</p>
<h1 id="4-触发BeanPostProcessor"><a href="#4-触发BeanPostProcessor" class="headerlink" title="4. 触发BeanPostProcessor"></a>4. 触发BeanPostProcessor</h1><p>BeanPostProcessor 的执行分为两种情况，一种是执行 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor，还有一种是执行普通的 BeanPostProcessor，。</p>
<p>在创建 Bean 的关键方法 AbstractAutowireCapableBeanFactory#doCreateBean 中，有这样几个关键步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">    <span class="comment">// 初始化 Bean 实例</span></span><br><span class="line">	<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 关注点!!!</span></span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.markAsPostProcessed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 关注点!!!</span></span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="comment">// 关注点!!!</span></span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家看到，在初始化 Bean 实例之后，有一个 applyMergedBeanDefinitionPostProcessors 方法，这个方法就是用来触发 MergedBeanDefinitionPostProcessor 执行的。</p>
<p>populateBean 方法是给 Bean 的各个属性填充值的，填充完成之后，调用 initializeBean 方法进行剩余的初始化工作，在 initializeBean 方法中，调用了其余的 BeanPostProcessor。</p>
<h2 id="4-1-触发-MergedBeanDefinitionPostProcessor"><a href="#4-1-触发-MergedBeanDefinitionPostProcessor" class="headerlink" title="4.1 触发 MergedBeanDefinitionPostProcessor"></a>4.1 触发 MergedBeanDefinitionPostProcessor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) &#123;</span><br><span class="line">		processor.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-触发其他-BeanPostProcessor"><a href="#4-2-触发其他-BeanPostProcessor" class="headerlink" title="4.2 触发其他 BeanPostProcessor"></a>4.2 触发其他 BeanPostProcessor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">	invokeAwareMethods(beanName, bean);</span><br><span class="line">	<span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">				(mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个顺序：</p>
<ul>
<li>先是调 applyBeanPostProcessorsBeforeInitialization，这个里边最终就触发到了 BeanPostProcessor#postProcessBeforeInitialization 方法；</li>
<li>然后调用 invokeInitMethods，afterPropertiesSet 和自定义的 init-method 都在这里被触发；</li>
<li>最后调用 applyBeanPostProcessorsAfterInitialization，这个里边最终就触发到 BeanPostProcessor#postProcessAfterInitialization 方法。</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>Controller层设置切面的三种方式</title>
    <url>/2024/04/01/Spring/spring%20boot/Controller%E5%B1%82%E8%AE%BE%E7%BD%AE%E5%88%87%E9%9D%A2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="1-自定义PointcutAdvisor"><a href="#1-自定义PointcutAdvisor" class="headerlink" title="1.自定义PointcutAdvisor"></a>1.自定义PointcutAdvisor</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface AopAnnotation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomizePointcutAdvisor</span> <span class="keyword">extends</span> <span class="title class_">DefaultPointcutAdvisor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(CustomizePointcutAdvisor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomizePointcutAdvisor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Pointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="built_in">this</span>.buildPointcut();</span><br><span class="line">        <span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="built_in">this</span>.buildAdvice();</span><br><span class="line">        <span class="built_in">this</span>.setAdvice(advice);</span><br><span class="line">        <span class="built_in">this</span>.setPointcut(pointcut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Advice <span class="title function_">buildAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MethodInterceptor</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> (methodInvocation) -&gt; &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodInvocation.getMethod();</span><br><span class="line">            Class&lt;?&gt; declaringClass = AopUtils.getTargetClass(methodInvocation.getThis());</span><br><span class="line">            <span class="type">Method</span> <span class="variable">specificMethod</span> <span class="operator">=</span> AopUtils.getMostSpecificMethod(method, declaringClass);</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            Object proceed;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                proceed = methodInvocation.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&quot;</span>, throwable);</span><br><span class="line">                <span class="keyword">throw</span> throwable;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;方法&#123;&#125;耗时:&#123;&#125;ms&quot;</span>, specificMethod.getName(), (System.currentTimeMillis() - start));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> proceed;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pointcut <span class="title function_">buildPointcut</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//ComposablePointcut 可组合的切点</span></span><br><span class="line">        <span class="type">Pointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> Pointcuts.union(</span><br><span class="line">            <span class="comment">//注解匹配切点</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationMatchingPointcut</span>(AopAnnotation.class, <span class="literal">true</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationMatchingPointcut</span>((Class) <span class="literal">null</span>, AopAnnotation.class));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pointcut;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CustomizeAutoConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CustomizePointcutAdvisor alertPointcutAdvisor() &#123;</span><br><span class="line">        return new CustomizePointcutAdvisor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/test&quot;)</span><br><span class="line">public class AopTestController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/0&quot;)</span><br><span class="line">    public String test0() &#123;</span><br><span class="line">        return &quot;test0&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AopAnnotation</span><br><span class="line">    @GetMapping(&quot;/1&quot;)</span><br><span class="line">    public String test1() &#123;</span><br><span class="line">        return &quot;test1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-Aspect注解实现"><a href="#2-Aspect注解实现" class="headerlink" title="2.@Aspect注解实现"></a>2.@Aspect注解实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(AopAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(public * com.zero.spingboot.aop.*Controller.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcutClass</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut( value = &quot;@annotation(com.zero.spingboot.aop.AopAnnotation)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcutAnnotation</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pointcutClass() &amp;&amp; pointcutAnnotation()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">executeAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Object proceed;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceed = pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>, throwable);</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;方法&#123;&#125;耗时:&#123;&#125;ms&quot;</span>, pjp.getSignature().getName(), (System.currentTimeMillis() - start));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-HandlerInterceptor"><a href="#3-HandlerInterceptor" class="headerlink" title="3.HandlerInterceptor"></a>3.HandlerInterceptor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomizerHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(CustomizerHandlerInterceptor.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">            <span class="type">AopAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> findAnnotation((HandlerMethod) handler, AopAnnotation.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;preHandle, url=&#123;&#125;&quot;</span>, contextPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A <span class="title function_">findAnnotation</span><span class="params">(HandlerMethod handler, Class&lt;A&gt; annotationType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">annotation</span> <span class="operator">=</span> handler.getBeanType().getAnnotation(annotationType);</span><br><span class="line">            <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">                annotation = handler.getMethodAnnotation(annotationType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = handler.getBean().getClass();</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                    annotation = clazz.getAnnotation(annotationType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> annotation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WevMvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addInterceptors(registry);</span><br><span class="line"></span><br><span class="line">        <span class="type">CustomizerHandlerInterceptor</span> <span class="variable">pmsInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomizerHandlerInterceptor</span>();</span><br><span class="line">        registry</span><br><span class="line">            .addInterceptor(pmsInterceptor)</span><br><span class="line">            .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot中自定义异常处理</title>
    <url>/2024/04/01/Spring/spring%20boot/Spring%20Boot%20%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>Spring Boot 中提供了默认的异常处理，但是对于应用来说，这些信息并不应该直接返回或者不够明确，需要结合自己的情况进行定制。</p>
<p>自定义处理异常有两种方式:</p>
<ul>
<li>org.springframework.web.servlet.HandlerExceptionResolver#resolveException</li>
<li>org.springframework.web.bind.annotation.RestControllerAdvice或org.springframework.web.bind.annotation.ControllerAdvice和org.springframework.web.bind.annotation.ExceptionHandler注解来实现</li>
</ul>
<p>当两种方式都实现时，HandlerExceptionResolver要先于ControllerAdvice执行</p>
<span id="more"></span>


<h2 id="使用-HandlerExceptionResolver-处理异常"><a href="#使用-HandlerExceptionResolver-处理异常" class="headerlink" title="使用 HandlerExceptionResolver 处理异常"></a>使用 HandlerExceptionResolver 处理异常</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CustomExceptionHandlerResolver implements HandlerExceptionResolver &#123;</span><br><span class="line"></span><br><span class="line">    private static final ObjectMapper OBJECT_MAPPER;</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        OBJECT_MAPPER = new ObjectMapper();</span><br><span class="line">        OBJECT_MAPPER.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);</span><br><span class="line">        OBJECT_MAPPER.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);</span><br><span class="line">        OBJECT_MAPPER.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123;</span><br><span class="line">    </span><br><span class="line">        String message = &quot;服务器错误&quot;;</span><br><span class="line">    </span><br><span class="line">        if (o instanceof HandlerMethod) &#123;</span><br><span class="line">            if (e instanceof IllegalArgumentException) &#123;</span><br><span class="line">                message = &quot;参数错误&quot;;</span><br><span class="line">            &#125; else if (e instanceof SecurityException) &#123;</span><br><span class="line">                message = &quot;不允许访问&quot;;</span><br><span class="line">            &#125; else if (e instanceof NullPointerException) &#123;</span><br><span class="line">                message = &quot;空指针异常&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (e instanceof NoHandlerFoundException) &#123;</span><br><span class="line">            message = &quot;未找到相应资源&quot;;</span><br><span class="line">        &#125; else if (e instanceof HttpMediaTypeNotSupportedException) &#123;</span><br><span class="line">            message = &quot;请求类型不支持&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        httpServletResponse.setCharacterEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">        httpServletResponse.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);</span><br><span class="line">    </span><br><span class="line">        try &#123;</span><br><span class="line">            httpServletResponse.getWriter()</span><br><span class="line">                               .write(</span><br><span class="line">                                       OBJECT_MAPPER.writeValueAsString(</span><br><span class="line">                                               CustomResponseContent.builder()</span><br><span class="line">                                                                    .code(500)</span><br><span class="line">                                                                    .status(&quot;fail&quot;)</span><br><span class="line">                                                                    .message(message)</span><br><span class="line">                                                                    .build()</span><br><span class="line">                                       )</span><br><span class="line">                               );</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        return new ModelAndView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还需要将该配置添加到应用中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CustomWebMvcConfigurer implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span><br><span class="line">        resolvers.add(new CustomExceptionHandlerResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="使用-RestControllerAdvice-ControllerAdvice-和-ExceptionHandler-处理异常"><a href="#使用-RestControllerAdvice-ControllerAdvice-和-ExceptionHandler-处理异常" class="headerlink" title="使用 RestControllerAdvice&#x2F;ControllerAdvice 和 ExceptionHandler 处理异常"></a>使用 RestControllerAdvice&#x2F;ControllerAdvice 和 ExceptionHandler 处理异常</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class CustomControllerExceptionResolver &#123;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(&#123;NullPointerException.class&#125;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ResponseEntity&lt;?&gt; handlerNullPointerException(HttpServletRequest request, Throwable throwable) &#123;</span><br><span class="line">        CustomResponseContent responseContent = CustomResponseContent.builder()</span><br><span class="line">                                                                     .code(500)</span><br><span class="line">                                                                     .status(&quot;fail&quot;)</span><br><span class="line">                                                                     .message(&quot;空指针异常&quot;)</span><br><span class="line">                                                                     .build();</span><br><span class="line">        return new ResponseEntity&lt;&gt;(responseContent, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(&#123;IllegalArgumentException.class&#125;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ResponseEntity&lt;?&gt; handlerIllegalArgumentException(HttpServletRequest request, Throwable throwable) &#123;</span><br><span class="line">        CustomResponseContent responseContent = CustomResponseContent.builder()</span><br><span class="line">                                                                     .code(400)</span><br><span class="line">                                                                     .status(&quot;fail&quot;)</span><br><span class="line">                                                                     .message(&quot;参数错误&quot;)</span><br><span class="line">                                                                     .build();</span><br><span class="line">        return new ResponseEntity&lt;&gt;(responseContent, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(&#123;MethodArgumentNotValidException.class&#125;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ResponseEntity&lt;?&gt; handlerMethodArgumentNotValidException(HttpServletRequest request, MethodArgumentNotValidException e) &#123;</span><br><span class="line">        String errorMessage = e.getBindingResult()</span><br><span class="line">                               .getAllErrors()</span><br><span class="line">                               .stream()</span><br><span class="line">                               .map(f -&gt; ((FieldError) f).getField() + &quot;:&quot; + f.getDefaultMessage())</span><br><span class="line">                               .collect(Collectors.joining(&quot;;&quot;));</span><br><span class="line">    </span><br><span class="line">        CustomResponseContent responseContent = CustomResponseContent.builder()</span><br><span class="line">                                                                     .code(400)</span><br><span class="line">                                                                     .status(&quot;fail&quot;)</span><br><span class="line">                                                                     .message(errorMessage)</span><br><span class="line">                                                                     .build();</span><br><span class="line">        return new ResponseEntity&lt;&gt;(responseContent, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(&#123;Exception.class&#125;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ResponseEntity&lt;?&gt; handlerException(HttpServletRequest request, Throwable throwable) &#123;</span><br><span class="line">        CustomResponseContent responseContent = CustomResponseContent.builder()</span><br><span class="line">                                                                     .code(500)</span><br><span class="line">                                                                     .status(&quot;fail&quot;)</span><br><span class="line">                                                                     .message(throwable.getMessage())</span><br><span class="line">                                                                     .build();</span><br><span class="line">        return new ResponseEntity&lt;&gt;(responseContent, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="403-404…-等错误"><a href="#403-404…-等错误" class="headerlink" title="403&#x2F;404… 等错误"></a>403&#x2F;404… 等错误</h2><p>添加了上述的异常处理后，还有一部分异常无法处理，如404 错误，这是因为这些错误的异常处理并不经过异常处理器，而是被转发到 &#x2F;error的路径下，默认由<code>org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController</code>处理，所以，继承<code>org.springframework.boot.autoconfigure.web.servlet.error.AbstractErrorController</code>并添加相应实现即可自定义处理该异常返回 JSON 数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/error&quot;)</span><br><span class="line">public class CustomNoHandlerExceptionResolver extends AbstractErrorController &#123;</span><br><span class="line"></span><br><span class="line">    public CustomNoHandlerExceptionResolver(ErrorAttributes errorAttributes) &#123;</span><br><span class="line">        super(errorAttributes);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String getErrorPath() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ResponseEntity&lt;?&gt; error(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        Optional&lt;String&gt; originRequestUri = Optional.ofNullable((String) request.getAttribute(&quot;javax.servlet.error.request_uri&quot;));</span><br><span class="line">        String reasonPhrase = HttpStatus.valueOf(response.getStatus()).getReasonPhrase();</span><br><span class="line">    </span><br><span class="line">        CustomResponseContent responseContent = CustomResponseContent.builder()</span><br><span class="line">                                                                     .code(response.getStatus())</span><br><span class="line">                                                                     .status(&quot;fail&quot;)</span><br><span class="line">                                                                     .message(originRequestUri.orElse(&quot;/error&quot;) + &quot;:&quot; + reasonPhrase)</span><br><span class="line">                                                                     .build();</span><br><span class="line">    </span><br><span class="line">        return new ResponseEntity&lt;&gt;(responseContent, HttpStatus.valueOf(response.getStatus()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>转载自：<a href="https://blog.csdn.net/u013360850/article/details/93101903">https://blog.csdn.net/u013360850/article/details/93101903</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>你的Spring Boot应用启动很慢？不妨试试这个工具！</title>
    <url>/2024/04/01/Spring/spring%20boot/%E4%BD%A0%E7%9A%84Spring%20Boot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E5%BE%88%E6%85%A2%EF%BC%9F%E4%B8%8D%E5%A6%A8%E8%AF%95%E8%AF%95%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%EF%BC%81/</url>
    <content><![CDATA[<p>在GitHub上看到一个不错的开源项目：<strong>Spring Startup Analyzer</strong>。</p>
<p>从项目名称中就大概能猜到，这是一个分析Spring应用启动过程的工具。Spring Startup Analyzer通过采集Spring应用启动过程的数据，进而生成一个交互式的分析报告，帮助用户发现Spring应用启动慢的位置。同时，Spring Startup Analyzer还提供了Spring Bean异步初始化的工具，来帮助开发者加快Spring应用的启动时间。</p>
<p>下面一起来看看其提供的强大功能。</p>
<span id="more"></span>

<h2 id="分析能力"><a href="#分析能力" class="headerlink" title="分析能力"></a>分析能力</h2><p>我们可以先从该项目中给出HTML样例报告（<a href="https://linyimin-blog.oss-cn-beijing.aliyuncs.com/spring-satrtup-analyzer/hokage-20230618000928-192.168.0.101-analyzer.html">点击这里查看</a>）来看看它所提供的分析功能。</p>
<p>把报告内容的细节部分都收起来，可以看到如下图所示的内容：</p>
<p><a href="https://blog.didispace.com/images2/202307/spring-satrtup-analyzer/1690049518900.png"><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291756153.png" alt="img"></a></p>
<p>主要有六个部分：</p>
<ul>
<li>启动的统计数据。其中包括：启动时间、Bean的数量、使用&#x2F;总共的JAR包数量、未使用&#x2F;总共的JAR包数量、ClassLoader数量</li>
</ul>
<p><a href="https://blog.didispace.com/images2/202307/spring-satrtup-analyzer/1690049712845.png"><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291757730.png" alt="img"></a></p>
<ul>
<li>Spring Bean初始化数据。这里采集了每个Spring Bean的初始化时间及其细节内容</li>
</ul>
<p><a href="https://blog.didispace.com/images2/202307/spring-satrtup-analyzer/1690049735608.png"><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291757584.png" alt="img"></a></p>
<ul>
<li>Bean初始化时间线。通过时间线的方式，清晰地展现了Spring应用启动时候，各个Bean的顺序关系以及时间消耗</li>
</ul>
<p><a href="https://blog.didispace.com/images2/202307/spring-satrtup-analyzer/1690049783718.png"><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291757214.png" alt="img"></a></p>
<ul>
<li>方法调用的详细信息。这里统计了每个方法的调用时间、总时间开销和每次调用的平均时间</li>
</ul>
<p><a href="https://blog.didispace.com/images2/202307/spring-satrtup-analyzer/1690049880585.png"><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291757496.png" alt="img"></a></p>
<p>点开之后，还能看到具体每次调用时候的时间开销和一些调用细节：</p>
<p><a href="https://blog.didispace.com/images2/202307/spring-satrtup-analyzer/1690049910865.png"><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291757078.png" alt="img"></a></p>
<ul>
<li>启动后未使用的JAR。列出了所有Spring应用启动后没有使用的jar包，可以有效的帮助你清理不需要的依赖，为应用瘦身</li>
</ul>
<p><a href="https://blog.didispace.com/images2/202307/spring-satrtup-analyzer/1690050005320.png"><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291757326.png" alt="img"></a></p>
<ul>
<li>应用启动过程的线程火焰图</li>
</ul>
<p><a href="https://blog.didispace.com/images2/202307/spring-satrtup-analyzer/1690050108092.png"><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291757263.png" alt="img"></a></p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>通过上面的介绍，相信你已经了解该工具的强大之处了。接下来就可以通过下面的方法尝试分析一下自己的应用吧：</p>
<p>第一步：从里面的链接中下载最新的安装包</p>
<p><a href="https://github.com/linyimin0812/spring-startup-analyzer/tags">https://github.com/linyimin0812/spring-startup-analyzer/tags</a></p>
<p>第二步：解压下载的安装包，记住解压后的路径，下面一步要用</p>
<p>第三步：编辑Spring Boot的启动参数，包括：</p>
<ol>
<li>该工具采用agent的方式启动，所以要添加参数<code>-javaagent:$HOME/spring-startup-analyzer/lib/spring-profiler-agent.jar</code>，这里<code>$HOME</code>代表以前的解压路径，记得根据上面解压后的路径编辑这个参数</li>
<li>配置分析工具的参数，这里根据自己需要添加即可，比如可以配置超时时间30分钟：<code>-Dspring-startup-analyzer.app.health.check.timeout=30</code>，其他可配置项如下表，你可以工具自己应用的情况去修改：</li>
</ol>
<p><a href="https://blog.didispace.com/images2/202307/spring-satrtup-analyzer/1690050542019.png"><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291757118.png" alt="img"></a></p>
<p>第四步：查看该工具的日志，可以通过<code>$HOME/spring-startup-analyzer/logs</code>路径，这里<code>$HOME</code>代表以前的解压路径，日志文件的类别为：</p>
<ul>
<li>startup.log: 启动过程中的日志</li>
<li>transform.log: 被re-transform的类&#x2F;方法信息</li>
</ul>
<p>另外，该工具还支持自定义扩展，这里DD没试过，就不具体介绍了。感兴趣的童鞋可以根据文档去试试。</p>
<h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><p>这里提到了一个启动加速的优化思路，就是把一些耗时的Bean初始化改成异步就能实现。该项目提供了Bean的异步初始化工具，也非常好用，只需要下面几步就能完成。</p>
<p>第一步：引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.linyimin0812&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-async-bean-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>第二步：配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 异步化的Bean可能在Spring Bean初始化顺序的末尾，导致异步优化效果不佳，打开配置优先加载异步化的Bean</span><br><span class="line">spring-startup-analyzer.boost.spring.async.bean-priority-load-enable=true</span><br><span class="line"># 指定异步的Bean名称</span><br><span class="line">spring-startup-analyzer.boost.spring.async.bean-names=testBean,testComponent</span><br><span class="line"># 执行异步化Bean初始化方法线程池的核心线程数</span><br><span class="line">spring-startup-analyzer.boost.spring.async.init-bean-thread-pool-core-size=8</span><br><span class="line"># 执行异步化Bean初始化方法线程池的最大线程数</span><br><span class="line">spring-startup-analyzer.boost.spring.async.init-bean-thread-pool-max-size=8</span><br></pre></td></tr></table></figure>

<p>第三步：检查Bean是否异步初始化。查看日志$HOME&#x2F;spring-startup-analyzer&#x2F;logs&#x2F;startup.log文件，对于异步执行初始化的方法，会按照以下格式写一条日志:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async-init-bean, beanName: $&#123;beanName&#125;, async init method: $&#123;initMethodName&#125;</span><br></pre></td></tr></table></figure>

<p>但是，作者在文档中也提到了，异步并不是万能的，你还需要注意以下这几点：</p>
<ul>
<li>应该优先从代码层面优化初始化时间长的Bean，从根本上解决Bean初始化耗时长问题</li>
<li>对于二方包&#x2F;三方包中初始化耗时长的Bean(无法进行代码优化)再考虑Bean的异步化</li>
<li>对于不被依赖的Bean可以放心进行异步化，可以通过各个Bean加载耗时中的Root Bean判断Bean是否被其他Bean依赖</li>
<li>对于被依赖的Bean需要小心分析，在应用启动过程中不能其他Bean被调用，否则可能会存在问题</li>
</ul>
<p>好了，今天的学习就到这里！如果您学习过程中如遇困难？可以加入我们超高质量的<a href="https://blog.didispace.com/join-group-spring/index.html">Spring技术交流群</a>，参与交流与讨论，更好的学习与进步！更多<a href="http://blog.didispace.com/spring-boot-learning-2x/">Spring Boot教程可以点击直达！</a>，欢迎收藏与转发支持！</p>
<p>最后，奉上项目地址：<a href="https://github.com/linyimin0812/spring-startup-analyzer">https://github.com/linyimin0812/spring-startup-analyzer</a></p>
<hr>
<p>转载自：<br><a href="https://blog.didispace.com/spring-satrtup-analyzer/">https://blog.didispace.com/spring-satrtup-analyzer/</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>注册bean到IOC容器</title>
    <url>/2024/04/01/Spring/spring%20boot/%E6%B3%A8%E5%86%8Cbean%E5%88%B0IOC%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="1-使用BeanFactoryPostProcessor"><a href="#1-使用BeanFactoryPostProcessor" class="headerlink" title="1.使用BeanFactoryPostProcessor"></a>1.使用BeanFactoryPostProcessor</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConstomBeadFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private Logger log = LoggerFactory.getLogger(ConstomBeadFactoryPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line"></span><br><span class="line">        GenericBeanDefinition genericBeanDefinition = (GenericBeanDefinition) beanFactory.getBeanDefinition(&quot;demonBean&quot;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 属性注入方式，</span><br><span class="line">         * 	 * @see #AUTOWIRE_NO   0，默认 @Autowired</span><br><span class="line">         * 	 * @see #AUTOWIRE_BY_NAME  setter方法</span><br><span class="line">         * 	 * @see #AUTOWIRE_BY_TYPE</span><br><span class="line">         * 	 * @see #AUTOWIRE_CONSTRUCTOR  构造方法注入</span><br><span class="line">         * 	 * @see #AUTOWIRE_AUTODETECT</span><br><span class="line">         */</span><br><span class="line">        int autowireMode = genericBeanDefinition.getAutowireMode();</span><br><span class="line">        log.debug(&quot;&#123;&#125;, autowireMode=&#123;&#125;&quot;, genericBeanDefinition.getBeanClassName(), autowireMode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 修改 bean的 构造方式</span><br><span class="line">         */</span><br><span class="line">        GenericBeanDefinition personBeanDefinition = (GenericBeanDefinition) beanFactory.getBeanDefinition(&quot;person&quot;);</span><br><span class="line">        ConstructorArgumentValues constructorArgumentValues = new ConstructorArgumentValues();</span><br><span class="line">        constructorArgumentValues.addIndexedArgumentValue(0,&quot;zero&quot;);</span><br><span class="line">        personBeanDefinition.setConstructorArgumentValues(constructorArgumentValues);</span><br><span class="line"></span><br><span class="line">//        log.debug(&quot;beanFactory=&#123;&#125;&quot;, beanFactory);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-通过-Import"><a href="#2-通过-Import" class="headerlink" title="2. 通过@Import"></a>2. 通过@Import</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(ImportClassA.class) //导入普通类，ok</span><br><span class="line">@Configuration</span><br><span class="line">public class ConstomEnableAutoConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-通过-Import-ImportBeanDefinitionRegistrar"><a href="#3-通过-Import-ImportBeanDefinitionRegistrar" class="headerlink" title="3. 通过@Import + ImportBeanDefinitionRegistrar"></a>3. 通过@Import + ImportBeanDefinitionRegistrar</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(ConstomImportBeanDefinitionRegister.class) //导入注册器， ok    mybatis方式</span><br><span class="line">@Configuration</span><br><span class="line">public class ConstomEnableAutoConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConstomImportBeanDefinitionRegister implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123;</span><br><span class="line">        System.out.println(&quot;------------- ConstomImportBeanDefinitionRegister&quot;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 注册一个 bean 到 IOC容器</span><br><span class="line">         */</span><br><span class="line">        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(InstA.class);</span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(&quot;instA&quot;, rootBeanDefinition);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 注册一个 bean 到 IOC容器</span><br><span class="line">         */</span><br><span class="line">        RootBeanDefinition beanDefinition = new RootBeanDefinition(IConstomMapper.class);</span><br><span class="line">        beanDefinition.setBeanClass(ConstomMapperFactoryBean.class);</span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(&quot;iConstomMapper&quot;, rootBeanDefinition);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-通过-Import-ImportSelector"><a href="#4-通过-Import-ImportSelector" class="headerlink" title="4.通过@Import + ImportSelector"></a>4.通过@Import + ImportSelector</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Import(ConstomImportSelector.class) // 批量导入，ok   springboot自动装配原理</span><br><span class="line">@Configuration</span><br><span class="line">public class ConstomEnableAutoConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConstomImportSelector implements ImportSelector &#123;</span><br><span class="line">    // V1</span><br><span class="line">//    @Override</span><br><span class="line">//    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">//        return new String[]&#123;&quot;com.zero.beandefition.importtest.InstB&quot;&#125;;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * V2</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        // 读取 META-INF/spring.factories 文件配置</span><br><span class="line">        // keys是 com.zero.beandefition.importtest.ImportConfig</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ts = SpringFactoriesLoader.loadFactoryNames(ConstomEnableAutoConfig.class,</span><br><span class="line">            ConstomImportSelector.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">        ts = Lists.newArrayList(&quot;com.zero.beandefition.importtest.InstB&quot;);</span><br><span class="line"></span><br><span class="line">//        return ts.toArray(new String[ts.size()]);</span><br><span class="line">        return StringUtils.toStringArray(ts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>Spring使用TransactionalEventListener解决事务未提交读取不到数据问题</title>
    <url>/2024/06/07/Spring/spring%20boot/Spring%E4%BD%BF%E7%94%A8TransactionalEventListener%E8%A7%A3%E5%86%B3%E4%BA%8B%E5%8A%A1%E6%9C%AA%E6%8F%90%E4%BA%A4%E8%AF%BB%E5%8F%96%E4%B8%8D%E5%88%B0%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a><strong>1 背景</strong></h2><p>业务处理过程，发现了以下问题，代码一是原代码能正常执行，代码二是经过迭代一次非正常执行代码。</p>
<p>代码一：以下代码开启线程后，代码正常执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                                     <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 插入记录</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">studentId</span> <span class="operator">=</span> studentService.insert(student);</span><br><span class="line">    <span class="comment">// 异步线程</span></span><br><span class="line">    writeStatisticsData(studentId);</span><br><span class="line">    <span class="keyword">return</span> studentId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeStatisticsData</span><span class="params">(Long studentId)</span> &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentService.findById(studentId);</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码二：以下代码开启线程后，代码不正常执行（获取不到student对象了）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 插入记录</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">studentId</span> <span class="operator">=</span> studentService.insert(student);</span><br><span class="line">    <span class="comment">// 异步线程</span></span><br><span class="line">    writeStatisticsData(studentId);</span><br><span class="line">    <span class="comment">// 插入学生地址记录</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">addressId</span> <span class="operator">=</span> addressService.insert(address);</span><br><span class="line">    <span class="keyword">return</span> studentId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeStatisticsData</span><span class="params">(Long studentId)</span> &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentService.findById(studentId);</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2 问题分析"></a><strong>2 问题分析</strong></h2><p>这里使用了spring事务，显然需要考虑事务的隔离级别。<br>查看mysql隔离级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT @<span class="meta">@tx_isolation</span>;</span><br><span class="line">READ-COMMITTED</span><br></pre></td></tr></table></figure>


<p>读提交，即在事务A插入数据过程中，事务B在A提交之前读取不到A插入的数据。</p>
<p>问题原因分析，代码一正常运行的原因：</p>
<blockquote>
<p>由于mysql事务的隔离级别是 读提交，test方法在开启异步线程后，异步线程也开启了事务，同时以读者身份去读 test 方法中插入的 student 记录，但此时 test 方法已经提交了事务，所以可以读取到 student 记录（即在异步方法中可以读取到 student 记录），但此代码有风险，若事务提交的时间晚一点，异步线程也有可能读取不到 student 记录。</p>
</blockquote>
<p>代码二不能正常运行的原因：</p>
<blockquote>
<p>经过上面分析，很明显异步方法中不能读取到 student 记录，由于代码二在异步线程下面又执行了其他操作，延时了test方法中事务的提交，所以代码二不能正常运行。</p>
</blockquote>
<h2 id="3-解决问题方案"><a href="#3-解决问题方案" class="headerlink" title="3 解决问题方案"></a><strong>3 解决问题方案</strong></h2><p>解决思路是在事务提交后再做其他的处理（如异步发消息处理等），这里还是从Spring执行事务的过程中入手，Spring事务的处理过程不再分析，这里直接看Spring事务增强器TransactionInterceptor的核心处理流程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 获取事务属性</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">    <span class="comment">//加载配置中配置的TransactionManager</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明式事务的处理</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        retVal = invocation.proceedWithInvocation();</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 编程式事务的处理......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里主要看声明式事务的处理，因为编程式事务的处理及提交都是用户在编码中进行控制。在声明式事务处理中，当方法执行完后，会执行 commitTransactionAfterReturning 方法来进行提交事务，该方法在 TransactionAspectSupport 类中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commitTransactionAfterReturning</span><span class="params">(TransactionInfo txInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看 commit 方法，该方法在 AbstractPlatformTransactionManager 类中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="comment">// 这里省略很多代码，如事务回滚......</span></span><br><span class="line">    processCommit(defStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">beforeCompletionInvoked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prepareForCommit(status);</span><br><span class="line">            triggerBeforeCommit(status);</span><br><span class="line">            triggerBeforeCompletion(status);</span><br><span class="line">            beforeCompletionInvoked = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">globalRollbackOnly</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">                globalRollbackOnly = status.isGlobalRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">                status.releaseHeldSavepoint();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 提交事务</span></span><br><span class="line">                doCommit(status);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (......) &#123;</span><br><span class="line">            <span class="comment">// 事务异常处理......</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 事务提交成功后的处理-----这里是重点</span></span><br><span class="line">            triggerAfterCommit(status);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        cleanupAfterCompletion(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">triggerAfterCommit</span><span class="params">(DefaultTransactionStatus status)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">        TransactionSynchronizationUtils.triggerAfterCommit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终会走到 TransactionSynchronizationUtils.triggerAfterCommit() 方法中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">triggerAfterCommit</span><span class="params">()</span> &#123;</span><br><span class="line">    invokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeAfterCommit</span><span class="params">(List&lt;TransactionSynchronization&gt; synchronizations)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (synchronizations != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (TransactionSynchronization synchronization : synchronizations) &#123;</span><br><span class="line">            synchronization.afterCommit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面会把缓存在 TransactionSynchronizationManager 中的 TransactionSynchronization 按顺序来执行 afterCommit 方法，其中 TransactionSynchronization 以集合形式缓存在 TransactionSynchronizationManager 的 ThreadLocal 中。</p>
<ul>
<li><p>方式一<br>经过上面分析，只需要代码中重新生成个 TransactionSynchronization 并加入到 TransactionSynchronizationManager 的 TransactionSynchronization 集合中即可，所以有了解决方案，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeStatisticsData</span><span class="params">(Long studentId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line">        <span class="comment">// 当前存在事务</span></span><br><span class="line">        TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> <span class="title class_">TransactionSynchronizationAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCommit</span><span class="params">()</span> &#123;</span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentService.findById(studentId);</span><br><span class="line">                    <span class="comment">//........</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前不存在事务</span></span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentService.findById(studentId);</span><br><span class="line">            <span class="comment">//........</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>方式二<br>使用 @TransactionalEventListener 结合 Spring事件监听机制，该注解自从Spring4.2版本开始有的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentEvent</span><span class="params">(Long studentId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(studentId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentEventListener</span>&#123;</span><br><span class="line">    <span class="meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeStatisticsData</span><span class="params">(StudentEvent studentEvent)</span> &#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentService.findById(studentEvent.getSource());</span><br><span class="line">            <span class="comment">//........</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="comment">// Spring4.2之后，ApplicationEventPublisher自动被注入到容器中，采用Autowired即可获取</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 插入记录</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">studentId</span> <span class="operator">=</span> studentService.insert(student);</span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">StudentEvent</span>(studentId));</span><br><span class="line">        <span class="comment">// 插入学生地址记录</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">addressId</span> <span class="operator">=</span> addressService.insert(address);</span><br><span class="line">        <span class="keyword">return</span> studentId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>原理分析：<br>Spring Bean在加载配置文件时，会使用 AnnotationDrivenBeanDefinitionParser注册TransactionalEventListenerFactory		：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnnotationDrivenBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionParser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 重点——将TransactionalEventListenerFactory加入到容器中</span></span><br><span class="line">        registerTransactionalEventListenerFactory(parserContext);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mode</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;mode&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;aspectj&quot;</span>.equals(mode)) &#123;</span><br><span class="line">            <span class="comment">// mode=&quot;aspectj&quot;</span></span><br><span class="line">            registerTransactionAspect(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// mode=&quot;proxy&quot;</span></span><br><span class="line">            AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerTransactionalEventListenerFactory</span><span class="params">(ParserContext parserContext)</span> &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        def.setBeanClass(TransactionalEventListenerFactory.class);</span><br><span class="line">        parserContext.registerBeanComponent(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(def,</span><br><span class="line">                                                                        TransactionManagementConfigUtils.TRANSACTIONAL_EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionalEventListenerFactory</span> <span class="keyword">implements</span> <span class="title class_">EventListenerFactory</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略部分代码......</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationListener&lt;?&gt; createApplicationListener(String beanName, Class&lt;?&gt; type, Method method) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplicationListenerMethodTransactionalAdapter</span>(beanName, type, method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationListenerMethodTransactionalAdapter</span> <span class="keyword">extends</span> <span class="title class_">ApplicationListenerMethodAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略部分代码......</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">            <span class="comment">// 事务存在时，生成TransactionSynchronization并加入到 TransactionSynchronizationManager的缓存集合中</span></span><br><span class="line">            <span class="type">TransactionSynchronization</span> <span class="variable">transactionSynchronization</span> <span class="operator">=</span> createTransactionSynchronization(event);</span><br><span class="line">            TransactionSynchronizationManager.registerSynchronization(transactionSynchronization);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.annotation.fallbackExecution()) &#123;</span><br><span class="line">            <span class="comment">//.......</span></span><br><span class="line">        &#125;</span><br><span class="line">        processEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前不存在事务什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 @TransactionalEventListener 本质上是一个 @EventListener，TransactionalEventListenerFactory类会将每一个扫描到的方法有TransactionalEventListener注解包装成ApplicationListenerMethodTransactionalAdapter对象，通过ApplicationListenerMethodTransactionalAdapter的onApplicationEvent方法可以看到若当前存在事务，就会生成TransactionSynchronization并加入到 TransactionSynchronizationManager的缓存ThreadLocal集合中，剩余流程同上述分析。</p>
<p>转载自：<a href="https://blog.csdn.net/zhuqiuhui/article/details/89299360">https://blog.csdn.net/zhuqiuhui/article/details/89299360</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>自动配置注解@EnableAutoConfiguration解密</title>
    <url>/2024/06/09/Spring/spring%20boot/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B3%A8%E8%A7%A3@EnableAutoConfiguration%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<p>&emsp;&emsp;Spring boot为了自动配置，增加了注解<code>@EnableAutoConfiguration</code>。一般只需要配置<code>@SpringBootApplication</code>即可，为什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;很明显的，这个注解就是三个常用的注解<code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>以及<code>@ComponentScan</code>组合在一起。</p>
<span id="more"></span>
<p>&emsp;&emsp;<code>@SpringBootConfiguration</code>这个注解实际上和<code>@Configuration</code>有相同的作用，配备了该注解的类就能够以JavaConfig的方式完成一些配置，可以不再使用XML配置。<br>&emsp;&emsp;<code>@ComponentScan</code>这个注解完成的是自动扫描的功能，相当于Spring XML配置文件中的：<code>&lt;context:component-scan&gt;</code>，可以使用basePackages属性指定要扫描的包，以及扫描的条件。如果不设置的话默认扫描<code>@ComponentScan</code>注解所在类的同级类和同级目录下的所有类，所以对于一个Spring Boot项目，一般会把入口类放在顶层目录中，这样就能够保证源码目录下的所有类都能够被扫描到。</p>
<p>&emsp;&emsp;<br>&emsp;&emsp;<code>@EnableAutoConfiguration</code>注解代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(EnableAutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个注解是让Spring Boot的配置能够如此简化的关键性注解。这个注解会引入<code>@AutoConfigurationPackage</code> 注解和<code>@Import(AutoConfigurationImportSelector.class) </code></p>
<p>&emsp;&emsp;那么<code>@EnableAutoConfiguration</code>注解到底是怎么生效的呢？<br>&emsp;&emsp;在SpringApplication的run方法中，会调用<code>context = createApplicationContext();</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title function_">createApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = <span class="built_in">this</span>.applicationContextClass;</span><br><span class="line">    <span class="keyword">if</span> (contextClass == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            contextClass = Class.forName(<span class="built_in">this</span>.webEnvironment</span><br><span class="line">                                         ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;Unable create a default ApplicationContext, &quot;</span></span><br><span class="line">                + <span class="string">&quot;please specify an ApplicationContextClass&quot;</span>,</span><br><span class="line">                ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里的DEFAULT_WEB_CONTEXT_CLASS值是<code>org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext</code>，DEFAULT_CONTEXT_CLASS值是<code>org.springframework.context.annotation.AnnotationConfigApplicationContext</code>。在实例化它们的时候都会实例化一个AnnotatedBeanDefinitionReader。例如AnnotationConfigEmbeddedWebApplicationContext实例化代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigEmbeddedWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这里将构造AnnotatedBeanDefinitionReader，在AnnotatedBeanDefinitionReader实例化过程中，会向beanFactory注册CommonAnnotationBeanPostProcessor、AutowiredAnnotationBeanPostProcessor、ConfigurationClassPostProcessor等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> &#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">    Assert.notNull(environment, <span class="string">&quot;Environment must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.registry = registry;</span><br><span class="line">    <span class="built_in">this</span>.conditionEvaluator = <span class="keyword">new</span> <span class="title class_">ConditionEvaluator</span>(registry, environment, <span class="literal">null</span>);</span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionRegistry registry, Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;BeanDefinitionHolder&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                                                AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;Cannot load optional framework class: &quot;</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;也就是说<code>createApplicationContext()</code>完后，beanFactory的beanDefinitionMap会有6个值。</p>
<p>&emsp;&emsp;<br>&emsp;&emsp;SpringApplication的run方法中，在调用<code>createApplicationContext();</code>后会调用<code>prepareContext(context, environment, listeners, applicationArguments,printedBanner)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span><br><span class="line"><span class="params">                            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span><br><span class="line"><span class="params">                            ApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;</span><br><span class="line">    <span class="comment">// …略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    Set&lt;Object&gt; sources = getSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[sources.size()]));</span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>getSources()</code>返回的就是<code>new SpringApplication(Application.class)</code>传入的参数，即Application.class，然后调用了<code>load()</code>方法，在<code>load()</code>中会生成BeanDefinitionLoader实例，并把主类注册到IOC容器中。<br>&emsp;&emsp;OK，到这里即在调用熟悉的<code>AbstractApplicationContext#refresh()</code>前，beanFactory有7个定义好的beanDefinition。</p>
<p>&emsp;&emsp;<br>&emsp;&emsp;ConfigurationClassPostProcessor是BeanFactoryPostProcessor的子类，会在Spring容器refresh时，<code>invokeBeanFactoryPostProcessors(beanFactory)</code>方法中调用到。ConfigurationClassPostProcessor会解析到我们的主类，把<code>@Import</code>中的类拿出来，调用它的<code>selectImports()</code>方法。</p>
<p>&emsp;&emsp;因为主类中引入的<code>@SpringBootApplication</code>注解引入了<code>@EnableAutoConfiguration</code>，这个注解又引入了Import了<code>AutoConfigurationImportSelector</code>，所以会调用它的selectImports方法，来看<code>AutoConfigurationImportSelector</code>类中的selectImports方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">AutoConfigurationMetadata</span> <span class="variable">autoConfigurationMetadata</span> <span class="operator">=</span> AutoConfigurationMetadataLoader</span><br><span class="line">            .loadMetadata(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">// 到spring.factories中找出所有的EnableAutoConfiguration 实现类，就是那些自动配置类</span></span><br><span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                                                                 attributes);</span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">        configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        <span class="comment">// 拿 AutoConfigurationImportFilter 进行过滤</span></span><br><span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="comment">// 通知 AutoConfigurationImportListener</span></span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[configurations.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>getCandidateConfigurations</code>方法就会在<code>META-INF/spring.factories</code>中找到获取约定好的自动配置类（key为EnableAutoConfiguration的value）。然后Spring容器会对这些配置类进行处理。</p>
<p>&emsp;&emsp;除了上面说的AutoConfigurationImportSelector，<code>@EnableAutoConfiguration</code>还引入了<code>@AutoConfigurationPackage</code>，来看下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里也有个@Import注解，这里导入的是个registrar类型，来看下AutoConfigurationPackages.Registrar 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125; to store the base package from the importing</span></span><br><span class="line"><span class="comment"> * configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Registrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">		register(registry, <span class="keyword">new</span> <span class="title class_">PackageImport</span>(metadata).getPackageName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> <span class="title class_">PackageImport</span>(metadata));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(BeanDefinitionRegistry registry, String... packageNames)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (registry.containsBeanDefinition(BEAN)) &#123;<span class="comment">// AutoConfigurationPackages.class.getName()</span></span><br><span class="line">		<span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> registry.getBeanDefinition(BEAN);</span><br><span class="line">		<span class="type">ConstructorArgumentValues</span> <span class="variable">constructorArguments</span> <span class="operator">=</span> beanDefinition.getConstructorArgumentValues();</span><br><span class="line">		constructorArguments.addIndexedArgumentValue(<span class="number">0</span>, addBasePackages(constructorArguments, packageNames));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">GenericBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">		beanDefinition.setBeanClass(BasePackages.class);</span><br><span class="line">		beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, packageNames);</span><br><span class="line">		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">		registry.registerBeanDefinition(BEAN, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看下上面的注释，说是为了存储基本的package。<code>new PackageImport(metadata).getPackageName()</code> 就是为了获取主启动类所在的包。最终使用BasePackages bean，获取存储的主启动类package。</p>
<p><strong>总结</strong><br>@EnableAutoConfiguration 自动装配注解由两个注解组成， @AutoConfigurationPackage 这个注解主要是为了将主启动类对应包 存储到BasePackages 这个bean对象中，@Import(AutoConfigurationImportSelector.class) 主要就是通过spi找出那些自动装配配置类，交个spring 实例化，加载。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>Spring事务介绍</title>
    <url>/2024/03/20/Spring/%E4%BA%8B%E5%8A%A1/Spring%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="1-核心接口"><a href="#1-核心接口" class="headerlink" title="1.核心接口"></a>1.核心接口</h1><p>&emsp;&emsp;Spring事务管理的实现有许多细节，下图是Spring的事务接口以及Spring实现事务的具体策略。Spring事务管理涉及的接口的联系如下：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202406291713751.png"></p>
<h2 id="1-1-事务管理器"><a href="#1-1-事务管理器" class="headerlink" title="1.1 事务管理器"></a>1.1 事务管理器</h2><p>&emsp;&emsp;Spring的事务属于逻辑事务。不是物理事务。<br>&emsp;&emsp;Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 例如JDBC的事物管理器就是<code>DataSourceTransactionManager</code>。<br>&emsp;&emsp;Spring事务管理器的接口是PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。接口如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line"></span><br><span class="line">    // 由TransactionDefinition得到TransactionStatus对象</span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    // 提交</span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    // 回滚</span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="1-1-1-JDBC事务"><a href="#1-1-1-JDBC事务" class="headerlink" title="1.1.1 JDBC事务"></a>1.1.1 JDBC事务</h3><p>&emsp;&emsp;如果应用程序中直接使用JDBC来进行持久化，<code>DataSourceTransactionManager</code>会处理事务边界。实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p>
<h3 id="1-1-2-Hibernate事务"><a href="#1-1-2-Hibernate事务" class="headerlink" title="1.1.2 Hibernate事务"></a>1.1.2 Hibernate事务</h3><p>&emsp;&emsp;如果应用程序的持久化是通过Hibernate实现的，需要使用<code>HibernateTransactionManager</code>。sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p>
<h3 id="1-1-3-Java持久化API事务（JPA）"><a href="#1-1-3-Java持久化API事务（JPA）" class="headerlink" title="1.1.3 Java持久化API事务（JPA）"></a>1.1.3 Java持久化API事务（JPA）</h3><p>&emsp;&emsp;如果使用JPA的话，那你需要使用Spring的<code>JpaTransactionManager</code>来处理事务。JpaTransactionManager只需要装配一个JPA实体管理工厂（javax.persistence.EntityManagerFactory接口的任意实现）。JpaTransactionManager将与由工厂所产生的JPA EntityManager合作来构建事务。</p>
<h3 id="1-1-4-Java原生API事务"><a href="#1-1-4-Java原生API事务" class="headerlink" title="1.1.4 Java原生API事务"></a>1.1.4 Java原生API事务</h3><p>&emsp;&emsp;如果没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），就需要使用<code>JtaTransactionManager</code>。JtaTransactionManager将事务管理的责任委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象，其中事务成功完成通过UserTransaction.commit()方法提交，事务失败通过UserTransaction.rollback()方法回滚。</p>
<p>&emsp;&emsp;</p>
<h2 id="1-2-基本事务属性的定义"><a href="#1-2-基本事务属性的定义" class="headerlink" title="1.2 基本事务属性的定义"></a>1.2 基本事务属性的定义</h2><p>&emsp;&emsp;事务管理器接口<code>PlatformTransactionManager</code>通过<code>getTransaction(TransactionDefinition definition)</code>方法来得到事务，这个方法里面的参数是TransactionDefinition类，这个类就定义了一些基本的事务属性。<br>&emsp;&emsp;事务属性包含了5个方面： </p>
<blockquote>
<p>（1）传播行为<br>（2）隔离规则<br>（3）是否只读<br>（4）事务超时<br>（5）回滚规则</p>
</blockquote>
<p>&emsp;&emsp;TransactionDefinition接口内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line"></span><br><span class="line">    // 返回事务的传播行为int（每一个int代表不同的传播行为）</span><br><span class="line">    int getPropagationBehavior();  </span><br><span class="line"></span><br><span class="line">    // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span><br><span class="line">    getIsolationLevel();      </span><br><span class="line"></span><br><span class="line">    // 返回事务必须在多少秒内完成</span><br><span class="line">    int getTimeout();             </span><br><span class="line"></span><br><span class="line">    // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span><br><span class="line">    boolean isReadOnly();         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-1-传播行为"><a href="#1-2-1-传播行为" class="headerlink" title="1.2.1 传播行为"></a>1.2.1 传播行为</h3><p>&emsp;&emsp;事务属性的第一个方面是传播行为。当一个事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，在新事物中运行。<br>&emsp;&emsp;Spring定义了七种传播行为：</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td align="left">表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务。</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td align="left">表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td align="left">表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRED_NEW</td>
<td align="left">表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td align="left">表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td align="left">表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td align="left">表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务</td>
</tr>
</tbody></table>
<p>（1）<strong>PROPAGATION_REQUIRED</strong> 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//事务属性 PROPAGATION_REQUIRED</span><br><span class="line">methodA&#123;</span><br><span class="line">    ……</span><br><span class="line">    methodB();</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//事务属性 PROPAGATION_REQUIRED</span><br><span class="line">methodB&#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;使用spring声明式事务，spring使用AOP来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。<br>&emsp;&emsp;单独调用methodB方法相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection con=null; </span><br><span class="line"> try&#123; </span><br><span class="line">     con = getConnection(); </span><br><span class="line">     con.setAutoCommit(false); </span><br><span class="line"></span><br><span class="line">     //方法调用</span><br><span class="line">     methodB(); </span><br><span class="line"></span><br><span class="line">     //提交事务</span><br><span class="line">     con.commit(); </span><br><span class="line"> &#125; Catch(RuntimeException ex) &#123; </span><br><span class="line">     //回滚事务</span><br><span class="line">     con.rollback();   </span><br><span class="line"> &#125; finally &#123; </span><br><span class="line">     //释放资源</span><br><span class="line">     closeCon(); </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Spring保证在methodB方法中所有的调用都会得到一个相同的连接。在调用methodB时，环境中没有一个存在的事务，所以获得一个新的连接，开启了一个新的事务，让methodB在这个事务中运行。<br>&emsp;&emsp;调用methodA时，在methodA内又会调用methodB。执行效果相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection con = null; </span><br><span class="line"> try&#123; </span><br><span class="line">     con = getConnection(); </span><br><span class="line">     methodA(); </span><br><span class="line">     con.commit(); </span><br><span class="line"> &#125; catch(RuntimeException ex) &#123; </span><br><span class="line">     con.rollback(); </span><br><span class="line"> &#125; finally &#123;    </span><br><span class="line">     closeCon(); </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;调用methodA时，环境中没有事务，所以开启一个新的事务。当在methodA中调用methodB时，环境中已经有了一个事务，所以methodB就加入当前事务，不需要新开一个事务。</p>
<p>（2）<strong>PROPAGATION_SUPPORTS</strong> 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行（不创建事务）。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。</p>
<p>（3）<strong>PROPAGATION_MANDATORY</strong> 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
<p>（4）<strong>PROPAGATION_REQUIRES_NEW</strong> 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//事务属性 PROPAGATION_REQUIRED</span><br><span class="line">methodA()&#123;</span><br><span class="line">    doSomeThingA();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomeThingB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//事务属性 PROPAGATION_REQUIRES_NEW</span><br><span class="line">methodB()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;调用A方法相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   TransactionManager tm = null;</span><br><span class="line">    try&#123;</span><br><span class="line">        //获得一个JTA事务管理器</span><br><span class="line">        tm = getTransactionManager();</span><br><span class="line">        tm.begin(); //开启一个新的事务</span><br><span class="line">        Transaction ts1 = tm.getTransaction();</span><br><span class="line">        doSomeThingA();</span><br><span class="line">        tm.suspend();//挂起当前事务</span><br><span class="line">        try&#123;</span><br><span class="line">            tm.begin();//重新开启第二个事务</span><br><span class="line">            Transaction ts2 = tm.getTransaction();</span><br><span class="line">            methodB();</span><br><span class="line">            ts2.commit();//提交第二个事务</span><br><span class="line">        &#125; Catch(RunTimeException ex) &#123;</span><br><span class="line">            ts2.rollback();//回滚第二个事务</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放资源</span><br><span class="line">        &#125;</span><br><span class="line">        //methodB执行完后，恢复第一个事务</span><br><span class="line">        tm.resume(ts1);</span><br><span class="line">        doSomeThingB();</span><br><span class="line">        ts1.commit();//提交第一个事务</span><br><span class="line">    &#125; catch(RunTimeException ex) &#123;</span><br><span class="line">        ts1.rollback();//回滚第一个事务</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放资源</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这里，把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。Ts2是否成功并不依赖于 ts1。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了methodB之外的其它代码导致的结果却被回滚了。使用PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager作为事务管理器。</p>
<p>（5）<strong>PROPAGATION_NOT_SUPPORTED</strong> 总是非事务地执行，并挂起任何存在的事务。使用PROPAGATION_NOT_SUPPORTED,也需要使用JtaTransactionManager作为事务管理器。</p>
<p>（6）<strong>PROPAGATION_NEVER</strong> 总是非事务地执行，如果存在一个活动事务，则抛出异常。</p>
<p>（7）<strong>PROPAGATION_NESTED</strong> 如果有一个活动的事务存在，则运行在一个嵌套的事务中；如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。<br>&emsp;&emsp;这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。需要JDBC 驱动的java.sql.Savepoint类。有一些JTA的事务管理器实现可能也提供了同样的功能。使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true;而 nestedTransactionAllowed属性值默认为false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//事务属性 PROPAGATION_REQUIRED</span><br><span class="line">methodA()&#123;</span><br><span class="line">    doSomeThingA();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomeThingB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//事务属性 PROPAGATION_NESTED</span><br><span class="line">methodB()&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果单独调用methodB方法，则按REQUIRED属性执行。如果调用methodA方法，相当于下面的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection con = null;</span><br><span class="line"> Savepoint savepoint = null;</span><br><span class="line"> try&#123;</span><br><span class="line">     con = getConnection();</span><br><span class="line">     con.setAutoCommit(false);</span><br><span class="line">     doSomeThingA();</span><br><span class="line">     savepoint = con2.setSavepoint();</span><br><span class="line">     try&#123;</span><br><span class="line">         methodB();</span><br><span class="line">     &#125; catch(RuntimeException ex) &#123;</span><br><span class="line">         con.rollback(savepoint);</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         //释放资源</span><br><span class="line">     &#125;</span><br><span class="line">     doSomeThingB();</span><br><span class="line">     con.commit();</span><br><span class="line"> &#125; catch(RuntimeException ex) &#123;</span><br><span class="line">     con.rollback();</span><br><span class="line"> &#125; finally &#123;</span><br><span class="line">     //释放资源</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;当methodB方法调用之前，调用setSavepoint方法，保存当前的状态到savepoint。如果methodB方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括methodB方法的所有操作。<br>&emsp;&emsp;嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</p>
<p>&emsp;&emsp;PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别：<br>&emsp;&emsp;• 它们非常类似，都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。<br>&emsp;&emsp;• 使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTA TrasactionManager实现可能有不同的支持方式。<br>&emsp;&emsp;• PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务。这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。<br>&emsp;&emsp;• 另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 嵌套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 嵌套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。<br>&emsp;&emsp;由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.<br>&emsp;&emsp;PROPAGATION_REQUIRED应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。</p>
<p>&emsp;&emsp;</p>
<h3 id="1-2-2-隔离级别"><a href="#1-2-2-隔离级别" class="headerlink" title="1.2.2 隔离级别"></a>1.2.2 隔离级别</h3><p>&emsp;&emsp;事务的第二个维度就是隔离级别。隔离级别定义了一个事务可能受其他并发事务影响的程度。</p>
<h5 id="1-2-2-1并发事务引起的问题"><a href="#1-2-2-1并发事务引起的问题" class="headerlink" title="1.2.2.1并发事务引起的问题"></a>1.2.2.1并发事务引起的问题</h5><p>&emsp;&emsp;在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致以下的问题。</p>
<p>&emsp;&emsp;<strong>脏读（Dirty reads）</strong><br>&emsp;&emsp;脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p>
<p>&emsp;&emsp;<strong>不可重复读（Nonrepeatable read）</strong><br>&emsp;&emsp;不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，数据被另一个事务修改并提交了。例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。<br>&emsp;&emsp;不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了另一个事务提交的数据。</p>
<p>&emsp;&emsp;<strong>幻读（Phantom read）</strong><br>&emsp;&emsp;幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。<br>&emsp;&emsp;幻读和不可重复读都是读取了另一条已经提交的事务（这点脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
<p>&emsp;&emsp;不可重复读与幻读的区别<br>&emsp;&emsp;1）不可重复读的重点是修改： 同样的条件, 读取过的数据, 再次读取出来发现值不一样了 。<br>&emsp;&emsp;2）幻读的重点在于新增或者删除： 同样的条件, 第1次和第2次读出来的记录数不一样（针对的是一批数据） 。 </p>
<p>&emsp;&emsp;从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果从控制的角度来看, 两者的区别就比较大。<br>&emsp;&emsp;对于不可重复读, 只需要锁住满足条件的记录。 对于幻读, 要锁住满足条件及其相近的记录。</p>
<h5 id="1-2-2-2隔离级别"><a href="#1-2-2-2隔离级别" class="headerlink" title="1.2.2.2隔离级别"></a>1.2.2.2隔离级别</h5><table>
<thead>
<tr>
<th>隔离级别</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td align="left">使用后端数据库默认的隔离级别</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td align="left">最低的隔离级别，允许读取尚未提交的数据变更。可能会导致脏读、幻读或不可重复读</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td align="left">允许读取并发事务已经提交的数据。可以阻止脏读，但是幻读或不可重复读仍有可能发生</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td align="left">对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td align="left">最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</td>
</tr>
</tbody></table>
<h3 id="1-2-3-只读"><a href="#1-2-3-只读" class="headerlink" title="1.2.3 只读"></a>1.2.3 只读</h3><p>&emsp;&emsp;事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读。</p>
<h3 id="1-2-4-事务超时"><a href="#1-2-4-事务超时" class="headerlink" title="1.2.4 事务超时"></a>1.2.4 事务超时</h3><p>&emsp;&emsp;为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</p>
<h3 id="1-2-5-回滚规则"><a href="#1-2-5-回滚规则" class="headerlink" title="1.2.5 回滚规则"></a>1.2.5 回滚规则</h3><p>&emsp;&emsp;事务的回滚规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。<br>默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚。<br>但是可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p>
<p>&emsp;&emsp;</p>
<h2 id="1-3-事务状态"><a href="#1-3-事务状态" class="headerlink" title="1.3 事务状态"></a>1.3 事务状态</h2><p>&emsp;&emsp;调用PlatformTransactionManager接口的getTransaction()的方法得到的是TransactionStatus接口的一个实现，这个接口的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface TransactionStatus &#123;</span><br><span class="line">    boolean isNewTransaction();     　　// 是否是新的事务</span><br><span class="line">    boolean hasSavepoint();        　 　// 是否有恢复点</span><br><span class="line">    void setRollbackOnly();         　　// 设置为只回滚</span><br><span class="line">    boolean isRollbackOnly();      　   // 是否为只回滚</span><br><span class="line">    boolean isCompleted;          　    // 是否已完成</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。</p>
<h1 id="2-编程式事务"><a href="#2-编程式事务" class="headerlink" title="2.编程式事务"></a>2.编程式事务</h1><h2 id="2-1-编程式和声明式事务的区别"><a href="#2-1-编程式和声明式事务的区别" class="headerlink" title="2.1 编程式和声明式事务的区别"></a>2.1 编程式和声明式事务的区别</h2><p>&emsp;&emsp;Spring提供了对编程式事务和声明式事务的支持。<br>&emsp;&emsp;编程式事务 ：允许用户在代码中精确定义事务的边界。<br>&emsp;&emsp;声明式事务（基于AOP）：有助于用户将操作与事务规则进行解耦。<br>&emsp;&emsp;简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。</p>
<h2 id="2-2-如何实现编程式事务？"><a href="#2-2-如何实现编程式事务？" class="headerlink" title="2.2 如何实现编程式事务？"></a>2.2 如何实现编程式事务？</h2><p>&emsp;&emsp;Spring提供两种方式的编程式事务管理，分别是：<br>&emsp;&emsp;（1）使用TransactionTemplate<br>&emsp;&emsp;（2）直接使用PlatformTransactionManager</p>
<h3 id="2-2-1-使用TransactionTemplate"><a href="#2-2-1-使用TransactionTemplate" class="headerlink" title="2.2.1 使用TransactionTemplate"></a>2.2.1 使用TransactionTemplate</h3><p>&emsp;&emsp;采用TransactionTemplate和采用其他Spring模板，如JdbcTempalte和HibernateTemplate是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate是线程安全的。代码片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 新建一个TransactionTemplate</span><br><span class="line">TransactionTemplate tt = new TransactionTemplate(); </span><br><span class="line">Object result = tt.execute(</span><br><span class="line">    new TransactionCallback()&#123;  </span><br><span class="line">        public Object doTransaction(TransactionStatus status)&#123;  </span><br><span class="line">            updateOperation();  </span><br><span class="line">            return resultOfUpdateOperation();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;); // 执行execute方法进行事务管理</span><br></pre></td></tr></table></figure>
<p>使用TransactionCallback()可以返回一个值。如果使用TransactionCallbackWithoutResult则没有返回值。</p>
<h3 id="2-2-2-使用PlatformTransactionManager"><a href="#2-2-2-使用PlatformTransactionManager" class="headerlink" title="2.2.2 使用PlatformTransactionManager"></a>2.2.2 使用PlatformTransactionManager</h3><p>&emsp;&emsp;示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个某个框架平台的TransactionManager，如JDBC、Hibernate</span><br><span class="line">DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); </span><br><span class="line">// 设置数据源</span><br><span class="line">dataSourceTransactionManager.setDataSource(this.getJdbcTemplate().getDataSource()); </span><br><span class="line">// 定义事务属性</span><br><span class="line">DefaultTransactionDefinition transDef = new DefaultTransactionDefinition(); </span><br><span class="line">// 设置传播行为属性</span><br><span class="line">transDef.setPropagationBehavior(DefaultTransactionDefinition.PROPAGATION_REQUIRED); </span><br><span class="line">// 获得事务状态</span><br><span class="line">TransactionStatus status = dataSourceTransactionManager.getTransaction(transDef); </span><br><span class="line">try &#123;</span><br><span class="line">    // 数据库操作</span><br><span class="line">    // 提交</span><br><span class="line">    dataSourceTransactionManager.commit(status);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 回滚</span><br><span class="line">    dataSourceTransactionManager.rollback(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;</p>
<h1 id="3-声明式事务"><a href="#3-声明式事务" class="headerlink" title="3.声明式事务"></a>3.声明式事务</h1><p>&emsp;&emsp;一般使用@Transactional注解的方式，当然需要先注册TransactionManager 这个Bean。<br>&emsp;&emsp;@Transactional注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface Transactional &#123;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;transactionManager&quot;)</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String transactionManager() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    Propagation propagation() default Propagation.REQUIRED;</span><br><span class="line"></span><br><span class="line">    Isolation isolation() default Isolation.DEFAULT;</span><br><span class="line"></span><br><span class="line">    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;</span><br><span class="line"></span><br><span class="line">    boolean readOnly() default false;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] rollbackForClassName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] noRollbackForClassName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;@Transactional(propagation&#x3D;Propagation.REQUIRED) 指定事务传播行为。Propagation取值：</p>
<blockquote>
<p>　　REQUIRED（默认值）：代表当前方法支持当前的事务，且与调用者处于同一事务上下文中，回滚统一回滚（如果当前方法是被其他方法调用的时候，且调用者本身即有事务），如果没有事务，则自己新建事务，<br>　　SUPPORTS：代表当前方法支持当前的事务，且与调用者处于同一事务上下文中，回滚统一回滚（如果当前方法是被其他方法调用的时候，且调用者本身即有事务），如果没有事务，则该方法在非事务的上下文中执行<br>　　MANDATORY：代表当前方法支持当前的事务，且与调用者处于同一事务上下文中，回滚统一回滚（如果当前方法是被其他方法调用的时候，且调用者本身即有事务）,如果没有事务，则抛出异常<br>　　REQUIRES_NEW：创建一个新的事务上下文，如果当前方法的调用者已经有了事务，则挂起调用者的事务，这两个事务不处于同一上下文，如果各自发生异常，各自回滚。<br>　　NOT_SUPPORTED：该方法以非事务的状态执行，如果调用该方法的调用者有事务则先挂起调用者的事务。<br>　　NEVER： 该方法以非事务的状态执行，如果调用者存在事务，则抛出异常。<br>　　NESTED：如果当前上下文中存在事务，则以嵌套事务执行该方法，也就说，这部分方法是外部方法的一部分，调用者回滚，则该方法回滚，但如果该方法自己发生异常，则自己回滚，不会影响外部事务，如果不存在事务，则与PROPAGATION_REQUIRED一样。</p>
</blockquote>
<p>&emsp;&emsp; timeout 设置事物超时设置，默认是30秒<br>　　isolation 设置事务隔离级别。Isolation.READ_UNCOMMITTED读取未提交数据(会出现脏读, 不可重复读) 基本不使用；Isolation.READ_COMMITTED 读取已提交数据(会出现不可重复读和幻读)；Isolation.REPEATABLE_READ可重复读(会出现幻读)；Isolation.SERIALIZABLE)串行化。<br>　　readOnly 该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。<br>　　rollbackFor 该属性用于设置需要进行回滚的异常类，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如：@Transactional(rollbackFor&#x3D;RuntimeException.class)。<br>　　rollbackForClassNam 该属性用于设置需要进行回滚的异常类名称，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。@Transactional(rollbackForClassName&#x3D;”RuntimeException”)。<br>　　noRollbackFor该属性用于设置不需要进行回滚的异常类，当方法中抛出指定异常数组中的<br>　　noRollbackForClassName该属性用于设置不需要进行回滚的异常类名称，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。</p>
<p>注意的几点:<br>　　1、@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能.<br>　　2、用 Spring 事务管理器,由Spring来负责数据库的打开,提交,回滚.默认遇到运行期例外(throw new RuntimeException();)会回滚，而遇到需要捕获的例外(throw new Exception(“”);)不会回滚。当需要用指定方式来让事务回滚要想所有异常都回滚,要加上 @Transactional( rollbackFor&#x3D;{Exception.class})。<br>　　3、Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。</p>
<p>&emsp;&emsp;Spring Boot 使用事务非常简单，首先使用注解@EnableTransactionManagement开启事务支持后，然后在Service方法上添加注解@Transactional便可。@EnableTransactionManagement，启注解事务管理等同于xml配置方式的<code> &lt;tx:annotation-driven /&gt;</code></p>
<p><strong>@Transactional注解工作原理</strong><br>　　运行配置@Transactional注解的类的时候，具体会发生如下步骤:<br>　　1)事务开始时，通过AOP机制，生成一个代理connection对象，并将其放入DataSource实例的某个与DataSourceTransactionManager相关的某处容器中。在接下来的整个事务中，客户代码都应该使用该connection连接数据库，执行所有数据库命令[不使用该connection连接数据库执行的数据库命令，在本事务回滚的时候得不到回滚]。<br>　　2)事务结束时，回滚在第1步骤中得到的代理connection对象上执行的数据库命令，然后关闭该代理connection对象。<br>&emsp;&emsp;<br>&emsp;&emsp;@Transactional注解使用示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   /**</span><br><span class="line">     * 1.添加事务注解</span><br><span class="line">     * 使用 propagation 指定事务的传播行为，即当前的事务方法被另外一个事务方法调用时如何使用事务。</span><br><span class="line">     * 默认取值为REQUIRED，即使用调用方法的事务</span><br><span class="line">     * REQUIRES_NEW：使用自己的事务，调用的事务方法的事务被挂起。</span><br><span class="line">     *</span><br><span class="line">     * 2.使用 isolation 指定事务的隔离级别，最常用的取值为READ_COMMITTED</span><br><span class="line">     * 3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚，也可以通过对应的属性进行设置。通常情况下，默认值即可。</span><br><span class="line">     * 4.使用 readOnly 指定事务是否为只读。 表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优化事务。若真的是一个只读取数据库值得方法，应设置readOnly=true</span><br><span class="line">     * 5.使用 timeOut 指定强制回滚之前事务可以占用的时间。</span><br><span class="line">     */@Transactional(propagation=Propagation.REQUIRES_NEW,</span><br><span class="line">            isolation=Isolation.READ_COMMITTED,</span><br><span class="line">            noRollbackFor=&#123;UserAccountException.class&#125;,</span><br><span class="line">            readOnly=true, timeout=3)</span><br><span class="line">    @Override</span><br><span class="line">    public void purchase(String username, String isbn) &#123;</span><br><span class="line">        //1.获取书的单价int price = bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">        //2.更新书的库存</span><br><span class="line">        bookShopDao.updateBookStock(isbn);</span><br><span class="line">        //3.更新用户余额</span><br><span class="line">        bookShopDao.updateUserAccount(username, price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>转载自：<br><a href="https://www.cnblogs.com/yixianyixian/p/8372832.html">https://www.cnblogs.com/yixianyixian/p/8372832.html</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>事务</category>
      </categories>
  </entry>
  <entry>
    <title>Spring声明式事务注意事项</title>
    <url>/2024/03/20/Spring/%E4%BA%8B%E5%8A%A1/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="Transactional-生效原则-1"><a href="#Transactional-生效原则-1" class="headerlink" title="@Transactional 生效原则 1"></a>@Transactional 生效原则 1</h3><p>除非特殊配置（比如使用 AspectJ 静态织入实现 AOP），否则只有定义在 public 方法上的 @Transactional 才能生效。</p>
<h3 id="Transactional-生效原则-2"><a href="#Transactional-生效原则-2" class="headerlink" title="@Transactional 生效原则 2"></a>@Transactional 生效原则 2</h3><p>必须通过代理过的类从外部调用目标方法才能生效。</p>
<h3 id="Transactional-生效原则-3"><a href="#Transactional-生效原则-3" class="headerlink" title="@Transactional 生效原则 3"></a>@Transactional 生效原则 3</h3><p>第一，只有异常传播出了标记了 @Transactional 注解的方法，事务才能回滚；<br>默认情况下，出现 RuntimeException（非受检异常）或 Error 的时候，Spring 才会回滚事务。</p>
<p>如果希望自己捕获异常进行处理的话，可以手动设置让当前事务处于回滚状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">public void createUserRight1(String name) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        userRepository.save(new UserEntity(name));</span><br><span class="line">        throw new RuntimeException(&quot;error&quot;);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        log.error(&quot;create user failed&quot;, ex);</span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Transactional-生效原则-4"><a href="#Transactional-生效原则-4" class="headerlink" title="@Transactional 生效原则 4"></a>@Transactional 生效原则 4</h3><p>确认事务传播配置是否符合自己的业务逻辑有这么一个场景：<br>一个用户注册的操作，会插入一个主用户到用户表，还会注册一个关联的子用户。我们希望将子用户注册的数据库操作作为一个独立事务来处理，即使失败也不会影响主流程，即不影响主用户的注册。接下来，我们模拟一个实现类似业务逻辑的 UserService：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private SubUserService subUserService;</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">public void createUserWrong(UserEntity entity) &#123;</span><br><span class="line">    createMainUser(entity);</span><br><span class="line">    subUserService.createSubUserWithExceptionWrong(entity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void createMainUser(UserEntity entity) &#123;</span><br><span class="line">    userRepository.save(entity);</span><br><span class="line">    log.info(&quot;createMainUser finish&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SubUserService 的 createSubUserWithExceptionWrong 实现正如其名，因为最后我们抛出了一个运行时异常，错误原因是用户状态无效，所以子用户的注册肯定是失败的。我们期望子用户的注册作为一个事务单独回滚，不影响主用户的注册，这样的逻辑可以实现吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">public class SubUserService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void createSubUserWithExceptionWrong(UserEntity entity) &#123;</span><br><span class="line">        log.info(&quot;createSubUserWithExceptionWrong start&quot;);</span><br><span class="line">        userRepository.save(entity);</span><br><span class="line">        throw new RuntimeException(&quot;invalid status&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 Controller 里实现一段测试代码，调用 UserService：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@GetMapping(&quot;wrong&quot;)</span><br><span class="line">public int wrong(@RequestParam(&quot;name&quot;) String name) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        userService.createUserWrong(new UserEntity(name));</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        log.error(&quot;createUserWrong failed, reason:&#123;&#125;&quot;, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    return userService.getUserCount(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用后可以在日志中发现如下信息，很明显事务回滚了，最后 Controller 打出了创建子用户抛出的运行时异常：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[22:50:42.866] [http-nio-45678-exec-8] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :555 ] - Rolling back JPA transaction on EntityManager [SessionImpl(103972212&lt;open&gt;)]</span><br><span class="line">[22:50:42.869] [http-nio-45678-exec-8] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :620 ] - Closing JPA EntityManager [SessionImpl(103972212&lt;open&gt;)] after transaction</span><br><span class="line">[22:50:42.869] [http-nio-45678-exec-8] [ERROR] [t.d.TransactionPropagationController:23  ] - createUserWrong failed, reason:invalid status</span><br></pre></td></tr></table></figure>

<p>你马上就会意识到，不对呀，因为运行时异常逃出了 @Transactional 注解标记的 createUserWrong 方法，Spring 当然会回滚事务了。如果我们希望主方法不回滚，应该把子方法抛出的异常捕获了。也就是这么改，把 subUserService.createSubUserWithExceptionWrong 包裹上 catch，这样外层主方法就不会出现异常了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">public void createUserWrong2(UserEntity entity) &#123;</span><br><span class="line">    createMainUser(entity);</span><br><span class="line">    try&#123;</span><br><span class="line">        subUserService.createSubUserWithExceptionWrong(entity);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        // 虽然捕获了异常，但是因为没有开启新事务，而当前事务因为异常已经被标记为rollback了，所以最终还是会回滚。</span><br><span class="line">        log.error(&quot;create sub user error:&#123;&#125;&quot;, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序后可以看到如下日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[22:57:21.722] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :370 ] - Creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo3.UserService.createUserWrong2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">[22:57:21.739] [http-nio-45678-exec-3] [INFO ] [t.c.transaction.demo3.SubUserService:19  ] - createSubUserWithExceptionWrong start</span><br><span class="line">[22:57:21.739] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :356 ] - Found thread-bound EntityManager [SessionImpl(1794007607&lt;open&gt;)] for JPA transaction</span><br><span class="line">[22:57:21.739] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :471 ] - Participating in existing transaction</span><br><span class="line">[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :843 ] - Participating transaction failed - marking existing transaction as rollback-only</span><br><span class="line">[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :580 ] - Setting JPA transaction on EntityManager [SessionImpl(1794007607&lt;open&gt;)] rollback-only</span><br><span class="line">[22:57:21.740] [http-nio-45678-exec-3] [ERROR] [.g.t.c.transaction.demo3.UserService:37  ] - create sub user error:invalid status</span><br><span class="line">[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :741 ] - Initiating transaction commit</span><br><span class="line">[22:57:21.740] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :529 ] - Committing JPA transaction on EntityManager [SessionImpl(1794007607&lt;open&gt;)]</span><br><span class="line">[22:57:21.743] [http-nio-45678-exec-3] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :620 ] - Closing JPA EntityManager [SessionImpl(1794007607&lt;open&gt;)] after transaction</span><br><span class="line">[22:57:21.743] [http-nio-45678-exec-3] [ERROR] [t.d.TransactionPropagationController:33  ] - createUserWrong2 failed, reason:Transaction silently rolled back because it has been marked as rollback-only</span><br><span class="line">org.springframework.transaction.UnexpectedRollbackException: Transaction silently rolled back because it has been marked as rollback-only</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>需要注意以下几点：<br>如第 1 行所示，对 createUserWrong2 方法开启了异常处理；<br>如第 5 行所示，子方法因为出现了运行时异常，标记当前事务为回滚；<br>如第 7 行所示，主方法的确捕获了异常打印出了 create sub user error 字样；如第 9 行所示，主方法提交了事务；<br>奇怪的是，如第 11 行和 12 行所示，Controller 里出现了一个 UnexpectedRollbackException，异常描述提示最终这个事务回滚了，而且是静默回滚的。之所以说是静默，是因为 createUserWrong2 方法本身并没有出异常，只不过提交后发现子方法已经把当前事务设置为了回滚，无法完成提交。</p>
<p>这挺反直觉的。我们之前说，出了异常事务不一定回滚，这里说的却是不出异常，事务也不一定可以提交。原因是，主方法注册主用户的逻辑和子方法注册子用户的逻辑是同一个事务，子逻辑标记了事务需要回滚，主逻辑自然也不能提交了。</p>
<p>看到这里，修复方式就很明确了，想办法让子逻辑在独立事务中运行，也就是改一下 SubUserService 注册子用户的方法，为注解加上 propagation &#x3D; Propagation.REQUIRES_NEW 来设置 REQUIRES_NEW 方式的事务传播策略，也就是执行到这个方法时需要开启新的事务，并挂起当前事务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">public void createSubUserWithExceptionRight(UserEntity entity) &#123;</span><br><span class="line">    log.info(&quot;createSubUserWithExceptionRight start&quot;);</span><br><span class="line">    userRepository.save(entity);</span><br><span class="line">    throw new RuntimeException(&quot;invalid status&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主方法没什么变化，同样需要捕获异常，防止异常漏出去导致主事务回滚，重新命名为 createUserRight：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">public void createUserRight(UserEntity entity) &#123;</span><br><span class="line">    createMainUser(entity);</span><br><span class="line">    try&#123;</span><br><span class="line">        subUserService.createSubUserWithExceptionRight(entity);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        // 捕获异常，防止主方法回滚</span><br><span class="line">        log.error(&quot;create sub user error:&#123;&#125;&quot;, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造后，重新运行程序可以看到如下的关键日志：<br>第 1 行日志提示我们针对 createUserRight 方法开启了主方法的事务；<br>第 2 行日志提示创建主用户完成；<br>第 3 行日志可以看到主事务挂起了，开启了一个新的事务，针对 createSubUserWithExceptionRight 方案，也就是我们的创建子用户的逻辑；<br>第 4 行日志提示子方法事务回滚；<br>第 5 行日志提示子方法事务完成，继续主方法之前挂起的事务；<br>第 6 行日志提示主方法捕获到了子方法的异常；<br>第 8 行日志提示主方法的事务提交了，随后我们在 Controller 里没看到静默回滚的异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[23:17:20.935] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :370 ] - Creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo3.UserService.createUserRight]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">[23:17:21.079] [http-nio-45678-exec-1] [INFO ] [.g.t.c.transaction.demo3.UserService:55  ] - createMainUser finish</span><br><span class="line">[23:17:21.082] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :420 ] - Suspending current transaction, creating new transaction with name [org.geekbang.time.commonmistakes.transaction.demo3.SubUserService.createSubUserWithExceptionRight]</span><br><span class="line">[23:17:21.153] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :834 ] - Initiating transaction rollback</span><br><span class="line">[23:17:21.160] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :1009] - Resuming suspended transaction after completion of inner transaction</span><br><span class="line">[23:17:21.161] [http-nio-45678-exec-1] [ERROR] [.g.t.c.transaction.demo3.UserService:49  ] - create sub user error:invalid status</span><br><span class="line">[23:17:21.161] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :741 ] - Initiating transaction commit</span><br><span class="line">[23:17:21.161] [http-nio-45678-exec-1] [DEBUG] [o.s.orm.jpa.JpaTransactionManager       :529 ] - Committing JPA transaction on EntityManager [SessionImpl(396441411&lt;open&gt;)]</span><br></pre></td></tr></table></figure>
<p>运行测试程序看到如下结果，getUserCount 得到的用户数量为 1，代表只有一个用户也就是主用户注册完成了，符合预期。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>事务</category>
      </categories>
  </entry>
  <entry>
    <title>自定义类型转换-表单请求或JSON请求的转换器</title>
    <url>/2024/04/01/Spring/spring%20boot/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E8%A1%A8%E5%8D%95%E8%AF%B7%E6%B1%82%E6%88%96JSON%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
    <content><![CDATA[<h2 id="表单类型参数"><a href="#表单类型参数" class="headerlink" title="表单类型参数"></a>表单类型参数</h2><p>有时候需要将前台传来一些特定格式的数据对象转化成特定的Java对象，这个时候类型转换器就派上用场了。这里简单介绍使用比较简单的Converter接口。Converter是Spring 3.0后的一个函数式接口，只有一个方法，将source转化成target。</p>
<p>首先需要定义自己的转换器，需要实现Converter&lt;S,T&gt;接口，convert就是具体的转换方法。</p>
<p>一般推荐使用<code>ConditionalGenericConverter</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Set;</span><br><span class="line">import org.springframework.core.convert.TypeDescriptor;</span><br><span class="line">import org.springframework.core.convert.converter.ConditionalGenericConverter;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">public class CustomConditionalConverter implements ConditionalGenericConverter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) &#123;</span><br><span class="line">        return targetType.hasAnnotation(Key.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;ConvertiblePair&gt; getConvertibleTypes() &#123;</span><br><span class="line">        // getConvertibleTypes方法返回可转换的源类型和目标类型的配对，</span><br><span class="line">        // 如果只关心，字符串类型的转换。</span><br><span class="line">        // return Collections.singleton(new ConvertiblePair(String.class, String.class));</span><br><span class="line"></span><br><span class="line">        // 如果全部都关注</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) &#123;</span><br><span class="line">        if (source == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Key annotation = targetType.getAnnotation(Key.class);</span><br><span class="line">        try &#123;</span><br><span class="line">            return annotation.using().newInstance().convert(source);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要将自定义的转换器进行注册：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CustomWebMvcConfig extends WebMvcConfigurerAdapter&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">	    registry.addConverter(new CustomConditionalConverter());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Key &#123;</span><br><span class="line">    Class&lt;? extends Convert&gt; using();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Convert&lt;T, P&gt; &#123;</span><br><span class="line">    abstract P convert(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="JSON类型参数"><a href="#JSON类型参数" class="headerlink" title="JSON类型参数"></a>JSON类型参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.annotation.JsonDeserialize;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReq</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonDeserialize(using = DateDeserializer.class)</span></span><br><span class="line">    <span class="keyword">private</span> Integer createTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonParser;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.DeserializationContext;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonDeserializer;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDeserializer</span> <span class="keyword">extends</span> <span class="title class_">JsonDeserializer</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">deserialize</span><span class="params">(JsonParser parser, DeserializationContext context)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> parser.getValueAsString();</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, Locale.CHINA);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(dateStr, formatter);</span><br><span class="line">        <span class="type">long</span> <span class="variable">epochSecond</span> <span class="operator">=</span> parse.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)epochSecond;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>表单类型：通过继承<code>Converter</code>配置自定义参数转换器。</li>
<li>JSON类型：配置自定义的Jackson反序列化器。</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>Spring事务源码解析</title>
    <url>/2024/03/20/Spring/%E4%BA%8B%E5%8A%A1/Spring%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Spring的事务属于逻辑事务。不是物理事务。<br>　　Spring并不直接管理事务，而是提供了多种事务管理器，它们将事务管理的职责委托给JDBC或者JTA等持久化机制所提供的相关平台框架的事务来实现。例如JDBC的事物管理器就是<code>DataSourceTransactionManager</code>。<br>　　Spring事务管理器的接口是<code>org.springframework.transaction.PlatformTransactionManager</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">	TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型。</p>
<p>　　Spring Boot 使用事务非常简单，需要<code>@EnableTransactionManagement</code>和<code>@Transactional</code>配合使用。首先使用注解<code>@EnableTransactionManagement </code>开启事务支持后，然后在Service方法上添加注解<code>@Transactional</code>便可。<code>@EnableTransactionManagement</code>，启注解事务管理等同于xml配置方式的 <code>&lt;tx:annotation-driven /&gt;</code>。</p>
<span id="more"></span>

<p>首先是EnableTransactionManagement类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(TransactionManagementConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br></pre></td></tr></table></figure>



<p>这里会import <code>TransactionManagementConfigurationSelector</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagementConfigurationSelector</span> <span class="keyword">extends</span> <span class="title class_">AdviceModeImportSelector</span>&lt;EnableTransactionManagement&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">			<span class="keyword">case</span> PROXY:</span><br><span class="line">			  <span class="comment">// 默认就是 PROXY</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">			<span class="keyword">case</span> ASPECTJ:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME&#125;;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>selectImports</code>会返回两个类：<code>AutoProxyRegistrar</code> 和 <code>ProxyTransactionManagementConfiguration</code>。</p>
<ul>
<li><p><code>AutoProxyRegistrar</code>的作用就是向BeanFactory注册<code>InfrastructureAdvisorAutoProxyCreator.class</code>。而InfrastructureAdvisorAutoProxyCreator继承自AbstractAdvisorAutoProxyCreator，就是让容器支持了AOP。</p>
</li>
<li><p><code>ProxyTransactionManagementConfiguration</code>会加载关键的几个bean：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTransactionManagementConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AbstractTransactionManagementConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	<span class="keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="title function_">transactionAdvisor</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactoryTransactionAttributeSourceAdvisor</span>();</span><br><span class="line">		advisor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">		advisor.setAdvice(transactionInterceptor());</span><br><span class="line">		advisor.setOrder(<span class="built_in">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="string">&quot;order&quot;</span>));</span><br><span class="line">		<span class="keyword">return</span> advisor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	<span class="keyword">public</span> TransactionAttributeSource <span class="title function_">transactionAttributeSource</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationTransactionAttributeSource</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">	<span class="keyword">public</span> TransactionInterceptor <span class="title function_">transactionInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">TransactionInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionInterceptor</span>();</span><br><span class="line">		interceptor.setTransactionAttributeSource(transactionAttributeSource());</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.txManager != <span class="literal">null</span>) &#123;</span><br><span class="line">			interceptor.setTransactionManager(<span class="built_in">this</span>.txManager);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> interceptor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BeanFactoryTransactionAttributeSourceAdvisor：实现了 PointcutAdvisor 接口，组合了TransactionAttributeSourcePointcut。</li>
<li>AnnotationTransactionAttributeSource：解析事务类，得到事务配置相关信息；</li>
<li>TransactionInterceptor：事务拦截器，实现了 Advice、MethodInterceptor 接口。TransactionInterceptor是个环绕增强，在目标方法执行前开启事务，执行完目标方法后，进行事务提交或者回滚；</li>
</ul>
<p><strong>事务代理类的创建</strong></p>
<p>了解Spring AOP应该会熟悉这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="type">boolean</span> hasIntroductions)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">		<span class="type">PointcutAdvisor</span> <span class="variable">pca</span> <span class="operator">=</span> (PointcutAdvisor) advisor;</span><br><span class="line">		<span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// It doesn&#x27;t have a pointcut so we assume it applies.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面 <code>BeanFactoryTransactionAttributeSourceAdvisor</code> 类，该类实现了 PointcutAdvisor 接口，其中的切面 pointcut 便是通过 TransactionAttributeSourcePointcut 来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactoryPointcutAdvisor</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> TransactionAttributeSource transactionAttributeSource;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TransactionAttributeSourcePointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionAttributeSourcePointcut</span>() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> TransactionAttributeSource <span class="title function_">getTransactionAttributeSource</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> transactionAttributeSource;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用路径会到<code>TransactionAttributeSourcePointcut</code>的matches方法，该方法根据能否可以从目标 bean 中得到 TransactionAttribute 来判断是否匹配的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (targetClass != <span class="literal">null</span> &amp;&amp; TransactionalProxy.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line">	<span class="keyword">return</span> (tas == <span class="literal">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的tas即AnnotationTransactionAttributeSource。AnnotationTransactionAttributeSource父类AbstractFallbackTransactionAttributeSource实现了getTransactionAttribute方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TransactionAttribute <span class="title function_">getTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, see if we have a cached value.</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(method, targetClass);</span><br><span class="line">	<span class="type">Object</span> <span class="variable">cached</span> <span class="operator">=</span> <span class="built_in">this</span>.attributeCache.get(cacheKey);</span><br><span class="line">	<span class="keyword">if</span> (cached != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Value will either be canonical value indicating there is no transaction attribute,</span></span><br><span class="line">		<span class="comment">// or an actual transaction attribute.</span></span><br><span class="line">		<span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> (TransactionAttribute) cached;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// We need to work it out.</span></span><br><span class="line">		<span class="comment">//重点，获取事务属性</span></span><br><span class="line">		<span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> computeTransactionAttribute(method, targetClass);</span><br><span class="line">		<span class="comment">// Put it in the cache.</span></span><br><span class="line">		<span class="keyword">if</span> (txAttr == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">methodIdentification</span> <span class="operator">=</span> ClassUtils.getQualifiedMethodName(method, targetClass);</span><br><span class="line">			<span class="keyword">if</span> (txAttr <span class="keyword">instanceof</span> DefaultTransactionAttribute) &#123;</span><br><span class="line">				((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Adding transactional method &#x27;&quot;</span> + methodIdentification + <span class="string">&quot;&#x27; with attribute: &quot;</span> + txAttr);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">this</span>.attributeCache.put(cacheKey, txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> txAttr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看看computeTransactionAttribute方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">computeTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">	<span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">	<span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The method may be on an interface, but we need attributes from the target class.</span></span><br><span class="line">	<span class="comment">// If the target class is null, the method will be unchanged.</span></span><br><span class="line">	<span class="type">Method</span> <span class="variable">specificMethod</span> <span class="operator">=</span> AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First try is the method in the target class.</span></span><br><span class="line">	<span class="comment">//先查找目标方式是否有事务属性</span></span><br><span class="line">	<span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> findTransactionAttribute(specificMethod);</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> txAttr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Second try is the transaction attribute on the target class.</span></span><br><span class="line">	<span class="comment">//再查找目标类是否有事务属性</span></span><br><span class="line">	txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">	<span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">		<span class="keyword">return</span> txAttr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">		<span class="comment">// Fallback is to look at the original method.</span></span><br><span class="line">		txAttr = findTransactionAttribute(method);</span><br><span class="line">		<span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> txAttr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Last fallback is the class of the original method.</span></span><br><span class="line">		txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">		<span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">			<span class="keyword">return</span> txAttr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面可知，方法级别上的注解会覆盖类级别上的注解，两个findTransactionAttribute方法都在AnnotationTransactionAttributeSource实现，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">findTransactionAttribute</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> determineTransactionAttribute(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">findTransactionAttribute</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> determineTransactionAttribute(clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看看determineTransactionAttribute方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">determineTransactionAttribute</span><span class="params">(AnnotatedElement ae)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (TransactionAnnotationParser annotationParser : <span class="built_in">this</span>.annotationParsers) &#123;</span><br><span class="line">		<span class="type">TransactionAttribute</span> <span class="variable">attr</span> <span class="operator">=</span> annotationParser.parseTransactionAnnotation(ae);</span><br><span class="line">		<span class="keyword">if</span> (attr != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> attr;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>annotationParsers集合包含了3个类，分别是SpringTransactionAnnotationParser、JtaTransactionAnnotationParser、Ejb3TransactionAnnotationParser。分别解析不同包的注解，这里的解析类是SpringTransactionAnnotationParser，其parseTransactionAnnotation方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TransactionAttribute <span class="title function_">parseTransactionAnnotation</span><span class="params">(AnnotatedElement ae)</span> &#123;</span><br><span class="line">	<span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> AnnotatedElementUtils.findMergedAnnotationAttributes(</span><br><span class="line">			ae, Transactional.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (attributes != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> parseTransactionAnnotation(attributes);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码讲解析目标元素上@Transactional注解的相关信息，然后封装成AnnotationAttributes类，其继承LinkedHashMap。</p>
<p>看看parseTransactionAnnotation方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">	<span class="type">RuleBasedTransactionAttribute</span> <span class="variable">rbta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuleBasedTransactionAttribute</span>();</span><br><span class="line">	<span class="type">Propagation</span> <span class="variable">propagation</span> <span class="operator">=</span> attributes.getEnum(<span class="string">&quot;propagation&quot;</span>);</span><br><span class="line">	rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">	<span class="type">Isolation</span> <span class="variable">isolation</span> <span class="operator">=</span> attributes.getEnum(<span class="string">&quot;isolation&quot;</span>);</span><br><span class="line">	rbta.setIsolationLevel(isolation.value());</span><br><span class="line">	rbta.setTimeout(attributes.getNumber(<span class="string">&quot;timeout&quot;</span>).intValue());</span><br><span class="line">	rbta.setReadOnly(attributes.getBoolean(<span class="string">&quot;readOnly&quot;</span>));</span><br><span class="line">	rbta.setQualifier(attributes.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">	ArrayList&lt;RollbackRuleAttribute&gt; rollBackRules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;RollbackRuleAttribute&gt;();</span><br><span class="line">	Class&lt;?&gt;[] rbf = attributes.getClassArray(<span class="string">&quot;rollbackFor&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; rbRule : rbf) &#123;</span><br><span class="line">		<span class="type">RollbackRuleAttribute</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RollbackRuleAttribute</span>(rbRule);</span><br><span class="line">		rollBackRules.add(rule);</span><br><span class="line">	&#125;</span><br><span class="line">	String[] rbfc = attributes.getStringArray(<span class="string">&quot;rollbackForClassName&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (String rbRule : rbfc) &#123;</span><br><span class="line">		<span class="type">RollbackRuleAttribute</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RollbackRuleAttribute</span>(rbRule);</span><br><span class="line">		rollBackRules.add(rule);</span><br><span class="line">	&#125;</span><br><span class="line">	Class&lt;?&gt;[] nrbf = attributes.getClassArray(<span class="string">&quot;noRollbackFor&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; rbRule : nrbf) &#123;</span><br><span class="line">		<span class="type">NoRollbackRuleAttribute</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoRollbackRuleAttribute</span>(rbRule);</span><br><span class="line">		rollBackRules.add(rule);</span><br><span class="line">	&#125;</span><br><span class="line">	String[] nrbfc = attributes.getStringArray(<span class="string">&quot;noRollbackForClassName&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (String rbRule : nrbfc) &#123;</span><br><span class="line">		<span class="type">NoRollbackRuleAttribute</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoRollbackRuleAttribute</span>(rbRule);</span><br><span class="line">		rollBackRules.add(rule);</span><br><span class="line">	&#125;</span><br><span class="line">	rbta.getRollbackRules().addAll(rollBackRules);</span><br><span class="line">	<span class="keyword">return</span> rbta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>切面实现</strong></p>
<p>TransactionInterceptor 实现了方法拦截器 MethodInterceptor 接口，用于对业务类进行事务增强。TransactionInterceptor 的 invoke 方法主要是调用了父类 TransactionAspectSupport 的 invokeWithinTransaction 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line">	<span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> <span class="title class_">InvocationCallback</span>() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Object <span class="title function_">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">			<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">	<span class="comment">// 获取事务配置信息</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">	<span class="comment">// 获取事务管理器</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">PlatformTransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line">	<span class="comment">// 同步操作</span></span><br><span class="line">	<span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		<span class="comment">// 创建事务类</span></span><br><span class="line">		<span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">		<span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 环绕增强：触发链条上的下一个拦截器，最终会调用目标类</span></span><br><span class="line">			retVal = invocation.proceedWithInvocation();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// 出现异常则回滚</span></span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 省略异步操作，原理类似</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invoke 方法里主要做以下几件事：</p>
<ol>
<li>获取事务属性；</li>
<li>获取事务管理器；</li>
<li>创建事务；</li>
<li>执行目标方法；</li>
<li>遇到异常则回滚，正常结束则提交。</li>
</ol>
<p>创建事务的是<code>TransactionAspectSupport#createTransactionIfNecessary()</code>方法，该方法的调用代码比较多，主要摘取比较重要的看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---+TransactionAspectSupport:createTransactionIfNecessary();</span><br><span class="line">   `---+AbstractPlatformTransactionManager:getTransaction();</span><br><span class="line">       +---AbstractPlatformTransactionManager:doGetTransaction();</span><br><span class="line">       `---+AbstractPlatformTransactionManager:doBegin();</span><br><span class="line">           +---DataSource:getConnection();</span><br><span class="line">           `---TransactionSynchronizationManager.bindResource();</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<hr>
<p>参考：<br><a href="https://blog.csdn.net/wang704987562/article/details/88913808">https://blog.csdn.net/wang704987562/article/details/88913808</a><br><a href="https://blog.csdn.net/ai_xiangjuan/article/details/79687560">https://blog.csdn.net/ai_xiangjuan/article/details/79687560</a><br><a href="https://blog.csdn.net/u012562943/article/details/78333153">https://blog.csdn.net/u012562943/article/details/78333153</a><br><a href="https://www.coder4.com/archives/5917">https://www.coder4.com/archives/5917</a><br><a href="https://blog.csdn.net/dslztx/article/details/46636079">https://blog.csdn.net/dslztx/article/details/46636079</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>事务</category>
      </categories>
  </entry>
  <entry>
    <title>三问Spring事务：解决什么问题？如何解决？存在什么问题？</title>
    <url>/2024/03/20/Spring/%E4%BA%8B%E5%8A%A1/%E4%B8%89%E9%97%AESpring%E4%BA%8B%E5%8A%A1%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="1-解决什么问题"><a href="#1-解决什么问题" class="headerlink" title="1. 解决什么问题"></a>1. 解决什么问题</h1><p>让我们先从事务说起，“什么是事务？我们为什么需要事务？”。事务是一组无法被分割的操作，要么所有操作全部成功，要么全部失败。我们在开发中需要通过事务将一些操作组成一个单元，来保证程序逻辑上的正确性，例如全部插入成功，或者回滚，一条都不插入。作为程序员的我们，对于事务管理，所需要做的便是进行<strong>事务的界定</strong>，即通过类似begin transaction和end transaction的操作来界定事务的开始和结束。</p>
<p>下面是一个基本的JDBC事务管理代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启数据库连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> openConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭自动提交</span></span><br><span class="line">    con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 业务处理</span></span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    con.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException | MyException e) &#123;</span><br><span class="line">    <span class="comment">// 捕获异常，回滚事务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        con.rollback();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        con.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">        con.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用JDBC进行事务管理的代码直观上来看，存在两个问题：</p>
<ol>
<li>业务处理代码与事务管理代码混杂；</li>
<li>大量的异常处理代码（在catch中还要try-catch）。而如果我们需要更换其他数据访问技术，例如Hibernate、MyBatis、JPA等，虽然事务管理的操作都类似，但API却不同，则需使用相应的API来改写。这也会引来第三个问题：</li>
<li>繁杂的事务管理API。</li>
</ol>
<p>上文列出了三个待解决的问题，下面我们看Spring事务是如何解决。</p>
<span id="more"></span>

<h1 id="2-如何解决"><a href="#2-如何解决" class="headerlink" title="2. 如何解决"></a>2. 如何解决</h1><h2 id="2-1-繁杂的事务管理API"><a href="#2-1-繁杂的事务管理API" class="headerlink" title="2.1 繁杂的事务管理API"></a>2.1 繁杂的事务管理API</h2><p>针对该问题，我们很容易可以想到，在众多事务管理的API上抽象一层。通过<strong>定义接口</strong>屏蔽具体实现，再使用<strong>策略模式</strong>来决定具体的API。下面我们看下Spring事务中定义的抽象接口。</p>
<p>在Spring事务中，核心接口是PlatformTransactionManager，也叫事务管理器，其定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface PlatformTransactionManager extends TransactionManager &#123;</span><br><span class="line">    // 获取事务（新的事务或者已经存在的事务）</span><br><span class="line">    TransactionStatus getTransaction(@Nullable TransactionDefinition definition)</span><br><span class="line">			throws TransactionException;   </span><br><span class="line">    // 提交事务</span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">    // 回滚事务</span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getTransaction通过入参TransactionDefinition来获得TransactionStatus，即通过定义的事务元信息来创建相应的事务对象。TransactionStatus事务对象可被传入到commit方法或rollback方法中，完成事务的提交或回滚。</p>
<p>下面我们通过一个具体实现来理解TransactionStatus的作用。以commit方法为例，如何通过TransactionStatus完成事务的提交。AbstractPlatformTransactionManager是PlatformTransactionManager接口的的实现，作为模板类，其commit实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void commit(TransactionStatus status) throws TransactionException &#123;</span><br><span class="line">    // 1.检查事务是否已完成</span><br><span class="line">    if (status.isCompleted()) &#123;</span><br><span class="line">        throw new IllegalTransactionStateException(</span><br><span class="line">            &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.检查事务是否需要回滚（局部事务回滚）</span><br><span class="line">    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">    if (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">        if (defStatus.isDebug()) &#123;</span><br><span class="line">            logger.debug(&quot;Transactional code has requested rollback&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        processRollback(defStatus, false);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.检查事务是否需要回滚（全局事务回滚）</span><br><span class="line">    if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">        if (defStatus.isDebug()) &#123;</span><br><span class="line">            logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        processRollback(defStatus, true);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4.提交事务</span><br><span class="line">    processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在commit<strong>模板方法</strong>中定义了事务提交的基本逻辑，通过查看status的事务状态来决定抛出异常还是回滚，或是提交。其中的processRollback和processCommit方法也是模板方法，进一步定义了回滚、提交的逻辑。以processCommit方法为例，具体的提交操作将由抽象方法doCommit完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected abstract void doCommit(DefaultTransactionStatus status) throws TransactionException;</span><br></pre></td></tr></table></figure>

<p>doCommit的实现取决于具体的数据访问技术。我们看下JDBC相应的具体实现类DataSourceTransactionManager中的doCommit实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doCommit(DefaultTransactionStatus status) &#123;</span><br><span class="line">    // 获取status中的事务对象    </span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">    // 通过事务对象获得数据库连接对象</span><br><span class="line">    Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">    if (status.isDebug()) &#123;</span><br><span class="line">        logger.debug(&quot;Committing JDBC transaction on Connection [&quot; + con + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行commit</span><br><span class="line">        con.commit();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (SQLException ex) &#123;</span><br><span class="line">        throw new TransactionSystemException(&quot;Could not commit JDBC transaction&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在commit和processCommit方法中我们根据入参的TransactionStatus提供的<strong>事务状态</strong>来决定事务行为，而在doCommit中需要执行事务提交时将会通过TransactionStatus中的<strong>事务对象</strong>来获得数据库连接对象，再执行最后的commit操作。通过这个示例我们可以理解TransactionStatus所提供的事务状态和事务对象的作用。</p>
<p>下面是用Spring事务API改写后的事务管理代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获得事务管理器</span><br><span class="line">PlatformTransactionManager txManager = getPlatformTransactionManager();</span><br><span class="line">DefaultTransactionDefinition def = new DefaultTransactionDefinition();</span><br><span class="line">// 指定事务元信息</span><br><span class="line">def.setName(&quot;SomeTxName&quot;);</span><br><span class="line">def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">// 获得事务</span><br><span class="line">TransactionStatus status = txManager.getTransaction(def);</span><br><span class="line">try &#123;</span><br><span class="line">    // 业务处理</span><br><span class="line">&#125;</span><br><span class="line">catch (MyException ex) &#123;</span><br><span class="line">    // 捕获异常，回滚事务</span><br><span class="line">    txManager.rollback(status);</span><br><span class="line">    throw ex;</span><br><span class="line">&#125;</span><br><span class="line">// 提交事务</span><br><span class="line">txManager.commit(status);</span><br></pre></td></tr></table></figure>

<p>无论是使用JDBC、Hibernate还是MyBatis，我们只需要传给txManager相应的具体实现就可以在多种数据访问技术中切换。</p>
<blockquote>
<p>小结：Spring事务通过PlatformTransactionManager、TransactionDefinition和TransactionStatus接口统一事务管理API，并结合策略模式和模板方法决定具体实现。</p>
</blockquote>
<p>Spring事务API代码还有个特点有没有发现，SQLException不见了。下面来看Spring事务是如何解决大量的异常处理代码。</p>
<h2 id="2-2-大量的异常处理代码"><a href="#2-2-大量的异常处理代码" class="headerlink" title="2.2 大量的异常处理代码"></a>2.2 大量的异常处理代码</h2><p>为什么使用JDBC的代码中会需要写这么多的异常处理代码。这是因为Connection的每个方法都会抛出SQLException，而SQLException又是<strong>检查异常</strong>，这就<strong>强制</strong>我们在使用其方法时必须进行异常处理。那Spring事务是如何解决该问题的。我们看下doCommit方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doCommit(DefaultTransactionStatus status) &#123;</span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">    Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">    if (status.isDebug()) &#123;</span><br><span class="line">        logger.debug(&quot;Committing JDBC transaction on Connection [&quot; + con + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        con.commit();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (SQLException ex) &#123;</span><br><span class="line">        // 异常转换</span><br><span class="line">        throw new TransactionSystemException(&quot;Could not commit JDBC transaction&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Connection的commit方法会抛出检查异常SQLException，在catch代码块中SQLException将被转换成TransactionSystemException抛出，而TransactionSystemException是一个非检查异常。通过将<strong>检查异常转换成非检查异常</strong>，让我们能够自行决定是否捕获异常，不强制进行异常处理。</p>
<p>Spring事务中几乎为数据库的所有错误都定义了相应的异常，统一了JDBC、Hibernate、MyBatis等不同异常API。这有助于我们在处理异常时使用统一的异常API接口，无需关心具体的数据访问技术。</p>
<blockquote>
<p>小结：Spring事务通过异常转换避免强制异常处理。</p>
</blockquote>
<h2 id="2-3-业务处理代码与事务管理代码混杂"><a href="#2-3-业务处理代码与事务管理代码混杂" class="headerlink" title="2.3 业务处理代码与事务管理代码混杂"></a>2.3 业务处理代码与事务管理代码混杂</h2><p>在2.1节中给出了使用Spring事务API的写法，即编程式事务管理，但仍未解决“业务处理代码与事务管理代码混杂”的问题。这时候就可以利用Spring AOP将事务管理代码这一横切关注点从代码中剥离出来，即<strong>声明式事务管理</strong>。以注解方式为例，通过为方法标注@Transaction注解，将为该方法提供事务管理。其原理如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e6b0c39b515fcbde9d4d4337a6346418.png" alt="三问Spring事务：解决什么问题？如何解决？存在什么问题？"></p>
<p>Spring事务会为@Transaction标注的方法的类生成AOP增强的动态代理类对象，并且在调用目标方法的拦截链中加入TransactionInterceptor进行环绕增加，实现事务管理。</p>
<p>下面我们看下TransactionInterceptor中的具体实现，其invoke方法中将调用invokeWithinTransaction方法进行事务管理，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation)</span><br><span class="line">        throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">    // 查询目标方法事务属性、确定事务管理器、构造连接点标识（用于确认事务名称）</span><br><span class="line">    final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">    final PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">    final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        // 创建事务</span><br><span class="line">        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">        Object retVal = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 通过回调执行目标方法</span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            // 目标方法执行抛出异常，根据异常类型执行事务提交或者回滚操作</span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            // 清理当前线程事务信息</span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        // 目标方法执行成功，提交事务</span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 带回调的事务执行处理，一般用于编程式事务</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用目标方法前后加入了创建事务、处理异常、提交事务等操作。这让我们不必编写事务管理代码，只需通过@Transaction的属性指定事务相关元信息。</p>
<blockquote>
<p>小结：Spring事务通过AOP提供声明式事务将业务处理代码和事务管理代码分离。</p>
</blockquote>
<h1 id="3-存在什么问题"><a href="#3-存在什么问题" class="headerlink" title="3. 存在什么问题"></a>3. 存在什么问题</h1><p>Spring事务为了我们解决了第一节中列出的三个问题，但同时也会带来些新的问题。</p>
<h2 id="3-1-非public方法失效"><a href="#3-1-非public方法失效" class="headerlink" title="3.1 非public方法失效"></a>3.1 非public方法失效</h2><p>@Transactional只有标注在public级别的方法上才能生效，对于非public方法将不会生效。这是由于Spring AOP不支持对private、protect方法进行拦截。从原理上来说，动态代理是通过接口实现，所以自然不能支持private和protect方法的。而CGLIB是通过继承实现，其实是可以支持protect方法的拦截的，但Spring AOP中并不支持这样使用，笔者猜测做此限制是出于代理方法应是public的考虑，以及为了保持CGLIB和动态代理的一致。如果需要对protect或private方法拦截则建议使用AspectJ。</p>
<h2 id="3-2-自调用失效"><a href="#3-2-自调用失效" class="headerlink" title="3.2 自调用失效"></a>3.2 自调用失效</h2><p>当通过在Bean的内部方法直接调用带有@Transactional的方法时，@Transactional将失效，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void saveAB(A a, B b)</span><br><span class="line">&#123;</span><br><span class="line">    saveA(a);</span><br><span class="line">    saveB(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">public void saveA(A a)</span><br><span class="line">&#123;</span><br><span class="line">    dao.saveA(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">public void saveB(B b)</span><br><span class="line">&#123;</span><br><span class="line">    dao.saveB(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在saveAB中调用saveA和saveB方法，两者的@Transactional都将失效。这是因为Spring事务的实现基于代理类，当在内部直接调用方法时，将不会经过代理对象，而是直接调用目标对象的方法，无法被TransactionInterceptor拦截处理。解决办法：</p>
<p><strong>（1）ApplicationContextAware</strong></p>
<p>通过ApplicationContextAware注入的上下文获得代理对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void saveAB(A a, B b)</span><br><span class="line">&#123;</span><br><span class="line">    Test self = (Test) applicationContext.getBean(&quot;Test&quot;);</span><br><span class="line">    self.saveA(a);</span><br><span class="line">    self.saveB(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）AopContext</strong></p>
<p>通过AopContext获得代理对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void saveAB(A a, B b)</span><br><span class="line">&#123;</span><br><span class="line">    Test self = (Test)AopContext.currentProxy();</span><br><span class="line">    self.saveA(a);</span><br><span class="line">    self.saveB(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）@Autowired</strong></p>
<p>通过@Autowired注解注入代理对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    Test self;</span><br><span class="line"></span><br><span class="line">    public void saveAB(A a, B b)</span><br><span class="line">    &#123;</span><br><span class="line">        self.saveA(a);</span><br><span class="line">        self.saveB(b);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）拆分</strong></p>
<p>将saveA、saveB方法拆分到另一个类中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void saveAB(A a, B b)</span><br><span class="line">&#123;</span><br><span class="line">    txOperate.saveA(a);</span><br><span class="line">    txOperate.saveB(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个问题都是由于Spring事务的实现方式的限制导致的问题。下面再看两个由于<strong>使用不当</strong>容易犯错的两个问题。</p>
<h2 id="3-3-检查异常默认不回滚"><a href="#3-3-检查异常默认不回滚" class="headerlink" title="3.3 检查异常默认不回滚"></a>3.3 检查异常默认不回滚</h2><p>在默认情况下，抛出非检查异常会触发回滚，而检查异常不会。</p>
<p>根据invokeWithinTransaction方法，我们可以知道异常处理逻辑在completeTransactionAfterThrowing方法中，其实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) &#123;</span><br><span class="line">    if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) &#123;</span><br><span class="line">        if (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() +</span><br><span class="line">                         &quot;] after exception: &quot; + ex);</span><br><span class="line">        &#125;</span><br><span class="line">        if (txInfo.transactionAttribute != null &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 异常类型为回滚异常，执行事务回滚</span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            catch (TransactionSystemException ex2) &#123;</span><br><span class="line">                logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);</span><br><span class="line">                ex2.initApplicationException(ex);</span><br><span class="line">                throw ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (RuntimeException | Error ex2) &#123;</span><br><span class="line">                logger.error(&quot;Application exception overridden by rollback exception&quot;, ex);</span><br><span class="line">                throw ex2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 异常类型为非回滚异常，仍然执行事务提交</span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            catch (TransactionSystemException ex2) &#123;</span><br><span class="line">                logger.error(&quot;Application exception overridden by commit exception&quot;, ex);</span><br><span class="line">                ex2.initApplicationException(ex);</span><br><span class="line">                throw ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (RuntimeException | Error ex2) &#123;</span><br><span class="line">                logger.error(&quot;Application exception overridden by commit exception&quot;, ex);</span><br><span class="line">                throw ex2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据rollbackOn判断异常是否为回滚异常。只有RuntimeException和Error的实例，即非检查异常，或者在@Transaction中通过rollbackFor属性指定的回滚异常类型，才会回滚事务。否则将继续提交事务。所以如果需要对非检查异常进行回滚，需要记得指定rollbackFor属性，不然将回滚失效。</p>
<h2 id="3-4-catch异常无法回滚"><a href="#3-4-catch异常无法回滚" class="headerlink" title="3.4 catch异常无法回滚"></a>3.4 catch异常无法回滚</h2><p>在3.3节中我们说到只有抛出非检查异常或是rollbackFor中指定的异常才能触发回滚。如果我们把异常catch住，而且没抛出，则会导致无法触发回滚，这也是开发中常犯的错误。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void insert(List&lt;User&gt; users) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</span><br><span class="line">        for (User user : users) &#123;</span><br><span class="line">            String insertUserSql = &quot;insert into User (id, name) values (?,?)&quot;;</span><br><span class="line">            jdbcTemplate.update(insertUserSql, new Object[] &#123; user.getId(),</span><br><span class="line">                                                             user.getName() &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里由于catch住了所有Exception，并且没抛出。当插入发生异常时，将不会触发回滚。</p>
<p>但同时我们也可以利用这种机制，用try-catch包裹不用参与事务的数据操作，例如对于写入一些不重要的日志，我们可将其用try-catch包裹，避免抛出异常，则能避免写日志失败而影响事务的提交。</p>
<hr>
<p>转载自：</p>
<p><a href="https://juejin.im/post/5ee4a740f265da76b828d3ce">https://juejin.im/post/5ee4a740f265da76b828d3ce</a></p>
<p>方法用final修饰</p>
<p>方法内部调用</p>
<p>为被spring管理</p>
<p>表不支持事务</p>
<p>错误的传播特性</p>
<p>自己吞了异常</p>
<p>手动抛了其他异常</p>
<p>自定义了回滚异常</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>事务</category>
      </categories>
  </entry>
  <entry>
    <title>基于接口而非实现编程</title>
    <url>/2024/04/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>什么是面向接口编程</strong><br>“基于接口而非实现编程”这条原则的英文描述是：“Program to an interface, not an implementation”。</p>
<p>我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如Java中的 interface）。这条原则是一条比较抽象、泛化的设计思想。</p>
<p>实际上，理解这条原则的关键，就是理解其中的“接口”两个字，这里的“接口”是泛指，可以理解为“抽象”。“基于接口而非实现编程”这条原则的另一个表述方式是“基于抽象而非实现编程”，后者的表述方式其实更能体现这条原则的设计初衷。落实到具体的编码，“接口”可以理解为编程语言中的接口（interface）或者抽象类（abstract class）。</p>
<span id="more"></span>

<p><strong>面向接口编程的好处</strong><br>在我看来，面向接口编程可以带来两大好处：解耦和提供扩展性。面向接口编程可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p>
<p><strong>解耦</strong><br>软件设计与开发最重要的工作之一就是应对复杂性，而控制代码复杂性最关键的就是解耦。对依赖关系复杂的软件作解耦的常用手段就是抽象和增加中间层，无论哪种手段，都体现了基于抽象而非实现编程的思想。</p>
<p>一个真实的典型耦合案例，就是java的logger，早些年，大家都用commons-logging、log4j并没有什么问题。然而，此处埋了一个雷—那就是对logger实现的强耦合。当logback与log4j2出现后，情况变得复杂，程序员发现想要切换logger实现的代价非常高，为了减少应用层代码的改动，尽可能最小代价地完成logger实现切换，不得不上各种Bridge（适配器模式），到最后日志体系代码搞得极其复杂，没什么人看得懂。</p>
<p>试想如果能够时光倒流，我们一开始就在应用与日志实现之间加入一层抽象，让两者解耦，应用层基于日志的抽象编程而非某一个具体的日志实现。MyLogger接口这个关键抽象将接口和实现相分离，封装了不稳定的实现，暴露稳定的接口。应用层面向稳定的MyLogger接口而非实现编程，不依赖不稳定的实现细节，这样当底层的Logger实现发生变化的时候，应用层的代码基本上不需要做改动，显著降低耦合性。</p>
<p><strong>提供扩展性</strong><br>可扩展设计，主要是利用了面向对象的多态特性，面向接口编程的思想将接口和实现分离，实现可以有N多种，上层可以按需加载最合适的那一个实现，这恰恰是良好扩展性的体现。</p>
<p>扩展性诉求在软件开发中无处不在，例如我要将系统产生的数据存储起来放置到如Oracle的数据库中，后来出现了IOE运动，我又要把数据放置到免费开源的MySQL数据库中。如果软件是直接基于底层存储为Oracle这个“现实”去编写的，当需要切换新的存储源时，就必须要修改应用代码了。更恰当的做法应该是定义一组接口，让不同的数据库厂商实现去实现这些接口，从而在切换配置实现的时候，应用代码不再需要更改了。</p>
<p>JDBC（Java Database Connection）就为Java开发者使用数据库提供了统一的编程接口，它由一组Java类和接口组成，是Java程序与数据库通信的标准API。只要数据库想要和Java连接的，数据库厂商必须自己实现JDBC这套接口，数据库厂商的JDBC实现，我们就叫它此数据库的驱动。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202407272340494.png" alt="img"></p>
<p>装载MySQL驱动：Class.forName(“com.mysql.jdbc.Driver”);<br>装载Oracle驱动：Class.forName(“com.jdbc.driver.OracleDriver”);</p>
<p><strong>面向接口编程实现依赖倒置</strong><br>依赖倒置原则的英文翻译是Dependency Inversion Principle，缩写为DIP，依赖倒置原则的含义有两层：</p>
<ul>
<li>高层模块不要依赖低层模块，高层模块和低层模块应该通过抽象（abstractions）来互相依赖。</li>
<li>抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）要依赖抽象（abstractions）</li>
</ul>
<p>这里“抽象”这个词是不是很熟悉，前面我们说了“基于接口而非实现编程”的真实含义就是“基于抽象编程”，而实现DIP的关键就是定义抽象，去依赖抽象而非实现（实现就是detail，是细节），所以实现DIP的手段无它，就是面向接口编程。</p>
<p>DIP规则中提到了高层模块和低层模块，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的，例如MVC结构的工程，从高到低，Controller层调用Service层，Service层调用Repository层，每一层各司其职。DIP原则主要用来指导框架型软件的设计。</p>
<p>我们拿Tomcat这个Servlet容器作为例子来解释一下，Tomcat是运行Java Web应用程序的容器。我们编写的Web应用程序代码只需要部署在Tomcat容器中，便可以被Tomcat容器调用执行。按照上面提到的划分原则，Tomcat就是高层模块，我们编写的Web应用程序代码就是低层模块。Tomcat和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是Servlet规范。Servlet规范只是定义并输出标准，不提供细节。而Tomcat容器和Web应用程序都去依赖Servlet规范，两者解耦，都去依赖抽象，各自独立发展，只要遵守规范即可。因此容器可以有很多种，例如Jetty与JBoss也是应用广泛的Servlet容器，而Spring可以算得上是最知名的实现了Servlet规范的Web应用程序开发框架了，它帮助程序员把很多可复用的底层工作都做好了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>解读RocketMQ 5.0全新的高可用设计</title>
    <url>/2024/08/03/MQ/%E8%A7%A3%E8%AF%BBRocketMQ%205.0%E5%85%A8%E6%96%B0%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="高可用架构演进背景"><a href="#高可用架构演进背景" class="headerlink" title="高可用架构演进背景"></a>高可用架构演进背景</h1><p>​	在分布式系统中不可避免的会遇到网络故障，机器宕机，磁盘损坏等问题，为了向用户不中断且正确的提供服务，要求系统有一定的冗余与容错能力。RocketMQ 在日志，统计分析，在线交易，金融交易等丰富的生产场景中发挥着至关重要的作用，而不同环境对基础设施的成本与可靠性提出了不同的诉求。</p>
<p>​	在 RocketMQ v4 版本中有两种主流高可用设计，分别是 主备模式的无切换架构 和 基于 Raft 的多副本架构（图中左侧和右侧所示）。</p>
<p>​	生产实践中我们发现，两副本的冷备模式下备节点资源利用率低，主宕机时特殊类型消息存在可用性问题；而 Raft 高度串行化，基于多数派的确认机制在扩展只读副本时不够灵活，无法很好的支持两机房对等部署，异地多中心等复杂场景。RocketMQ v5 版本融合了上述方案的优势，提出 DLedger Controller 作为管控节点（中间部分所示），将选举逻辑插件化并优化了数据复制的实现。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031322339.png" alt="在这里插入图片描述"></p>
<span id="more"></span>

<h1 id="如何实现高可用系统"><a href="#如何实现高可用系统" class="headerlink" title="如何实现高可用系统"></a>如何实现高可用系统</h1><h2 id="副本组与数据分片"><a href="#副本组与数据分片" class="headerlink" title="副本组与数据分片"></a>副本组与数据分片</h2><p>​	在 Primary-Backup 架构的分布式系统中，一份数据将被复制成多个副本来避免数据丢失。处理相同数据的一组节点被称为副本组（ReplicaSet），副本组的粒度可以是单个文件级别的（例如 HDFS），也可以是分区级 &#x2F; 队列级的（例如 Kafka），每个真实存储节点上可以容纳若干个不同副本组的副本，也可以像 RocketMQ 一样粗粒度的独占节点。独占能够显著简化数据写入时确保持久化成功的复杂度，因为每个副本组上只有主副本会响应读写请求，备机一般配置只读来提供均衡读负载，选举这件事儿等价于让副本组内一个副本持有独占的写锁。</p>
<p>​	RocketMQ 为每个存储数据的 Broker 节点配置 ClusterName，BrokerName 标识来更好的进行资源管理。多个 BrokerName 相同的节点构成一个副本组。每个副本还拥有一个从 0 开始编号，不重复也不一定连续的 BrokerId 用来表示身份，编号为 0 的节点是这个副本组的 Leader &#x2F; Primary &#x2F; Master，故障时通过选举来重新对 Broker 编号标识新的身份。例如 BrokerId &#x3D; {0, 1, 3}，则 0 为主，其他两个为备。</p>
<p>​	一个副本组内，节点间共享数据的方式有多种，资源的共享程度由低到高来说一般有 Shared Nothing，Shared Disk，Shared Memory，Shared EveryThing。典型的 Shared Nothing 架构是 TiDB 这类纯分布式的数据库，TiDB 在每个存储节点上使用基于 RocksDB 封装的 TiKV 进行数据存储，上层通过协议交互实现事务或者 MVCC。相比于传统的分库分表策略来说，TiKV 易用性和灵活程度很高，更容易解决数据热点与伸缩时数据打散的一系列问题，但实现跨多节点的事务就需要涉及到多次网络的通信。另一端 Shared EveryThing 的案例是 AWS 的 Aurora，Aliyun 的 PolarStore，旁路 Kernal 的方式使应用完全运行于用户态，以最大程度的存储复用来减少资源消耗，一主多备完全共用一份底层可靠的存储，实现一写多读，快速切换。</p>
<p>​	大多数 KV 操作都是通过关键字的一致性哈希来计算所分配的节点，当这个节点所在的主副本组产生存储抖动，主备切换，网络分区等情况下，这个分片所对应的所有键都无法更新，局部会有一些操作失败。消息系统的模型有所不同，流量大但跨副本组的数据交互极少，无序消息发送到预期分区失败时还可以向其他副本组（分片）写入，一个副本组的故障不影响全局，这在整体服务的层面上额外提供了跨副本组的可用性。此外，考虑到 MQ 作为 Paas 层产品，被广泛部署于 Windows，Linux on Arm 等各种环境，只有减少和 Iaas 层产品的深度绑定，才能提供更好的灵活性。这种局部故障隔离和轻依赖的特性是 RocketMQ 选则 Shared Nothing 模型重要原因。</p>
<p>​	副本组中，各个节点处理的速度不同，也就有了日志水位的概念。Master 和与其差距不大的 Slave 共同组成了同步副本集（SyncStateSet）。如何定义差距不大呢？衡量的指标可以是日志水位（文件大小）差距较小，也可以是备落后的时间在一定范围内。在主宕机时，同步副本集中的其余节点有机会被提升为主，有时需要对系统进行容灾演练，或者对某些机器进行维护或灰度升级时希望定向的切换某一个副本成为新主，这又产生了优先副本（PriorityReplica）的概念。选择优先副本的原则和策略很多，可以动态选择水位最高，加入时间最久或 CommitLog 最长的副本，也可以支持机架，可用区优先这类静态策略。</p>
<p>​	从模型的角度来看，RocketMQ 单节点上 Topic 数量较多，如果像 kafka 以 topic &#x2F; partition 粒度维护状态机，节点宕机会导致上万个状态机切换，这种惊群效应会带来很多潜在风险，因此 v4 版本时 RocketMQ 选择以单个 Broker 作为切换的最小粒度来管理，相比于其他更细粒度的实现，副本身份切换时只需要重分配 Broker 编号，对元数据节点压力最小。由于通信的数据量少，可以加快主备切换的速度，单个副本下线的影响被限制在副本组内，减少管理和运维成本。这种实现也一些缺点，例如存储节点的负载无法以最佳状态在集群上进行负载均衡，Topic 与存储节点本身的耦合度较高，水平扩展一般会改变分区总数，这就需要在上层附加额外的处理逻辑。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031331326.png" alt="在这里插入图片描述"></p>
<p>为了更规范更准确的衡量副本组的可用性指标，学术上就引入了几个名词：</p>
<ul>
<li>RTO（Recovery Time Objective）恢复时间目标，一般表示业务中断到恢复的时间。</li>
<li>RPO（Recovery Point Object）恢复点目标，用于衡量业务连续性。例如某个硬盘每天备份，故障时丢失最近备份后的所有更新。</li>
<li>SLA（Service-Level Agreement）服务等级协议，厂商以合约的形式对用户进行服务质量承诺，SLA 越高通常成本也越高。</li>
</ul>
<p>节点数量与可靠性关系密切，根据不同生产场景，RocketMQ 的一个副本组可能会有 1，2，3，5 个副本。</p>
<ol>
<li>单副本成本最低，维护最简单，宕机时其他副本组接管新消息的写入，但已写入的数据无法读取，造成部分消息消费延迟。底层硬件故障还可能导致数据永久丢失，一般用于非关键日志，数据采集等低可靠性成本诉求较强的场景。</li>
<li>两副本较好的权衡了数据冗余的成本与性能，RocketMQ 跨副本组容灾的特性使得两副本模式适用于绝大部分 IOPS 比较高的场景。此时备机可以分摊一定的读压力（尤其是主副本由于内存紧张或者产生冷读时）。两副本由于不满足多数派（quorum）原则，没有外部系统的参与时，故障时无法进行选举切换。</li>
<li>三副本和五副本是业界使用最为广泛的，精心设计的算法使得多数情况下系统可以自愈。基于 Paxos &#x2F; Raft 属于牺牲高可用性来保证一致性的 CP 型设计，存储成本很高，容易受到 IO 分布不均匀和水桶效应的影响。每条数据都需要半数以上副本响应的设计在需要写透（write through）多副本的消息场景下不够灵活。</li>
</ol>
<h2 id="日志复制还是消息复制"><a href="#日志复制还是消息复制" class="headerlink" title="日志复制还是消息复制"></a>日志复制还是消息复制</h2><p>​	如何保证副本组中数据的最终一致性？那肯定是通过数据复制的方式实现，我们该选择逻辑复制还是物理复制呢？</p>
<p>​	<strong>逻辑复制</strong>： 使用消息来进行同步的场景也很多，各种 connector 实现本质上就是把消息从一个系统挪到另外一个系统上，例如将数据导入导出到 ES，Flink 这样的系统上进行分析，根据业务需要选择特定 Topic &#x2F; Tag 进行同步，灵活程度和可扩展性非常高。这种方案随着 Topic 增多，系统还会有服务发现，位点和心跳管理等上层实现造成的性能损失。因此对于消息同步的场景，RocketMQ 也支持以消息路由的形式进行数据转移，将消息复制作为业务消费的特例来看待。</p>
<p>​	<strong>物理复制</strong>： 大名鼎鼎的 MySQL 对于操作会记录逻辑日志（bin log）和重做日志（redo log）两种日志。其中 bin log 记录了语句的原始逻辑，比如修改某一行某个字段，redo log 属于物理日志，记录了哪个表空间哪个数据页改了什么。在 RocketMQ 的场景下，存储层的 CommitLog 通过链表和内核的 MappedFile 机制抽象出一条 append only 的数据流。主副本将未提交的消息按序传输给其他副本（相当于 redo log），并根据一定规则计算确认位点（confirm offset）判断日志流是否被提交。这种方案仅使用一份日志和位点就可以保证主备之间预写日志的一致性，简化复制实现的同时也提高了性能。</p>
<p>​	为了可用性而设计的多副本结构，很明显是需要对所有需要持久化的数据进行复制的，选择物理复制更加节省资源。RocketMQ 在物理复制时又是如何保证数据的最终一致性呢？这就涉及到数据的水位对齐。对于消息和流这样近似 FIFO 的系统来说，越近期的消息价值越高，消息系统的副本组的单个节点不会像数据库系统一样，保留这个副本的全量数据，Broker一方面不断的将冷数据规整并转入低频介质来节约成本，同时对热数据盘上的数据也会由远及近滚动删除。如果副本组中有副本宕机较久，或者在备份重建等场景下就会出现日志流的不对齐和分叉的复杂情况。在下图中我们将主节点的 CommitLog 的首尾位点作为参考点，这样就可以划分出三个区间。在下图中以蓝色箭头表示。排列组合一下就可以证明备机此时的 CommitLog 一定满足下列 6 种情况之一。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031337722.png" alt="在这里插入图片描述"></p>
<p>下面对每种情况进行讨论与分析：</p>
<ul>
<li>1-1 情况下满足备 Max &lt;&#x3D; 主 Min，一般是备新上线或下线较久，备跳过存量日志，从主的 Min 开始复制。</li>
<li>1-2，2-2 两种情况下满足 主 Min &lt; 备 Max &lt;&#x3D; 主 Max，一般是由于备网络闪断导致日志水位落后，通过 HA 连接追随主即可。</li>
<li>1-3，2-3 两种情况下备 Max &gt; 主 Max，可能由于主异步写磁盘宕机后又成为主，或者网络分区时双主写入造成 CommitLog 分叉。由于新主落后于备，少量未确认的消息丢失，非正常模式的选举（RocketMQ 将这种情况称为 unclean 选举）是应该尽量避免的。</li>
<li>3-3 理论上不会出现，备的数据长于主，原因可能是主节点数据丢失又叠加了非正常选举，因此这种情况需要人工介入处理。</li>
</ul>
<h2 id="租约与节点身份变更"><a href="#租约与节点身份变更" class="headerlink" title="租约与节点身份变更"></a>租约与节点身份变更</h2><p>​	前文提到 RocketMQ 每个副本组的主副本才接受外部写请求，节点的身份又是如何决定的呢？</p>
<p>​	分布式系统一般分为中心化架构和去中心化架构。对于 MultiRaft，每个副本组包含三个或者五个副本，副本组内可以通过 Paxos &#x2F; Raft 这样的共识协议来进行选主。典型的中心化架构，为了节省数据面资源成本会部署两副本，此时依赖于外部 ZK，ETCD，或者 DLedger Controller 这样的组件作为中心节点进行选举。由外置组件裁决成员身份涉及到分布式中两个重要的问题：1. 如何判断节点的状态是否正常; 2. 如何避免双主问题。</p>
<p>​	对于第一个问题，kubernetes 的解决方案相对优雅，k8s 对与 Pod 的健康检查包括存活检测（Liveness probes）和就绪检测（Readiness probes），Liveness probes 主要是探测应用是否还活着，失败时重启 Pod。Readiness probes 来判断探测应用是否接受流量。简单的心跳机制一般只能实现存活检测，来看一个例子：假设有副本组中有 A、B、C 三个副本，另有一个节点 Q（哨兵） 负责观测节点状态，同时承担了全局选举与状态维护的职责。节点 A、B、C 周期性的向 Q 发送心跳，如果 Q 超过一段时间（一般是两个心跳间隔 ）收不到某个节点的心跳则认为这个节点异常。如果异常的是主副本，Q 将副本组的其他副本提升为主并广播告知其他副本。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031341652.png" alt="在这里插入图片描述"></p>
<p>​	在工程实践中，节点下线的可能性一般要小于网络抖动的可能性。我们假设节点 A 是副本组的主，节点 Q 与节点 A 之间的网络中断。节点 Q 认为 A 异常。重新选择节点 B 作为新的 Master，并通知节点 A、B、C 新的 Master 是节点 B。节点 A 本身工作正常，与节点 B、C 之间的网络也正常。由于节点 Q 的通知事件到达节点 A、B、C 的顺序是未知的，假如先达到 B，在这一时刻，系统中同时存在两个工作的主，一个是 A，另一个是 B。假如此时 A、B 都接收外部请求并与 C 同步数据，会产生严重的数据错误。上述 “双主” 问题出现的原因在于虽然节点 Q 认为节点 A 异常，但节点 A 自己不认为自己异常，在旧主新主都接受写入的时候就产生了日志流的分叉，其问题的本质是由于网络分区造成的系统对于节点状态没有达成一致。</p>
<p>​	租约是一种避免双主的有效手段，租约的典型含义是现在中心节点承认哪个节点为主，并允许节点在租约有效期内正常工作。如果节点 Q 希望切换新的主，只需等待前一个主的租约过期，则就可以安全的颁发新租约给新 Master 节点，而不会出现双主问题。这种情况下系统对 Q 本身的可用性诉求非常高，可能会成为集群的性能瓶颈。生产中使用租约还有很多实现细节，例如依赖时钟同步需要颁发者的有效期设置的比接收者的略大，颁发者本身的切换也较为复杂。</p>
<p>​	在 RocketMQ 的设计中，希望以一种去中心化的设计降低中心节点宕机带来的全局风险，（这里认为中心化和是否存在中心节点是两件事）所以没有引入租约机制。在 Controller （对应于 Q ）崩溃恢复期间，由于 Broker 对自己身份会进行永久缓存，每个主副本会管理这个副本组的状态机，RocketMQ Dledger Controller 这种模式能够尽量保证在大部分副本组在哨兵组件不可用时仍然不影响收发消息的核心流程。而旧主由于永久缓存身份，无法降级导致了网络分区时系统必须容忍双主。产生了多种解决方案，用户可以通过预配置选择 AP 型可用性优先，即允许系统通过短时分叉来保障服务连续性（下文还会继续谈谈为什么消息系统中分叉很难避免），还是 CP 型一致性优先，通过配置最小副本 ack 数超过集群半数以上节点。此时发送到旧主的消息将因为无法通过 ha 链路将数据发送给备，向客户端返回超时，由客户端将发起重试到其他分片。客户端经历一个服务发现的周期之后，客户端就可以正确发现新主。</p>
<p>​	特别的，在网络分区的情况下，例如旧主和备，Controller 之间产生网络分区，此时由于没有引入租约机制，旧主不会自动降级，旧主可以配置为异步双写，每一条消息需要经过主备的双重确认才能向客户端返回成功。而备在切换为主时，会设置自己只需要单个副本确认的同步写盘模式。此时，客户端短时间内仍然可以向旧主发送消息，旧主需要两副本确认才能返回成功，因此发送到旧主的消息会返回 SLAVE_NOT_AVAILABLE 的超时响应，通过客户端重试将消息发往新的节点。几秒后，客户端从 NameServer &#x2F; Controller 获取新的路由时，旧主从客户端缓存中移除，此时完成了备节点的提升。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031345807.png" alt="在这里插入图片描述"></p>
<p>外置的组件可以对节点身份进行分配，上图展示了一个两副本的副本组上线流程：</p>
<ol>
<li><p>多个 Controller 通过选举和对 Broker 的请求进行重定向，最终由一个 Controller 做为主节点进行身份分配。</p>
</li>
<li><p>如果 RocketMQ 副本组存在多个副本且需要选主，节点默认以备的身份启动，备节点会将自己注册到 Controller。</p>
</li>
<li><p>节点从 Controller 获取 BrokerMemberGroup，包含了这个副本组的描述和连接信息。</p>
<blockquote>
<ol>
<li>若分配的身份为备，解析出主节点的对外服务的地址并连接，完成日志截断后进行 HA 同步。</li>
<li>若分配的身份为主，等待备机连接到自身的 HA 端口，并向 NameServer 再次宣告自己是主节点。</li>
</ol>
</blockquote>
</li>
<li><p>主节点维护整个副本组的信息，向备发起数据复制，周期性的向 Controller 汇报主备之间水位差距，复制速度等。</p>
</li>
</ol>
<p>​	RocketMQ 弱依赖 Controller 的实现并不会打破 Raft 中每个 term 最多只有一个 leader 的假设，工程中一般会使用 Leader Lease 解决脏读的问题，配合 Leader Stickiness 解决频繁切换的问题，保证主的唯一性。</p>
<ul>
<li>Leader Lease: 租约，上一任 Leader 的 Lease 过期后，等待一段时间再发起 Leader 选举。</li>
<li>Leader Stickiness: Leader Lease 未过期的 Follower 拒绝新的 Leader 选举请求。<br>注：Raft 认为具有最新已提交的日志的节点才有资格成为 Leader，而 Multi-Paxos 无此限制。</li>
</ul>
<p>对于日志的连续性问题，Raft 在确认一条日志之前会通过位点检查日志连续性，若检查到日志不连续会拒绝此日志，保证日志连续性，Multi-Paxos 允许日志中有空洞。Raft 在 AppendEntries 中会携带 Leader 的 commit index，一旦日志形成多数派，Leader 更新本地的 commit index（对应于 RocketMQ 的 confirm offset）即完成提交，下一条 AppendEntries 会携带新的 commit index 通知其它节点，Multi-Paxos 没有日志连接性假设，需要额外的 commit 消息通知其它节点。</p>
<h2 id="计算日志分叉位点"><a href="#计算日志分叉位点" class="headerlink" title="计算日志分叉位点"></a>计算日志分叉位点</h2><p>​	除了网络分区，很多情况导致日志数据流分叉。有如下案例：三副本采用异步复制，异步持久化，A 为旧主 B C 为备，切换瞬间 B 日志水位大于 C，此时 C 成为新主，B C 副本上的数据会产生分叉，因为 B 还多出了一段未确认的数据。那么 B 是如何以一个简单可靠的方法去判断自己和 C 数据分叉的位点？</p>
<p>​	一个直观的想法就是，直接将主备的 CommitLog 从前向后逐渐字节比较，一般生产环境下，主备都有数百 GB 的日志文件流，读取和传输大量数据的方案费时费力。很快我们发现，确定两个大文件是否相同的一个好办法就是比较数据的哈希值，需要对比的数据量一下子就从数百 GB 降低为了几百个哈希值，对于第一个不相同的 CommitLog 文件，还可以采取局部哈希的方式对齐，这里仍然存在一些计算的代价。还有没有优化的空间呢，那就是利用任期 Epoch 和偏移量 StartOffset 实现一个新的截断算法。这种 Epoch-StartOffset 满足如下原则：</p>
<ol>
<li>通过共识协议保证给定的一个任期 Epoch 只有一个Leader。</li>
<li>只有 Leader 可以写入新的数据流，满足一定条件才会被提交。</li>
<li>Follower 只能从 Leader 获取最新的数据流，Follower 上线时按照选举算法进行截断。</li>
</ol>
<p>​	下面是一个选举截断的具体案例，选举截断算法思想和流程如下：</p>
<blockquote>
<p>主 CommitLog Min &#x3D; 300，Max &#x3D; 2500，EpochMap &#x3D; {&lt;6, 200&gt;, &lt;7, 1200&gt;, &lt;8,2500&gt;}</p>
<p>备 CommitLog Min &#x3D; 300，Max &#x3D; 2500，EpochMap &#x3D; {&lt;6, 200&gt;, &lt;7, 1200&gt;, &lt;8,2250&gt;}</p>
</blockquote>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031352838.png" alt="在这里插入图片描述"></p>
<ol>
<li>备节点连接到主节点进行 HA 协商，获取主节点的 Epoch-StartOffset 信息并比较</li>
<li>备从后向前找到任期-起始点相同的那个点作为分叉任期，在上述案例里是 &lt;8,2250&gt;</li>
<li>选择这个任期里主备结束位点的最小值（如果主副本没有切换且为最大任期，则主副本的结束位点是无穷大）</li>
</ol>
<h2 id="数据回发与日志截断"><a href="#数据回发与日志截断" class="headerlink" title="数据回发与日志截断"></a>数据回发与日志截断</h2><p>​	故障发生后，系统将会对分叉数据进行修复，有很多小小细节值得深究与探讨。</p>
<p>​	在实现数据截断的过程中，有一个很特殊的动作，当备切主的时候要把 ConsumeQueue 的 Confirm Offset 提升到 CommitLog 的 MaxPhyOffset，即使这一部分数据在主上是否被提交是未知的。回想起几年前看 Raft 的时候，当一条日志被传输到 Follower，Follower 确认收到这条消息，主再把这条日志应用到自己的状态机时，通知客户端和通知所有的 follower 去 commit 这条日志这两件事是并行的，假如 leader 先回复 client 处理成功，此时 leader 挂了，由于其他 follower 的确认位点 confirm offset 一般会略低于 leader，中间这段未决日志还没应用到 follower 的状态机上，这时就出现了状态机不一致的情况，即已经写入 leader 的数据丢失了。</p>
<p>​	让我们来举一个具体的案例，假设两副本一主一备：</p>
<ol>
<li><p>主的 max offset &#x3D; 100，主向备发送当前 confirm offset &#x3D; 40 和 message buffer &#x3D; [40-100] 的数据</p>
</li>
<li><p>备向主回复 confirm offset &#x3D; 100 后，主需要同时做几件事</p>
<blockquote>
<p>a. 本地提交（apply） [40-100] 区间的数据，用后台的 dispatch 线程异步构建这段数据的索引;<br>b. 向 producer 响应 [40-100] 这段数据是发送成功的;<br>c. 向多个备机异步的提交，实际上是发送了 confirm offset &#x3D; 100;</p>
</blockquote>
</li>
<li><p>此时主突然宕机，备机的 confirm offset 可能是 [40-100] 中的值</p>
</li>
</ol>
<p>​	所以当备切换为主的时候，如果直接以 40 进行截断，意味着客户端已经发送到服务端的消息丢失了，正确的水位应该被提升至 100。但是备还没有收到 2.c 的 confirm &#x3D; 100 的信息，这个行为相当于要提交了未决消息。事实上新 leader 会遵守 “Leader Completeness” 的约定，切换时任何副本都不会删除也不会更改旧 leader 未决的 entry。新 leader 在新的 term 下，会直接应用一个较大的版本将未决的 entry 一起提交，这里副本组主备节点的行为共同保证了复制状态机的安全性。</p>
<p>​	那么备切换成功的标志是什么，什么时候才能接收 producer 新的流量呢？对于 Raft 来说一旦切换就可以，对于 RocketMQ 来说这个阶段会被稍稍推迟，即索引已经完全构建结束的时候。RocketMQ 为了保证构建 consume queue 的一致性，会在 CommitLog 中记录 consume queue offset 的偏移量，此时 confirm offset 到 max offset 间的数据是副本作为备来接收的，这部分消息在 consume queue 中的偏移量已经固定下来了，而 producer 新的流量时由于 RocketMQ 预计算位点的优化，等到消息实际放入 CommitLog 的再真实的数据分发（dispatch）的时候就会发现对应位置的 consume queue 已经被占用了，此时就造成了主备索引数据不一致。本质原因是 RocketMQ 存储层预构建索引的优化对日志有一些侵入性，但切换时短暂等待的代价远远小于正常运行时提速的收益。</p>
<h2 id="消息中间件场景"><a href="#消息中间件场景" class="headerlink" title="消息中间件场景"></a>消息中间件场景</h2><p><strong>a. 元数据变更是否依赖于日志</strong></p>
<p>​	目前 RocketMQ 对于元数据是在内存中单独管理的，备机间隔 5 秒向当前的主节点同步数据。例如当前主节点上创建了一个临时 Topic 并接受了一条消息，在一个同步周期内这个 Topic 又被删除了，此时主备节点元数据可能不一致。又比如位点更新的时候，对于单个队列而言，多副本架构中存在多条消费位点更新链路，Consumer 拉取消息时更新，Consumer 主动向 broker 更新，管控重置位点，HA 链路更新，当副本组发生主备切换时，consumer group 同时发生 consumer 上下线，由于路由发现的时间差，还可能造成同一个消费组两个不同 consumer 分别消费同一副本组主备上同一个队列的情况。</p>
<p>​	原因在于备机重做元数据更新和消息流这两件事是异步的，这有一定概率会造成脏数据。由于 RocketMQ 单个节点上 Topic &#x2F; Group 数量较多，通过日志的实现会导致持久化的数据量很大，在复杂场景下基于日志做回滚依赖 snapshot 机制也会增加计算开销和恢复时间。这个问题和数据库很像，MySQL 在执行 DDL 修改元数据时通过会创建 MDL 锁，阻塞用户其他操作访问表空间的访问。备库同步主库也会加锁，元数据修改开始点和结束点所代表的两个日志并不是一个原子操作，这意味着主库上在修改元数据的过程中如果宕机了，备库上持有的 MDL 锁就无法释放。MySQL 的解决方案是在主库每次崩溃恢复后，都写一条特殊的日志，通知所有连接的备库释放其持有的所有 MDL 排他锁。对所有操作都走日志流进行状态机复制要求存储层有多种日志类型，实现也更加复杂。RocketMQ 选择以另一种同步的模式操作，即类似 ZAB 这样二阶段协议，例如位点更新时的可以选择配置 LockInStrictMode 让备都同步这条修改。事实上 RocketMQ 为了优化上述位点跳跃的现象，客户端在未重启时，遇到服务端主备切换还会用优先采纳本地位点的方式获取消息，进一步减少重复消费。</p>
<p><strong>b. 同步复制与异步复制</strong></p>
<p>​	同步复制的含义是用户的一个操作在多个副本上都已经提交。正常情况下，假设一个副本组中的 3 个副本都要对相同一个请求进行确认，相当于数据写透 3 个副本（简称 3-3 写），3-3 写提供了非常高的数据可靠性，但是把所有从节点都配置为同步复制时任何一个同步节点的中断都会导致整个副本组处理请求失败。当第三个副本是跨可用区时，长尾也会带来一定的延迟。</p>
<p>​	异步复制模式下，尚未复制到从节点的写请求都会丢失。向客户端确认的写操作也无法保证被持久化。异步复制是一种故障时 RPO 不为 0 的配置模式，由于不用考虑从节点上的状态，总是可以继续响应写请求，系统的延迟更低，吞吐性能更好。为了权衡两者，通常只有其中一个从节点是同步的，而其他节点是异步的模式。只要同步的从节点变得不可用或性能下降，则将另一个异步的从节点提升为同步模式。这样可以保证至少有两个节点（即主节点和一个同步从节点）拥有最新的数据副本。这种模式称为 2-3 写，能帮助避免抖动，提供更好的延迟稳定性，有时候也叫称为半同步。</p>
<p>​	在 RocketMQ 的场景中，异步复制也被广泛应用在消息读写比极高，从节点数量多或者异地多副本场景。同步复制和异步复制是通过 Broker 配置文件里的 brokerRole 参数进行设置的，这个参数可以被设置成 ASYNC_MASTER、SYNC_MASTER、SLAVE 三个值中的一个。实际应用中要结合业务场景合理设置持久化方式和主从复制方式，通常，由于网络的速度高于本地 IO 速度，采用异步持久化和同步复制是一个权衡性能与可靠性的设置。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031403030.png" alt="在这里插入图片描述"></p>
<p><strong>c. 副本组自适应降级</strong></p>
<p>​	同步复制的含义是一条数据同时被主备确认才返回用户操作成功，可以保证主宕机后消息还在备中，适合可靠性要求较高的场景，同步复制还可以限制未同步的数据量以减少 ha 链路的内存压力，缺点则是副本组中的某一个备出现假死就会影响写入。异步复制无需等待备确认，性能高于同步复制，切换时未提交的消息可能会丢失（参考前文的日志分叉）。在三副本甚至五副本且对可靠性要求高的场景中无法采用异步复制，采用同步复制需要每一个副本确认后才会返回，在副本数多的情况下严重影响效率。关于一条消息需要被多少副本确认这个问题，RocketMQ 服务端会有一些数量上的配置来进行灵活调整：</p>
<ul>
<li>TotalReplicas：全部副本数</li>
<li>InSyncReplicas：每条消息至少要被这个数量的 Broker 确认（如果主为 ASYNC_MASTER 或者 AllAck 模式则该参数不生效）</li>
<li>MinInSyncReplicas：最小的同步副本数，如果 InSyncReplicas &lt; MinInSyncReplicas 会对客户端快速失败</li>
<li>AllAckInSyncStateSet：主确认持久化成功，为 true 表示需要 SyncStateSet 中所有备确认。</li>
</ul>
<p>​	因此，RocketMQ 提出了副本组在同步复制的模式下，也可以支持副本组的自适应降级（参数名称为 enableAutoInSyncReplicas）来适配消息的特殊场景。当副本组中存活的副本数减少或日志流水位差距过大时进行自动降级，最小降级到 minInSyncReplicas 副本数。比如在两副本下配置 。对于正常情况下，两个副本会处于同步复制，当备下线或假死时，会进行自适应降级，保证主节点还能正常收发消息，这个功能为用户提供了一个可用性优先的选择。</p>
<p><strong>d. 轻量级心跳与快速隔离</strong></p>
<p>​	在 RocketMQ v4.x 版本的实现中，Broker 周期性的（间隔 30 秒）将自身的所有 Topic 序列化并传输到 NameServer 注册进行保活。由于 Broker 上 Topic 的元数据规模较大，带来了较大的网络流量开销，Broker 的注册间隔不能设置的太短。同时 NameServer 对 Broker 是采取延迟隔离机制，防止 NameServer 网络抖动时可能瞬间移除所有 Broker 的注册信息，引发服务的雪崩。默认情况下异常主宕机时超过 2 分钟，或者备切换为主重新注册后才会替换。容错设计的同时导致 Broker 故障转移缓慢，RocketMQ v5.0 版本引入轻量级心跳（参数liteHeartBeat），将 Broker 的注册行为与 NameServer 的心跳进行了逻辑拆分，将心跳间隔减小到 1 秒。当 NameServer 间隔 5 秒（可配置）没有收到来自 Broker 的心跳请求就对 Broker 进行移除，使异常场景下自愈的时间从分钟级缩短到了秒级。</p>
<h1 id="RocketMQ-高可用架构演进路线"><a href="#RocketMQ-高可用架构演进路线" class="headerlink" title="RocketMQ 高可用架构演进路线"></a>RocketMQ 高可用架构演进路线</h1><h2 id="无切换架构的演进"><a href="#无切换架构的演进" class="headerlink" title="无切换架构的演进"></a>无切换架构的演进</h2><p>​	最早的时候，RocketMQ 基于 Master-Slave 模式提供了主备部署的架构，这种模式提供了一定的高可用能力，在 Master 节点负载较高情况下，读流量可以被重定向到备机。由于没有选主机制，在 Master 节点不可用时，这个副本组的消息发送将会完全中断，还会出现延迟消息、事务消息、Pop 消息等二级消息无法消费或者延迟。此外，备机在正常工作场景下资源使用率较低，造成一定的资源浪费。为了解决这些问题，社区提出了在一个 Broker 进程内运行多个 BrokerContainer，这个设计类似于 Flink 的 slot，让一个 Broker 进程上可以以 Container 的形式运行多个节点，复用传输层的连接，业务线程池等资源，通过单节点主备交叉部署来同时承担多份流量，无外部依赖，自愈能力强。这种方式下隔离性弱于使用原生容器方式进行隔离，同时由于架构的复杂度增加导致了自愈流程较为复杂。</p>
<h2 id="切换架构的演进"><a href="#切换架构的演进" class="headerlink" title="切换架构的演进"></a>切换架构的演进</h2><p>​	另一条演进路线则是基于可切换的，RocketMQ 也尝试过依托于 Zookeeper 的分布式锁和通知机制进行 HA 状态的管理。引入外部依赖的同时给架构带来了复杂性，不容易做小型化部署，部署运维和诊断的成本较高。另一种方式就是基于 Raft 在集群内自动选主，Raft 中的副本身份被透出和复用到 Broker Role 层面去除外部依赖，然而强一致的 Raft 版本并未支持灵活的降级策略，无法在 C 和 A 之间灵活调整。两种切换方案都是 CP 设计，牺牲高可用优先保证一致性。主副本下线时选主和路由定时更新策略导致整个故障转移时间依然较长，Raft 本身对三副本的要求也会面临较大的成本压力，RocketMQ 原生的 TransientPool，零拷贝等一些用来避免减少 IO 压力的方案在 Raft 下无法有效使用。</p>
<h2 id="RocketMQ-DLedger-融合模式"><a href="#RocketMQ-DLedger-融合模式" class="headerlink" title="RocketMQ DLedger 融合模式"></a>RocketMQ DLedger 融合模式</h2><p>RocketMQ DLedger 融合模式是 RocketMQ 5.0 演进中结合上述两条路线后的一个系统的解决方案。核心的特性有以下几点：</p>
<ol>
<li>利用可内嵌于 NameServer 的 Controller 进行选主，无外部依赖，对两副本支持友好。</li>
<li>引入 Epoch-StartOffset 机制来计算日志分叉位点。</li>
<li>消息在进行写入时，提供了灵活的配置来协调系统对于可用性还是一致性优先的诉求。</li>
<li>简化日志复制协议使得日志复制为高效。</li>
</ol>
<p>几种实现对比表如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031408328.png" alt="在这里插入图片描述"></p>
<h1 id="与其他消息系统的对比"><a href="#与其他消息系统的对比" class="headerlink" title="与其他消息系统的对比"></a>与其他消息系统的对比</h1><h2 id="控制节点"><a href="#控制节点" class="headerlink" title="控制节点"></a>控制节点</h2><ol>
<li>是否强制要求选主<br>Kafka 的 Controller 是 Broker 选举产生，这需要有一个存储节点间的服务发现机制。RocketMQ 的 Controller 可以作为管控节点单独存在。对 Kafka，Pulsar 而言必须选择主副本进行写入，随着时间的运行节点之间负载需要通过复杂的方案进行再均衡。对 RocketMQ 的融合架构而言，由于选主是可选的，静态布局的方案（例如无需依赖复杂的动态调度就可以较为均衡的实现跨机架跨可用区），并且无切换与切换架构可以相互转换。</li>
<li>Controller 的逻辑复杂度<br>RocketMQ Controller 相比 Kafka Controller 更加轻量，Kafka 的 Controller 承担 Partition 粒度的 ISR 维护和选举等功能，而RocketMQ 的 Controller 维护的数据是副本组粒度的，对于元数据只维护节点身份，更加简单。RocketMQ Controller 可以独立部署，也可以内嵌 NameServer 运行。</li>
<li>Controller 依赖程度<br>RocketMQ Broker 的同步副本集维护是 Master Broker 节点上报，由于不强依赖中心节点来提供租约，controller 宕机时虽然无法为同时有主故障的副本组选举，但不影响绝大部分副本组可用性。Pulsar 中通过 fencing 机制防止有多个 writer（pulsar 中的计算节点称为 broker）同时写同一个 partition，是对外部有依赖的。</li>
</ol>
<h2 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h2><ol>
<li>副本存储结构的抽象与最小粒度不同，在这一点上其实三者的设计各有优势</li>
</ol>
<ul>
<li>Kafka 的存储抽象粒度是 Partition，对每个分区进行维护多副本，扩容需要进行数据复制，对于冷读支持更好。</li>
<li>RocketMQ 的日志流是 Broker 粒度的，顺序写盘效率更高，在磁盘空间不足时一般选择水平扩容，只需复制元数据。</li>
<li>Pulsar 其实抽象了一个分布式日志流 Journal，分区被进一步分成分片，根据配置的时间或大小进行滚动，扩容只需复制元数据。</li>
</ul>
<ol start="2">
<li><p>复杂的参数配置被收敛至服务端<br>Kafka 和 RocketMQ 都支持灵活的配置单条消息的 ack 数，即权衡数据写入灵活性与可靠性。RocketMQ 在向云原生演进的过程希望简化客户端 API 与配置，让业务方只需关心消息本身，选择在服务端配置统一配置这个值。</p>
</li>
<li><p>副本数据的同步方式不同<br>   Pulsar 采用星型写：数据直接从 writer 写到多个 bookeeper。适合客户端与存储节点混部场景。数据路径只需要 1 跳，延迟更低。缺点是当存储计算分离时，星型写需要更多的存储集群和计算集群间网络带宽。<br>   RocketMQ 和 Kafka 采用 Y 型写：client 先写到一个主副本，由其再转发给另外 Broker 副本。虽然服务端内部带宽充裕，但需要 2 跳网络，会增加延迟。Y 型写利于解决文件多客户端写的问题，也更容易利用 2-3 写克服毛刺，提供更好的延迟稳定性。</p>
</li>
</ol>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/alisystemsoftware/article/details/131457069">https://blog.csdn.net/alisystemsoftware/article/details/131457069</a></p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ NameServer如何保证数据最终一致</title>
    <url>/2024/04/06/MQ/RocketMQ%20NameServer%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<p>[toc]<br>NameServer是RocketMQ的命名服务（路由中心、注册中心），提供更新和发现Broker服务的功能，是几乎无状态节点，可集群部署。NameServer节点之间互不通信，路由变化也不会马上通知客户端（生产者和消费者）。</p>
<p>既然NameServer的节点之间互不通信，变更也不发送通知，那又是如何保证数据最终一致的呢？</p>
<h2 id="路由更新"><a href="#路由更新" class="headerlink" title="路由更新"></a>路由更新</h2><ol>
<li><p>Broker节点在启动时，轮询NameServer集群，与每个NameServer节点建立长连接，发起注册请求。</p>
</li>
<li><p>Broker节点注册成功后，每隔30s定期向NameServer上报Topic路由信息，NameServer收到心跳包后记录Broker的最新时间戳。</p>
</li>
<li><p>Broker节点正常下线时，会与NameServer断开长连接，Netty的通道关闭，监听器会监听到连接断开事件，然后将这个Broker剔除掉。</p>
</li>
<li><p>NameServer中有一个定时任务，每隔10s扫描Broker列表，如果Broker的最新时间戳距离当前时间超过120s，会判定Broker失效并将其剔除掉。</p>
</li>
</ol>
<span id="more"></span>

<h2 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>​       生产者与NameServer集群中的一个随机节点建立长连接，每隔30s从NameServer读取Topic路由信息，并向提供Topic服务的Master Broker建立长连接，且定时向Master Broker发送心跳。</p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>​         消费者与NameServer集群中的一个随机节点建立长连接，每隔30s从NameServer拉取Topic路由信息，并向提供Topic服务的Master&#x2F;Slave Broker建立长连接，且定时向Master&#x2F;Slave Broker发送心跳。消费者可以从Master&#x2F;Slave Broker订阅消息，订阅规则由Broker配置决定。</p>
<p>​	无论是生产者还是消费者，都是每隔30s从NameServer拉取Topic路由信息，如果生产者和消费者在这30s内，向某个宕机的broker发送或消费消息呢？RocketMQ通过重试机制和Broker规避来保证消息可靠性。</p>
<h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><h3 id="消息发送重试"><a href="#消息发送重试" class="headerlink" title="消息发送重试"></a>消息发送重试</h3><p>​	生产者连接Broker发起消息发送请求时，可能会因为网络故障、服务异常等原因导致调用失败。为保证消息的可靠性，生产者会按照设置的重试次数一直重试发送消息。<br>​	同步发送和异步发送模式均支持消息发送重试。</p>
<h3 id="消息消费重试"><a href="#消息消费重试" class="headerlink" title="消息消费重试"></a>消息消费重试</h3><p>​	消费者出现异常，消费某条消息失败时，会根据消费重试策略重新投递该消息进行故障恢复。超过一次定数后若还未消费成功，则该消息将不再继续重试，直接被发送到死信队列中。</p>
<h3 id="Broker规避"><a href="#Broker规避" class="headerlink" title="Broker规避"></a>Broker规避</h3><p>​	在一次消息发送过程中规避上次发送失败的Broker，在一时间段内，生产者不会选择该Broker上的消息队列，提高发送消息的成功率。</p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
  </entry>
  <entry>
    <title>闲聊MQ设计之异（Kafka、RocketMQ 、Pulsar ）</title>
    <url>/2024/04/06/MQ/%E9%97%B2%E8%81%8AMQ%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%BC%82%EF%BC%88Kafka%E3%80%81RocketMQ%20%E3%80%81Pulsar%20%EF%BC%89/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><ol>
<li>Kafka 架构中，服务节点没有主从之分，主从概念是针对某个 topic 下的分区。 </li>
<li>存储单位为分区，通过不同方式分散在各个节点，形成各种架构图。</li>
<li>生产者数量为 1，消费者数量为 1，分区数为 2，副本数为 3，服务节点数为 3。</li>
<li>图中有两块绿色图案，分别为 topic1-partition1 分区和 topic1-partition2 分区，浅绿色方块为它们的副本。</li>
<li>对于服务节点 1，topic1-partition1 是主节点；对于服务节点 2，topic1-partition2 是主节点。</li>
</ol>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031504810.png" alt="在这里插入图片描述"></p>
<span id="more"></span>

<p>消息队列的大致工作流程如下：</p>
<ol>
<li><p>生产者、消费者与元数据中心建立连接，并保持心跳，获取服务的实况和路由信息。</p>
</li>
<li><p>生产者将消息发送到 topic 下的任一分区中，通过算法保证每个 topic 下的分区尽可能均匀。</p>
</li>
<li><p>信息需要落盘才可以给上游返回 ack，以保证宕机后的信息的完整性。</p>
</li>
<li><p>在信息写成功主分区后，系统会根据策略选择同步复制还是异步复制，以保证单节点故障时的信息完整性。</p>
</li>
<li><p>消费者开始工作，拉取响应的信息，并返回 ack。</p>
</li>
<li><p>消费者在获取消息时，会根据偏移量 (offset) 进行拉取，每次拉取后偏移量加 1。</p>
</li>
</ol>
<h2 id="Good-Design-—-磁盘顺序写盘"><a href="#Good-Design-—-磁盘顺序写盘" class="headerlink" title="Good Design —&gt; 磁盘顺序写盘"></a>Good Design —&gt; 磁盘顺序写盘</h2><p>Kafka 在底层设计上强依赖于文件系统（一个分区对应一个文件系统），本质上是基于磁盘存储的消息队列，在我们固有印象中磁盘的读写速度是非常慢的，慢的原因是因为在读写的过程中所有的进程都在抢占“磁头”这把锁，磁头在读写之前需要将其移动到合适的位置，这个“移动”极其耗费时间，这也就是磁盘慢的原因，但是如何不用移动磁头呢，顺序写盘就诞生了。</p>
<p>Kafka 消息存储在分区中，每个分区对应一组连续的物理空间。新消息追加到磁盘文件末尾。消费者按顺序拉取分区数据消费。Kafka 的读写是顺序的，可以高效地利用 PageCache，解决磁盘读写的性能问题。</p>
<p>这一特性非常重要，很多组件的底层存储设计都会用到这点，理解好这点对理解消息队列尤为重要。</p>
<h2 id="Poor-Impact—-topic-数量不能过大"><a href="#Poor-Impact—-topic-数量不能过大" class="headerlink" title="Poor Impact—&gt; topic 数量不能过大"></a>Poor Impact—&gt; topic 数量不能过大</h2><p>kafka 的整体性能受 topic 数量的限制，这和底层的存储有密不可分的关系，我们上面讲过，当消息来的时候，底层数据使用追加写入的方式，顺序写盘，使得整体的写性能大大提高，但这并不能代表所有情况，当我们 topic 数量从几个变成上千个的时候，情况就有所不同了</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031504701.png" alt="在这里插入图片描述"></p>
<ul>
<li>左图代表了，队列中从头到尾的信息为：topic1、topic1、topic1、topic2，在这种情况下，很好地运用了顺序写盘的特性，磁头不用去移动；</li>
<li>右边图的情况，队列中从头到尾的信息为：topic1、topic2、topic3、topic4，当队列中的信息变的很分散的时候，这个时候我们会发现，似乎没有办法利用磁盘的顺序写盘的特性，因为每次写完一种信息，磁头都需要进行移动。</li>
</ul>
<p>就很好理解，为什么当 topic 数量很大时，kafka 的性能会急剧下降了。当然没有其他办法了吗，当然有。我们可以把存储换成速度更快 ssd 或者针对每一个分区都搞一块磁盘，当然这都是钱！ 这也是架构设计中的一种 trade off</p>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><p>对比 kafka，rocketmq 有两点很大的不同：</p>
<ul>
<li>元数据管理系统，从 zookeeper 变成了轻量级的独立服务集群。</li>
<li>服务节点变为 多主多从架构</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031506211.png" alt="在这里插入图片描述"></p>
<h2 id="zookeeper-vs-namesrv"><a href="#zookeeper-vs-namesrv" class="headerlink" title="zookeeper vs namesrv"></a>zookeeper vs namesrv</h2><p>zookeeper 是 cp 强一致架构的一种，其内部使用 zab 算法，进行信息同步和容灾，在信息量较小的情况下，性能较好，当信息交互变多，因为同步带来的性能损耗加大，性能和吞吐量降低。如果 zookeeper 宕机，会导致整个集群的不可用，对于一些交易场景，这是不可接受的</p>
<ul>
<li><p>相比 Zookeeper，RocketMQ 选择了轻量级的独立服务器 NameSRV。</p>
</li>
<li><p>NameSRV 使用简单的 K&#x2F;V 结构保存信息。</p>
</li>
<li><p>NameSRV 支持集群模式，每个 NameSRV 相互独立，不进行任何通信。</p>
</li>
<li><p>Data 都保存在内存当中，Broker 的注册过程通过循环遍历所有 NameSRV 进行注册。</p>
</li>
</ul>
<h2 id="局部顺序写（kafka）-与-完全顺序写（rocketmq）"><a href="#局部顺序写（kafka）-与-完全顺序写（rocketmq）" class="headerlink" title="局部顺序写（kafka） 与 完全顺序写（rocketmq）"></a>局部顺序写（kafka） 与 完全顺序写（rocketmq）</h2><ul>
<li>Kafka 将不同分区写入对应的文件系统中，保证了优秀的水平扩容能力。</li>
<li>RocketMQ 追求极致的消息写，将所有 topic 消息存储在同一个文件中，确保消息发送时按顺序写文件，提高可用性和吞吐量。</li>
<li>RocketMQ 的设计使得其不支持删除指定 topic 功能，因为 topic 信息在磁盘上是一段非连续的区域，不像 Kafka 一个 topic 是一段连续的区域。</li>
</ul>
<h2 id="Rocketmq-存储结构"><a href="#Rocketmq-存储结构" class="headerlink" title="Rocketmq 存储结构"></a>Rocketmq 存储结构</h2><p>RocketMQ 的存储结构设计是为了追求极致的消息写性能，它采用了混合存储的方式，将多个 Topic 的消息实体内容都存储于一个 CommitLog 中。在 RocketMQ 的存储架构中，有三个重要的存储文件，分别是 CommitLog、ConsumeQueue 和 IndexFile。</p>
<ol>
<li><p>CommitLog<br>CommitLog 是存储消息的主体。Producer 发送的消息都会顺序写入 commitLog 文件，所以随着写入的消息增多，文件也会随之变大。单个文件大小默认 1G，文件名长度为 20 位，左边补零，剩余为起始偏移量。例如，00000000000000000000 代表了第一个文件，起始偏移量为 0，文件大小为 1G。当第一个文件写满了，第二个文件为 00000000001073741824，起始偏移量为 1073741824，以此类推。存储路径为 <code>HOME/store/commitLog</code>。     </p>
</li>
<li><p>ConsumeQueue<br>ConsumeQueue(逻辑消费队列) 可以看成基于 topic 的 commitLog 的索引文件。因为 CommitLog 是按照顺序写入的，不同的 topic 消息都会混淆在一起，而 Consumer 又是按照 topic 来消费消息的，这样的话势必会去遍历 commitLog 文件来过滤 topic，这样性能肯定会非常差，所以 rocketMq 采用 ConsumeQueue 来提高消费性能。即每个 Topic 下的每个 queueId 对应一个 Consumequeue，其中存储了单条消息对应在 commitLog 文件中的物理偏移量 offset，消息大小 size，消息 Tag 的 hash 值。存储路径为 <code>HOME/store/consumequeue/topic/queueId/fileName</code>。</p>
</li>
<li><p>IndexFile<br>IndexFile 提供了一种可以通过 key(topicmsgId) 或时间区间来查询消息的方法。他的存在主要是针对在客户端 (生产者和消费者) 和控制台接口提供了根据 key 查询消息的实现。为了方便用户查询具体某条消息。IndexFile 的存储结构可以认为是一个 hashmap。存储路径为 <code>HOME/store/index/. HOME/store/index/fileName</code> 文件名 fileName 是以创建时的时间戳命名的。</p>
</li>
</ol>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031508637.png" alt="在这里插入图片描述"></p>
<p>总结起来，RocketMQ 的存储结构设计非常复杂，但它通过合理的设计实现了高效的消息写入和读取性能。同时，RocketMQ 也支持多种存储方式，如本地存储、分布式存储和云存储等，可以满足不同场景下的需求。</p>
<h1 id="Pulsar"><a href="#Pulsar" class="headerlink" title="Pulsar"></a>Pulsar</h1><p>架构图（分层+分片）</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031508624.png" alt="在这里插入图片描述"></p>
<p>pulsar 相比与 kafka 与 rocketmq 最大的特点则是使用了分层和分片的架构，回想一下 kafka 与 rocketmq，一个服务节点即是计算节点也是服务节点，节点有状态使得平台化、容器化困难、数据迁移、数据扩缩容等运维工作都变的复杂且困难。</p>
<ul>
<li><p>分层：Pulsar 分离出了 Broker（服务层）和 Bookie（存储层）架构，Broker 为无状态服务，用于发布和消费消息，而 BookKeeper 专注于存储。</p>
</li>
<li><p>分片 : 这种将存储从消息服务中抽离出来，使用更细粒度的分片（Segment）替代粗粒度的分区（Partition），为 Pulsar 提供了更高的可用性，更灵活的扩展能力</p>
</li>
</ul>
<h2 id="服务层设计"><a href="#服务层设计" class="headerlink" title="服务层设计"></a>服务层设计</h2><p>Broker 集群在 Pulsar 中形成无状态服务层。服务层是“无状态的”，所有的数据信息都存储在了 BookKeeper 上，所有的元信息都存储在了 zookeeper 上，这样使得一个 broker 节点没有任何的负担，这里的负担有几层含义：</p>
<ul>
<li>容器化没负担，broker 节点不用考虑任何数据状态带来的麻烦。</li>
<li>扩容、缩容没负担，当请求量级突增或者降低的同时，可以随时的添加节点或者减少节点以动态的调整资源，使得整体在一种“合适”的状态。</li>
<li>故障转移没负担，当一个节点宕机、服务不可用时，可以通快速地转移所负责的 topic 信息到别的基节点上，可以很好做到故障对外无感知。</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031509926.png" alt="在这里插入图片描述"></p>
<h2 id="存储层设计"><a href="#存储层设计" class="headerlink" title="存储层设计"></a>存储层设计</h2><p>pulsar 使用了类似于 raft 的存储方案，数据会并发的写入多个存储节点上，下图为四存储节点、三副本架构。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031510962.png" alt="在这里插入图片描述"></p>
<p>broker2 节点当前需要写入 segment1 到 segment4 数据，流程为： segment1 并发写入 b1、b2、b3 数据节点、segment2 并发写入 b2、b3、b4 数据节点、segment3 并发写入 b3、b4、b1 数据节点、segment4 并发写入 b1、b2、b4 数据节点。这种写入方式称为条带化的写入方式。</p>
<p>这种方式潜在的决定了数据的分布方式、通过路由算法，可以很快的找到对应数据的位置信息，在数据迁移与恢复中起到重要的作用。</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>当存储节点资源不足的时候，常规的运维操作就是动态扩容，相比 kafka 与 rocketmq、pulsar 不用考虑原数据的”人为”搬移工作，而是动态新增一个或者多个节点，broker 在写入数据时通过路有算法优先写入资源充足的节点，使得整体的资源利用力达到一个平衡的状态，如图所示。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031511575.png" alt="在这里插入图片描述"></p>
<h2 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h2><p>当 bookie4 存储节点宕机不可用时，如何恢复节点数据？这里只需要增加新的存储节点，并且拷贝 bookie2 与 bookie3 上的数据即可，这个过程对外是无感知的，实现了平滑切换，如图所示</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031512780.png" alt="在这里插入图片描述"></p>
<hr>
<p>转载自：<br><a href="https://artisan.blog.csdn.net/article/details/131903082?spm=1001.2014.3001.5502">https://artisan.blog.csdn.net/article/details/131903082?spm=1001.2014.3001.5502</a></p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
  </entry>
  <entry>
    <title>Apache RocketMQ在阿里云大规模商业化实践之路</title>
    <url>/2024/08/03/MQ/Apache%20RocketMQ%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%95%86%E4%B8%9A%E5%8C%96%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="阿里云消息队列-RocketMQ-商业化历程"><a href="#阿里云消息队列-RocketMQ-商业化历程" class="headerlink" title="阿里云消息队列 RocketMQ 商业化历程"></a>阿里云消息队列 RocketMQ 商业化历程</h1><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031433010.png" alt="在这里插入图片描述"></p>
<p>RocketMQ 诞生于 2012 年，诞生即开源。2012～2015 年，RocketMQ 一直在通过内部电商业务打磨自身服务能力,并在 2015 年于阿里云上线公测。2016 年，阿里云 RocketMQ 完成商业化，同时被捐赠给 Apache 基金会，同年获得了年度受欢迎中国开源软件荣誉。</p>
<p>在 Apache 孵化期间，Apache RocketMQ 经历了快速发展，2017 年即毕业成为了 Apache 顶级项目。同年，Apache RocketMQ TLP RocketMQ 4.0 正式发布。此后，RocketMQ 4.0 经历了长足发展，期间阿里云商业和开源相辅相成、齐头并进，直到今天，共同迈入 RocketMQ 5.0 时代。</p>
<p>RocketMQ 5.0 发布后，阿里云商业会持续采取 OpenCore 的发展模式，秉承上游优先的社区发展原则，与社区一起将 RocketMQ 打造为一个超融合的数据处理平台。</p>
<span id="more"></span>

<h1 id="阿里云消息队列产品矩阵"><a href="#阿里云消息队列产品矩阵" class="headerlink" title="阿里云消息队列产品矩阵"></a>阿里云消息队列产品矩阵</h1><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031434204.png" alt="在这里插入图片描述"></p>
<p>阿里云基于 RocketMQ 消息底座，构建了多元化的消息产品系列。</p>
<p>RocketMQ 是阿里云主打的消息品牌，互联网新兴业务领域首选的数据通道。消息队列 Kafka 是大数据的首选数据通道，微消息队列 MQTT 是移动互联网和物联网的数据通道，消息队列 RocketMQ 是传统业务领域的数据通道。消息服务 MNS 是 RocketMQ 轻量版，主要应用于应用集成领域，为平台型应用提供简单的队列服务。事件总线 Event Bridge 定位为云上事件枢纽，旨在阿里云上构建统一的事件中心。</p>
<p>阿里云消息队列产品矩阵完全构建在 RocketMQ 之上，基本实现了应用场景全覆盖，包括微服务解耦、SaaS 集成、物联网、大数据或日志收集生态，同时也在内部覆盖了阿里巴巴所有业务，在云上为数万阿里云企业提供了优质的消息服务。阿里云的消息产品矩阵涵盖了互联网、大数据、移动互联网等领域业务场景，为云原生客户提供不可或缺的一站式解决方案。</p>
<p>RocketMQ 在阿里云商业化历程中，一直致力于探索业务消息实践，也孵化了大量业务消息特性，并持续反哺到开源社区。</p>
<h1 id="RocketMQ-4-0-业务消息探索之路"><a href="#RocketMQ-4-0-业务消息探索之路" class="headerlink" title="RocketMQ 4.0 业务消息探索之路"></a>RocketMQ 4.0 业务消息探索之路</h1><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031434265.png" alt="在这里插入图片描述"></p>
<p>RocketMQ 在商业化过程中，陆续推出了四种消息类型来满足丰富的业务场景。</p>
<ul>
<li><p>普通消息：普通消息提供极致弹性、海量堆积能力，内置重试与死信队列来满足业务对失败重试的需求，同时具备高吞吐、高可用、低延迟等特性，广泛应用于应用集成、异步解耦、削峰填谷等场景。</p>
</li>
<li><p>定时消息：提供秒级定时精度， 40 天超长定时，主要面向分布式定时调度、任务超时处理等场景，目前正在开源中。</p>
</li>
<li><p>顺序消息：支持全局与局部严格有序，从发送、存储到消费，保证端到端有序。面向有序事件处理、撮合交易、数据实时增量同步等场景。</p>
</li>
<li><p>事务消息：分布式、高性能、高可用的最终一致性事务解决方案，广泛应用于电商交易系统中服务的一致性协调场景并且已经开源。</p>
</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031434274.png" alt="在这里插入图片描述"></p>
<p>RocketMQ 4.0 期间，商业和开源都致力于全方位拓展消息接入能力，使 RocketMQ 能够非常轻松地连接应用开源和云产品生态。比如商业上提供了多语言 SDK ，开源也有相应的 SDK 能够覆盖 Java、Go、Python 、C++使用 RocketMQ。同时支持 Spring 生态，能够通过 Spring Cloud 的方式使用 RocketMQ。商业上提供了一组非常简单易用的 HTTP API，提供了 6-7 种语言的实现。</p>
<p>除了 SDK 接入，RocketMQ 也在积极拥抱社区标准，在云产品侧提供了 AMQP 和 MQTT 的接入能力，其中 MQTT 已开源。</p>
<p>RocketMQ 也大力在发展 connector 生态，能够通过 RocketMQ connector 接入很多数据源，包括 Redis、MongoDB、Hudi 等大数据系统。</p>
<p>另外，阿里云构建的事件总线 EventBridge 也已开源，通过该产品能够将阿里云的云产品、SaaS 应用、自建数据平台的数据引入 RocketMQ。</p>
<p>RocketMQ 4.0 版本做了大量尝试，提供了全方位的消息接入能力。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031435248.png" alt="在这里插入图片描述"></p>
<p>RocketMQ 在服务阿里集团用户和商业化历程中，沉淀了大量领先的业务消息处理与服务能力。比如消息订阅方面，RocketMQ 支持集群分布式消费能力，也支持广播消费。在消息处理方面支持基于 Tag 和 SQL 做灵活过滤，其中基于 SQL 过滤是电商交易中非常重要的特性，能够支持在非常订阅比的情况下实现较低的投递比。</p>
<p>全球消息路由能力具备性能高、实时性强的特点。在云时代，数据中心天然分布在各个地域，各个地域之间还有 VPC 网络隔离。但是通过全球消息路由功能可以将地域与网络打通，能够满足更多业务场景。比如在阿里内部基于该能力实现了异地多活、异地容灾等企业级特性。</p>
<p>另外，全球消息路由具备非常高的易用性，提供了可视化任务管理界面，通过简单配置即可创建复制链路。</p>
<p>消息治理方面，RocketMQ 提供了访问控制、命名空间、实例限流、消息回放、重试消息、死信消息、堆积治理等能力。</p>
<p>服务能力方面，RocketMQ 经历了非常多沉淀，它在为交易链路服务了 12 年，参加了 10 年双 11，这也保证了 RocketMQ 能够在阿里云上提供非常高的可靠性。双 11 消息收发 TPS 峰值过亿，日消息收发总量超过 3 万亿。而即使在双十一万亿级数据洪峰下，消息也能做到 99.996% 毫秒级响应能力，消息发布平均响应时间不超过 3 毫秒，最大不超过 20 毫秒，真正实现了低延迟消息发布。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031435639.png" alt="在这里插入图片描述"></p>
<p>商业化初期，客户遇到最大难题是在分布式环境下如何完整地追踪异步消息链路。基于此背景，我们打造了可视化全生命周期消息轨迹追踪系统，能够提供丰富的消息查询、消息下载、定点重投、轨迹追踪能力，通过可观测系统帮助用户解决分布式环境中不可观测的问题。</p>
<p>如上图所示，一条消息从产生、发送至服务端存储到最终投递到消费者，整个发送和消费轨迹都有迹可循，包括投递给哪些消费者、哪些消费者在什么地方成功消费或者消费失败、何时进行重投，真正帮助客户解决了分布式观测难题。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031435562.png" alt="在这里插入图片描述"></p>
<p>除了功能特性，RocketMQ 在稳定性方面也做了很多建设。我们始终坚持，SLA 是云原生的根本，因此整个研发运维链路都有严格的稳定性保障措施：</p>
<ul>
<li><p><strong>架构开发</strong>：每个方案设计都会面向失败设计，代码开发阶段会有严格 Code Review 阶段，也会完整经历单元测试、集成测试、性能测试和容灾测试流程。</p>
</li>
<li><p><strong>变更管理</strong>：有着非常严格的变更制度，要做到每个变更可灰度、可监控、可回滚、可降级。</p>
</li>
<li><p><strong>稳定性防护</strong>：提供了限流、降级、容量评估、应急方案、大促保障等能力，会定期进行故障和预案演练，定期进行风险梳理。</p>
</li>
<li><p><strong>体系化巡检</strong>：在云上有全方位的生产环境黑盒巡检。基于用户视角，会对全地域所有功能做全功能扫描，包含高达 50 多项检测项，任意项功能出问题都能立刻被监测到。在白盒巡检方面，会对 JVM 运行时指标、内核系统、集群指标进行巡检。</p>
</li>
<li><p><strong>故障应急</strong>：有完整地故障应急流程，包括监控报警、故障发生、快速止血、排查根因、故障复盘。</p>
</li>
</ul>
<h1 id="RocketMQ-5-0-云原生架构升级之路"><a href="#RocketMQ-5-0-云原生架构升级之路" class="headerlink" title="RocketMQ 5.0 云原生架构升级之路"></a>RocketMQ 5.0 云原生架构升级之路</h1><p>云原生时代，云上用户对云产品服务化程度、弹性能力、可控制性能力以及韧性都有了更高的要求。在此背景之下，我们对 RocketMQ 进行了云原生架构升级，这也是 RocketMQ 5.0 的诞生背景。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031436561.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>轻量级 SDK：基于云原生通信标准 gRPC 开发了一组轻量级 SDK，能够与当前富客户端优势互补。</p>
</li>
<li><p>无状态消息网关：在核心数据链路推出了无状态消息网关。通过搭建无状态服务节点Proxy，再通过 LB 进行服务暴露，将存储节点数据分离来独立负责核心消息存储和高可用。Proxy 与 Store 节点分离部署，独立弹性。</p>
</li>
<li><p>Leaderless 高可用架构：Store 节点身份完全对等，完全 Leaderless 化，去 ZK 和 HA 管控节点，能够做到非常高的可用性。同时相比传统的 Raft 一致性协议，该 Leaderless 架构能够做到副本数灵活选择，同步异步自动升降级，实现秒级故障转移。高可用架构目前已经完成开源并与 Dledger 进行了融合。</p>
</li>
<li><p>云原生基础设施：可观测验能力云原生化，OpenTelemetry 标准化。整体架构走向 Kubernetes 化，能够充分利用售卖区的资源弹性能力。</p>
</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031436858.png" alt="在这里插入图片描述"></p>
<p>RocketMQ 4.0 推荐的接入方式主要是富客户端。富客户端提供了诸如客户端侧负载均衡、消息缓存、故障转移等一系列企业级特性。但在云原生时代，轻量级、高性能的客户端更容易被云原生技术栈所集成。</p>
<p>因此，RocketMQ 5.0 重磅推出了全新多语言轻量级 SDK，具有以下优势：</p>
<ul>
<li><p>全新极简 API 设计：不可变 API，有完善的错误处理。多语言 SDK 保障 API 在 Native 层面对齐。同时引入了全新的 Simple Consumer，能够支持按消息模型进行消费，用户不再需要关心消息队列，只需要关注消息。</p>
</li>
<li><p>通信层采用 gRPC 协议：拥抱云原生通信标准，gRPC 能够使服务更易被集成。多语言 SDK 通信代码也可以通过 gRPC 快速生成，更 Native 。</p>
</li>
<li><p>轻量级实现：采用无状态消费模式，能够大幅降低客户端的实现复杂度。客户端更轻量，采用的应用也更容易被 Serverless化、Mesh 化。</p>
</li>
<li><p>云原生可观测性：客户端实现了 OpenTelemetry 标准，能够支持以 OpenTelemetry 形式导出 Metrics 与 Tracing。</p>
</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031437923.png" alt="在这里插入图片描述"></p>
<p>RocketMQ 5.0 的另一个重大升级是引入了全新的无状态消费模型。该消费模型完全构建在原先的队列模型之上。队列模型是与存储模型一致的消费模型，消费者完全按照队列做负载均衡，也按照队列做消息拉取，非常适合批量高速拉取以及对单条消息状态不敏感的场景，比如流计算等。</p>
<p>RocketMQ 5.0 推出了 PoP 机制，巧妙地在队列模型之上构建了消息模型，实现了鱼与熊掌兼得。在此消息模型的设计上，业务可以只关心消息而无需关心队列，所有 API 都能够支持单条消息级别的消费、重试、修改不可见时间、删除。</p>
<p>在消息模型下，消息发送过来被存储后，即对消费者可见。消费者通过 Receive Message API 对消息进行消费后，消息进入定时不可见状态。消息超时过后又会重新处于可见状态，能被其他消费者继续消费。某消费者确认消息后，服务端会对该消息进行删除，随即不可见。</p>
<p>基于消息系模型的消费流程下，API 完全面向消息而不是面向队列。而当 PoP 机制遇见了无状态 Proxy，除了存储层，其他节点都是无状态的；客户端、连接和消费也是无状态的，可任意在 Proxy 节点上飘移，真正做到轻量级。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031437182.png" alt="在这里插入图片描述"></p>
<p>经过重构，RocketMQ 5.0 的可观测性也走向了云原生标准。</p>
<p><strong>Metrics 侧：</strong></p>
<ul>
<li>指标涵盖丰富：设计了更丰富的指标，包含消息量、堆积量、各个阶段耗时等指标，每个指标从实例、Topic、消费 GroupID 多维度做聚合和展示。</li>
<li>消息团队实践模板：为用户提供实践模板，并持续迭代更新。</li>
<li>Prometheus + Grafana：Prometheus 标准数据格式，利用 Grafana 展示。除了模板，用户也可以自定义展示大盘。</li>
</ul>
<p><strong>Tracing 侧：</strong></p>
<ul>
<li>OpenTelemetry Tracing 标准：RocketMQ Tracing 标准已经合并到 OpenTelemetry 开源标准，提供了规范和丰富的 messaging tracing 场景定义。</li>
<li>消息领域定制化展示：按照消息维度重新组织抽象的请求 span数据，展示一对多的消费，多次消费信息直观且方便理解。</li>
<li>可衔接 tracing 链路上下游：消息的 tracing 可继承调用上下文，补充到完整的调用链路中，消息链路信息串联了异步链路的上游和下游链路信息。</li>
</ul>
<p><strong>Logging 侧：</strong></p>
<ul>
<li>Error Code 标准化：不同的错误有唯一的 Error Code。</li>
<li>Error Message 完整：包含完整的错误信息和排序所需要的资源信息。</li>
<li>Error Level 标准化：细化了各种不同错误信息的日志级别，用户可根据 Error、Warn 等级别配置更适合的监控告警。</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031438651.png" alt="在这里插入图片描述"></p>
<p>弹性方面，RocketMQ 5.0 商业版能够充分撬动云的计算、存储和网络的池化资源。比如在计算方面，RocketMQ 5.0 所有工作负载完全部署在 ACK 之上，充分利用了 ACK 弹性能力，撬动 ACK 弹性资源。主要依赖 ACK 的两项技术，一是弹性资源池，另一个是 HPA 支持计算能力快速弹性。同时也会在 ACK 之上做跨可用区部署以提供高可用保障。</p>
<p>网络层面，RocketMQ 5.0 也会充分利用阿里云网络设施，为用户提供更便捷的网络访问能力。比如 RocketMQ 5.0 实例能够支持公网随开随用，需要依赖公网做测试的时候即开即用，测试完立即关闭，安全与方便兼具。同时支持多种私网类型的网络形态，包括 Single Tunnel、Private Link，另外也基于 CEN 构建了全球互通设计网络。</p>
<p>存储方面，RocketMQ 5.0 商业版率先引入多级存储概念，基于 OSS 构建二级存储，能够充分利用 OSS 存储的弹性能力，存储计费也转向了按量付费。而用户能够在 RocketMQ 之上自定义消息存储时长，比如将消息从 3 天有效时长延长至 30 天，能够真正将消息变为数据资产。同时利用二级存储能力，将冷热数据分离，为用户提供一致的冷读 SLA 。</p>
<h1 id="RocketMQ-5-0-商业版发布预告"><a href="#RocketMQ-5-0-商业版发布预告" class="headerlink" title="RocketMQ 5.0 商业版发布预告"></a>RocketMQ 5.0 商业版发布预告</h1><p>RocketMQ 4.0 历经了五年发展，开源和商业版本共同迈入了 5.0 时代。7 月底，阿里云消息队列将会基于开源版发布全新的 5.0 商业化版本。注：截止发稿前，RocketMQ 5.0 已经在阿里云消息队列 RocketMQ 产品上全新发布，目前支持国内主要地域。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031438264.png" alt="在这里插入图片描述"></p>
<p>RocketMQ 5.0 版相对于 4.0 版实例主要有以下几大改变：</p>
<p>第一，新版本、新售卖，更便宜。新版本采取了全新计量方式，有包年、包月型，也有按量付费和公网流量弹性计费。也有更全的售卖体系，比如新增专业版实例，能够满足部分用户需求。同时每个商品系列都新增了测试环境专用实例，能够方便用户以低成本的方式搭建自己的开发环境。</p>
<p>第二，更强弹性，降本提效利器。存储完全走向弹性，能够通过 Serverless 按需使用，按量付费。预留弹性，实例基础规格支持实时升降配，用户可以很方便地在流量到来之前做弹性。此外，专业版支持突发流量弹性，能够解决线上稳定性风险。</p>
<p>第三，全新架构，增强可观测运维。无状态消息消费模型能够解决一些老版本的痛点。同时在可观测上全面采取了云原生接入栈。</p>
<h1 id="消息的全新形态：事件总线-EventBridge"><a href="#消息的全新形态：事件总线-EventBridge" class="headerlink" title="消息的全新形态：事件总线 EventBridge"></a>消息的全新形态：事件总线 EventBridge</h1><p>事件总线 EventBridge 已经开源到 RocketMQ 社区中。云原生时代，事件无处不在，云计算资源散落在各地，各类生态孤岛随处可见。因此，以事件和事件驱动的方式来集成这一切是大势所趋。</p>
<p>基于此，阿里云推出了全新事件型产品 EventBridge。该产品构建在 RocketMQ 之上，是 RocketMQ 之上的一个事件驱动架构实践。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031438083.png" alt="在这里插入图片描述"></p>
<p>EventBridge 的事件源包括阿里云服务的管控事件比如资源变更事件、审计事件、配置变更事件，阿里云服务的数据事件，也包括自定义应用、SaaS 应用、自建数据平台、其他云厂商服务等。</p>
<p>事件经过 EventBridge 处理后会投递到事件目标，事件目标包括函数计算、消息服务、自建网关、HTTP(S)、短信、邮箱、钉钉等。</p>
<p>事件源到事件目标之间会经历完整的事件处理，包括事件源接入到 EB 后，可以对事件进行过滤、转换、归档、回放等。事件在 EventBridge 整个流程中也有完善的可观测性设计，包括事件查询、链路追踪。事件的接入方式非常丰富，可以通过 OpenAPI 来接入、7 种多语言 SDK、CloudEvents SDK、Web Console 和 Webhook 。</p>
<p>EventBridge 具有如下特点：</p>
<ul>
<li><p>能够大幅度减少用户开发成本，用户无需额外开发，通过创建 EventBridge 源、事件目标、事件规则等资源即可实现事件架构。用户可以编写事件规则，对事件做过滤、转换。</p>
</li>
<li><p>提供原生 CloudEvents 支持，拥抱 CNCF 社区，能够无缝对接社区 SDK 。标准协议也能统一个阿里云事件规范。</p>
</li>
<li><p>事件 Schema 支持：能够支持事件 Schema 自动探测和校验，支持 Source 和 Target 的 Schema 绑定。</p>
</li>
<li><p>全球事件任意互通：组建了全球事件任意互通网络，组件了跨地域、跨账户的事件网络，能够支持跨云、跨数据中心的事件路由。</p>
</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408031439093.png" alt="在这里插入图片描述"></p>
<p>EventBridge在云上生态已经初具规模，已经集成了 255+ 云产品事件源和 1000+ 事件类型。</p>
<p>EventBridge率先对消息生态做了融合。阿里云的消息产品矩阵生态均通过 EventBridge 做了完全融合。任何一款消息产品与另一款消息产品的数据都能互通。同时，依靠 EventBridge 的全球事件网络，能够为所有消息产品赋予全球消息路由的能力。</p>
<p>EventBridge 目前已经在内部接入钉钉 ISV、聚石塔 ISV，外部也有 50+ SaaS 系统可以通过 Webhook 的方式接入。另外，海量事件源可以触达 10 多种事件目标，已经对接了全系云产品 API ，任何事件都可以驱动全量云产品 API。</p>
<hr>
<p>原文链接：<br><a href="https://blog.csdn.net/alisystemsoftware/article/details/127338274">https://blog.csdn.net/alisystemsoftware/article/details/127338274</a></p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
  </entry>
  <entry>
    <title>Redis Cluster模式架构介绍</title>
    <url>/2024/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E7%BC%93%E5%AD%98/Redis/Redis%20Cluster%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>Redis Cluster，采用了去中心化的多主多从架构，以提高数据的可用性和伸缩性。Redis集群的目的是实现数据的横向伸缩，把一块数据分片保存到多个机器，可以横向扩展数据库大小，扩展带宽，计算能力等。</p>
<p>以下是Redis Cluster的几个关键特点和优势的详细阐述：</p>
<ul>
<li><p><strong>去中心化的多主多从架构</strong>：</p>
<ul>
<li>每个从节点都复制主节点的数据，但不直接参与读写操作，主要用于数据备份和故障恢复。</li>
<li>这种架构使得每个节点都可以在需要时承担主节点的角色，从而提高了整体系统的可靠性和容错能力。</li>
</ul>
</li>
<li><p><strong>数据处理与性能</strong>：</p>
<ul>
<li>Redis Cluster在处理涉及多个键的操作时可能面临性能挑战，尤其是在数据量大和高并发的场景下。这是因为多key操作可能需要跨多个节点进行，从而增加了操作的复杂性。</li>
<li>然而，对于单key操作，Redis Cluster能够保持其一贯的高性能，特别是在读操作上。</li>
</ul>
</li>
<li><p><strong>动态扩容和收缩能力</strong>：</p>
<ul>
<li>Redis Cluster支持动态地添加或移除节点，这意味着可以根据实际需求调整集群的规模，无需停机或中断服务。</li>
<li>这一特性对于处理不断变化的负载和数据量非常重要，使得Redis Cluster在大型应用中更具弹性。</li>
</ul>
</li>
<li><p><strong>节点间的通信与故障转移</strong>：</p>
<ul>
<li>在Redis Cluster中，主节点之间会进行定期的健康检查和状态同步，确保数据的一致性。</li>
<li>当主节点出现故障时，其他主节点可以通过选举机制快速选出新的主节点，实现故障的自动转移，从而确保服务的连续性。</li>
</ul>
</li>
</ul>
 <span id="more"></span>

<p>​	Redis Cluster 是Redis的集群实现，内置数据自动分片机制，集群内部将所有的key映射到16384个Slot中，集群中的每个Redis Instance负责其中的一部分的Slot的读写。集群客户端连接集群中任一Redis Instance即可发送命令，当Redis Instance收到自己不负责的Slot的请求时，会将负责请求Key所在Slot的Redis Instance地址返回给客户端，客户端收到后自动将原请求重新发往这个地址，对外部透明。一个Key到底属于哪个Slot由crc16(key) % 16384 决定。</p>
<h1 id="2-集群的模型"><a href="#2-集群的模型" class="headerlink" title="2. 集群的模型"></a>2. 集群的模型</h1><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132210929.webp" alt="img"></p>
<ol>
<li><p>所有的节点通过服务通道直接相连，各个节点之间通过二进制协议优化传输的速度和带宽。</p>
</li>
<li><p>客户端与节点之间通过 ascii 协议进行通信</p>
</li>
<li><p>客户端与节点直连，不需要中间 Proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</p>
</li>
<li><p>尽管这些节点彼此相连，功能相同，但是仍然分为两种节点：master 和 slave。</p>
</li>
<li><p>Hash slot。</p>
<ul>
<li>key的空间被分到16384个hash slot里；</li>
<li>计算key属于哪个slot，CRC16(key) &amp; 16384。</li>
</ul>
</li>
<li><p>集群内的每个redis实例监听两个tcp端口，6379（默认）用于服务客户端查询，16379（默认服务端口 + 10000）用于集群内部通信。</p>
</li>
<li><p>节点间状态同步：gossip协议，最终一致性。节点间通信使用轻量的二进制协议，减少带宽占用。</p>
</li>
</ol>
<h1 id="3-Redis-Cluster请求路由方式"><a href="#3-Redis-Cluster请求路由方式" class="headerlink" title="3. Redis-Cluster请求路由方式"></a>3. Redis-Cluster请求路由方式</h1><ul>
<li><p>redis-cluster借助客户端实现了混合形式的路由查询</p>
<p>查询路由并非直接从一个redis节点到另外一个redis，而是借助客户端转发到正确的节点。根据客户端的实现方式，可以分为以下两种：</p>
<ul>
<li>dummy client</li>
<li>smart client</li>
</ul>
</li>
<li><p>包括Jedis在内的许多redis client，已经实现了对Redis Cluster的支持。</p>
</li>
</ul>
<p>查询路由的流程如下所示：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132219215.png" alt="1521743-65d69d2217bef71f"></p>
<blockquote>
<p>Redis cluster采用这种架构的考虑：</p>
<ul>
<li>减少redis实现的复杂度</li>
<li>降低客户端等待的时间。Smart client可以在客户端缓存 slot 与 redis节点的映射关系，当接收到 MOVED 响应时，会修改缓存中的映射关系。请求时会直接发送到正确的节点上，减少一次交互。</li>
</ul>
</blockquote>
<h1 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4. 实现细节"></a>4. 实现细节</h1><p><strong>各个节点之间都传递了什么信息</strong></p>
<p>各个节点之间通过 PING-PONG 机制通信，下面是一段关于 PING-PONG 机制的会话”内容”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">节点M：PING，嘿，朋友你好吗？我是 XYZ 哈希槽的 master ，配置信息是 FF89X1JK。</span><br><span class="line">节点N：PONG，我很好朋友，我也是 XYZ 哈希槽的 master ，配置信息是 FF89X1JK。</span><br><span class="line">节点M：我这里有一些关于我最近收到的其他节点的信息 ，A 节点回复了我的 PING 消息，我认为 A 节点是正常的。B 没有回应我的消息，我猜它现在可能出问题了，但是我需要一些 ACK(Acknowledgement) 消息来确认。</span><br><span class="line">节点N：我也想给你分享一些关于其它节点的信息，C 和 D 节点在指定的时间内回应了我， 我认为它们都是正常的，但是 B 也没有回应我，我觉得它现在可能已经挂掉了。</span><br></pre></td></tr></table></figure>

<p>每个节点会向集群中的其他节点发送节点状态信息，如果某个节点挂掉停止了服务，那么会执行投票容错机制，关于这个机制，会在下面讲到。</p>
<p><strong>Hash 槽(slot)</strong></p>
<p>Redis 集群没有使用一致性hash, 而是引入了哈希槽的概念。Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽(Slot)，集群的每个节点负责一部分hash槽。这种结构很容易添加或者删除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。</p>
<p>Redis 集群中有 16384 个散列槽，为了计算给定密钥的散列槽，Redis 对 key 采用 CRC16 算法，以下是负责将键映射到槽的算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slot = crc16(key) mod NUMER_SLOTS</span><br></pre></td></tr></table></figure>

<p>例如，你可能有 3 个节点，其中一个集群：</p>
<p>节点 A 包含从 0 到 5500 的散列槽。</p>
<p>节点 B 包含从 5501 到 11000 的散列槽。</p>
<p>节点 C 包含 从 11001 到 16383 的散列槽。</p>
<ol>
<li><p><strong>存入数据</strong>：例如，存储一个键值对，键名为“key”，其哈希值按照 CRC16(‘key’) % 16384 &#x3D; 6782 计算。根据这个哈希槽号，数据将被存储在节点B上。</p>
</li>
<li><p><strong>获取数据</strong>：无论连接哪个节点（A、B、C），获取键名为“key”的数据时，都会根据同样的哈希算法路由到节点B上提取数据。</p>
</li>
</ol>
<p>Hash 槽可以轻松地添加和删除集群中的节点。例如，如果我想添加一个新节点 D，我需要将节点 A，B，C 中的一些散列槽移动到 D。同样，如果我想从节点 A 中删除节点 A，可以只移动由 A 服务的散列槽到 B 和 C。当节点 A 为空时，可以将它从群集中彻底删除。</p>
<ol>
<li>对象保存到 Redis 之前先经过 CRC16 哈希到一个指定的 Node 上，例如 Object4 最终 Hash 到了 Node1 上。</li>
<li>每个 Node 被平均分配了一个 Slot 段，对应着 0-16384，Slot 不能重复也不能缺失，否则会导致对象重复存储或无法存储。</li>
<li>Node 之间也互相监听，一旦有 Node 退出或者加入，会按照 Slot 为单位做数据的迁移。例如 Node1 如果掉线了，0-5640 这些 Slot 将会平均分摊到 Node2 和 Node3 上,由于 Node2 和 Node3 本身维护的 Slot 还会在自己身上不会被重新分配，所以迁移过程中不会影响到 5641-16384Slot 段的使用。</li>
</ol>
<p>想扩展并发读就添加 Slaver，想扩展并发写就添加 Master，想扩容也就是添加 Master，任何一个 Slaver 或者几个 Master 挂了都不会是灾难性的故障。</p>
<p>简单总结下哈希 Slot 的优缺点：</p>
<p>缺点：每个 Node 承担着互相监听、高并发数据写入、高并发数据读出，工作任务繁重</p>
<p>优点：将 Redis 的写操作分摊到了多个节点上，提高写的并发能力，扩容简单。</p>
<blockquote>
<p><strong>为什么Redis集群有16384个槽</strong> </p>
<p>CRC16算法产生的hash值有16bit，该算法可以产生2^16-&#x3D;65536个值。换句话说，值是分布在0~65535之间。那作者在做mod运算的时候，为什么不mod65536，而选择mod16384？</p>
<p><strong>redis集群内节点，每秒都在发ping消息</strong>。规律如下</p>
<p>(1)每秒会随机选取5个节点，找出最久没有通信的节点发送ping消息</p>
<p>(2)每100毫秒(1秒10次)都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster-node-timeout&#x2F;2 则立刻发送ping消息</p>
<p>因此，每秒单节点发出ping消息数量为数量&#x3D;1+10*num（node.pong_received&gt;cluster_node_timeout&#x2F;2）</p>
<p>(1)<strong>如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大</strong>。如上所述，在消息头中，最占空间的是myslots[CLUSTER_SLOTS&#x2F;8]。当槽位为65536时，这块的大小是:65536÷8÷1024&#x3D;8kb</p>
<p>因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，<strong>浪费带宽</strong>。</p>
<p>(2)redis的集群主节点数量基本不可能超过1000个。如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。那么，<strong>对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。</strong></p>
<p>(3)槽位越小，节点少的情况下，压缩比高<strong>Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的</strong>，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots &#x2F; N很高的话(N表示节点数)，bitmap的压缩率就很低。如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。</p>
<p>ps：文件压缩率指的是，文件压缩前后的大小比。</p>
<p>综上所述，作者决定取16384个槽，不多不少，刚刚好！</p>
</blockquote>
<p><strong>Redis Cluster 的 Gossip 通信机制</strong></p>
<p>Redis Cluster 是在 3.0 版本引入集群功能。为了让让集群中的每个实例都知道其他所有实例的状态信息，Redis 集群规定各个实例之间按照 Gossip 协议来通信传递信息。</p>
<p>Gossip 协议又称 epidemic 协议（epidemic protocol），是基于流行病传播方式的节点或者进程之间信息交换的协议，在P2P网络和分布式系统中应用广泛，它的方法论也特别简单：</p>
<blockquote>
<p>在一个处于有界网络的集群里，如果每个节点都随机与其他节点交换特定信息，经过足够长的时间后，集群各个节点对该份信息的认知终将收敛到一致。</p>
</blockquote>
<p>这里的“特定信息”一般就是指集群状态、各节点的状态以及其他元数据等。Gossip协议是完全符合 BASE 原则，可以用在任何要求最终一致性的领域，比如分布式存储和注册中心。另外，它可以很方便地实现弹性集群，允许节点随时上下线，提供快捷的失败检测和动态负载均衡等。</p>
<p>此外，Gossip 协议的最大的好处是，即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。这就允许 Redis Cluster 或者 Consul 集群管理的节点规模能横向扩展到数千个。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132228968.png" alt="img"></p>
<p>上图展示了主从架构的 Redis Cluster 示意图，其中实线表示节点间的主从复制关系，而虚线表示各个节点之间的 Gossip 通信。</p>
<p>Redis Cluster 中的每个节点都维护一份自己视角下的当前整个集群的状态，主要包括：</p>
<blockquote>
<ol>
<li>当前集群状态</li>
<li>集群中各节点所负责的 slots信息，及其migrate状态</li>
<li>集群中各节点的master-slave状态</li>
<li>集群中各节点的存活状态及怀疑Fail状态</li>
</ol>
</blockquote>
<p>也就是说上面的信息，就是集群中Node相互八卦传播流言蜚语的内容主题，而且比较全面，既有自己的更有别人的，这么一来大家都相互传，最终信息就全面而且一致了。</p>
<p>Redis Cluster 的节点之间会相互发送多种消息，较为重要的如下所示：</p>
<ul>
<li>MEET：通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群，然后新节点就会开始与其他节点进行通信；</li>
<li>PING：节点按照配置的时间间隔向集群中其他节点发送 ping 消息，消息中带有自己的状态，还有自己维护的集群元数据，和部分其他节点的元数据；</li>
<li>PONG: 节点用于回应 PING 和 MEET 的消息，结构和 PING 消息类似，也包含自己的状态和其他信息，也可以用于信息广播和更新；</li>
<li>FAIL: 节点 PING 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li>
</ul>
<h1 id="5-容错"><a href="#5-容错" class="headerlink" title="5.容错"></a>5.容错</h1><ul>
<li>集群中的节点不断的 PING 其他的节点，当一个节点向另一个节点发送 PING 命令， 但是目标节点未能在给定的时限内回复， 那么发送命令的节点会将目标节点标记为 PFAIL(possible failure，可能已失效)。</li>
<li>当节点接收到其他节点发来的信息时， 它会记下那些被其他节点标记为失效的节点。 这被称为失效报告（failure report）。</li>
<li>如果节点已经将某个节点标记为 PFAIL ， 并且根据节点所收到的失效报告显式， 集群中的大部分其他主节点也认为那个节点进入了失效状态， 那么节点会将那个失效节点的状态标记为 FAIL 。</li>
<li>一旦某个节点被标记为 FAIL ， 关于这个节点已失效的信息就会被广播到整个集群， 所有接收到这条信息的节点都会将失效节点标记为 FAIL 。</li>
</ul>
<p>简单来说， 一个节点要将另一个节点标记为失效， 必须先询问其他节点的意见， 并且得到大部分主节点的同意才行。</p>
<ul>
<li>如果被标记为 FAIL 的是从节点， 那么当这个节点重新上线时， FAIL 标记就会被移除。 一个从节点是否处于 FAIL 状态， 决定了这个从节点在有需要时能否被提升为主节点。</li>
<li>如果一个主节点被打上 FAIL 标记之后， 经过了节点超时时限的四倍时间， 再加上十秒钟之后， 针对这个主节点的槽的故障转移操作仍未完成， 并且这个主节点已经重新上线的话， 那么移除对这个节点的 FAIL 标记。在不符合上面的条件后，一旦某个主节点进入 FAIL 状态， 如果这个主节点有一个或多个从节点存在， 那么其中一个从节点会被升级为新的主节点， 而其他从节点则会开始对这个新的主节点进行复制。</li>
</ul>
<blockquote>
<p><strong>【为了保证高可用，redis-cluster集群引入了主从模式】</strong>，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。</p>
</blockquote>
<h1 id="6-优缺点"><a href="#6-优缺点" class="headerlink" title="6.优缺点"></a>6.优缺点</h1><p>优点：</p>
<ol>
<li>无中心架构；</li>
<li>数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布；</li>
<li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</li>
<li>高可用性：部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升；</li>
<li>降低运维成本，提高系统的扩展性和可用性。</li>
</ol>
<p>缺点：</p>
<ol>
<li>Client实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅Jedis Cluster相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</li>
<li>节点会因为某些原因发生阻塞（阻塞时间大于clutser-node-timeout），被判断下线，这种failover是没有必要的。</li>
<li>数据通过异步复制，不保证数据的强一致性。</li>
<li>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</li>
<li>Slave在集群中充当“冷备”，不能缓解读压力，当然可以通过SDK的合理设计来提高Slave资源的利用率。</li>
<li>Key批量操作限制，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作。对于映射为不同slot值的Key由于Keys不支持跨slot查询，所以执行mset、mget、sunion等操作支持不友好。</li>
<li>Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能。</li>
<li>Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点。</li>
<li>不支持多数据库空间，单机下的redis可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</li>
<li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li>
<li>避免产生hot-key，导致主库节点成为系统的短板。</li>
<li>避免产生big-key，导致网卡撑爆、慢查询等。</li>
<li>重试时间应该大于cluster-node-time时间。</li>
<li>Redis Cluster不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</li>
</ol>
]]></content>
      <categories>
        <category>数据库&amp;缓存</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>RST及java socket关闭后读写的各种异常</title>
    <url>/2024/04/06/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/RST%E5%8F%8Ajava%20socket%E5%85%B3%E9%97%AD%E5%90%8E%E8%AF%BB%E5%86%99%E7%9A%84%E5%90%84%E7%A7%8D%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="1-RST-Reset"><a href="#1-RST-Reset" class="headerlink" title="1. RST(Reset)"></a>1. RST(Reset)</h2><p>TCP连接的断开有两种方式：</p>
<ul>
<li><ol>
<li>连接正常关闭时双方会发送FIN，经历4次挥手过程；</li>
</ol>
</li>
<li><ol start="2">
<li>通过RST包异常退出，此时会丢弃缓冲区内的数据，也不会对RST响应ACK。</li>
</ol>
</li>
</ul>
<p>java中，调用<code>Socket#close()</code>可以关闭Socket，该方法类似Unix网络编程中的close方法，将Socket的 <strong>读写</strong> 都关闭，已经排队等待发送的数据会被尝试发送，最后（默认）发送FIN。考虑一个典型的网络事务，A向B发送数据，A发送完毕后<code>close()</code>，FIN发送出去；B一直read直到返回了-1，也通过<code>close()</code>发送FIN，4次挥手，连接关闭，一切都很和谐。</p>
<p>那什么时候会用RST而非FIN关闭连接呢？</p>
<ol>
<li><code>Socket#setSoLinger(true,0)</code>，则close时会发送RST；</li>
<li>如果主动关闭方缓冲区还有数据没有被应用层消费掉，close会发送RST并忽略这些数据；</li>
<li>A向B发送数据，B已经通过<code>close()</code>方法关闭了Socket，虽然TCP规定半关闭状态下B仍然可以接收数据，但close动作关闭了该socket上的任何数据操作，如果此时A继续write，B将返回RST，A的该次write无法立即通知应用层（因为write仅把数据写入发送缓冲区），只会把状态保存在tcp协议栈内，下次write时才会抛出<code>SocketException</code>。</li>
</ol>
<span id="more"></span>



<h2 id="2-对已关闭socket读写会产生的异常"><a href="#2-对已关闭socket读写会产生的异常" class="headerlink" title="2. 对已关闭socket读写会产生的异常"></a>2. 对已关闭socket读写会产生的异常</h2><h3 id="2-1-主动关闭方"><a href="#2-1-主动关闭方" class="headerlink" title="2.1 主动关闭方"></a>2.1 主动关闭方</h3><p><code>close()</code>后，无论是发送FIN&#x2F;RST关闭的，之后再读写均会抛<code>java.net.SocketException:socket is closed</code>.</p>
<h3 id="2-2-被动关闭方"><a href="#2-2-被动关闭方" class="headerlink" title="2.2 被动关闭方"></a>2.2 被动关闭方</h3><p><strong>被FIN关闭</strong></p>
<ol>
<li>写（即向”已被对方关闭的Socket”写）<br>如上所说，第一次write得到RST响应但不抛异常，第二次write抛异常，ubuntu下是<code>broken pipe (断开的管道)</code>，win7下是<code>Software caused connection abort: socket write error</code></li>
<li>读 – 始终返回 -1</li>
</ol>
<p><strong>被RST关闭</strong></p>
<p>读写都会抛出异常：<code>connection reset (by peer)</code></p>
<p>重点在于：</p>
<ol>
<li><code>connection reset</code>：另一端用RST主动关闭连接</li>
<li><code>broken pipe / Software caused connection abort: socket write error</code> ： 对方已调用Socket#close()关闭连接，己方还在写数据</li>
</ol>
<p>java中网络编程时很大一部分代码在做各种fail时的处理，了解各种异常发生时背后的逻辑才能正确地处理之。以上列举的只是连接关闭的异常，还有其他各种异常没有提及，以后有机会再补上。</p>
<h2 id="3-怎么避免意外的RST？"><a href="#3-怎么避免意外的RST？" class="headerlink" title="3. 怎么避免意外的RST？"></a>3. 怎么避免意外的RST？</h2><p>针对几种出现RST的情况：</p>
<ol>
<li>利用应用层协议定义结构化的数据，双方对何时数据发送&#x2F;接收完毕&#x2F;可以安全关闭连接有明确一致的契约；</li>
<li>close之前消费掉数据；</li>
<li>需要在半关闭状态下读数据时，使用<code>shutdownOutput()</code>，它会发送FIN但依然可以读取数据；等对方发送FIN，<code>read()</code>返回-1后再调用<code>close()</code>释放socket。</li>
</ol>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/liuxiao723846/article/details/128402301">https://blog.csdn.net/liuxiao723846/article/details/128402301</a></p>
]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>常见的Socket网络异常场景分析</title>
    <url>/2024/04/06/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E5%B8%B8%E8%A7%81%E7%9A%84Socket%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Socket状态变迁图"><a href="#Socket状态变迁图" class="headerlink" title="Socket状态变迁图"></a>Socket状态变迁图</h1><p>先快速回顾下正常情况下TCP的交互过程与socket状态变迁，如下：<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132318008.png" alt="在这里插入图片描述"></p>
<span id="more"></span>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol>
<li>客户端调用connect函数，会发SYN包给服务端，客户端状态变为SYN_SENT，服务端收到后变为SYN_RECV，同时回复SYN+ACK包给客户端。</li>
<li>客户端收到SYN+ACK包后，变成ESTABLISHED状态，同时回复ACK包给服务端，并且客户端的connect函数执行完成。</li>
<li>服务端收到ACK包后，也变成ESTABLISHED状态，至此连接建立完成。</li>
</ol>
<p>思考：如果第一个SYN包服务端没收到，会怎么样？<br>客户端会重发SYN包给服务端，服务端收到后会再次发SYN+ACK给客户端。</p>
<p>思考：如果最后一个ACK包没收到，会怎么样？<br>服务端会重发SYN+ACK包给客户端，客户端收到后会再次发ACK给服务端。</p>
<p>这里可以发现，TCP协议里面，重发都发生在没有收到ACK的场景，纯ACK确认包不会重发。</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><ol>
<li>客户端调用write函数，发送请求数据，服务端调用read函数，接收请求数据。</li>
<li>服务端请求处理结束，服务端调用write函数，返回响应数据，客户端调用read函数，接收响应数据。</li>
</ol>
<p>思考：如果之前三次握手时ACK丢失了，但客户端已经是ESTABLISHED状态了，调用write发数据了，会怎么样？<br>write发的数据包，也是带有ACK标记的，不管与之前的ACK包哪个先到，服务端都会变成ESTABLISHED状态。</p>
<p>而如果ACK与数据包都到不了服务端，一段时间后，服务端SYN_RECV状态的Socket会自动关闭，且不回复任何包给客户端，可以发现这种场景下，客户端认为连接成功，而服务端根本就没有连接。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ol>
<li>客户端调用close函数，会发送FIN包给服务端，状态变为FIN_WAIT_1，服务端收到后，回复ACK，且状态变为CLOSE_WAIT。</li>
<li>客户端收到ACK后，状态变为FIN_WAIT_2状态。</li>
<li>服务端调用close函数，也会发送FIN包给客户端，状态变为LAST_ACK，客户端收到后，回复ACK，且状态变为TIME_WAIT。</li>
<li>服务端收到ACK后，Socket被操作系统回收，客户端的TIME_WAIT状态Socket在等待2MSL后，也被操作系统回收。</li>
</ol>
<p>思考：如果一个连接一直没有被使用(如连接池)，而超过服务端最大空闲时间，服务端主动关闭了连接，会怎么样？<br>这时服务端会变成FIN_WAIT_2，这个状态也是有超时时间的，如果对方一直不发FIN过来，操作系统就会回收掉这个Socket，而客户端会一直是CLOSE_WAIT状态。</p>
<p>所以如果CLOSE_WAIT状态很多，一般是程序漏写了关闭Socket的代码。</p>
<p>从上面的状态变迁图，也可以推断出，绝大多数情况下，SYN_SENT、SYN_RECV、FIN_WAIT_1、LAST_ACK状态应该很少，除非网络很卡，因为这些状态只要一收到了ACK就转变成其它状态了！</p>
<p>ok，上面是TCP正常流程，下面以Java网络异常为例，讲讲各种异常情况！</p>
<h1 id="常见网络异常场景"><a href="#常见网络异常场景" class="headerlink" title="常见网络异常场景"></a>常见网络异常场景</h1><h2 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发生异常：java.net.SocketTimeoutException: connect timed out</span><br><span class="line">        at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:589)</span><br></pre></td></tr></table></figure>

<p>这个异常原因是，客户端connect建立连接时，服务端一直没收到SYN包，超过了设置的连接超时时间后，就会报此异常。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132318567.png" alt="在这里插入图片描述"></p>
<p>还可能是，服务端收到了SYN包，但SYN+ACK一直发不到客户端，也会报此异常。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132318150.png" alt="在这里插入图片描述"></p>
<h2 id="连接拒绝"><a href="#连接拒绝" class="headerlink" title="连接拒绝"></a>连接拒绝</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发生异常：java.net.ConnectException: Connection refused (Connection refused)</span><br><span class="line">        at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:589)</span><br></pre></td></tr></table></figure>

<p>这个异常原因是，当服务端没有程序监听某个端口时，客户端却又试图connect连接这个端口就会出现此异常，其本质是服务端回复了一个RST包。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132318773.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>注：RST包就是TCP协议中用来处理异常情况的，一般接收方收到RST包后，会直接回收Socket资源而不经过四次挥手过程。</p>
</blockquote>
<h2 id="read读取超时"><a href="#read读取超时" class="headerlink" title="read读取超时"></a>read读取超时</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发生异常：java.net.SocketTimeoutException: Read timed out</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br></pre></td></tr></table></figure>

<p>当socket.read()读对端数据时，等待数据超时了，则会报Read timed out读取超时异常。</p>
<ol>
<li>服务端处理太慢</li>
<li>网络卡了，数据包一直传输不过来</li>
</ol>
<p>大多数情况下，这种异常都是服务端处理太慢导致的，可通过socket.setSoTimeout()来修改这个超时时间，注意理解这个超时时间，它不是整个读取过程时间，而是无任何数据通信的空闲时间。</p>
<h2 id="write重传超时"><a href="#write重传超时" class="headerlink" title="write重传超时"></a>write重传超时</h2><p>一般来说，由于socket有写缓冲(send buffer)，write方法是不阻塞立即返回的，但如果write大量数据(如文件上传)，当send buffer用完时write方法还是会阻塞的。<br>不管write方法是否阻塞，数据多次重传失败，会导致异常，区别是阻塞write被异常打断，而没有阻塞write时，会在下一次write时抛异常。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132318559.png" alt="在这里插入图片描述"></p>
<p>对于这种情况的异常信息，不同的操作系统表现不一样，如下：</p>
<ol>
<li>Linux上，抛如下异常，且会同时会关闭本端Socket，不给对端发任何包。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发生异常：java.net.SocketException: Connection timed out (Write failed)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:111)</span><br><span class="line">        at java.net.SocketOutputStream.write(SocketOutputStream.java:143)</span><br></pre></td></tr></table></figure>

<ol>
<li>Windows上，抛如下异常，且会同时会关闭本端Socket，不给对端发任何包。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发生异常：java.net.SocketException: Connection reset by peer: socket write error</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:111)</span><br><span class="line">        at java.net.SocketOutputStream.write(SocketOutputStream.java:143)</span><br></pre></td></tr></table></figure>

<p>对于重传的次数，Linux上默认15次，可通过内核参数<code>net.ipv4.tcp_retries2</code>配置，而Windows上默认5次，可通过注册表项TcpMaxDataRetransmissions配置。</p>
<p>总而言之，write超时可能导致Connection timed out (Write failed)异常或Connection reset by peer异常(Windows上)。</p>
<h2 id="读写时收到对方RST包"><a href="#读写时收到对方RST包" class="headerlink" title="读写时收到对方RST包"></a>读写时收到对方RST包</h2><p>一般来说，如果对端机器上连接不存在了，还调用write往其发数据包，对方会回复RST包来终止连接。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132318006.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>注：那什么时候会出现连接不存在呢？如机器直接断电后重启，或网络包被路由到了错误的机器上等，都会使得机器上没有相应的TCP连接。</p>
</blockquote>
<p>而当阻塞在write&#x2F;read时，收到了对方的RST包，或先收到对方的RST包，再write&#x2F;read时，就会报Connection reset异常。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132318863.png" alt="在这里插入图片描述"></p>
<p>如果对端机器上连接不存在了，本端连续调用write&#x2F;read时，在不同操作系统上会产生不一样的异常序列，如下：</p>
<ul>
<li>在Linux或Windows上先write，然后一直read，表现如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次write，调用正常，对端返回RST包</span><br><span class="line"></span><br><span class="line"># 第二次read，抛connection reset异常：</span><br><span class="line">发生异常：java.net.SocketException: Connection reset</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:210)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line"></span><br><span class="line"># 第三次read，抛connection reset异常：</span><br><span class="line">发生异常：java.net.SocketException: Connection reset</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:210)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br></pre></td></tr></table></figure>

<ul>
<li>在Linux上一直write，表现如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次write，调用正常，对端返回RST包</span><br><span class="line"></span><br><span class="line"># 第二次write，抛connection reset异常：</span><br><span class="line">发生异常：java.net.SocketException: Connection reset</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:115)</span><br><span class="line">        at java.net.SocketOutputStream.write(SocketOutputStream.java:143)</span><br><span class="line"></span><br><span class="line"># 第三次write，抛broken pipe异常：</span><br><span class="line">发生异常：java.net.SocketException: Broken pipe (Write failed)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:111)</span><br><span class="line">        at java.net.SocketOutputStream.write(SocketOutputStream.java:143)</span><br></pre></td></tr></table></figure>

<ul>
<li>在Windows上一直write，表现如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次write，调用正常，对端返回RST包</span><br><span class="line"></span><br><span class="line"># 第二次write，抛Connection reset by peer异常：</span><br><span class="line">发生异常：java.net.SocketException: Connection reset by peer: socket write error</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:111)</span><br><span class="line">        at java.net.SocketOutputStream.write(SocketOutputStream.java:143)</span><br><span class="line"></span><br><span class="line"># 第三次write，抛Connection reset by peer异常：</span><br><span class="line">发生异常：java.net.SocketException: Connection reset by peer: socket write error</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:111)</span><br><span class="line">        at java.net.SocketOutputStream.write(SocketOutputStream.java:143)</span><br></pre></td></tr></table></figure>

<p>总而言之，RST包会导致Connection reset异常，同时也可能导致Broken pipe异常。</p>
<h2 id="对方关闭连接后依然读写"><a href="#对方关闭连接后依然读写" class="headerlink" title="对方关闭连接后依然读写"></a>对方关闭连接后依然读写</h2><p>如果对方调用close关闭了连接，本端再调用read或write方法读写数据会怎么样呢？</p>
<p>如果首次是read调用，Linux和Windows都会返回-1，表示EOF，如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132318419.png" alt="在这里插入图片描述"></p>
<p>如果首次是write调用，对端会回复RST包，如下：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132318992.png" alt="在这里插入图片描述"></p>
<p>而如果是连续的write&#x2F;read调用，不同操作系统上表现不同，如下：</p>
<ul>
<li>在Linux上一直write&#x2F;read，表现如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次write，调用正常，对端返回RST包</span><br><span class="line"></span><br><span class="line"># 第二次write，抛broken pipe异常：</span><br><span class="line">发生异常：java.net.SocketException: Broken pipe (Write failed)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:111)</span><br><span class="line">        at java.net.SocketOutputStream.write(SocketOutputStream.java:143)</span><br><span class="line"></span><br><span class="line"># 第三次write，抛broken pipe异常：</span><br><span class="line">发生异常：java.net.SocketException: Broken pipe (Write failed)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:111)</span><br><span class="line">        at java.net.SocketOutputStream.write(SocketOutputStream.java:143)</span><br><span class="line"></span><br><span class="line"># 第四次read，返回-1</span><br></pre></td></tr></table></figure>

<ul>
<li>在Windows上一直write&#x2F;read，表现如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次write，调用正常，对端返回RST包</span><br><span class="line"></span><br><span class="line"># 第二次write，抛Software caused connection abort: socket write error异常：</span><br><span class="line">发生异常：java.net.SocketException: Software caused connection abort: socket write error</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:111)</span><br><span class="line">        at java.net.SocketOutputStream.write(SocketOutputStream.java:143)</span><br><span class="line"></span><br><span class="line"># 第三次write，抛Software caused connection abort: socket write error异常：</span><br><span class="line">发生异常：java.net.SocketException: Software caused connection abort: socket write error</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite0(Native Method)</span><br><span class="line">        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:111)</span><br><span class="line">        at java.net.SocketOutputStream.write(SocketOutputStream.java:143)</span><br><span class="line"></span><br><span class="line"># 第四次read，抛Software caused connection abort: recv failed异常：</span><br><span class="line">发生异常：java.net.SocketException: Software caused connection abort: recv failed</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br></pre></td></tr></table></figure>

<p>总而言之，如果对方关闭了连接，本端还write数据，会报Broken pipe或Software caused connection abort异常。</p>
<blockquote>
<p>注：如果直接Ctrl+c或kill -9杀死程序，由于只是进程死亡，Linux内核还在，内核会给对端发送FIN包以关闭连接。</p>
</blockquote>
<h2 id="其它RST场景"><a href="#其它RST场景" class="headerlink" title="其它RST场景"></a>其它RST场景</h2><p>上面已经看到了，绝大多数异常都是因为收到了RST包，除了端口未监听或连接不存在这两种情况会产生RST包外，还有一些特殊情况，也会导致RST包产生，如下：</p>
<ol>
<li>TCP连接队列backlog满了<br>如果连接队列满了，在Linux上是丢弃SYN包，而Windows上是响应RST包。</li>
<li>NAT环境中连接长时间空闲<br>目前的公网环境，除有公网IP的服务器外，基本上都是通过NAT转发技术连网的，如果程序中tcp连接长时间未通信，NAT设备会断开数据链路，而当连接被再次使用而发送数据时，NAT设备回复RST包。</li>
<li>GFW国家防火墙<br>GFW国家防火墙如果发现数据包中有敏感信息，回复RST中断TCP连接。</li>
<li>dns污染<br>dns污染会导致dns会被解析来错误的ip地址上，而如果对应ip地址上没有监听相关端口，就会回复RST包。</li>
<li>socket的recv buffer中还有未读取的数据时关闭连接<br>如果socket的recv buffer中还有未读取走的数据，直接调用close()，会给对方发RST包。</li>
<li>socket的send buffer中还有未发送的数据时关闭连接<br>默认情况下，socket的send buffer中还有未发送的数据时，直接调用close()会阻塞，直到数据发送完毕，但如果设置了TCP的SO_LINGER选项，则close会立马完成，并给对方发RST包。</li>
<li>NAT环境下，启用了TCP快速回收<br>Linux在启用了tcp_recycle的情况下，若收到SYN包的timestamp比之前包的timestamp小，则会回复RST包，参考：<a href="https://mp.weixin.qq.com/s/uwykopNnkcRL5JXTVufyBw">https://mp.weixin.qq.com/s/uwykopNnkcRL5JXTVufyBw</a> 。</li>
<li>使用Linux的NAT功能时，收到out of tcp window的数据包<br>Linux的NAT是使用netfilter机制实现的，对于out of tcp window的数据包，经过netfilter时，会被标记为无效，而invalid的报文不在Connection Track模块里，即不处理也不丢弃，直接交给协议栈继续处理。<br>所以包的源ip地址不会被替换，对端接收到这个包后，会发现没有对应socket连接，就会回应RST数据包，进而导致连接断开，参考：<a href="https://mp.weixin.qq.com/s/phcaowQWFQf9dzFCqxSCJA">https://mp.weixin.qq.com/s/phcaowQWFQf9dzFCqxSCJA</a> 。</li>
</ol>
<h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><p>如果你也想复现这些网络异常，可以了解下iptables和hping3命令，实现包丢弃或发送指定包(如RST包)，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 观测22333端口数据包</span><br><span class="line">sudo tcpdump -ni any port 22333</span><br><span class="line"></span><br><span class="line"># 添加iptables规则，丢弃22333端口的数据包</span><br><span class="line">sudo iptables -t filter -I INPUT -p tcp -m tcp --dport 22333 -j DROP  </span><br><span class="line"># 添加iptables规则，丢弃22333端口除SYN+ACK的所有ACK包</span><br><span class="line">sudo iptables -t filter -I INPUT -p tcp -m tcp --dport 22333 --tcp-flags SYN,ACK ACK -j DROP  </span><br><span class="line"># 删除iptables规则</span><br><span class="line">sudo iptables -t filter -D INPUT -p tcp -m tcp --dport 22333 --tcp-flags SYN,ACK ACK -j DROP  </span><br><span class="line"></span><br><span class="line"># 手动发RST包  </span><br><span class="line"># -a：源ip地址</span><br><span class="line"># -s：源端口号</span><br><span class="line"># -p：目标端口号</span><br><span class="line"># --rst：开启RST标记位</span><br><span class="line"># --win：设置tcp window大小</span><br><span class="line"># --setseq：设置包seq号</span><br><span class="line">sudo hping3 -a 10.243.72.157 -s 22333 -p 53824 --rst --win 0 --setseq 654041264 -c 1 10.243.211.45</span><br></pre></td></tr></table></figure>










<hr>
<p>转载自：<br><a href="https://www.toutiao.com/article/7074157092403233280/?log_from=c7b2c95cec3f1_1713617832774">https://www.toutiao.com/article/7074157092403233280/?log_from=c7b2c95cec3f1_1713617832774</a></p>
]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>TCP中Delayed Ack与Nagle算法</title>
    <url>/2024/04/06/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/TCP%E4%B8%ADDelayed%20Ack%E4%B8%8ENagle%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="什么是Delayed-Ack"><a href="#什么是Delayed-Ack" class="headerlink" title="什么是Delayed Ack"></a>什么是Delayed Ack</h2><p>　　TCP是可靠传输，可靠的核心是收到包后回复一个ack来告诉对方收到了。但如果只是单纯的发送一个确认，代价会比较高(20字节的ip首部,20字节的tcp首部)，最好能附带响应数据一起发送给对方。</p>
<p>　　Delayed Ack是指收到包后不立即ack，而是等一小会（比如40毫秒）看看，如果这40毫秒以内正好有一个包发给client，那么这个ack包就跟着发过去，而不需要增加任何大小，这样节省了资源。当然如果超过这个时间还没有包发给client，那么这个ack也要发给client了（要不client以为丢包了，又要重发）。<br>　　假如这个时候ack包还在等待延迟发送的时候，又收到了client的一个包，那么这个时候server有两个ack包要回复，那么os会把这两个ack包合起来立即回复一个ack包给client，告诉client前两个包都收到了。</p>
<p>　　也就是Delayed Ack开启的情况下：ack包有顺风车就搭；如果凑两个ack包自己包个车也立即发车；再如果等了40毫秒以上也没顺风车，那么自己打个车也发车。</p>
<span id="more"></span>

<hr>
<h2 id="什么是Nagle算法"><a href="#什么是Nagle算法" class="headerlink" title="什么是Nagle算法"></a>什么是Nagle算法</h2><p>　　当tcp用来传输小的数据段时代价是很高的，Nagle算法是为了提高带宽利用率设计的算法，其做法是合并小的TCP 包为一个，避免了过多的小报文的 TCP 头所浪费的带宽。如果开启了这个算法 （默认），则协议栈会累积数据直到以下两个条件之一满足的时候才真正发送出去：</p>
<blockquote>
<ul>
<li>积累的数据量到达最大的 TCP Segment Size</li>
<li>收到了一个 Ack</li>
</ul>
</blockquote>
<p>　　因此，如果要发送的数据大于最大传输包（MSS）的话，立即发送；否则，看看前面发出去的包是不是还有没有ack的，如果有没有ack的，那么这个小包不急着发送，等前面的ack回来再发送。这样可以优化带宽利用率，Nagle算法也是用来优化改进tcp传输效率的。<strong>Nagle算法一般默认开启的。</strong></p>
<hr>
<h2 id="如果client启用Nagle，并且server端启用了delay-ack会有什么后果呢？"><a href="#如果client启用Nagle，并且server端启用了delay-ack会有什么后果呢？" class="headerlink" title="如果client启用Nagle，并且server端启用了delay ack会有什么后果呢？"></a>如果client启用Nagle，并且server端启用了delay ack会有什么后果呢？</h2><p>　　假如client要发送一个http请求给server，这个请求有1600个bytes，握手的MSS是1460，那么这1600个bytes就会分成2个TCP包，第一个包1460，剩下的140bytes放在第二个包。<br>　　第一个包发出去后，server收到第一个包，因为delay ack所以没有回复ack，同时因为server没有收全这个HTTP请求，所以也没法回复HTTP response（server等一个完整的HTTP请求，或者40毫秒的delay时间）。client这边开启了Nagle算法（默认开启）第二个包比较小（140&lt;MSS),第一个包的ack还没有回来，那么第二个包就不发了，等！互相等！一直到Delay Ack的Delay时间到了。</p>
<hr>
<h2 id="再来看一个经典例子和数据分析"><a href="#再来看一个经典例子和数据分析" class="headerlink" title="再来看一个经典例子和数据分析"></a>再来看一个经典例子和数据分析</h2><p>　　这个案例来自：<a href="http://www.stuartcheshire.org/papers/nagledelayedack/">http://www.stuartcheshire.org/papers/nagledelayedack/</a><br>　　案例核心奇怪的问题是，如果传输的数据是 99,900 bytes，速度5.2M&#x2F;秒；如果传输的数据是 100,000 bytes 速度2.7M&#x2F;秒，多了10个bytes，不至于传输速度差这么多。</p>
<p>原因就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">99,900 bytes = 68 full-sized 1448-byte packets, plus 1436 bytes extra</span><br><span class="line">100,000 bytes = 69 full-sized 1448-byte packets, plus   88 bytes extra</span><br></pre></td></tr></table></figure>
<p>　　99,900 bytes时，68个整包会立即发送（都是整包，不受Nagle算法的影响），因为68是偶数，对方收到最后两个包后立即回复ack（delay ack凑够两个也立即ack），那么剩下的1436也很快发出去（根据Nagle算法，没有没ack的包了，立即发）。<br>　　100,000 bytes时，前面68个整包很快发出去也收到ack回复了，然后发了第69个整包，剩下88bytes（不够一个整包）根据Nagle算法要等一等，server收到第69个ack后，因为delay ack不回复（手里只攒下一个没有回复的包），所以client、server两边等在等，一直等到server的delay ack超时了。</p>
<hr>
<p>转载自：<br><a href="http://jm.taobao.org/2017/06/01/20170601/">http://jm.taobao.org/2017/06/01/20170601/</a><br><a href="https://blog.csdn.net/zheng0518/article/details/78560942">https://blog.csdn.net/zheng0518/article/details/78560942</a></p>
]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>常见的Socket网络异常场景分析</title>
    <url>/2024/04/06/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90socket%E7%9A%84timeout/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="1-socket超时分类"><a href="#1-socket超时分类" class="headerlink" title="1. socket超时分类"></a>1. socket超时分类</h2><p>socket设置为阻塞模式时，就需要考虑处理socket操作超时的问题。</p>
<p>所谓阻塞模式，是指其完成指定的操作之前阻塞当前的进程或线程，直到操作有结果返回。</p>
<p>简单分类的话，可以将超时处理分成两类：</p>
<ul>
<li>连接(connect)超时;</li>
<li>发送(send), 接收(recv)超时;</li>
</ul>
<span id="more"></span>

<h2 id="2-连接超时"><a href="#2-连接超时" class="headerlink" title="2. 连接超时"></a>2. 连接超时</h2><p>从字面上看，连接超时就是在一定时间内还是连接不上目标主机。socket连接其实最终都要进行系统调用进入内核态，剩下的就是等待内核通知连接建立。所以自行在代码中设置了超时时间（一般是叫connectTimeout或者socketTimeout），那么这个超时时间一到如果内核还没成功建立连接，那就认为是连接超时了。如果他们没设置超时时间，那么这个connectTimeout就取决于内核什么时候抛出超时异常了。</p>
<h3 id="2-1-内核层的超时分析"><a href="#2-1-内核层的超时分析" class="headerlink" title="2.1 内核层的超时分析"></a>2.1 内核层的超时分析</h3><p>个连接的建立需要经过3次握手，所以连接超时简单的说是是客户端往服务端发的SYN报文没有得到响应（服务端没有返回ACK报文）。</p>
<p>server 端为什么没有回复ack, 因为syn包的回复是内核层的，要么网络层丢包，要么就是内核层back_log的queue满了。</p>
<p>内核在发送SYN报文没有得到响应后，往往还是进行多次重试。同时，为了避免发送太多的包影响网络，重试的时间间隔还会不断增加。</p>
<p>在linux中，重试的时间间隔会呈指数型增长，为2的N次方，即：</p>
<p>第一次发送SYN报文后等待1s（2的0次幂）后再重试</p>
<p>第二次发送SYN报文后等待2s（2的1次幂）后再重试</p>
<p>第三次发送SYN报文后等待4s（2的2次幂）后再重试</p>
<p>第四次发送SYN报文后等待8s（2的3次幂）后再重试</p>
<p>第五次发送SYN报文后等待16s（2的4次幂）后再重试</p>
<p>第六次发送SYN报文后等待32s（2的5次幂）后再重试</p>
<p>第七次发送SYN报文后等待64s（2的6次幂）后再重试</p>
<p>对于重试次数，由linux的<code>net.ipv4.tcp_syn_retries</code>来确定，默认值一般是6，可以通过<code>sysctl net.ipv4.tcp_syn_retries</code>查看。比如重试次数是6次，那么以得出超时时间应该是 1+2+4+8+16+32+64&#x3D;127秒 （上面的第一条是第一次发送SYN报文，不算重试）。</p>
<p>如果想修改重试次数，可以输入命令<code>sysctl -w net.ipv4.tcp_syn_retries=5</code>来修改。如果希望重启后生效，将<code>net.ipv4.tcp_syn_retries = 5</code>放入<code>/etc/sysctl.conf</code>中，之后执行<code>sysctl -p </code>即可生效。</p>
<p>在一些linux发行版中，重试时间可能会变动。如果想确定操作系统具体的超时时间，可以通过下面这条命令来判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">gaoke<span class="meta">@ubuntu</span>:~$ date; telnet <span class="number">10.16</span><span class="number">.15</span><span class="number">.15</span> <span class="number">5000</span>; date</span><br><span class="line"></span><br><span class="line">Sat Apr <span class="number">2</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">33</span> CST <span class="number">2022</span></span><br><span class="line"></span><br><span class="line">Trying <span class="number">10.16</span><span class="number">.15</span><span class="number">.15</span>...</span><br><span class="line"></span><br><span class="line">telnet: Unable to connect to remote host: Connection timed out</span><br><span class="line"></span><br><span class="line">Sat Apr <span class="number">2</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">40</span> CST <span class="number">2022</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-综合分析"><a href="#2-2-综合分析" class="headerlink" title="2.2 综合分析"></a>2.2 综合分析</h3><p>如果应用层面设置了自己的超时时间，同时内核也有自己的超时时间，那么应该以哪个为准呢？答案是哪个超时时间小以哪个为准。</p>
<p>个人认为，在我们的实际应用中，这个超时时间不宜设置的太长，通常建议2-10s。比如在分布式系统中，我们通常会在多台节点中根据一定策略选择一台进行连接。在有机器宕机的情况下，如果连接超时时间设置的比较长，而我们客户端的线程池又比较小，就很可能大多数的线程都在等待建立连接，过了较长时间才发现连接不上，影响应用的整体吞吐量。</p>
<h3 id="2-3-connect系统调用"><a href="#2-3-connect系统调用" class="headerlink" title="2.3 connect系统调用"></a>2.3 connect系统调用</h3><p>直接说结论。</p>
<p>linux层面可以设置SO_SNDTIMEO来控制connect系统调用的超时，如果不设置SO_SNDTIMEO，会由tcp重传定时器在重传超过设置的时候后超时，重传次数由<code>tcp_syn_retries</code>控制。</p>
<h3 id="2-4-java-connect-API"><a href="#2-4-java-connect-API" class="headerlink" title="2.4 java connect API"></a>2.4 java connect API</h3><p>看下java的connect api：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(SocketAddress endpoint, <span class="type">int</span> timeout)</span> <span class="keyword">throws</span> IOException &#123;</span><br></pre></td></tr></table></figure>

<p>其connect最终调用下面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java_java_net_PlainSocketImpl_socketConnect(...)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        connect_rv = NET_Connect(fd, ( structsockaddr*)&amp;him, len);</span><br><span class="line">        .....</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="comment">// 如果timeout &gt; 0 ，则设置为nonblock模式</span></span><br><span class="line">        SET_NONBLOCKING(fd); <span class="comment">/* no need to use NET_Connect as non-blocking */</span></span><br><span class="line">        connect_rv = connect(fd, ( structsockaddr*)&amp;him, len); </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这边用系统调用select来模拟阻塞调用超时</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">1</span>) &#123;</span><br><span class="line">            ...... </span><br><span class="line">            struct timeval t;</span><br><span class="line">            t.tv_sec = timeout / <span class="number">1000</span>;</span><br><span class="line">            t.tv_usec = (timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">            connect_rv = NET_Select(fd+ <span class="number">1</span>, <span class="number">0</span>, &amp;wr, &amp;ex, &amp;t);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ...... <span class="comment">// 重新设置为阻塞模式</span></span><br><span class="line">        SET_BLOCKING(fd);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里，</p>
<ul>
<li><p>在timeout&lt;&#x3D;0的时候，走默认的系统调用不设置超时时间的逻辑；</p>
</li>
<li><p>在timeout&gt;0时，将socket设置为非阻塞，然后用select系统调用去模拟超时, 而没有走linux本身的超时逻辑，如下图所示:</p>
</li>
</ul>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132321009.png" alt="img"></p>
<p>所以在timeout为0的时候，直接就通过重传次数来控制超时时间。而在timeout大于0的时候,超时时间如下表格所示:</p>
<table>
<thead>
<tr>
<th align="left">tcp_syn_retries</th>
<th>timeout</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td>min(timeout, 3s)</td>
</tr>
<tr>
<td align="left">2</td>
<td>min(timeout, 7s)</td>
</tr>
<tr>
<td align="left">3</td>
<td>min(timeout, 15s)</td>
</tr>
<tr>
<td align="left">4</td>
<td>min(timeout, 31s)</td>
</tr>
<tr>
<td align="left">5</td>
<td>min(timeout, 63s)</td>
</tr>
</tbody></table>
<p>笔者在机器上(macOS)测试，实际超时时间情况如下：</p>
<blockquote>
<p>当timeout为0，超时为75s；</p>
<p>当timeout为1000*50，超时为50s；</p>
<p>当timeout为1000*100，超时为75s；</p>
</blockquote>
<h2 id="3-发送超时"><a href="#3-发送超时" class="headerlink" title="3. 发送超时"></a>3. 发送超时</h2><p>在tcp连接建立之后，写操作可以理解为向对端发送tcp报文的过程。</p>
<p>在tcp的实现中，每一段报文都需要有对端的回应，即ACK报文。和连接时发送SYN报文一样，如果超过一定时间没有收到响应，内核会再次重发该报文。</p>
<p>和SYN报文的重试不同的是，linux有另外的参数来控制这个重试次数，即<code>net.ipv4.tcp_retries2</code>，可以通过<code>sysctl net.ipv4.tcp_retries2</code>查看其值。和SYN报文的超时时间一样，如果应用层设置了超时时间，哪么具体的超时时间以内核和应用层的超时时间的最小值为准。</p>
<p>socket的write系统调用最后调用的是tcp_sendmsg，源码中如果socket的write buffer依旧有空间的时候，会立马返回，并不会有timeout。但是write buffer不够的时候，会等待SO_SNDTIMEO的时间(nonblock时候为0)。SO_SNDTIMEO不设置，write buffer满之后ack一直不返回的情况(例如，物理机宕机)，则会在重传定时器<code>tcp_retransmit_timer</code>到期后timeout，其重传到期时间通过tcp_retries2以及TCP_RTO_MIN计算出来。</p>
<table>
<thead>
<tr>
<th>tcp_retries2</th>
<th>buffer未满</th>
<th>buffer满</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>立即返回</td>
<td>min(SO_SNDTIMEO,(25.6s-51.2s)根据动态rto定</td>
</tr>
<tr>
<td>15</td>
<td>立即返回</td>
<td>min(SO_SNDTIMEO,(924.6s-1044.6s)根据动态rto定</td>
</tr>
</tbody></table>
<p>java的sockWrite0没有设置超时时间的地方，同时也没有设置过SO_SNDTIMEOUT，其直接调用了系统调用,所以其超时时间和系统调用保持一致。</p>
<h2 id="4-接收超时"><a href="#4-接收超时" class="headerlink" title="4. 接收超时"></a>4. 接收超时</h2><p>在tcp协议中，读的操作和写操作的逻辑是相通的。</p>
<p>tcp连接建立后，两边的通信无非就是报文的互传。对于tcp协议而言，其实不会分辨他们发送的报文具体是要干嘛，因此readTimeout的判断逻辑和writeTimeout基本一样。它的重传次数也是由参数<code>net.ipv4.tcp_retries2</code>控制。在应用层面也一般是统一叫socketTimeout。</p>
<p>socket的read系统调用最终调用的是tcp_recvmsg，最终超时时间是依据对端响应与否、SO_RCVTIMEO以及通过tcp_retries2以及TCP_RTO_MIN计算出来。</p>
<table>
<thead>
<tr>
<th>tcp_retries2</th>
<th><strong>对端无响应</strong></th>
<th>对端内核响应正常</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>min(SO_RCVTIMEO,(25.6s-51.2s)根据动态rto定</td>
<td>SO_RCVTIMEO&#x3D;&#x3D;0?无限,SO_RCVTIMEO)</td>
</tr>
<tr>
<td>15</td>
<td>min(SO_RCVTIMEO,(924.6s-1044.6s)根据动态rto定</td>
<td>SO_RCVTIMEO&#x3D;&#x3D;0?无限,SO_RCVTIMEO)</td>
</tr>
</tbody></table>
<p>java的超时时间由SO_TIMOUT决定，而linux的socket并没有这个选项。看下jdk中SO_TIMOUT的描述：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Set a timeout on blocking Socket operations:</span></span><br><span class="line"><span class="comment"> * &lt;PRE&gt;</span></span><br><span class="line"><span class="comment"> * ServerSocket.accept();</span></span><br><span class="line"><span class="comment"> * SocketInputStream.read();</span></span><br><span class="line"><span class="comment"> * DatagramSocket.receive();</span></span><br><span class="line"><span class="comment"> * &lt;/PRE&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;P&gt; The option must be set prior to entering a blocking</span></span><br><span class="line"><span class="comment"> * operation to take effect.  If the timeout expires and the</span></span><br><span class="line"><span class="comment"> * operation would continue to block,</span></span><br><span class="line"><span class="comment"> * &lt;B&gt;java.io.InterruptedIOException&lt;/B&gt; is raised.  The Socket is</span></span><br><span class="line"><span class="comment"> * not closed in this case.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;P&gt; Valid for all sockets: SocketImpl, DatagramSocketImpl</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Socket#setSoTimeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ServerSocket#setSoTimeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DatagramSocket#setSoTimeout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SO_TIMEOUT</span> <span class="operator">=</span> <span class="number">0x1006</span>;</span><br></pre></td></tr></table></figure>

<p>java对这里超时的实现，就和上面的java connect一样，在SO_TIMEOUT&gt;0的时候依旧是由nonblock socket模拟出来的。所以最终超时时间的情况如下：</p>
<table>
<thead>
<tr>
<th>tcp_retries2</th>
<th><strong>对端无响应</strong></th>
<th>对端内核响应正常</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>min(SO_TIMEOUT,(25.6s-51.2s)根据动态rto定</td>
<td>SO_TIMEOUT&#x3D;&#x3D;0?无限,SO_RCVTIMEO</td>
</tr>
<tr>
<td>15</td>
<td>min(SO_TIMEOUT,(924.6s-1044.6s)根据动态rto定</td>
<td>SO_TIMEOUT&#x3D;&#x3D;0?无限,SO_RCVTIMEO</td>
</tr>
</tbody></table>
<h2 id="5-对端物理机宕机之后的timeout"><a href="#5-对端物理机宕机之后的timeout" class="headerlink" title="5. 对端物理机宕机之后的timeout"></a>5. 对端物理机宕机之后的timeout</h2><p><strong>对端物理机宕机后还依旧有数据发送</strong></p>
<p>对端物理机宕机时对端内核也gg了(不会发出任何包通知宕机)，那么本端发送任何数据给对端都不会有响应。其超时时间就由上面讨论的 min(设置的socket超时[例如SO_TIMEOUT],内核内部的定时器超时来决定)。</p>
<p><strong>对端物理机宕机后没有数据发送，但在read等待</strong></p>
<p>这时候如果设置了超时时间timeout，则在timeout后返回。但是，如果仅仅是在read等待，由于底层没有数据交互，那么其无法知道对端是否宕机，所以会一直等待。但是，内核会在一个socket两个小时都没有数据交互情况下(可设置)启动keepalive定时器来探测对端的socket。如下图所示:</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132321893.jpeg" alt="img"></p>
<p>大概是2小时11分钟之后会超时返回。keepalive的设置由内核参数指定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat/proc/sys/net/ipv4/tcp_keepalive_time <span class="number">7200</span> 即两个小时后开始探测</span><br><span class="line">cat/proc/sys/net/ipv4/tcp_keepalive_intvl <span class="number">75</span> 即每次探测间隔为75s</span><br><span class="line">cat/proc/sys/net/ipv4/tcp_keepalve_probes <span class="number">9</span> 即一共探测<span class="number">9</span>次</span><br></pre></td></tr></table></figure>

<p>可以在setsockops中对单独的socket指定是否启用keepalive定时器(java也可以)。</p>
<p><strong>对端物理机宕机后没有数据发送，也没有read等待</strong></p>
<p>和上面同理，也是在keepalive定时器超时之后，将连接close。所以我们可以看到一个不活跃的socket在对端物理机突然宕机之后,依旧是ESTABLISHED状态，过很长一段时间之后才会关闭。</p>
<p><strong>进程宕后的超时</strong></p>
<p>如果仅仅是对端进程宕机的话(进程所在内核会close其所拥有的所有socket)，由于fin包的发送，本端内核可以立刻知道当前socket的状态。如果socket是阻塞的，那么将会在当前或者下一次write&#x2F;read系统调用的时候返回给应用层相应的错误。如果是nonblock，那么会在select&#x2F;epoll中触发出对应的事件通知应用层去处理。</p>
<p>如果fin包没发送到对端，那么在下一次write&#x2F;read的时候内核会发送reset包作为回应。</p>
<p><strong>nonblock</strong></p>
<p>设置为nonblock&#x3D;true后，由于read&#x2F;write都是立刻返回，且通过select&#x2F;epoll等处理重传超时&#x2F;probe超时&#x2F;keep alive超时&#x2F;socket close等事件，所以根据应用层代码决定其超时特性。定时器超时事件发生的时间如上面几小节所述，和是否nonblock无关。nonblock的编程模式可以让应用层对这些事件做出响应。</p>
<hr>
<p>转载自：<br><a href="https://blog.csdn.net/yinshipin007/article/details/129370511">https://blog.csdn.net/yinshipin007/article/details/129370511</a><br><a href="https://www.cnblogs.com/alchemystar/p/13704067.html">https://www.cnblogs.com/alchemystar/p/13704067.html</a><br><a href="https://www.jb51.net/article/111163.htm">https://www.jb51.net/article/111163.htm</a></p>
]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
  </entry>
  <entry>
    <title>SLA（服务等级协议）</title>
    <url>/2024/05/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/SLA%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AD%89%E7%BA%A7%E5%8D%8F%E8%AE%AE%EF%BC%89/</url>
    <content><![CDATA[<p>[toc]</p>
<p>在硅谷一线大厂所维护的系统服务中，我们经常可以看见SLA这样的承诺。<br>例如，在谷歌的云计算服务平台Google Cloud Platform中，他们会写着“99.9% Availability”这样的承诺。那什么是“99.9% Availability”呢？<br>要理解这个承诺是什么意思，首先，你需要了解到底什么是SLA？</p>
<p>SLA（Service-Level Agreement），也就是<strong>服务等级协议</strong>，指的是系统服务提供者（Provider）对客户（Customer）的一个服务承诺。这<strong>是衡量一个大型分布式系统是否“健康”的常见方法</strong>。</p>
<p>在开发设计系统服务的时候，无论面对的客户是公司外部的个人、商业用户，还是公司内的不同业务部门，我们都应该对自己所设计的系统服务有一个定义好的SLA。</p>
<p>因为SLA是一种服务承诺，所以指标可以多种多样。根据我的实践经验，给你介绍<strong>最常见的四个SLA指标，可用性、准确性、系统容量和延迟</strong>。<br><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132353615.png" alt="图片"><br> <span id="more"></span></p>
<h2 id="1-可用性（Availabilty）"><a href="#1-可用性（Availabilty）" class="headerlink" title="1. 可用性（Availabilty）"></a>1. 可用性（Availabilty）</h2><hr>
<p>可用性指的是系统服务能正常运行所占的时间百分比。</p>
<p>如果我们搭建了一个拥有“100％可用性”的系统服务，那就意味着这个系统在任何时候都能正常运行。是不是很完美？但真要实现这样的目标其实非常困难，并且成本也会很高。</p>
<p>我们知道，即便是大名鼎鼎的亚马逊AWS云计算服务这样大型的、对用户来说极为关键的系统，也不能承诺100％的可用性，它的系统服务从推出到现在，也有过服务中断（Service Outage）的时候。</p>
<p>对于许多系统而言，<strong>四个9的可用性（99.99％ Availability，或每年约50分钟的系统中断时间）即可以被认为是高可用性（High availability）</strong>。</p>
<p>说到这里，我来为你揭开一开始所提到的“99.9% Availability”的真实含义。</p>
<p><strong>“99.9% Availability”指的是一天当中系统服务将会有大约86秒的服务间断期</strong>。服务间断也许是因为系统维护，也有可能是因为系统在更新升级系统服务。</p>
<p>86秒这个数字是怎么算出来的呢？</p>
<p>99.9%意味着有0.1%的可能性系统服务会被中断，而一天中有24小时 × 60分钟 × 60秒，也就是有(24 × 60 × 60 × 0.001) &#x3D; 86.4秒的可能系统服务被中断了。而上面所说的四个9的高可用性服务就是承诺可以将一天当中的服务中断时间缩短到只有(24 × 60 × 60 × 0.0001) &#x3D; 8.64秒。</p>
<h2 id="2-准确性（Accuracy）"><a href="#2-准确性（Accuracy）" class="headerlink" title="2. 准确性（Accuracy）"></a>2. 准确性（Accuracy）</h2><hr>
<p>准确性指的是我们所设计的系统服务中，是否允许某些数据是不准确的或者是丢失了的。如果允许这样的情况发生，用户可以接受的概率（百分比）是多少？</p>
<p>这该怎么衡量呢？不同的系统平台可能会用不同的指标去定义准确性。很多时候，系统架构会以错误率（Error Rate）来定义这一项SLA。</p>
<p>怎么计算错误率呢？可以用导致系统产生内部错误（Internal Error）的有效请求数，除以这期间的有效请求总数。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408132353210.jpeg" alt="图片"></p>
<p>例如，我们在一分钟内发送100个有效请求到系统中，其中有5个请求导致系统返回内部错误，那我们可以说这一分钟系统的错误率是 5 &#x2F; 100 &#x3D; 5%。</p>
<p>下面，我想带你看看硅谷一线公司所搭建的架构平台的准确性SLA。</p>
<p><strong>Google Cloud Platform</strong>的SLA中，有着这样的准确性定义：<strong>每个月系统的错误率超过5%的时间要少于0.1%，以每分钟为单位来计算</strong>。</p>
<p>而<strong>亚马逊AWS</strong>云计算平台有着稍微不一样的准确性定义：**以每5分钟为单位，错误率不会超过0.1%**。</p>
<p>你看，我们可以<strong>用错误率来定义准确性</strong>，但具体该如何评估系统的准确性呢？一般来说，我们可以采用性能测试（Performance Test）或者是查看系统日志（Log）两种方法来评估。</p>
<p>具体的做法我会在后面展开讲解，今天你先理解这项指标就可以了。</p>
<h2 id="3-系统容量（Capacity）"><a href="#3-系统容量（Capacity）" class="headerlink" title="3. 系统容量（Capacity）"></a>3. 系统容量（Capacity）</h2><hr>
<p>在数据处理中，系统容量通常指的是系统能够支持的预期负载量是多少，一般会以每秒的请求数为单位来表示。</p>
<p>我们常常可以看见，某个系统的架构可以处理的QPS （Queries Per Second）是多少又或者RPS（Requests Per Second）是多少。这里的<strong>QPS或者是RPS就是指系统每秒可以响应多少请求数</strong>。</p>
<p>我们来看看之前Twitter发布的一项数据，<strong>Twitter系统可以响应30万的QPS来读取Twitter Timelines</strong>。这里Twitter系统给出的就是他们对于系统容量（Capacity）的SLA。</p>
<p>你可能会问，我要怎么给自己设计的系统架构定义出准确的QPS呢？以我的经验看，可以有下面这几种方式。</p>
<p>第一种，是使用<strong>限流</strong>（Throttling）的方式。</p>
<p>如果你是使用Java语言进行编程的，就可以使用<strong>Google Guava库中的RateLimiter类</strong>来定义每秒最多发送多少请求到后台处理。</p>
<p>假设我们在每台服务器都定义了一个每秒最多处理1000个请求的RateLimiter，而我们有N台服务器，<strong>在最理想的情况下，我们的QPS可以达到1000 * N</strong>。</p>
<p>这里要注意的雷区是，<strong>这个请求数并不是设置得越多越好</strong>。因为每台服务器的内存有限，<strong>过多的请求堆积在服务器中有可能会导致内存溢出</strong>（Out-Of-Memory）的异常发生，也就是所有请求所需要占用的内存超过了服务器能提供的内存，从而让整个服务器崩溃。</p>
<p>第二种，是在系统交付前进行<strong>性能测试</strong>（Performance Test）。</p>
<p>我们可以使用像Apache JMeter又或是LoadRunner这类型的工具对系统进行性能测试。这类工具可以测试出系统在峰值状态下可以应对的QPS是多少。</p>
<p>当然了，这里也是有<strong>雷区</strong>的。</p>
<p>有的开发者可能使用<strong>同一类型的请求参数</strong>，导致后台服务器在多数情况下<strong>命中缓存（Cache Hit）</strong>。这个时候得到的QPS可能并不是真实的QPS。</p>
<p>打个比方，服务器处理请求的正常流程需要查询后台数据库，得到数据库结果后再返回给用户，这个过程平均需要1秒。在第一次拿到数据库结果后，这个数据就会被保存在缓存中，而如果后续的请求都使用同一类型的参数，导致结果不需要从数据库得到，而是直接从缓存中得到，这个过程我们假设只需要0.1秒。那这样，我们所计算出来的QPS就会比正常的高出10倍。所以在生成请求的时候，要格外注意这一点。</p>
<p>第三种，是<strong>分析系统在实际使用时产生的日志</strong>（Log）。</p>
<p>系统上线使用后，我们可以得到日志文件。一般的日志文件会记录每个时刻产生的请求。我们可以通过系统每天在最繁忙时刻所接收到的请求数，来计算出系统可以承载的QPS。</p>
<p>不过，<strong>这种方法不一定可以得到系统可以承载的最大QPS</strong>。</p>
<p>在这里打个比喻，一家可以容纳上百桌客人的餐馆刚开业，因为客流量还比较小，在每天最繁忙的时候只接待了10桌客人。那我们可以说这家餐馆最多只能接待10桌客人吗？不可以。</p>
<p>同样的，以分析系统日志的方法计算出来的QPS并不一定是服务器能够承载的最大QPS。<strong>想要得到系统能承受的最大QPS，更多的是性能测试和日志分析相结合的手段</strong>。</p>
<h2 id="4-延迟（Latency）"><a href="#4-延迟（Latency）" class="headerlink" title="4. 延迟（Latency）"></a>4. 延迟（Latency）</h2><hr>
<p><strong>延迟</strong>指的是系统在<strong>收到用户的请求到响应这个请求之间的时间间隔</strong>。</p>
<p>在定义延迟的SLA时，我们常常看到系统的SLA会有p95或者是p99这样的延迟声明。这里的p指的是percentile，也就是百分位的意思。<strong>如果说一个系统的p95 延迟是1秒的话，那就表示在100个请求里面有95个请求的响应时间会少于1秒，而剩下的5个请求响应时间会大于1秒</strong>。</p>
<p>下面我们用一个具体的例子来说明延迟这项指标在SLA中的重要性。</p>
<p>假设，我们已经设计好了一个社交软件的系统架构。这个社交软件在接收到用户的请求之后，需要读取数据库中的内容返回给用户。</p>
<p>为了降低系统的延迟，我们会将数据库中内容放进缓存（Cache）中，以此来减少数据库的读取时间。在系统运行了一段时间后，我们得到了一些缓存命中率（Cache Hit Ratio）的信息。有90%的请求命中了缓存，而剩下的10%的请求则需要重新从数据库中读取内容。</p>
<p>这时服务器所给我们的p95或者p99延迟恰恰就衡量了系统的最长时间，也就是从数据库中读取内容的时间。<strong>作为一个优秀架构师，你可以通过改进缓存策略从而提高缓存命中率，也可以通过优化数据库的Schema或者索引（Index）来降低p95或p99 延迟</strong>。</p>
<p>总而言之，<strong>当p95或者p99过高时，总会有5%或者1%的用户抱怨产品的用户体验太差，这都是我们要通过优化系统来避免的</strong>。</p>
<hr>
<p>转载自：<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjY5NDU2Ng==&mid=2651863287&idx=1&sn=6533f67eade7f38bcdbbabec1506a03d&chksm=80497dbeb73ef4a831fd49113eccd1faef2f21ad97501e5aea15cffee8d43fe091980a79a695&scene=27">https://mp.weixin.qq.com/s?__biz=MzAxMjY5NDU2Ng==&amp;mid=2651863287&amp;idx=1&amp;sn=6533f67eade7f38bcdbbabec1506a03d&amp;chksm=80497dbeb73ef4a831fd49113eccd1faef2f21ad97501e5aea15cffee8d43fe091980a79a695&amp;scene=27</a></p>
]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
  </entry>
  <entry>
    <title>监控系统介绍</title>
    <url>/2024/05/16/%E7%9B%AE%E5%BD%95%E5%BE%85%E5%AE%9A/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="监控系统的分类"><a href="#监控系统的分类" class="headerlink" title="监控系统的分类"></a>监控系统的分类</h1><p>针对不同场景把监控系统分为三类，分别是：</p>
<ul>
<li>日志类</li>
<li>调用链类</li>
<li>度量类</li>
</ul>
<h2 id="日志类-logs"><a href="#日志类-logs" class="headerlink" title="日志类(logs)"></a>日志类(logs)</h2><p>通常我们在系统和业务级别上加入一些日志代码，记录一些日志信息，方便我们在发现问题的时候查找。</p>
<p>这些信息会与事件做相关，例如：用户登录，下订单，用户浏览某件商品，一小时以内的网关流量，用户平均响应时间等等。</p>
<p>这类以日志的记录和查询的解决方案比较多。比如 ELK 方案（Elasticsearch+Logstash+Kibana），使用ELK（Elasticsearch、Logstash、Kibana）+ Kafka&#x2F;Redis&#x2F;RabbitMQ 来搭建一个日志系统。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408140000435.png" alt="img"></p>
<p>ELK 结合 Redis&#x2F;Kafka&#x2F;RabbitMQ 实现日志类监控</p>
<p>程序内部通过 Spring AOP 记录日志，Beats 收集日志文件，然后用 Kafka&#x2F;Redis&#x2F;RabbitMQ 将其发送给 Logstash，Logstash 再将日志写入 Elasticsearch。</p>
<p>最后，使用 Kibana 将存放在 Elasticsearch 中的日志数据显示出来，形式可以是实时数据图表。</p>
<span id="more"></span>

<h2 id="调用链类-tracing"><a href="#调用链类-tracing" class="headerlink" title="调用链类(tracing)"></a>调用链类(tracing)</h2><p>对于服务较多的系统，特别是微服务系统。一次服务的调用有可能涉及到多个服务。A 调用 B，B 又要调用 C，好像一个链条一样，形成了服务调用链。</p>
<p>调用链就是记录一个请求经过所有服务的过程。请求从开始进入服务，经过不同的服务节点后，再返回给客户端，通过调用链参数来追踪全链路行为。从而知道请求在哪个环节出了故障，系统的瓶颈在哪儿。</p>
<p>这个可以了解下OpenTracing，不展开了。</p>
<p>业界也有比较成熟的方案，可以参考文章:</p>
<p> <a href="https://www.bilibili.com/read/cv7018003/">网易云音乐全链路跟踪系统实践</a></p>
<p><a href="https://blog.csdn.net/panjianlongWUHAN/article/details/113347757">全链路监控Jaeger</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2311237">主流微服务全链路监控系统实战</a></p>
<h2 id="度量类-metrics"><a href="#度量类-metrics" class="headerlink" title="度量类(metrics)"></a>度量类(metrics)</h2><p>说白了，就是描述某个被测主体在一段时间内的测量值变化（度量）。比如CPU、内存、网络情况等等。</p>
<p>这里一般依赖时序数据库（TimeSeriesData，TSD）。</p>
<h1 id="监控系统的分层"><a href="#监控系统的分层" class="headerlink" title="监控系统的分层"></a>监控系统的分层</h1><p>用户请求到数据返回，经历系统中的层层关卡。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408140000365.jpeg" alt="img"></p>
<p>一般我们将监控系统分为五层来考虑，当然也有人分成三层，大致的意思都差不多，仅供参考：</p>
<ul>
<li>客户端监控，用户行为信息，业务返回码，客户端性能，运营商，版本，操作系统等。</li>
<li>业务层监控，核心业务的监控，例如：登录，注册，下单，支付等等。</li>
<li>应用层监控，相关的技术参数，例如：URL 请求次数，Service 请求数量，SQL 执行的结果，Cache 的利用率，QPS 等等。</li>
<li>系统层监控，物理主机，虚拟主机以及操作系统的参数。例如：CPU 利用率，内存利用率，磁盘空间情况。</li>
<li>网络层监控，网络情况参数。例如：网关流量情况，丢包率，错包率，连接数等等。</li>
</ul>
<h1 id="监控系统典型架构"><a href="#监控系统典型架构" class="headerlink" title="监控系统典型架构"></a>监控系统典型架构</h1><p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408140000652.png" alt="在这里插入图片描述"></p>
<p>从上图来看，从左往右，监控数据的采集，采集到的数据一般是写入时序库，然后就是对时序库中的数据进行分析和可视化，分析部分最经典做法就是告警规则判断（复杂一些的做会引入统计算法和机器学习的能力做预判），也就是上图中的告警引擎，告警引擎产生告警事件之后交给告警发送模块做不同媒介的通知。可视化就比较好理解，即图上的数据展示，通过各种图表来合理地渲染各类监控数据，便于用户查看比较、日常巡检。</p>
<h2 id="采集器"><a href="#采集器" class="headerlink" title="采集器"></a>采集器</h2><p>采集器负责采集监控数据，有两种典型部署方式，一种是跟随监控对象部署，常见做法是所有机器都部署一个采集器采集机器的 CPU、内存、硬盘、IO、网络相关的指标；另一种是远程探针式，比如选取一个中心机器做探针，同时探测很多个机器的 PING 连通性，或者连到很多 MySQL 实例上去，执行命令采集数据。</p>
<p>下面我们就介绍几个典型的开源采集器：</p>
<h3 id="Telegraf"><a href="#Telegraf" class="headerlink" title="Telegraf"></a>Telegraf</h3><p>Telegraf 是 InfluxData 公司的产品，开源协议是 MIT，非常开放，有很多外部贡献者，主要配合 InfluxDB 使用。当然，Telegraf 也可以把监控数据推给 Prometheus、Graphite、Datadog、OpenTSDB 等很多其他存储，但和 InfluxDB 的对接是最丝滑的。</p>
<p>InfluxDB 支持存储字符串，而 Telegraf 采集的很多数据都是字符串类型，但如果把这类数据推给 Prometheus 生态的时序库，比如 VictoriaMetrics、M3DB、Thanos 等，它就会报错。因为这些时序库只能存储数值型时序数据。另外，Telegraf 采集的很多数据在成功和失败的时候会打上不同的标签，比如成功的时候会打上 result&#x3D;success 标签，失败的时候打上 result&#x3D;failed 标签。</p>
<p>在 InfluxDB 中这种情况是可以的，但是在 Prometheus 生态里，标签变化就表示不同的指标，这种情况我叫它标签非稳态结构，使用 Prometheus 生态的时序库与 Telegraf 对接时需要把这类标签丢弃掉。</p>
<p>Telegraf 是指标领域的 All-In-One 采集器，支持各种采集插件，只需要使用 Telegraf 这一个采集器，就能解决绝大部分采集需求</p>
<h3 id="Exporters"><a href="#Exporters" class="headerlink" title="Exporters"></a>Exporters</h3><p>Exporter 是专门用于 Prometheus 生态的组件，Prometheus 生态的采集器比较零散，每个采集目标都有对应的 Exporter 组件，比如 MySQL 有 mysqld_exporter，Redis 有 redis_exporter，交换机有 snmp_exporter，JVM 有 jmx_exporter。</p>
<p>这些 Exporter 的核心逻辑，就是去这些监控对象里采集数据，然后暴露为 Prometheus 协议的监控数据。比如 mysqld_exporter，就是连上 MySQL，执行一些类似于 show global status 、show global variables 、show slave status 这样的命令，拿到输出，再转换为 Prometheus 协议的数据；还有 redis_exporter，它是连上 Redis，执行一些类似于 info 的命令，拿到输出，转换为 Prometheus 协议的数据。</p>
<p>随着 Prometheus 的影响越来越大，很多中间件都内置支持了 Prometheus，直接通过自身的 &#x2F;metrics 接口暴露监控数据，不用再单独伴生 Exporter，简化了架构。比如 Kubernetes 中的各类组件：kube-apiserver、kube-proxy、kube-scheduler 等等，比如 etcd，还有新版本的 ZooKeeper、 RabbitMQ、HAProxy，都可以直接暴露 Prometheus 协议的监控数据，无需 Exporter。</p>
<p>不管是 Exporter 还是直接内置支持 Prometheus 协议的各类组件，都提供 HTTP 接口（通常是 &#x2F;metrics ）来暴露监控数据，让监控系统来拉，这叫做 PULL 模型。而像 Telegraf 那种则是 PUSH 模型，采集了数据之后调用服务端的接口来推送数据。</p>
<h3 id="Grafana-Agent"><a href="#Grafana-Agent" class="headerlink" title="Grafana-Agent"></a>Grafana-Agent</h3><p>Grafana-Agent 是 Grafana 公司推出的一款 All-In-One 采集器，不但可以采集指标数据，也可以采集日志数据和链路数据。开源协议是 Apache 2.0，比较开放。</p>
<p>Grafana-Agent 作为后来者，是如何快速集成各类采集能力的呢？Grafana-Agent 写了个框架，方便导入各类 Exporter，把各个 Exporter 当做 Lib 使用，常见的 Node-Exporter、Kafka-Exporter、Elasticsearch-Exporter、Mysqld-Exporter 等，都已经完成了集成。这样我们就不用到处去找各类 Exporter，只使用 Grafana-Agent 这一个二进制就可以搞定众多采集能力了。</p>
<p>Grafana-Agent 这种集成 Exporter 的方式，完全兼容 Exporter 的指标体系，比如 Node-Exporter。如果我们的场景不方便使用 PULL 的方式来抓取数据，就可以换成 Grafana-Agent，采用 PUSH 的方式推送监控数据，完全兼容 Node-Exporter 的指标。当然，Exporter 种类繁多，Grafana-Agent 不可能全部集成，对于默认没有集成进去的 Exporter，Grafana-Agent 也支持用 PULL 的方式去抓取其他 Exporter 的数据，然后再通过 Remote Write 的方式，将采集到的数据转发给服务端。</p>
<p>对于日志采集，Grafana-Agent 集成了 Loki 生态的日志采集器 Promtail。对于链路数据，Grafana-Agent 集成了 OpenTelemetry Collector。相当于把可观测性三大支柱的采集能力都建全了。一个 Agent 搞定所有采集能力有个显而易见的好处，就是便于附加一些通用标签，比如某个机器的所有可观测性数据，都统一打上机器名的标签，后面就可以使用这种统一的标签做关联查询，这个关联能力是这类 All-In-One 采集器带来的最大好处。</p>
<table>
<thead>
<tr>
<th align="center">采集器</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">telegraf</td>
<td align="center">指标方面全家桶方案</td>
<td align="center">不太适合prometgeus生态，资深高手通过配置可规避这些问题</td>
<td align="center">与influxDB一起作为机器的统一的agent使用</td>
</tr>
<tr>
<td align="center">Exporters</td>
<td align="center">生态庞大，所有指标场景计划全部都exporters</td>
<td align="center">不同的exporter水平参差不齐kubernetes生态，或sidecar部署模式的场合</td>
<td align="center">kubernetes生态，或sidecar部署模式的场合</td>
</tr>
<tr>
<td align="center">garfana-agent</td>
<td align="center">指标、日志、链路全部支持大一统方案</td>
<td align="center">集成的采集器不全，和监控目标之间仍然是一对一的，同时采集多个监控目标的时候，不太方便。</td>
<td align="center">kubernetes生态，或sidecar部署模式的场合</td>
</tr>
</tbody></table>
<h2 id="时序库"><a href="#时序库" class="headerlink" title="时序库"></a>时序库</h2><p>监控系统的架构中，最核心的就是时序库。老一些的监控系统直接复用关系型数据库，比如 Zabbix 直接使用 MySQL 存储时序数据，MySQL 擅长处理事务场景，没有针对时序场景做优化，容量上有明显的瓶颈。Open-Falcon 是用 RRDtool 攒了一个分布式存储组件 Falcon-Graph，但是 RRDTool 本身的设计就有问题，散文件很多，对硬盘的 IO 要求太高，性能较差。Falcon-Graph 是分布式的，可以通过堆机器来解决大规模的问题，但显然不是最优解。</p>
<p>后来，各种专门解决时序存储问题的数据库横空出世，比较有代表性的有：OpenTSDB、InfluxDB、TDEngine、M3DB、VictoriaMetrics、TimescaleDB 等。下面我们逐一介绍一下。</p>
<h3 id="OpenTSDB"><a href="#OpenTSDB" class="headerlink" title="OpenTSDB"></a>OpenTSDB</h3><p>OpenTSDB 出现得较早，2010 年左右就有了，OpenTSDB 的指标模型有别于老一代监控系统死板的模型设计，它非常灵活，给业界带来了非常好的引导。</p>
<p>OpenTSDB 是基于 HBase 封装的，后来持续发展，也有了基于 Cassandra 封装的版本。你可以看一下它的架构图。由于底层存储是基于 HBase 的，一般小公司都玩不转，在国内的受众相对较少，当下再选型时序数据库时，就已经很少有人会选择 OpenTSDB 了。</p>
<h3 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h3><p>InfluxDB 来自 InfluxData，是一个创业公司做的项目，2019 年 D 轮融资 6000 万美金，所以开发人员不担心养家糊口的问题，做的产品还是非常不错的。</p>
<p>InfluxDB 针对时序存储场景专门设计了存储引擎、数据结构、存取接口，国内使用范围比较广泛，而且 InfluxDB 可以和 Grafana、Telegraf 等良好整合，生态是非常完备的。不过 InfluxDB 开源版本是单机的，没有开源集群版本。毕竟是商业公司，需要赚钱实现良性发展，这个点是需要我们斟酌的。</p>
<h3 id="TDEngine"><a href="#TDEngine" class="headerlink" title="TDEngine"></a>TDEngine</h3><p>TDEngine 姑且可以看做是国产版 InfluxDB，GitHub 的 Star 数上万，针对物联网设备的场景做了优化，性能很好，也可以和 Grafana、Telegraf 整合，对于偏设备监控的场景，TDEngine 是个不错的选择。</p>
<p>TDEngine 的集群版是开源的，相比 InfluxDB，TDEngine 这点很有吸引力。TDEngine 不止是做时序数据存储，还内置支持了流式计算，可以让用户少部署一些组件。</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408140002560.png" alt="image-20230510114318879"></p>
<p>你可能比较关注 TDEngine 是否可以和 Prometheus 生态良好打通。通过 TDEngine 的官网可以得知，TDEngine 是支持 Prometheus 的 remote_read 和 remote_write 接口的。不过不支持 Prometheus 的 Query 类接口，这点需要注意。</p>
<h3 id="M3DB"><a href="#M3DB" class="headerlink" title="M3DB"></a>M3DB</h3><p>M3DB 是来自 Uber 的时序数据库，M3 声称在 Uber 抗住了 66 亿监控指标，这个量非常庞大。而且 M3DB 是全开源的，包括集群版，不过架构原理比较复杂，CPU 和内存占用较高，在国内没有大规模推广起来。M3DB 的架构代码中包含很多分布式系统设计的知识，是个可以拿来学习的好项目。</p>
<h3 id="VictoriaMetrics"><a href="#VictoriaMetrics" class="headerlink" title="VictoriaMetrics"></a>VictoriaMetrics</h3><p>VictoriaMetrics，简称 VM，架构非常简单清晰，采用 merge read 方式，避免了数据迁移问题，搞一批云上虚拟机，挂上云硬盘，部署 VM 集群，使用单副本，是非常轻量可靠的集群方式。</p>
<p>VM 实现了 Prometheus 的 Query 类接口，即 &#x2F;api&#x2F;v1&#x2F;query、&#x2F;api&#x2F;v1&#x2F;query_range、&#x2F;api&#x2F;v1&#x2F;label&#x2F;&#x2F;values 相关的接口，是 Prometheus 一个非常好的 Backend，甚至可以说是 Prometheus 的一个替代品。其实 VM 的初衷就是想要替换掉 Prometheus 的。</p>
<h3 id="TimescaleDB"><a href="#TimescaleDB" class="headerlink" title="TimescaleDB"></a>TimescaleDB</h3><p>TimescaleDB 是 timescale.inc 开发的一款时序数据库，作为一个 PostgreSQL 的扩展提供服务。</p>
<p>它是基于 PostgreSQL 设计而成的，而 PostgreSQL 生态四十年的积累，就是巨人的肩膀，很多底层的工作 PostgreSQL 其实已经完成了。就拿保障数据安全来说吧，因为程序可能随时会崩溃，服务器可能会遇到电源问题或硬件故障，磁盘可能损坏或者夯住，这些极端场景都需要完善的解决方案来处理。PostgreSQL 社区已经有了现成的高可用特性，包括完善的流复制和只读副本、数据库快照功能、增量备份和任意时间点恢复、wal 支持、快速导入导出工具等。而其他时序库，这些问题都要从头解决。</p>
<p>但是传统数据库是基于 btree 做索引的，数据量到百亿或者千亿行，btree 会大到内存都存不下，产生频繁的磁盘交换，数据库性能会显著下降。另外，时序数据的写入量特别大，PostgreSQL 面对大量的插入，性能也不理想。TimescaleDB 就要解决这些问题。目前 Zabbix 社区在尝试对接到 TimescaleDB，不过国内应用案例还比较少。</p>
<h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p>随着这几年云环境的发展，Prometheus 被广泛地认可。它的本质是时间序列数据库。Prometheus 能够很好地支持大量数据的写入。</p>
<p>它采用拉的模式（Pull）从应用中拉取数据，并通过 Alert 模块实现监控预警。据说单机可以消费百万级时间序列。</p>
<h2 id="告警引擎"><a href="#告警引擎" class="headerlink" title="告警引擎"></a>告警引擎</h2><p>告警引擎的核心职责是处理告警规则，生成告警事件。通常来说，用户会配置数百甚至数千条告警规则，一些超大型公司可能需要配置数万条告警规则。每个规则里含有数据过滤条件、阈值、执行频率等，有一些配置丰富的监控系统，还支持配置规则生效时段、持续时长、留观时长等。</p>
<p>告警引擎通常有两种架构，一种是数据触发式，一种是周期轮询式。</p>
<p>数据触发式，是指服务端接收到监控数据之后，除了存储到时序库，还会转发一份数据给告警引擎，告警引擎每收到一条监控数据，就要判断是否关联了告警规则，做告警判断。因为监控数据量比较大，告警规则的量也可能比较大，所以告警引擎是会做分片部署的，即部署多个实例。这样的架构，即时性很好，但是想要做指标关联计算就很麻烦，因为不同的指标哈希后可能会落到不同的告警引擎实例。</p>
<p>周期轮询式，架构简单，通常是一个规则一个协程，按照用户配置的执行频率，周期性查询判断即可，因为是主动查询的，做指标关联计算就会很容易。像 Prometheus、Grafana 等，都是这样的架构。</p>
<p>生成事件之后，通常是交给一个单独的模块来做告警发送，这个模块负责事件聚合、收敛，根据不同的条件发送给不同的接收者和不同的通知媒介。告警事件的处理，是一个非常通用的需求，而且非常零碎、复杂，每个监控系统都去实现一套，通常不会做得很完备。于是就有了专门处理这类需求的产品，最典型的比如 PagerDuty ，可以接收各类事件源的事件，用户就只需要在 PagerDuty 做 OnCall 响应即可，非常方便。</p>
<h2 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h2><p>监控数据的可视化也是一个非常通用且重要的需求，业界做得最成功的当数 Grafana。</p>
<p>Grafana 采用插件式架构，可以支持不同类型的数据源，图表非常丰富，基本可以看做是开源领域的事实标准。很多公司的商业化产品中，甚至直接内嵌了 Grafana，可见它是多么流行。当然，Grafana 新版本已经修改了开源协议，使用 AGPLv3，这就意味着如果某公司的产品基于 Grafana 做了二次开发，就必须公开代码，有些厂商想要 Fork Grafana，然后进行闭源商业分发，就行不通了。</p>
<p>监控数据可视化，通常有两类需求，一个是即时查询，一个是监控大盘（Dashboard）。即时查询是临时起意，比如线上有个问题，需要追查监控数据，还原现场排查问题，这就需要有个方便我们查看的指标浏览功能，快速找到想要的指标。监控大盘通常用于日常巡检和问题排查，由资深工程师创建，放置了一些特别值得重点关注的指标，一定程度上可以引发我们思考，具有很强的知识沉淀效果。如果想要了解某个组件的原理，这个组件的监控大盘通常可以带给你一些启发。</p>
<hr>
<p>补充：</p>
<p><img src="https://zero-pic.oss-cn-beijing.aliyuncs.com/img/202408140002211.png" alt="在这里插入图片描述"></p>
<p>参考：<br><a href="https://blog.csdn.net/Tiger_lin1/article/details/130712365">https://blog.csdn.net/Tiger_lin1/article/details/130712365</a><br><a href="https://www.sohu.com/a/344073073_236714">https://www.sohu.com/a/344073073_236714</a></p>
]]></content>
      <categories>
        <category>目录待定</category>
      </categories>
  </entry>
</search>
